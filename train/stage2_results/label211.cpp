//<#!@READ-ONLY-SECTION-START@!#>
/*
 * \class cfm_datacenter
 * \brief Intel(R) CoFluent(TM) Studio - Intel Corporation
 * \details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2
 */
/// Model Source includes start
#include "cfm_datacenter.h"
/// Model Source includes end
using namespace std;
using namespace sc_core;
using namespace cf_dt;
using namespace cf_pk;
using namespace cf_core;

//<#!@READ-ONLY-SECTION-END@!#>
//Start of 'datacenter definitions' algorithm generated code
void merge_and_sort_vector(std::vector<cf_dt::cf_time>& vect1,
		std::vector<cf_dt::cf_time>& vect2) {
	vect1.insert(vect1.begin(), vect2.begin(), vect2.end());
}
//End of 'datacenter definitions' algorithm generated code
//<#!@READ-ONLY-SECTION-START@!#>

/// \name constructor
//@{
cfm_datacenter::cfm_datacenter(sc_core::sc_module_name name) :
		cf_application(name), cfm_datacenter_dp_if() {
	cf_application::init();
	DataCenterSwitch = new cfm_datacenterswitch("DataCenterSwitch");

	// instantiation of ServerRoom_vec
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		cfm_serverroom* module = new cfm_serverroom(
				cf_string("ServerRoom[%d]", i).c_str());
		CF_ASSERT (module)
		ServerRoom_vec.push_back(module);
	}
	// instantiation of mq_MsgQToDataCenterSwitch_vec
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		mq_MsgQToDataCenterSwitch_t* module = new mq_MsgQToDataCenterSwitch_t(
				cf_string("MsgQToDataCenterSwitch[%d]", i).c_str());
		CF_ASSERT (module)
		mq_MsgQToDataCenterSwitch_vec.push_back(module);
	}
	// instantiation of mq_MsgQToServerRoom_vec
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		mq_MsgQToServerRoom_t* module = new mq_MsgQToServerRoom_t(
				cf_string("MsgQToServerRoom[%d]", i).c_str());
		CF_ASSERT (module)
		mq_MsgQToServerRoom_vec.push_back(module);
	}
	// connections
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		for (cf_count j = 0;
				j
						< (cf_count) DataCenterSwitch->p_mq_MsgQToDataCenterSwitch_vec.size();
				j++) {
			cfm_datacenterswitch::p_mq_MsgQToDataCenterSwitch_t* port =
					DataCenterSwitch->p_mq_MsgQToDataCenterSwitch_vec[j];
			if (port != nullptr) {
				port->bind(mq_MsgQToDataCenterSwitch_vec[i]->p_target_socket);
			}
		}
	}
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		for (cf_count j = 0;
				j
						< (cf_count) DataCenterSwitch->p_mq_MsgQToServerRoom_vec.size();
				j++) {
			cfm_datacenterswitch::p_mq_MsgQToServerRoom_t* port =
					DataCenterSwitch->p_mq_MsgQToServerRoom_vec[j];
			if (port != nullptr) {
				port->bind(mq_MsgQToServerRoom_vec[i]->p_target_socket);
			}
		}
	}

	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		cfm_serverroom* module = ServerRoom_vec[i];
		if (module != nullptr) {
			for (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {
				module->p_mq_MsgQToDataCenterSwitch(
						mq_MsgQToDataCenterSwitch_vec[j]->p_target_socket);
			}
			for (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {
				module->p_mq_MsgQToServerRoom(
						mq_MsgQToServerRoom_vec[j]->p_target_socket);
			}
		}
	}

	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'datacenter constructor' algorithm generated code

	//End of 'datacenter constructor' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>

	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		CF_COMM_CB_MQ_SEND((*mq_MsgQToDataCenterSwitch_vec[i]),
				cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_send_time);
		CF_COMM_CB_MQ_RECEIVE((*mq_MsgQToDataCenterSwitch_vec[i]),
				cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_receive_time);
	}
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		CF_COMM_CB_MQ_SEND((*mq_MsgQToServerRoom_vec[i]),
				cfm_datacenter::mq_MsgQToServerRoom_cb_send_time);
		CF_COMM_CB_MQ_RECEIVE((*mq_MsgQToServerRoom_vec[i]),
				cfm_datacenter::mq_MsgQToServerRoom_cb_receive_time);
	}

	cf_application::elab_end();
}
//@}

/// \name destructor
//@{
cfm_datacenter::~cfm_datacenter(void) {
	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'datacenter destructor' algorithm generated code

	//End of 'datacenter destructor' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
	for (vector<cfm_serverroom*>::const_iterator vi = ServerRoom_vec.begin();
			vi != ServerRoom_vec.end(); vi++) {
		delete (*vi);
	}
	for (vector<mq_MsgQToDataCenterSwitch_t*>::const_iterator vi =
			mq_MsgQToDataCenterSwitch_vec.begin();
			vi != mq_MsgQToDataCenterSwitch_vec.end(); vi++) {
		delete (*vi);
	}
	for (vector<mq_MsgQToServerRoom_t*>::const_iterator vi =
			mq_MsgQToServerRoom_vec.begin();
			vi != mq_MsgQToServerRoom_vec.end(); vi++) {
		delete (*vi);
	}
	delete DataCenterSwitch;
}
//@}

/// \name pre-elaboration section
//@{
void cfm_datacenter::cb_before_elaboration(void) {
	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'datacenter pre elaboration' algorithm generated code

	//End of 'datacenter pre elaboration' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name post-elaboration section
//@{
void cfm_datacenter::cb_end_of_elaboration(void) {
//<#!@READ-ONLY-SECTION-END@!#>
//Start of 'datacenter post elaboration' algorithm generated code
// Start chrono
	t_start = std::chrono::high_resolution_clock::now();
//End of 'datacenter post elaboration' algorithm generated code
//<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name post-simulation section
//@{
void cfm_datacenter::cb_end_of_simulation(void) {
	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'datacenter post simulation' algorithm generated code
	// End chrono except for controller (controller already measures execution time)
#ifndef COF_LSS_CONTROLLER
	std::chrono::high_resolution_clock::time_point t_end =
			std::chrono::high_resolution_clock::now();
	std::chrono::duration<double> time_span = std::chrono::duration_cast
			< std::chrono::duration<double> > (t_end - t_start);
	cf_mon_ostream << "Wall-clock simulation time: " << time_span.count()
			<< " sec" << cf_mon_endl;
#endif

	// Create map for chart
	std::map<int, int> graph;
	// Need dp for it
	for (auto it : producer_exec_time) {
		//cf_trace_report("time %s", it.to_c_str());
		int t = (int) it.to_scalar(CF_NS) / 100;
		auto s = graph.find(t);
		if (s != graph.end())
			s->second = s->second + 1;
		else
			graph.insert(std::pair<int, int>(t, 1));
	}

	for (auto it : graph) {
		//cf_trace_report("key %d value %d", it.first, it.second);
		// create graph point
		cf_trace_gui_f_x("latency", "nb_func", it.first, it.second);
	}

	// Display simulation result
	// Transaction counts
	cf_trace_report("Total number of transaction sent is %d",
			total_requests_sent);
	cf_trace_report("Transaction number routed by ToR switches : %d",
			nb_trans_routed_by_ToR_Switch);
	cf_trace_report("Transaction number routed by AGG switches : %d",
			nb_trans_routed_by_AGG_Switch);
	cf_trace_report("Transaction number routed by Data Center switch : %d",
			nb_trans_routed_by_Data_Center_Switch);
	cf_trace_report("Total number of transaction received is %d",
			total_requests_received);

	// controller and sequential simulation 
#if defined(COF_LSS_CONTROLLER) || !defined(COF_LSS)

	cf_trace_report(
			"Assert number of requests sent and received are the same.");
	cf_assert((total_requests_sent == total_requests_received),
			"Post-Simulation", CF_ERROR_USER_ASSERT,
			"The number of transactions received (%d) is not the same as the number of transactions sent (%d). \nIncrease simulation time to get full simulation results.",
			total_requests_received, total_requests_sent);

	// Transaction rate
	cf_trace_report("Rate of outside server room transaction is %.2f ",
			((float) nb_trans_routed_by_Data_Center_Switch
					/ total_requests_received) * 100);
	cf_trace_report("Rate of outside rack transaction is %.2f ",
			((float) (nb_trans_routed_by_AGG_Switch
					- (nb_trans_routed_by_Data_Center_Switch))
					/ total_requests_received) * 100);
	// Display simulation_duration
	cf_trace_report("simulation_duration %s", simulation_duration.to_string());
	// Display switches load 
	data_center_switch_load = (data_center_switch_running_time.to_scalar(CF_MS)
			* 100) / simulation_duration.to_scalar(CF_MS);
	cf_trace_report("Data center switch load = %.2f%%",
			data_center_switch_load);
	agg_switch_load = ((agg_switch_running_time.to_scalar(CF_MS) * 100)
			/ simulation_duration.to_scalar(CF_MS)) / (dpServerRoomNb + 1);
	cf_trace_report("Agg switch average load = %.2f%%", agg_switch_load);
	tor_switch_load = ((tor_switch_running_time.to_scalar(CF_MS) * 100)
			/ simulation_duration.to_scalar(CF_MS))
			/ ((dpServerRoomNb + 1) * (dpRackNb + 1));
	cf_trace_report("ToR switch average load = %.2f%%", tor_switch_load);

	// Latencies
	// Update average latency		
	average_latency = total_latency / ((double) total_requests_received);
	cf_trace_report("Average latency = %.0f ns",
			average_latency.to_scalar(CF_NS));
	intra_rack_average_latency = intra_rack_total_latency
			/ ((double) intra_rack_total_requests_received);
	cf_trace_report("Intra rack requests average latency = %.0f ns",
			intra_rack_average_latency.to_scalar(CF_NS));
	intra_server_room_average_latency = intra_server_room_total_latency
			/ ((double) intra_server_room_total_requests_received);
	cf_trace_report("Intra server room requests average latency = %.0f ns",
			intra_server_room_average_latency.to_scalar(CF_NS));
	outside_server_room_average_latency = outside_server_room_total_latency
			/ ((double) outside_server_room_total_requests_received);
	cf_trace_report("Outside server room requests average latency = %.0f ns",
			outside_server_room_average_latency.to_scalar(CF_NS));

#endif
	//End of 'datacenter post simulation' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name initialize attributes
//@{
void cfm_datacenter::cb_init_attributes() {

// initialize function attributes
	cfa_cycle_period.init(cf_expr_time(10, CF_NS));
// initialize relations attributes
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_queue_policy.init(
				CF_MQ_POLICY_FIFO_FINITE);
		(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_queue_capacity.init(
				(cf_nonzero_count) 1);
		(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_concurrency.init(
				(cf_nonzero_count) 1);
		(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_send_threshold.init(
				(cf_nonzero_count) 1);
		(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_receive_threshold.init(
				(cf_nonzero_count) 1);
	}
	for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {
		(*mq_MsgQToServerRoom_vec[i]).cfa_queue_policy.init(
				CF_MQ_POLICY_FIFO_FINITE);
		(*mq_MsgQToServerRoom_vec[i]).cfa_queue_capacity.init(
				(cf_nonzero_count) 1);
		(*mq_MsgQToServerRoom_vec[i]).cfa_concurrency.init(
				(cf_nonzero_count) 1);
		(*mq_MsgQToServerRoom_vec[i]).cfa_send_threshold.init(
				(cf_nonzero_count) 1);
		(*mq_MsgQToServerRoom_vec[i]).cfa_receive_threshold.init(
				(cf_nonzero_count) 1);
	}

	return;
}
//@}

/// \name initialize definitions
//@{
void cfm_datacenter::cb_init_local_vars(void) {

	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'datacenter initializations' algorithm generated code
	// Init variables used to generate transaction rate
	min_waiting_time = 1000000000
			/ (dpTransactionRate + dpTransactionRateInterval);
	max_waiting_time = 1000000000
			/ (dpTransactionRate - dpTransactionRateInterval);

	// Init variables used to count transaction
	nb_trans_routed_by_ToR_Switch = 0;
	nb_trans_routed_by_AGG_Switch = 0;
	nb_trans_routed_by_Data_Center_Switch = 0;

	// Init variables used to compute latency
	total_latency = cf_dt::cf_time(0, CF_SEC);
	average_latency = cf_dt::cf_time(0, CF_SEC);
	intra_rack_total_latency = cf_dt::cf_time(0, CF_SEC);
	intra_rack_average_latency = cf_dt::cf_time(0, CF_SEC);
	intra_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);
	intra_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);
	outside_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);
	outside_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);

	// Init variables used to compute requests number
	/*total_requests_sent = (dpServerRoomNb + 1) * (dpRackNb + 1)
	 * (dpServerPerRackNb + 1) * dpNbTransPerServer;*/
	total_requests_received = 0;
	intra_rack_total_requests_received = 0;
	intra_server_room_total_requests_received = 0;

	// Variables used to compute switches loads
	simulation_duration = cf_dt::cf_time(0, CF_SEC);
	data_center_switch_running_time = cf_dt::cf_time(0, CF_SEC);
	data_center_switch_load = 0;
	agg_switch_running_time = cf_dt::cf_time(0, CF_SEC);
	agg_switch_load = 0;
	tor_switch_running_time = cf_dt::cf_time(0, CF_SEC);
	tor_switch_load = 0;
	//End of 'datacenter initializations' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name Overload function for mq_MsgQToDataCenterSwitch message queue send time
//@{
cf_duration cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_send_time(
		cf_payload_b* _trans) {
	CF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToDataCenterSwitch_trans, _trans);
	//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN
	return cf_expr_duration(dpServerRoomToDataCenterTime / 2, CF_NS);
	//#COFS_MESSAGE_QUEUE_SEND_TIME_END
}
//@}
/// \name Overload function for mq_MsgQToDataCenterSwitch message queue receive time
//@{
cf_duration cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_receive_time(
		cf_payload_b* _trans) {
	CF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToDataCenterSwitch_trans, _trans);
	//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN
	return cf_expr_duration(dpServerRoomToDataCenterTime / 2, CF_NS);
	//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END
}
//@}
/// \name Overload function for mq_MsgQToServerRoom message queue send time
//@{
cf_duration cfm_datacenter::mq_MsgQToServerRoom_cb_send_time(
		cf_payload_b* _trans) {
	CF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServerRoom_trans, _trans);
	//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN
	return cf_expr_duration(dpDataCenterToServerRoomTime / 2, CF_NS);
	//#COFS_MESSAGE_QUEUE_SEND_TIME_END
}
//@}
/// \name Overload function for mq_MsgQToServerRoom message queue receive time
//@{
cf_duration cfm_datacenter::mq_MsgQToServerRoom_cb_receive_time(
		cf_payload_b* _trans) {
	CF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServerRoom_trans, _trans);
	//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN
	return cf_expr_duration(dpDataCenterToServerRoomTime / 2, CF_NS);
	//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END
}
//@}


//<#!@READ-ONLY-SECTION-END@!#>