
/*
 * \class cfm_backend
 * \brief Intel(R) CoFluent(TM) Studio - Intel Corporation
 * \details Simulation model of memss_ref generated by C++ Generator for SystemC/TLM2
 */
#include "cfm_backend.h"
#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME
#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME
#endif
#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memsub
#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME
#undef COFLUENT_SELF_FUNCTION_CLASS_NAME
#endif
#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_backend
using namespace std;
using namespace sc_core;
using namespace cf_dt;
using namespace cf_pk;
using namespace cf_core;



cfm_backend::cfm_backend(sc_core::sc_module_name name)
cf_function_container(name)
, cfm_backend_dp_if()
, p_mq_DQs("p_mq_DQs")
, p_mq_DataRead("p_mq_DataRead")
, p_mq_WriteAck("p_mq_WriteAck")
, p_mq_MemReadRequest("p_mq_MemReadRequest")
, p_mq_MemWriteRequest("p_mq_MemWriteRequest")
, p_mq_DDRCommand("p_mq_DDRCommand")
, sv_RequestCounter("RequestCounter"
)
, mq_RequestInformation("RequestInformation"
)
, sv_ListRequestsPtr("ListRequestsPtr"
)
, mq_Requests2Memory("Requests2Memory"
)

{
	cf_function_container::init();
	Arbitration = new cfm_arbitration
	("Arbitration");
	CollectRequests = new cfm_collectrequests
	("CollectRequests");
	DDRCommandGeneration = new cfm_ddrcommandgeneration
	("DDRCommandGeneration");
	ResponseForward = new cfm_responseforward
	("ResponseForward");

	for (cf_count i = 0; i < (cf_count)(M_Nb + 1); i++)
	{
		mq_MemoryStatus_t* module=new mq_MemoryStatus_t(cf_string("MemoryStatus[%d]", i).c_str());
		CF_ASSERT( module )
		mq_MemoryStatus_vec.push_back(module);
	}
	for (cf_count i = 0; i < (cf_count)(M_Nb + 1); i++) {
		Arbitration->p_mq_MemoryStatus
		(mq_MemoryStatus_vec[i]
				->p_target_socket
		);
	}
	Arbitration->p_mq_RequestInformation
	(mq_RequestInformation
			.p_target_socket
	);
	Arbitration->p_sv_RequestCounter
	(sv_RequestCounter
			.p_target_socket
	);
	Arbitration->p_mq_DQs
	(p_mq_DQs
	);

	CollectRequests->p_mq_WriteAck
	(p_mq_WriteAck
	);
	CollectRequests->p_mq_DataRead
	(p_mq_DataRead
	);
	CollectRequests->p_mq_MemReadRequest
	(p_mq_MemReadRequest
	);
	CollectRequests->p_mq_MemWriteRequest
	(p_mq_MemWriteRequest
	);
	CollectRequests->p_mq_DDRCommand
	(p_mq_DDRCommand
	);
	for (cf_count i = 0; i < (cf_count)(M_Nb + 1); i++) {
		CollectRequests->p_mq_MemoryStatus
		(mq_MemoryStatus_vec[i]
				->p_target_socket
		);
	}
	CollectRequests->p_mq_ListRequestsPtr
	(sv_ListRequestsPtr
			.p_target_socket
	);
	CollectRequests->p_mq_Requests2Memory
	(mq_Requests2Memory
			.p_target_socket
	);

	DDRCommandGeneration->p_mq_DDRCommand
	(p_mq_DDRCommand
	);
	for (cf_count i = 0; i < (cf_count)(M_Nb + 1); i++) {
		DDRCommandGeneration->p_mq_MemoryStatus
		(mq_MemoryStatus_vec[i]
				->p_target_socket
		);
	}

	ResponseForward->p_mq_DataForward
	(sv_DataForward
			.p_target_socket
	);
	ResponseForward->p_mq_WriteForward
	(sv_WriteForward
			.p_target_socket
	);
	ResponseForward->p_mq_MemForward
	(sv_MemForward
			.p_target_socket
	);
	ResponseForward->p_mq_DQForward
	(sv_DQForward
			.p_target_socket
	);
	for (cf_count i = 0; i < (cf_count)(M_Nb + 1); i++) {
		ResponseForward->p_mq_MemoryStatus
		(mq_MemoryStatus_vec[i]
				->p_target_socket
		);
	}
	ResponseForward->p_mq_ListRequestsPtr
	(sv_ListRequestsPtr
			.p_target_socket
	);
	ResponseForward->p_mq_ReqInfo
	(mq_RequestInformation
			.p_target_socket
	);
	ResponseForward->p_ev_Event
	(sv_Event
			.p_target_socket
	);



	cf_function_container::elab_end();
}

cfm_backend::~cfm_backend(void) {

	for (vector<mq_MemoryStatus_t*>::const_iterator vi = mq_MemoryStatus_vec.begin(); vi != mq_MemoryStatus_vec.end(); vi++) {
		delete (*vi);
	}
	delete Arbitration;	///ddd
	delete CollectRequests;	///ddd
	delete DDRCommandGeneration;	///ddd
	delete ResponseForward;	///ddd
}

void cfm_backend::cb_before_elaboration(void) {

}

void cfm_backend::cb_end_of_elaboration(void) {

}

void cfm_backend::cb_end_of_simulation(void) {

}

void cfm_backend::cb_init_attributes() {

	sv_RequestCounter.cfa_write_time.init(cf_expr_duration(1, CF_NS));
	sv_RequestCounter.cfa_read_time.init(cf_expr_duration(1, CF_NS));
	sv_RequestCounter.cfa_semaphore.init(false);
	sv_RequestCounter.cfa_concurrency.init((cf_nonzero_count) 1);
	for (cf_count i = 0; i < (cf_count)(M_Nb + 1); i++) {
		(*mq_MemoryStatus_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));
		(*mq_MemoryStatus_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_NS));
		(*mq_MemoryStatus_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);
		(*mq_MemoryStatus_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);
		(*mq_MemoryStatus_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);
		(*mq_MemoryStatus_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);
		(*mq_MemoryStatus_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);
	}
	mq_RequestInformation.cfa_send_time.init(cf_expr_duration(0, CF_NS));
	mq_RequestInformation.cfa_receive_time.init(cf_expr_duration(0, CF_NS));
	mq_RequestInformation.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
	mq_RequestInformation.cfa_concurrency.init((cf_nonzero_count) 1);
	mq_RequestInformation.cfa_send_threshold.init((cf_nonzero_count) 1);
	mq_RequestInformation.cfa_receive_threshold.init((cf_nonzero_count) 1);
	sv_ListRequestsPtr.cfa_write_time.init(cf_expr_duration(0, CF_NS));
	sv_ListRequestsPtr.cfa_read_time.init(cf_expr_duration(0, CF_NS));
	sv_ListRequestsPtr.cfa_semaphore.init(false);
	sv_ListRequestsPtr.cfa_concurrency.init((cf_nonzero_count) 1);
	mq_ReqInfo.cfa_send_time.init(cf_expr_duration(0, CF_NS));
	mq_ReqInfo.cfa_receive_time.init(cf_expr_duration(0, CF_NS));
	mq_ReqInfo.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
	mq_ReqInfo.cfa_concurrency.init((cf_nonzero_count) 1);
	mq_ReqInfo.cfa_send_threshold.init((cf_nonzero_count) 1);
	mq_ReqInfo.cfa_receive_threshold.init((cf_nonzero_count) 1);
	ev_Event.cfa_set_time.init(cf_expr_duration(1, CF_NS));
	ev_Event.cfa_get_time.init(cf_expr_duration(1, CF_NS));
	ev_Event.cfa_event_policy.init(CF_EV_POLICY_COUNTER);
	mq_Requests2Memory.cfa_send_time.init(cf_expr_duration(0, CF_NS));
	mq_Requests2Memory.cfa_receive_time.init(cf_expr_duration(0, CF_NS));
	mq_Requests2Memory.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
	mq_Requests2Memory.cfa_concurrency.init((cf_nonzero_count) 1);
	mq_Requests2Memory.cfa_send_threshold.init((cf_nonzero_count) 1);
	mq_Requests2Memory.cfa_receive_threshold.init((cf_nonzero_count) 1);

	return;
}

void cfm_backend::cb_init_local_vars(void) {


}


