//<#!@READ-ONLY-SECTION-START@!#>
/*
 * \class cfm_opp_usecase
 * \brief Intel(R) CoFluent(TM) Studio - Intel Corporation
 * \details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2
 */
/// Model Source includes start
#include "cfm_opp_usecase.h"
/// Model Source includes end
using namespace std;
using namespace sc_core;
using namespace cf_dt;
using namespace cf_pk;
using namespace cf_core;

//<#!@READ-ONLY-SECTION-END@!#>
//Start of 'OPP_UseCase definitions' algorithm generated code

//End of 'OPP_UseCase definitions' algorithm generated code
//<#!@READ-ONLY-SECTION-START@!#>

/// \name constructor
//@{
cfm_opp_usecase::cfm_opp_usecase(sc_core::sc_module_name name) :
		cf_application(name), cfm_opp_usecase_dp_if(), mq_M2S("M2S"), mq_S2M(
				"S2M"), ev_StartEv("StartEv"), ev_UnusedEv("UnusedEv") {
	cf_application::init();
	Master = new cfm_bt_system("Master");
	Slave = new cfm_bt_system("Slave");
	StartFunc = new cfm_startfunc("StartFunc");
	UnusedFunc = new cfm_unusedfunc("UnusedFunc");

	// connections
	Master->p_mq_BaseBand_Out(mq_M2S.p_target_socket);
	Master->p_mq_BaseBand_In(mq_S2M.p_target_socket);
	Master->p_ev_startEv(ev_StartEv.p_target_socket);

	Slave->p_mq_BaseBand_Out(mq_S2M.p_target_socket);
	Slave->p_mq_BaseBand_In(mq_M2S.p_target_socket);
	Slave->p_ev_startEv(ev_UnusedEv.p_target_socket);

	StartFunc->p_ev_StartEv(ev_StartEv.p_target_socket);

	UnusedFunc->p_ev_UnusedEv(ev_UnusedEv.p_target_socket);

	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'OPP_UseCase constructor' algorithm generated code

	//End of 'OPP_UseCase constructor' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>

	cf_application::elab_end();
}
//@}

/// \name destructor
//@{
cfm_opp_usecase::~cfm_opp_usecase(void) {
	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'OPP_UseCase destructor' algorithm generated code

	//End of 'OPP_UseCase destructor' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
	delete Master;
	delete Slave;
	delete StartFunc;
	delete UnusedFunc;
}
//@}

/// \name pre-elaboration section
//@{
void cfm_opp_usecase::cb_before_elaboration(void) {
	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'OPP_UseCase pre elaboration' algorithm generated code

	//End of 'OPP_UseCase pre elaboration' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name post-elaboration section
//@{
void cfm_opp_usecase::cb_end_of_elaboration(void) {
//<#!@READ-ONLY-SECTION-END@!#>
//Start of 'OPP_UseCase post elaboration' algorithm generated code
	nb_file_parts = 0;
	nb_OBEX_df = 0;
	nb_RFCOMM_df = 0;
	total_delay_FILE = 0;
	total_delay_OBEX = 0;
	total_delay_RFCOMM = 0;
	nb_cdts_req = 0;
	total_L2CAP_data = 0;
//End of 'OPP_UseCase post elaboration' algorithm generated code
//<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name post-simulation section
//@{
void cfm_opp_usecase::cb_end_of_simulation(void) {
	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'OPP_UseCase post simulation' algorithm generated code
	//perf result computation
	total_time = last_write_time - first_read_time; //in us
	average_throughput = 1000000.0 * (double) File_Size * 8.0
			/ (double) total_time;
	cf_trace_gui_f_param("average_throughput", average_throughput, "kbits/s");

	//print out results
	if (Verbose_Level != LEVEL_SILENT) {
		//file level perfs
		cf_trace_report("FILE LEVEL:");
		cf_trace_report("	File size: %d kBytes", (int) File_Size);
		cf_trace_report("	Max file part size: %d Bytes", (int) OBEX_pl_size);
		cf_trace_report("	Number of file parts: %d", nb_file_parts);
		cf_trace_report(
				"	--> Total time between first read and last write:%d us",
				total_time);
		cf_trace_report("	--> Average throughput:%f kbits/s",
				average_throughput);
		cf_trace_report(
				"	--> Average delay between read and OBEX final packet (acknowledge) reception:%f us",
				(double) total_delay_FILE / (double) nb_file_parts);
		cf_trace_report("OBEX LEVEL:");
		cf_trace_report("	Maximum frame size:%d Bytes",
				(int) OBEX_pl_size + OBEX_HDR_S);
		cf_trace_report("	--> Number of data frames: %d", nb_OBEX_df);
		cf_trace_report(
				"	--> Average delay between data frame send and receive:%f us",
				(double) total_delay_OBEX / (double) nb_OBEX_df);
		cf_trace_report("RFCOMM LEVEL:");
		cf_trace_report("	Maximum frame size:%d Bytes",
				(int) RFCOMM_pl_size + RFCOMM_HDR_S);
		cf_trace_report("	--> Number of data frames:%d", nb_RFCOMM_df);
		cf_trace_report(
				"	--> Average delay between data frame send and receive:%f us",
				(double) total_delay_RFCOMM / (double) nb_RFCOMM_df);
		cf_trace_report("	Number of credits:%d", (int) RFCOMM_credits);
		cf_trace_report("	Number of credit requests:%d", nb_cdts_req);
		cf_trace_report("L2CAP LEVEL:");
		cf_trace_report("	Maximum frame size:%d Bytes",
				(int) RFCOMM_pl_size + RFCOMM_HDR_S + L2CAP_HDR_S);
		cf_trace_report("	--> Number of data frames:%d", nb_RFCOMM_df);
		cf_trace_report("	--> Total amount of data exchanged:%d Bytes",
				total_L2CAP_data);
		cf_trace_report("	--> Average load:%f kbits/s",
				8000.0 * (float) total_L2CAP_data / (float) total_time);
		cf_trace_report("BASEBAND LEVEL:");
		cf_trace_report("	Average throughput:%d kbits/s",
				(int) Throughput_BaseBand);
	}
	//End of 'OPP_UseCase post simulation' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name initialize attributes
//@{
void cfm_opp_usecase::cb_init_attributes() {

// initialize function attributes
	cfa_cycle_period.init(cf_expr_time(10, CF_NS));
// initialize relations attributes
	mq_M2S.cfa_send_time.init(cf_expr_duration(0, CF_NS));
	mq_M2S.cfa_receive_time.init(cf_expr_duration(0, CF_NS));
	mq_M2S.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);
	mq_M2S.cfa_queue_capacity.init((cf_nonzero_count) 1);
	mq_M2S.cfa_concurrency.init((cf_nonzero_count) 1);
	mq_S2M.cfa_send_time.init(cf_expr_duration(0, CF_NS));
	mq_S2M.cfa_receive_time.init(cf_expr_duration(0, CF_NS));
	mq_S2M.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);
	mq_S2M.cfa_queue_capacity.init((cf_nonzero_count) 1);
	mq_S2M.cfa_concurrency.init((cf_nonzero_count) 1);
	ev_StartEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));
	ev_StartEv.cfa_get_time.init(cf_expr_duration(0, CF_NS));
	ev_StartEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);
	ev_UnusedEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));
	ev_UnusedEv.cfa_get_time.init(cf_expr_duration(1, CF_NS));
	ev_UnusedEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);

	return;
}
//@}

/// \name initialize definitions
//@{
void cfm_opp_usecase::cb_init_local_vars(void) {

	//<#!@READ-ONLY-SECTION-END@!#>
	//Start of 'OPP_UseCase initializations' algorithm generated code

	//End of 'OPP_UseCase initializations' algorithm generated code
	//<#!@READ-ONLY-SECTION-START@!#>
}
//@}


//<#!@READ-ONLY-SECTION-END@!#>