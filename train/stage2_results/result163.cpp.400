
//<#!@READ-ONLY-SECTION-START@!#>
/*
 * \class cfm_memorycontroller
 * \brief Intel(R) CoFluent(TM) Studio - Intel Corporation
 * \details Simulation model of DDRMemory generated by C++ Generator for
 * SystemC/TLM2
 */
/// Model Source includes start
#include "cfm_memorycontroller.h"
#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME
#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME
#endif
#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ddrmemory
#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME
#undef COFLUENT_SELF_FUNCTION_CLASS_NAME
#endif
#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memorycontroller
/// Model Source includes end
using namespace std;
using namespace sc_core;
using namespace cf_dt;
using namespace cf_pk;
using namespace cf_core;

//<#!@READ-ONLY-SECTION-END@!#>
// Start of 'MemoryController definitions' algorithm generated code

// End of 'MemoryController definitions' algorithm generated code
//<#!@READ-ONLY-SECTION-START@!#>

/// \name constructor
//@{
cfm_memorycontroller ::cfm_memorycontroller()
    : // instantiation of non-vector Event, MessageQueue, SharedVariable
      cf_function_container(name), cfm_memorycontroller_dp_if(),
      mq_MemReadRequest("MemReadRequest"), mq_MemWriteRequest("MemWriteRequest"),
      p_mq_ARADDRchn("p_mq_ARADDRchn"), p_mq_AWADDRchn("p_mq_AWADDRchn"),
      p_mq_BRESPchn("p_mq_BRESPchn"), p_mq_DDRCommand("p_mq_DDRCommand"),
      p_mq_DQs("p_mq_DQs"), p_mq_RDATAchn("p_mq_RDATAchn"),
      p_mq_WDATAchn("p_mq_WDATAchn") {
  cf_function_container::init();
  // instantiation of models
  BackEnd = new cfm_backend("BackEnd");
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    cfm_frontend *module =
        new cfm_frontend(cf_string("FrontEnd[%d]", i).c_str());
    CF_ASSERT(module)
    FrontEnd_vec.push_back(module);
  }
  RAddrDmux = new cfm_raddrdmux("RAddrDmux");
  WAddrDmux = new cfm_waddrdmux("WAddrDmux");
  WdataDmux = new cfm_wdatadmux("WdataDmux");
  // instantiation of relations
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    mq_ARADDRin_t *module =
        new mq_ARADDRin_t(cf_string("ARADDRin[%d]", i).c_str());
    CF_ASSERT(module)
    mq_ARADDRin_vec.push_back(module);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    mq_AWADDRin_t *module =
        new mq_AWADDRin_t(cf_string("AWADDRin[%d]", i).c_str());
    CF_ASSERT(module)
    mq_AWADDRin_vec.push_back(module);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    mq_DataRead_t *module =
        new mq_DataRead_t(cf_string("DataRead[%d]", i).c_str());
    CF_ASSERT(module)
    mq_DataRead_vec.push_back(module);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    mq_WriteAck_t *module =
        new mq_WriteAck_t(cf_string("WriteAck[%d]", i).c_str());
    CF_ASSERT(module)
    mq_WriteAck_vec.push_back(module);
  }
  // connections
  // model connect to relation
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    BackEnd->p_mq_DataRead(mq_DataRead_vec[i]->p_target_socket);
  }
  BackEnd->p_mq_MemReadRequest(mq_MemReadRequest.p_target_socket);
  BackEnd->p_mq_MemWriteRequest(mq_MemWriteRequest.p_target_socket);
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    BackEnd->p_mq_WriteAck(mq_WriteAck_vec[i]->p_target_socket);
  }
  // model connect to port
  BackEnd->p_mq_DDRCommand(p_mq_DDRCommand);
  BackEnd->p_mq_DQs(p_mq_DQs);
  // model connect to relation
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    FrontEnd->p_mq_ARADDRin(mq_ARADDRin_vec[i]->p_target_socket);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    FrontEnd->p_mq_DataRead(mq_DataRead_vec[i]->p_target_socket);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    FrontEnd->p_mq_MemReadRequest(mq_MemReadRequest.p_target_socket);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    FrontEnd->p_mq_MemWriteRequest(mq_MemWriteRequest.p_target_socket);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    FrontEnd->p_mq_WriteAck(mq_WriteAck_vec[i]->p_target_socket);
  }
  // model connect to port
  FrontEnd->p_mq_BRESPchn(p_mq_BRESPchn);
  FrontEnd->p_mq_RDATAchn(p_mq_RDATAchn);
  // model connect to relation
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    RAddrDmux->p_mq_ARADDRin(mq_ARADDRin_vec[i]->p_target_socket);
  }
  RAddrDmux->p_mq_RDATAchn(mq_RDATAchn.p_target_socket);
  // model connect to port
  RAddrDmux->p_mq_ARADDRchn(p_mq_ARADDRchn);
  // model connect to relation
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    WAddrDmux->p_mq_AWADDRin(mq_AWADDRin_vec[i]->p_target_socket);
  }
  WAddrDmux->p_mq_WDATAchn(mq_WDATAchn.p_target_socket);
  // model connect to port
  WAddrDmux->p_mq_AWADDRchn(p_mq_AWADDRchn);
  // model connect to relation
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    WdataDmux->p_mq_WDATAin(mq_WDATAin_vec[i]->p_target_socket);
  }
  WdataDmux->p_mq_WDATAchn(mq_WDATAchn.p_target_socket);
  cf_function_container::elab_end();
}
//@}

/// \name destructor
//@{
cfm_memorycontroller::~cfm_memorycontroller(void) {
  //<#!@READ-ONLY-SECTION-END@!#>
  // Start of 'MemoryController destructor' algorithm generated code

  // End of 'MemoryController destructor' algorithm generated code
  //<#!@READ-ONLY-SECTION-START@!#>
  // deconstruct for models
  delete BackEnd;
  for (vector<cfm_frontend *>::const_iterator vi = FrontEnd_vec.begin();
       vi != FrontEnd_vec.end(); vi++) {
    delete (*vi);
  }
  delete RAddrDmux;
  delete WAddrDmux;
  delete WdataDmux;
  // deconstructor for vector relation
  for (vector<mq_ARADDRin_t *>::const_iterator vi = mq_ARADDRin_vec.begin();
       vi != mq_ARADDRin_vec.end(); vi++) {
    delete (*vi);
  }
  for (vector<mq_AWADDRin_t *>::const_iterator vi = mq_AWADDRin_vec.begin();
       vi != mq_AWADDRin_vec.end(); vi++) {
    delete (*vi);
  }
  for (vector<mq_DataRead_t *>::const_iterator vi = mq_DataRead_vec.begin();
       vi != mq_DataRead_vec.end(); vi++) {
    delete (*vi);
  }
  for (vector<mq_MemReadRequest_t *>::const_iterator vi =
           mq_MemReadRequest_vec.begin();
       vi != mq_MemReadRequest_vec.end(); vi++) {
    delete (*vi);
  }
  for (vector<mq_MemWriteRequest_t *>::const_iterator vi =
           mq_MemWriteRequest_vec.begin();
       vi != mq_MemWriteRequest_vec.end(); vi++) {
    delete (*vi);
  }
  for (vector<mq_WriteAck_t *>::const_iterator vi = mq_WriteAck_vec.begin();
       vi != mq_WriteAck_vec.end(); vi++) {
    delete (*vi);
  }
}
//@}

/// \name pre-elaboration section
//@{
void cfm_memorycontroller::cb_before_elaboration(void) {
  //<#!@READ-ONLY-SECTION-END@!#>
  // Start of 'MemoryController pre elaboration' algorithm generated code

  // End of 'MemoryController pre elaboration' algorithm generated code
  //<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name post-elaboration section
//@{
void cfm_memorycontroller::cb_end_of_elaboration(void) {
  //<#!@READ-ONLY-SECTION-END@!#>
  // Start of 'MemoryController post elaboration' algorithm generated code

  // End of 'MemoryController post elaboration' algorithm generated code
  //<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name post-simulation section
//@{
void cfm_memorycontroller::cb_end_of_simulation(void) {
  //<#!@READ-ONLY-SECTION-END@!#>
  // Start of 'MemoryController post simulation' algorithm generated code

  // End of 'MemoryController post simulation' algorithm generated code
  //<#!@READ-ONLY-SECTION-START@!#>
}
//@}

/// \name initialize attributes
//@{
void cfm_memorycontroller::cb_init_attributes() {

  // initialize function attributes
  // initialize relations attributes
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    (*mq_ARADDRin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));
    (*mq_ARADDRin_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_NS));
    (*mq_ARADDRin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
    (*mq_ARADDRin_vec[i]).cfa_concurrency.init((cf_nonzero_count)1);
    (*mq_ARADDRin_vec[i]).cfa_send_threshold.init((cf_nonzero_count)1);
    (*mq_ARADDRin_vec[i]).cfa_receive_threshold.init((cf_nonzero_count)1);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    (*mq_AWADDRin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));
    (*mq_AWADDRin_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_NS));
    (*mq_AWADDRin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
    (*mq_AWADDRin_vec[i]).cfa_concurrency.init((cf_nonzero_count)1);
    (*mq_AWADDRin_vec[i]).cfa_send_threshold.init((cf_nonzero_count)1);
    (*mq_AWADDRin_vec[i]).cfa_receive_threshold.init((cf_nonzero_count)1);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    (*mq_DataRead_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));
    (*mq_DataRead_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_NS));
    (*mq_DataRead_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
    (*mq_DataRead_vec[i]).cfa_concurrency.init((cf_nonzero_count)1);
    (*mq_DataRead_vec[i]).cfa_send_threshold.init((cf_nonzero_count)1);
    (*mq_DataRead_vec[i]).cfa_receive_threshold.init((cf_nonzero_count)1);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    (*mq_MemReadRequest_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));
    (*mq_MemReadRequest_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_NS));
    (*mq_MemReadRequest_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
    (*mq_MemReadRequest_vec[i]).cfa_concurrency.init((cf_nonzero_count)1);
    (*mq_MemReadRequest_vec[i]).cfa_send_threshold.init((cf_nonzero_count)1);
    (*mq_MemReadRequest_vec[i]).cfa_receive_threshold.init((cf_nonzero_count)1);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    (*mq_MemWriteRequest_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));
    (*mq_MemWriteRequest_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_NS));
    (*mq_MemWriteRequest_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
    (*mq_MemWriteRequest_vec[i]).cfa_concurrency.init((cf_nonzero_count)1);
    (*mq_MemWriteRequest_vec[i]).cfa_send_threshold.init((cf_nonzero_count)1);
    (*mq_MemWriteRequest_vec[i]).cfa_receive_threshold.init((cf_nonzero_count)1);
  }
  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {
    (*mq_WriteAck_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));
    (*mq_WriteAck_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_NS));
    (*mq_WriteAck_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);
    (*mq_WriteAck_vec[i]).cfa_concurrency.init((cf_nonzero_count)1);
    (*mq_WriteAck_vec[i]).cfa_send_threshold.init((cf_nonzero_count)1);
    (*mq_WriteAck_vec[i]).cfa_receive_threshold.init((cf_nonzero_count)1);
  }

  return;
}
//@}

/// \name initialize definitions
//@{
void cfm_memorycontroller::cb_init_local_vars(void) {

  //<#!@READ-ONLY-SECTION-END@!#>
  // Start of 'MemoryController initializations' algorithm generated code

  // End of 'MemoryController initializations' algorithm generated code
  //<#!@READ-ONLY-SECTION-START@!#>
}
//@}

//<#!@READ-ONLY-SECTION-END@!#>