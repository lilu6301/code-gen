[
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'SoftwareDefinedRadioApp', 'models': [{'name': 'MobilePhone', 'type': 'cofluent:Function'}, {'name': 'Networks', 'type': 'cofluent:Function'}, {'name': 'User', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Request', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'UMTSToNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Response', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'Video', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToDVB', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'Networks']}]}",
        "Response": [
            "/*!\n * \\class cfm_softwaredefinedradioapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_softwaredefinedradioapp_dp_if.h\"\n#include \"cfm_mobilephone.h\"\n#include \"cfm_networks.h\"\n#include \"cfm_user.h\"\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defvideo.h\"\n\n\n\nclass cfm_softwaredefinedradioapp: public cf_core::cf_application, public cfm_softwaredefinedradioapp_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_NetToDVB_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_NetToUMTS_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_Request_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_Response_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_UMTSToNet_t;\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_Video_t;\n\n\n\tcfm_softwaredefinedradioapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_softwaredefinedradioapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_mobilephone* MobilePhone;\n\tcfm_networks* Networks;\n\tcfm_user* User;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_NetToDVB_t mq_NetToDVB;\n\tmq_NetToUMTS_t mq_NetToUMTS;\n\tmq_Request_t mq_Request;\n\tmq_Response_t mq_Response;\n\tmq_UMTSToNet_t mq_UMTSToNet;\n\tmq_Video_t mq_Video;\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'SoftwareDefinedRadioApp', 'models': [{'name': 'MobilePhone', 'type': 'cofluent:Function'}, {'name': 'Networks', 'type': 'cofluent:Function'}, {'name': 'User', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Request', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'UMTSToNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Response', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'Video', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToDVB', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'Networks']}]}",
        "Response": [
            "/*\n * \\class cfm_softwaredefinedradioapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_softwaredefinedradioapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_softwaredefinedradioapp::cfm_softwaredefinedradioapp(sc_core::sc_module_name name)\ncf_application(name)\n, cfm_softwaredefinedradioapp_dp_if()\n, mq_NetToDVB(\"NetToDVB\"\n)\n, mq_NetToUMTS(\"NetToUMTS\"\n)\n, mq_Request(\"Request\"\n)\n, mq_Response(\"Response\"\n)\n, mq_UMTSToNet(\"UMTSToNet\"\n)\n, mq_Video(\"Video\"\n)\n\n{\n\tcf_application::init();\n\tMobilePhone = new cfm_mobilephone\n\t(\"MobilePhone\");\n\tNetworks = new cfm_networks\n\t(\"Networks\");\n\tUser = new cfm_user\n\t(\"User\");\n\n\tMobilePhone->p_mq_NetToDVB\n\t(mq_NetToDVB\n\t\t\t.p_target_socket\n\t);\n\tMobilePhone->p_mq_Video\n\t(mq_Video\n\t\t\t.p_target_socket\n\t);\n\tMobilePhone->p_mq_NetToUMTS\n\t(mq_NetToUMTS\n\t\t\t.p_target_socket\n\t);\n\tMobilePhone->p_mq_UMTSToNet\n\t(mq_UMTSToNet\n\t\t\t.p_target_socket\n\t);\n\tMobilePhone->p_mq_Response\n\t(mq_Response\n\t\t\t.p_target_socket\n\t);\n\tMobilePhone->p_mq_Request\n\t(mq_Request\n\t\t\t.p_target_socket\n\t);\n\n\tNetworks->p_mq_NetToDVB\n\t(mq_NetToDVB\n\t\t\t.p_target_socket\n\t);\n\tNetworks->p_mq_NetToUMTS\n\t(mq_NetToUMTS\n\t\t\t.p_target_socket\n\t);\n\tNetworks->p_mq_UMTSToNet\n\t(mq_UMTSToNet\n\t\t\t.p_target_socket\n\t);\n\n\tUser->p_mq_Video\n\t(mq_Video\n\t\t\t.p_target_socket\n\t);\n\tUser->p_mq_Response\n\t(mq_Response\n\t\t\t.p_target_socket\n\t);\n\tUser->p_mq_Request_0\n\t(mq_Request\n\t\t\t.p_target_socket\n\t);\n\tUser->p_mq_Request_1\n\t(mq_Request\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_softwaredefinedradioapp::~cfm_softwaredefinedradioapp(void) {\n\n\tdelete MobilePhone;\t///ddd\n\tdelete Networks;\t///ddd\n\tdelete User;\t///ddd\n}\n\nvoid cfm_softwaredefinedradioapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_softwaredefinedradioapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_softwaredefinedradioapp::cb_end_of_simulation(void) {\n\tcf_trace_report(\"************************************************************\");\n\tcf_trace_report(\"Frames = %i\", TotalFrames);\n\tcf_trace_gui_f_param(\"Frames\", (int) TotalFrames);\n\tif (TotalFrames > 0) {\n\t\tcf_trace_report(\"AverageFrameLatency = %i ms\", (int) (AverageFrameLatency.to_scalar(CF_MS) / TotalFrames));\n\t\tcf_trace_gui_f_param(\"AverageFrameLatency\", (int) (AverageFrameLatency.to_scalar(CF_MS) / TotalFrames), \"ms\");\n\t}\n\tcf_trace_report(\"TotalSizeFrames = %i MB\", (int) TotalSizeFrames.to_scalar(CF_MBYTE));\n\tcf_trace_gui_f_param(\"TotalFramesSize\", (int) TotalSizeFrames.to_scalar(CF_MBYTE), \"MB\");\n\tcf_trace_report(\"Bursts = %i\", TotalBursts);\n\tcf_trace_gui_f_param(\"Bursts\", (int) TotalBursts);\n\tif (TotalBursts > 0) {\n\t\tcf_trace_report(\"AverageBurstLatency = %i ms\", (int) (AverageBurstLatency.to_scalar(CF_MS) / TotalBursts));\n\t\tcf_trace_gui_f_param(\"AverageBurstLatency\", (int) (AverageBurstLatency.to_scalar(CF_MS) / TotalBursts), \"ms\");\n\t}\n\tcf_trace_report(\"************************************************************\");\n}\n\nvoid cfm_softwaredefinedradioapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_NetToDVB.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToDVB.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToDVB.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_NetToDVB.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_NetToDVB.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_NetToUMTS.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToUMTS.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToUMTS.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_NetToUMTS.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_NetToUMTS.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Request.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Request.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Request.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Request.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Request.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Response.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Response.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Response.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Response.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Response.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_UMTSToNet.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToNet.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToNet.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_UMTSToNet.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_UMTSToNet.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Video.cfa_send_time.init(cf_expr_duration(1, CF_MS));\n\tmq_Video.cfa_receive_time.init(cf_expr_duration(1, CF_MS));\n\tmq_Video.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Video.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Video.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_softwaredefinedradioapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MobilePhone', 'type': 'cofluent:Function', 'models': [{'name': 'ApplicationLayer', 'type': 'cofluent:Function'}, {'name': 'CallProtocolStack', 'type': 'cofluent:Function'}, {'name': 'VideoProtocolStack', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'relations': [{'name': 'AppToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'HTTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'AppToCtrl', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'Controller']}, {'name': 'RTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer', 'VideoProtocolStack']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_mobilephone\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_mobilephone_dp_if.h\"\n#include \"cfm_applicationlayer.h\"\n#include \"cfm_callprotocolstack.h\"\n#include \"cfm_controller.h\"\n#include \"cfm_videoprotocolstack.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_mobilephone: public cf_core::cf_function_container, public cfm_mobilephone_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_AppToCtrl_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_AppToHTTP_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_HTTPToApp_t;\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_RTPToApp_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_UMTSToNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_Request_t;\n\n\tcfm_mobilephone(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_mobilephone(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_t p_mq_Request;\n\npublic:\n\tcfm_applicationlayer* ApplicationLayer;\n\tcfm_callprotocolstack* CallProtocolStack;\n\tcfm_controller* Controller;\n\tcfm_videoprotocolstack* VideoProtocolStack;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_AppToCtrl_t mq_AppToCtrl;\n\tmq_AppToHTTP_t mq_AppToHTTP;\n\tmq_HTTPToApp_t mq_HTTPToApp;\n\tmq_RTPToApp_t mq_RTPToApp;\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MobilePhone', 'type': 'cofluent:Function', 'models': [{'name': 'ApplicationLayer', 'type': 'cofluent:Function'}, {'name': 'CallProtocolStack', 'type': 'cofluent:Function'}, {'name': 'VideoProtocolStack', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'relations': [{'name': 'AppToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'HTTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'AppToCtrl', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'Controller']}, {'name': 'RTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer', 'VideoProtocolStack']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_mobilephone\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_mobilephone.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mobilephone\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_mobilephone::cfm_mobilephone(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_mobilephone_dp_if()\n, p_mq_NetToDVB(\"p_mq_NetToDVB\")\n, p_mq_Video(\"p_mq_Video\")\n, p_mq_NetToUMTS(\"p_mq_NetToUMTS\")\n, p_mq_UMTSToNet(\"p_mq_UMTSToNet\")\n, p_mq_Response(\"p_mq_Response\")\n, p_mq_Request(\"p_mq_Request\")\n, mq_AppToCtrl(\"AppToCtrl\"\n)\n, mq_AppToHTTP(\"AppToHTTP\"\n)\n, mq_HTTPToApp(\"HTTPToApp\"\n)\n, mq_RTPToApp(\"RTPToApp\"\n)\n\n{\n\tcf_function_container::init();\n\tApplicationLayer = new cfm_applicationlayer\n\t(\"ApplicationLayer\");\n\tCallProtocolStack = new cfm_callprotocolstack\n\t(\"CallProtocolStack\");\n\tController = new cfm_controller\n\t(\"Controller\");\n\tVideoProtocolStack = new cfm_videoprotocolstack\n\t(\"VideoProtocolStack\");\n\n\tApplicationLayer->p_mq_Video\n\t(p_mq_Video\n\t);\n\tApplicationLayer->p_mq_RTPToApp\n\t(mq_RTPToApp\n\t\t\t.p_target_socket\n\t);\n\tApplicationLayer->p_mq_AppToCtrl\n\t(mq_AppToCtrl\n\t\t\t.p_target_socket\n\t);\n\tApplicationLayer->p_mq_HTTPToApp\n\t(mq_HTTPToApp\n\t\t\t.p_target_socket\n\t);\n\tApplicationLayer->p_mq_AppToHTTP\n\t(mq_AppToHTTP\n\t\t\t.p_target_socket\n\t);\n\tApplicationLayer->p_mq_Response\n\t(p_mq_Response\n\t);\n\tApplicationLayer->p_mq_Request\n\t(p_mq_Request\n\t);\n\n\tCallProtocolStack->p_mq_NetToUMTS\n\t(p_mq_NetToUMTS\n\t);\n\tCallProtocolStack->p_mq_UMTSToNet\n\t(p_mq_UMTSToNet\n\t);\n\tCallProtocolStack->p_mq_HTTPToApp\n\t(mq_HTTPToApp\n\t\t\t.p_target_socket\n\t);\n\tCallProtocolStack->p_mq_AppToHTTP\n\t(mq_AppToHTTP\n\t\t\t.p_target_socket\n\t);\n\n\tController->p_mq_AppToCtrl\n\t(mq_AppToCtrl\n\t\t\t.p_target_socket\n\t);\n\n\tVideoProtocolStack->p_mq_NetToDVB\n\t(p_mq_NetToDVB\n\t);\n\tVideoProtocolStack->p_mq_RTPToApp\n\t(mq_RTPToApp\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_mobilephone::~cfm_mobilephone(void) {\n\n\tdelete ApplicationLayer;\t///ddd\n\tdelete CallProtocolStack;\t///ddd\n\tdelete Controller;\t///ddd\n\tdelete VideoProtocolStack;\t///ddd\n}\n\nvoid cfm_mobilephone::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_mobilephone::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_mobilephone::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_mobilephone::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_AppToCtrl.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToCtrl.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToCtrl.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_AppToCtrl.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_AppToCtrl.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_AppToHTTP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToHTTP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToHTTP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_AppToHTTP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_AppToHTTP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_HTTPToApp.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToApp.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToApp.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_HTTPToApp.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_HTTPToApp.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RTPToApp.cfa_send_time.init(cf_expr_duration(100, CF_US));\n\tmq_RTPToApp.cfa_receive_time.init(cf_expr_duration(1, CF_MS));\n\tmq_RTPToApp.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RTPToApp.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RTPToApp.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_mobilephone::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Networks', 'type': 'cofluent:Function', 'models': [{'name': 'InteractiveNetwork', 'type': 'cofluent:Function'}, {'name': 'BroadcastNetwork', 'type': 'cofluent:Function'}, {'name': 'ClockGenerator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'relations': [{'name': 'VideoNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'VideoFiles', 'type': 'cofluent:SharedVariable', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'BurstClock', 'type': 'cofluent:Event', 'connectTo': ['BroadcastNetwork', 'ClockGenerator']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_networks\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_networks_dp_if.h\"\n#include \"cfm_broadcastnetwork.h\"\n#include \"cfm_clockgenerator.h\"\n#include \"cfm_interactivenetwork.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defnet.h\"\n\n\n\nclass cfm_networks: public cf_core::cf_function_container, public cfm_networks_dp_if {\npublic:\n\ttypedef cf_core::cf_event ev_BurstClock_t;\n\ttypedef cf_core::cf_shared_variable<cft_defnet> sv_VideoFiles_t;\n\ttypedef cf_core::cf_message_queue<cft_defnet> mq_VideoNet_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_networks, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_networks, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_networks, cft_defcall> p_mq_UMTSToNet_t;\n\n\tcfm_networks(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_networks(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\npublic:\n\tcfm_broadcastnetwork* BroadcastNetwork;\n\tcfm_clockgenerator* ClockGenerator;\n\tcfm_interactivenetwork* InteractiveNetwork;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tev_BurstClock_t ev_BurstClock;\n\tsv_VideoFiles_t sv_VideoFiles;\n\tmq_VideoNet_t mq_VideoNet;\n\n\n\tDefNet initSem;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Networks', 'type': 'cofluent:Function', 'models': [{'name': 'InteractiveNetwork', 'type': 'cofluent:Function'}, {'name': 'BroadcastNetwork', 'type': 'cofluent:Function'}, {'name': 'ClockGenerator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'relations': [{'name': 'VideoNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'VideoFiles', 'type': 'cofluent:SharedVariable', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'BurstClock', 'type': 'cofluent:Event', 'connectTo': ['BroadcastNetwork', 'ClockGenerator']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_networks\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_networks.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_networks\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_networks::cfm_networks(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_networks_dp_if()\n, p_mq_NetToDVB(\"p_mq_NetToDVB\")\n, p_mq_NetToUMTS(\"p_mq_NetToUMTS\")\n, p_mq_UMTSToNet(\"p_mq_UMTSToNet\")\n, ev_BurstClock(\"BurstClock\"\n)\n, sv_VideoFiles(\"VideoFiles\"\n)\n, mq_VideoNet(\"VideoNet\"\n)\n\n{\n\tcf_function_container::init();\n\tBroadcastNetwork = new cfm_broadcastnetwork\n\t(\"BroadcastNetwork\");\n\tClockGenerator = new cfm_clockgenerator\n\t(\"ClockGenerator\");\n\tInteractiveNetwork = new cfm_interactivenetwork\n\t(\"InteractiveNetwork\");\n\n\tBroadcastNetwork->p_mq_NetToDVB\n\t(p_mq_NetToDVB\n\t);\n\tBroadcastNetwork->p_ev_BurstClock\n\t(ev_BurstClock\n\t\t\t.p_target_socket\n\t);\n\tBroadcastNetwork->p_sv_VideoFiles\n\t(sv_VideoFiles\n\t\t\t.p_target_socket\n\t);\n\tBroadcastNetwork->p_mq_VideoNet\n\t(mq_VideoNet\n\t\t\t.p_target_socket\n\t);\n\n\tClockGenerator->p_ev_BurstClock\n\t(ev_BurstClock\n\t\t\t.p_target_socket\n\t);\n\n\tInteractiveNetwork->p_sv_VideoFiles\n\t(sv_VideoFiles\n\t\t\t.p_target_socket\n\t);\n\tInteractiveNetwork->p_mq_VideoNet\n\t(mq_VideoNet\n\t\t\t.p_target_socket\n\t);\n\tInteractiveNetwork->p_mq_NetToUMTS\n\t(p_mq_NetToUMTS\n\t);\n\tInteractiveNetwork->p_mq_UMTSToNet\n\t(p_mq_UMTSToNet\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_networks::~cfm_networks(void) {\n\n\tdelete BroadcastNetwork;\t///ddd\n\tdelete ClockGenerator;\t///ddd\n\tdelete InteractiveNetwork;\t///ddd\n}\n\nvoid cfm_networks::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_networks::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_networks::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_networks::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tev_BurstClock.cfa_set_time.init(cf_expr_duration(0, CF_MS));\n\tev_BurstClock.cfa_get_time.init(cf_expr_duration(0, CF_MS));\n\tev_BurstClock.cfa_event_policy.init(CF_EV_POLICY_FUGITIVE);\n\tsv_VideoFiles.cfa_write_time.init(cf_expr_duration(10, CF_MS));\n\tsv_VideoFiles.cfa_read_time.init(cf_expr_duration(10, CF_MS));\n\tsv_VideoFiles.cfa_semaphore.init(false);\n\tsv_VideoFiles.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_VideoNet.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_VideoNet.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_VideoNet.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_VideoNet.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_VideoNet.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_networks::cb_init_local_vars(void) {\n\n\tsv_VideoFiles.init_value(initSem);\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'User', 'type': 'cofluent:Function', 'models': [{'name': 'Requesting', 'type': 'cofluent:Function'}, {'name': 'Watching', 'type': 'cofluent:Function'}, {'name': 'Reading', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_user\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_user_dp_if.h\"\n#include \"cfm_reading.h\"\n#include \"cfm_requesting.h\"\n#include \"cfm_watching.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_user: public cf_core::cf_function_container, public cfm_user_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defcall> p_mq_Request_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defcall> p_mq_Request_1_t;\n\n\tcfm_user(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_user(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_0_t p_mq_Request_0;\n\tp_mq_Request_1_t p_mq_Request_1;\n\npublic:\n\tcfm_reading* Reading;\n\tcfm_requesting* Requesting;\n\tcfm_watching* Watching;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'User', 'type': 'cofluent:Function', 'models': [{'name': 'Requesting', 'type': 'cofluent:Function'}, {'name': 'Watching', 'type': 'cofluent:Function'}, {'name': 'Reading', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_user\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_user.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_user\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_user::cfm_user(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_user_dp_if()\n, p_mq_Video(\"p_mq_Video\")\n, p_mq_Response(\"p_mq_Response\")\n, p_mq_Request_0(\"p_mq_Request_0\")\n, p_mq_Request_1(\"p_mq_Request_1\")\n\n{\n\tcf_function_container::init();\n\tReading = new cfm_reading\n\t(\"Reading\");\n\tRequesting = new cfm_requesting\n\t(\"Requesting\");\n\tWatching = new cfm_watching\n\t(\"Watching\");\n\n\tReading->p_mq_Request\n\t(p_mq_Request_1\n\t);\n\tReading->p_mq_Response\n\t(p_mq_Response\n\t);\n\n\tRequesting->p_mq_Request\n\t(p_mq_Request_0\n\t);\n\n\tWatching->p_mq_Video\n\t(p_mq_Video\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_user::~cfm_user(void) {\n\n\tdelete Reading;\t///ddd\n\tdelete Requesting;\t///ddd\n\tdelete Watching;\t///ddd\n}\n\nvoid cfm_user::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_user::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_user::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_user::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n\nvoid cfm_user::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationLayer', 'type': 'cofluent:Function', 'models': [{'name': 'CallApplication', 'type': 'cofluent:Function'}, {'name': 'VideoApplication', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_applicationlayer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationlayer_dp_if.h\"\n#include \"cfm_callapplication.h\"\n#include \"cfm_videoapplication.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_applicationlayer: public cf_core::cf_function_container, public cfm_applicationlayer_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defvideo> p_mq_RTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_AppToCtrl_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_AppToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_Request_t;\n\n\tcfm_applicationlayer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_applicationlayer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\tp_mq_AppToCtrl_t p_mq_AppToCtrl;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_t p_mq_Request;\n\npublic:\n\tcfm_callapplication* CallApplication;\n\tcfm_videoapplication* VideoApplication;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationLayer', 'type': 'cofluent:Function', 'models': [{'name': 'CallApplication', 'type': 'cofluent:Function'}, {'name': 'VideoApplication', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_applicationlayer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_applicationlayer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_applicationlayer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_applicationlayer::cfm_applicationlayer(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_applicationlayer_dp_if()\n, p_mq_Video(\"p_mq_Video\")\n, p_mq_RTPToApp(\"p_mq_RTPToApp\")\n, p_mq_AppToCtrl(\"p_mq_AppToCtrl\")\n, p_mq_HTTPToApp(\"p_mq_HTTPToApp\")\n, p_mq_AppToHTTP(\"p_mq_AppToHTTP\")\n, p_mq_Response(\"p_mq_Response\")\n, p_mq_Request(\"p_mq_Request\")\n\n{\n\tcf_function_container::init();\n\tCallApplication = new cfm_callapplication\n\t(\"CallApplication\");\n\tVideoApplication = new cfm_videoapplication\n\t(\"VideoApplication\");\n\n\tCallApplication->p_mq_AppToCtrl\n\t(p_mq_AppToCtrl\n\t);\n\tCallApplication->p_mq_HTTPToApp\n\t(p_mq_HTTPToApp\n\t);\n\tCallApplication->p_mq_AppToHTTP\n\t(p_mq_AppToHTTP\n\t);\n\tCallApplication->p_mq_Response\n\t(p_mq_Response\n\t);\n\tCallApplication->p_mq_Request\n\t(p_mq_Request\n\t);\n\n\tVideoApplication->p_mq_Video\n\t(p_mq_Video\n\t);\n\tVideoApplication->p_mq_RTPToApp\n\t(p_mq_RTPToApp\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_applicationlayer::~cfm_applicationlayer(void) {\n\n\tdelete CallApplication;\t///ddd\n\tdelete VideoApplication;\t///ddd\n}\n\nvoid cfm_applicationlayer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_applicationlayer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_applicationlayer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_applicationlayer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n\nvoid cfm_applicationlayer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CallProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP', 'type': 'cofluent:Function'}, {'name': 'IPCall', 'type': 'cofluent:Function'}, {'name': 'UMTS', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'relations': [{'name': 'HTTPToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}, {'name': 'UMTSToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_callprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_callprotocolstack_dp_if.h\"\n#include \"cfm_httptcp.h\"\n#include \"cfm_ipcall.h\"\n#include \"cfm_umts.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_callprotocolstack: public cf_core::cf_function_container, public cfm_callprotocolstack_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_HTTPToIP_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_IPToHTTP_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_IPToUMTS_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_UMTSToIP_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_UMTSToNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_AppToHTTP_t;\n\n\tcfm_callprotocolstack(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_callprotocolstack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\npublic:\n\tcfm_httptcp* HTTPTCP;\n\tcfm_ipcall* IPCall;\n\tcfm_umts* UMTS;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_HTTPToIP_t mq_HTTPToIP;\n\tmq_IPToHTTP_t mq_IPToHTTP;\n\tmq_IPToUMTS_t mq_IPToUMTS;\n\tmq_UMTSToIP_t mq_UMTSToIP;\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CallProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP', 'type': 'cofluent:Function'}, {'name': 'IPCall', 'type': 'cofluent:Function'}, {'name': 'UMTS', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'relations': [{'name': 'HTTPToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}, {'name': 'UMTSToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_callprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_callprotocolstack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_callprotocolstack\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_callprotocolstack::cfm_callprotocolstack(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_callprotocolstack_dp_if()\n, p_mq_NetToUMTS(\"p_mq_NetToUMTS\")\n, p_mq_UMTSToNet(\"p_mq_UMTSToNet\")\n, p_mq_HTTPToApp(\"p_mq_HTTPToApp\")\n, p_mq_AppToHTTP(\"p_mq_AppToHTTP\")\n, mq_HTTPToIP(\"HTTPToIP\"\n)\n, mq_IPToHTTP(\"IPToHTTP\"\n)\n, mq_IPToUMTS(\"IPToUMTS\"\n)\n, mq_UMTSToIP(\"UMTSToIP\"\n)\n\n{\n\tcf_function_container::init();\n\tHTTPTCP = new cfm_httptcp\n\t(\"HTTPTCP\");\n\tIPCall = new cfm_ipcall\n\t(\"IPCall\");\n\tUMTS = new cfm_umts\n\t(\"UMTS\");\n\n\tHTTPTCP->p_mq_IPToHTTP\n\t(mq_IPToHTTP\n\t\t\t.p_target_socket\n\t);\n\tHTTPTCP->p_mq_HTTPToIP\n\t(mq_HTTPToIP\n\t\t\t.p_target_socket\n\t);\n\tHTTPTCP->p_mq_HTTPToApp\n\t(p_mq_HTTPToApp\n\t);\n\tHTTPTCP->p_mq_AppToHTTP\n\t(p_mq_AppToHTTP\n\t);\n\n\tIPCall->p_mq_UMTSToIP\n\t(mq_UMTSToIP\n\t\t\t.p_target_socket\n\t);\n\tIPCall->p_mq_IPToUMTS\n\t(mq_IPToUMTS\n\t\t\t.p_target_socket\n\t);\n\tIPCall->p_mq_IPToHTTP\n\t(mq_IPToHTTP\n\t\t\t.p_target_socket\n\t);\n\tIPCall->p_mq_HTTPToIP\n\t(mq_HTTPToIP\n\t\t\t.p_target_socket\n\t);\n\n\tUMTS->p_mq_UMTSToIP\n\t(mq_UMTSToIP\n\t\t\t.p_target_socket\n\t);\n\tUMTS->p_mq_NetToUMTS\n\t(p_mq_NetToUMTS\n\t);\n\tUMTS->p_mq_UMTSToNet\n\t(p_mq_UMTSToNet\n\t);\n\tUMTS->p_mq_IPToUMTS\n\t(mq_IPToUMTS\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_callprotocolstack::~cfm_callprotocolstack(void) {\n\n\tdelete HTTPTCP;\t///ddd\n\tdelete IPCall;\t///ddd\n\tdelete UMTS;\t///ddd\n}\n\nvoid cfm_callprotocolstack::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_callprotocolstack::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_callprotocolstack::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_callprotocolstack::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_HTTPToIP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToIP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToIP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_HTTPToIP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_HTTPToIP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_IPToHTTP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToHTTP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToHTTP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_IPToHTTP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_IPToHTTP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_IPToUMTS.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToUMTS.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToUMTS.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_IPToUMTS.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_IPToUMTS.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_UMTSToIP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToIP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToIP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_UMTSToIP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_UMTSToIP.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_callprotocolstack::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VideoProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'RTPUDP', 'type': 'cofluent:Function'}, {'name': 'IPVideo', 'type': 'cofluent:Function'}, {'name': 'MPETSL', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'relations': [{'name': 'MPEToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['IPVideo', 'MPETSL']}, {'name': 'IPToRTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP', 'IPVideo']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_videoprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_videoprotocolstack_dp_if.h\"\n#include \"cfm_ipvideo.h\"\n#include \"cfm_mpetsl.h\"\n#include \"cfm_rtpudp.h\"\n#include \"dt/cft_defvideo.h\"\n\n\n\nclass cfm_videoprotocolstack: public cf_core::cf_function_container, public cfm_videoprotocolstack_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_IPToRTP_t;\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_MPEToIP_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoprotocolstack, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoprotocolstack, cft_defvideo> p_mq_RTPToApp_t;\n\n\tcfm_videoprotocolstack(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_videoprotocolstack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\npublic:\n\tcfm_ipvideo* IPVideo;\n\tcfm_mpetsl* MPETSL;\n\tcfm_rtpudp* RTPUDP;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_IPToRTP_t mq_IPToRTP;\n\tmq_MPEToIP_t mq_MPEToIP;\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VideoProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'RTPUDP', 'type': 'cofluent:Function'}, {'name': 'IPVideo', 'type': 'cofluent:Function'}, {'name': 'MPETSL', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'relations': [{'name': 'MPEToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['IPVideo', 'MPETSL']}, {'name': 'IPToRTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP', 'IPVideo']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_videoprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_videoprotocolstack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_videoprotocolstack\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_videoprotocolstack::cfm_videoprotocolstack(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_videoprotocolstack_dp_if()\n, p_mq_NetToDVB(\"p_mq_NetToDVB\")\n, p_mq_RTPToApp(\"p_mq_RTPToApp\")\n, mq_IPToRTP(\"IPToRTP\"\n)\n, mq_MPEToIP(\"MPEToIP\"\n)\n\n{\n\tcf_function_container::init();\n\tIPVideo = new cfm_ipvideo\n\t(\"IPVideo\");\n\tMPETSL = new cfm_mpetsl\n\t(\"MPETSL\");\n\tRTPUDP = new cfm_rtpudp\n\t(\"RTPUDP\");\n\n\tIPVideo->p_mq_IPToRTP\n\t(mq_IPToRTP\n\t\t\t.p_target_socket\n\t);\n\tIPVideo->p_mq_MPEToIP\n\t(mq_MPEToIP\n\t\t\t.p_target_socket\n\t);\n\n\tMPETSL->p_mq_NetToDVB\n\t(p_mq_NetToDVB\n\t);\n\tMPETSL->p_mq_MPEToIP\n\t(mq_MPEToIP\n\t\t\t.p_target_socket\n\t);\n\n\tRTPUDP->p_mq_RTPToApp\n\t(p_mq_RTPToApp\n\t);\n\tRTPUDP->p_mq_IPToRTP\n\t(mq_IPToRTP\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_videoprotocolstack::~cfm_videoprotocolstack(void) {\n\n\tdelete IPVideo;\t///ddd\n\tdelete MPETSL;\t///ddd\n\tdelete RTPUDP;\t///ddd\n}\n\nvoid cfm_videoprotocolstack::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_videoprotocolstack::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_videoprotocolstack::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_videoprotocolstack::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_IPToRTP.cfa_send_time.init(cf_expr_duration(100, CF_US));\n\tmq_IPToRTP.cfa_receive_time.init(cf_expr_duration(100, CF_US));\n\tmq_IPToRTP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_IPToRTP.cfa_queue_capacity.init((cf_nonzero_count) FramesBufferSize);\n\tmq_IPToRTP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MPEToIP.cfa_send_time.init(cf_expr_duration(1, CF_MS));\n\tmq_MPEToIP.cfa_receive_time.init(cf_expr_duration(1, CF_MS));\n\tmq_MPEToIP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MPEToIP.cfa_queue_capacity.init((cf_nonzero_count) BurstBufferSize);\n\tmq_MPEToIP.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_videoprotocolstack::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_controller_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_controller: public cf_core::cf_function, public cfm_controller_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_controller, cft_defcall> p_mq_AppToCtrl_t;\n\n\tcfm_controller(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_controller(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_AppToCtrl_t p_mq_AppToCtrl;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tbool SendToCallStack;\n\tbool SendToVideoStack;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_controller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_controller\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_controller::cfm_controller(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_controller_dp_if()\n, p_mq_AppToCtrl(\"p_mq_AppToCtrl\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_controller::~cfm_controller(void) {\n\n}\n\nvoid cfm_controller::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_controller::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_controller::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_controller::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_controller::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InteractiveNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefNet'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_interactivenetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_interactivenetwork_dp_if.h\"\n#include \"dt/cft_defnet.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_interactivenetwork: public cf_core::cf_function, public cfm_interactivenetwork_dp_if {\npublic:\n\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_interactivenetwork, cft_defnet> p_sv_VideoFiles_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_interactivenetwork, cft_defnet> p_mq_VideoNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_interactivenetwork, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_interactivenetwork, cft_defcall> p_mq_UMTSToNet_t;\n\n\tcfm_interactivenetwork(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_interactivenetwork(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_sv_VideoFiles_t p_sv_VideoFiles;\n\tp_mq_VideoNet_t p_mq_VideoNet;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint StartSize;\n\tint EndSize;\n\tint FileSize;\n\n\tbool FileRequest;\n\tbool ExitLoop;\n\tbool Sending;\n\tbool FullLink;\n\tbool ExitWaiting;\n\n\tint VideoIndex;\n\tint index;\n\tint VideoSendIndex;\n\n\tDefVideoIndex VideoInd[4];\n\tDefFramesInBurst FramesInBurst[4];\n\tDefBurstsInVideo BurstsInVideo[4];\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InteractiveNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefNet'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_interactivenetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_interactivenetwork.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_interactivenetwork\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_interactivenetwork::cfm_interactivenetwork(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_interactivenetwork_dp_if()\n, p_sv_VideoFiles(\"p_sv_VideoFiles\")\n, p_mq_VideoNet(\"p_mq_VideoNet\")\n, p_mq_NetToUMTS(\"p_mq_NetToUMTS\")\n, p_mq_UMTSToNet(\"p_mq_UMTSToNet\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_interactivenetwork::~cfm_interactivenetwork(void) {\n\n}\n\nvoid cfm_interactivenetwork::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_interactivenetwork::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_interactivenetwork::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_interactivenetwork::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_interactivenetwork::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BroadcastNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'BurstClock', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefNet'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_broadcastnetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_broadcastnetwork_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defnet.h\"\n\n\n\nclass cfm_broadcastnetwork: public cf_core::cf_function, public cfm_broadcastnetwork_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_broadcastnetwork, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_broadcastnetwork> p_ev_BurstClock_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_broadcastnetwork, cft_defnet> p_sv_VideoFiles_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_broadcastnetwork, cft_defnet> p_mq_VideoNet_t;\n\n\tcfm_broadcastnetwork(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_broadcastnetwork(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_ev_BurstClock_t p_ev_BurstClock;\n\tp_sv_VideoFiles_t p_sv_VideoFiles;\n\tp_mq_VideoNet_t p_mq_VideoNet;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tbool ExitBurstLoop;\n\tbool FullLink;\n\tbool ExitWaiting;\n\tbool SendWaiting;\n\tint IndexBurst;\n\tint BurstSize;\n\tint IndexWaiting;\n\tint FramesInBurst;\n\tint BurstsInVideo;\n\tbool Init;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BroadcastNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'BurstClock', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefNet'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_broadcastnetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_broadcastnetwork.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_broadcastnetwork\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_broadcastnetwork::cfm_broadcastnetwork(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_broadcastnetwork_dp_if()\n, p_mq_NetToDVB(\"p_mq_NetToDVB\")\n, p_ev_BurstClock(\"p_ev_BurstClock\")\n, p_sv_VideoFiles(\"p_sv_VideoFiles\")\n, p_mq_VideoNet(\"p_mq_VideoNet\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_broadcastnetwork::~cfm_broadcastnetwork(void) {\n\n}\n\nvoid cfm_broadcastnetwork::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_broadcastnetwork::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_broadcastnetwork::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_broadcastnetwork::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_broadcastnetwork::cb_init_local_vars(void) {\n\n\tInit = true;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ClockGenerator', 'type': 'cofluent:Function', 'ports': [{'name': 'BurstClock', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_clockgenerator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_clockgenerator_dp_if.h\"\n\n\n\nclass cfm_clockgenerator: public cf_core::cf_function, public cfm_clockgenerator_dp_if {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_clockgenerator> p_ev_BurstClock_t;\n\n\tcfm_clockgenerator(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_clockgenerator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_BurstClock_t p_ev_BurstClock;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ClockGenerator', 'type': 'cofluent:Function', 'ports': [{'name': 'BurstClock', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_clockgenerator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_clockgenerator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_clockgenerator\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_clockgenerator::cfm_clockgenerator(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_clockgenerator_dp_if()\n, p_ev_BurstClock(\"p_ev_BurstClock\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_clockgenerator::~cfm_clockgenerator(void) {\n\n}\n\nvoid cfm_clockgenerator::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_clockgenerator::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_clockgenerator::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_clockgenerator::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_clockgenerator::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Requesting', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_requesting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_requesting_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_requesting: public cf_core::cf_function, public cfm_requesting_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_requesting, cft_defcall> p_mq_Request_t;\n\n\tcfm_requesting(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_requesting(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Request_t p_mq_Request;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint Index;\n\tdouble UserDelay;\n\n\tdouble Delay[13];\n\tDefUseCase UseCase[13];\n\tDefCommand Command[13];\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Requesting', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_requesting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_requesting.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_requesting\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_requesting::cfm_requesting(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_requesting_dp_if()\n, p_mq_Request(\"p_mq_Request\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_requesting::~cfm_requesting(void) {\n\n}\n\nvoid cfm_requesting::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_requesting::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_requesting::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_requesting::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_requesting::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Watching', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_watching\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_watching_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n\n\nclass cfm_watching: public cf_core::cf_function, public cfm_watching_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_watching, cft_defvideo> p_mq_Video_t;\n\n\tcfm_watching(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_watching(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Video_t p_mq_Video;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Watching', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_watching\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_watching.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_watching\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_watching::cfm_watching(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_watching_dp_if()\n, p_mq_Video(\"p_mq_Video\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_watching::~cfm_watching(void) {\n\n}\n\nvoid cfm_watching::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_watching::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_watching::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_watching::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_watching::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reading', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_reading\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_reading_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_reading: public cf_core::cf_function, public cfm_reading_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reading, cft_defcall> p_mq_Request_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reading, cft_defcall> p_mq_Response_t;\n\n\tcfm_reading(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_reading(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Request_t p_mq_Request;\n\tp_mq_Response_t p_mq_Response;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint VideoIndex;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reading', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_reading\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_reading.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reading\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_reading::cfm_reading(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_reading_dp_if()\n, p_mq_Request(\"p_mq_Request\")\n, p_mq_Response(\"p_mq_Response\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_reading::~cfm_reading(void) {\n\n}\n\nvoid cfm_reading::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_reading::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_reading::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_reading::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_reading::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CallApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_callapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_callapplication_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_callapplication: public cf_core::cf_function, public cfm_callapplication_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_AppToCtrl_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_AppToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_Request_t;\n\n\tcfm_callapplication(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_callapplication(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_AppToCtrl_t p_mq_AppToCtrl;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_t p_mq_Request;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tbool SendToCtrl;\n\tbool SendToUser;\n\tbool SendToCallStack;\n\tint FileIndex;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CallApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_callapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_callapplication.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationlayer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_callapplication\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_callapplication::cfm_callapplication(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_callapplication_dp_if()\n, p_mq_AppToCtrl(\"p_mq_AppToCtrl\")\n, p_mq_HTTPToApp(\"p_mq_HTTPToApp\")\n, p_mq_AppToHTTP(\"p_mq_AppToHTTP\")\n, p_mq_Response(\"p_mq_Response\")\n, p_mq_Request(\"p_mq_Request\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_callapplication::~cfm_callapplication(void) {\n\n}\n\nvoid cfm_callapplication::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_callapplication::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_callapplication::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_callapplication::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_callapplication::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VideoApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_videoapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_videoapplication_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n\n\nclass cfm_videoapplication: public cf_core::cf_function, public cfm_videoapplication_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoapplication, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoapplication, cft_defvideo> p_mq_RTPToApp_t;\n\n\tcfm_videoapplication(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_videoapplication(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tcf_dt::cf_data_size SizeFrame;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VideoApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_videoapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_videoapplication.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationlayer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_videoapplication\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_videoapplication::cfm_videoapplication(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_videoapplication_dp_if()\n, p_mq_Video(\"p_mq_Video\")\n, p_mq_RTPToApp(\"p_mq_RTPToApp\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_videoapplication::~cfm_videoapplication(void) {\n\n}\n\nvoid cfm_videoapplication::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_videoapplication::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_videoapplication::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_videoapplication::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_videoapplication::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function'}, {'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_httptcp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_dp_if.h\"\n#include \"cfm_httptcp_receive.h\"\n#include \"cfm_httptcp_send.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_httptcp: public cf_core::cf_function_container, public cfm_httptcp_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_IPToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_HTTPToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_AppToHTTP_t;\n\n\tcfm_httptcp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_httptcp(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\npublic:\n\tcfm_httptcp_receive* HTTPTCP_Receive;\n\tcfm_httptcp_send* HTTPTCP_Send;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function'}, {'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_httptcp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_httptcp.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_httptcp::cfm_httptcp(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_httptcp_dp_if()\n, p_mq_IPToHTTP(\"p_mq_IPToHTTP\")\n, p_mq_HTTPToIP(\"p_mq_HTTPToIP\")\n, p_mq_HTTPToApp(\"p_mq_HTTPToApp\")\n, p_mq_AppToHTTP(\"p_mq_AppToHTTP\")\n\n{\n\tcf_function_container::init();\n\tHTTPTCP_Receive = new cfm_httptcp_receive\n\t(\"HTTPTCP_Receive\");\n\tHTTPTCP_Send = new cfm_httptcp_send\n\t(\"HTTPTCP_Send\");\n\n\tHTTPTCP_Receive->p_mq_IPToHTTP\n\t(p_mq_IPToHTTP\n\t);\n\tHTTPTCP_Receive->p_mq_HTTPToApp\n\t(p_mq_HTTPToApp\n\t);\n\n\tHTTPTCP_Send->p_mq_HTTPToIP\n\t(p_mq_HTTPToIP\n\t);\n\tHTTPTCP_Send->p_mq_AppToHTTP\n\t(p_mq_AppToHTTP\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_httptcp::~cfm_httptcp(void) {\n\n\tdelete HTTPTCP_Receive;\t///ddd\n\tdelete HTTPTCP_Send;\t///ddd\n}\n\nvoid cfm_httptcp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_httptcp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_httptcp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_httptcp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n\nvoid cfm_httptcp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall', 'type': 'cofluent:Function', 'models': [{'name': 'IPCall_Send', 'type': 'cofluent:Function'}, {'name': 'IPCall_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_ipcall\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_dp_if.h\"\n#include \"cfm_ipcall_receive.h\"\n#include \"cfm_ipcall_send.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_ipcall: public cf_core::cf_function_container, public cfm_ipcall_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_IPToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_IPToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_HTTPToIP_t;\n\n\tcfm_ipcall(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_ipcall(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\npublic:\n\tcfm_ipcall_receive* IPCall_Receive;\n\tcfm_ipcall_send* IPCall_Send;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall', 'type': 'cofluent:Function', 'models': [{'name': 'IPCall_Send', 'type': 'cofluent:Function'}, {'name': 'IPCall_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_ipcall\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_ipcall.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_ipcall::cfm_ipcall(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_ipcall_dp_if()\n, p_mq_UMTSToIP(\"p_mq_UMTSToIP\")\n, p_mq_IPToUMTS(\"p_mq_IPToUMTS\")\n, p_mq_IPToHTTP(\"p_mq_IPToHTTP\")\n, p_mq_HTTPToIP(\"p_mq_HTTPToIP\")\n\n{\n\tcf_function_container::init();\n\tIPCall_Receive = new cfm_ipcall_receive\n\t(\"IPCall_Receive\");\n\tIPCall_Send = new cfm_ipcall_send\n\t(\"IPCall_Send\");\n\n\tIPCall_Receive->p_mq_UMTSToIP\n\t(p_mq_UMTSToIP\n\t);\n\tIPCall_Receive->p_mq_IPToHTTP\n\t(p_mq_IPToHTTP\n\t);\n\n\tIPCall_Send->p_mq_IPToUMTS\n\t(p_mq_IPToUMTS\n\t);\n\tIPCall_Send->p_mq_HTTPToIP\n\t(p_mq_HTTPToIP\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_ipcall::~cfm_ipcall(void) {\n\n\tdelete IPCall_Receive;\t///ddd\n\tdelete IPCall_Send;\t///ddd\n}\n\nvoid cfm_ipcall::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_ipcall::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_ipcall::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_ipcall::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n\nvoid cfm_ipcall::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS', 'type': 'cofluent:Function', 'models': [{'name': 'UMTS_Send', 'type': 'cofluent:Function'}, {'name': 'UMTS_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_umts\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_dp_if.h\"\n#include \"cfm_umts_receive.h\"\n#include \"cfm_umts_send.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_umts: public cf_core::cf_function_container, public cfm_umts_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_UMTSToNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_IPToUMTS_t;\n\n\tcfm_umts(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_umts(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\npublic:\n\tcfm_umts_receive* UMTS_Receive;\n\tcfm_umts_send* UMTS_Send;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS', 'type': 'cofluent:Function', 'models': [{'name': 'UMTS_Send', 'type': 'cofluent:Function'}, {'name': 'UMTS_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_umts\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_umts.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_umts::cfm_umts(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_umts_dp_if()\n, p_mq_UMTSToIP(\"p_mq_UMTSToIP\")\n, p_mq_NetToUMTS(\"p_mq_NetToUMTS\")\n, p_mq_UMTSToNet(\"p_mq_UMTSToNet\")\n, p_mq_IPToUMTS(\"p_mq_IPToUMTS\")\n\n{\n\tcf_function_container::init();\n\tUMTS_Receive = new cfm_umts_receive\n\t(\"UMTS_Receive\");\n\tUMTS_Send = new cfm_umts_send\n\t(\"UMTS_Send\");\n\n\tUMTS_Receive->p_mq_UMTSToIP\n\t(p_mq_UMTSToIP\n\t);\n\tUMTS_Receive->p_mq_NetToUMTS\n\t(p_mq_NetToUMTS\n\t);\n\n\tUMTS_Send->p_mq_IPToUMTS\n\t(p_mq_IPToUMTS\n\t);\n\tUMTS_Send->p_mq_UMTSToNet\n\t(p_mq_UMTSToNet\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_umts::~cfm_umts(void) {\n\n\tdelete UMTS_Receive;\t///ddd\n\tdelete UMTS_Send;\t///ddd\n}\n\nvoid cfm_umts::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_umts::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_umts::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_umts::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n\nvoid cfm_umts::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RTPUDP', 'type': 'cofluent:Function', 'ports': [{'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_rtpudp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rtpudp_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n\n\nclass cfm_rtpudp: public cf_core::cf_function, public cfm_rtpudp_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rtpudp, cft_defvideo> p_mq_RTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rtpudp, cft_defvideo> p_mq_IPToRTP_t;\n\n\tcfm_rtpudp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_rtpudp(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\tp_mq_IPToRTP_t p_mq_IPToRTP;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint SyncFramesDuration;\n\tint DelayDuration;\n\tint FramesInBurst;\n\tint TimeDifference;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RTPUDP', 'type': 'cofluent:Function', 'ports': [{'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_rtpudp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_rtpudp.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rtpudp\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_rtpudp::cfm_rtpudp(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_rtpudp_dp_if()\n, p_mq_RTPToApp(\"p_mq_RTPToApp\")\n, p_mq_IPToRTP(\"p_mq_IPToRTP\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_rtpudp::~cfm_rtpudp(void) {\n\n}\n\nvoid cfm_rtpudp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_rtpudp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_rtpudp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_rtpudp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_rtpudp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPVideo', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_ipvideo\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipvideo_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n\n\nclass cfm_ipvideo: public cf_core::cf_function, public cfm_ipvideo_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipvideo, cft_defvideo> p_mq_IPToRTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipvideo, cft_defvideo> p_mq_MPEToIP_t;\n\n\tcfm_ipvideo(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_ipvideo(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_IPToRTP_t p_mq_IPToRTP;\n\tp_mq_MPEToIP_t p_mq_MPEToIP;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint FramesInBurst;\n\tint IndexFrame;\n\tint TimeDifference;\n\tint Size;\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPVideo', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_ipvideo\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_ipvideo.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipvideo\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_ipvideo::cfm_ipvideo(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_ipvideo_dp_if()\n, p_mq_IPToRTP(\"p_mq_IPToRTP\")\n, p_mq_MPEToIP(\"p_mq_MPEToIP\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_ipvideo::~cfm_ipvideo(void) {\n\n}\n\nvoid cfm_ipvideo::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_ipvideo::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_ipvideo::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_ipvideo::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_ipvideo::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MPETSL', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_mpetsl\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_mpetsl_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n\n\nclass cfm_mpetsl: public cf_core::cf_function, public cfm_mpetsl_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mpetsl, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mpetsl, cft_defvideo> p_mq_MPEToIP_t;\n\n\tcfm_mpetsl(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_mpetsl(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_MPEToIP_t p_mq_MPEToIP;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MPETSL', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_mpetsl\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_mpetsl.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mpetsl\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_mpetsl::cfm_mpetsl(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_mpetsl_dp_if()\n, p_mq_NetToDVB(\"p_mq_NetToDVB\")\n, p_mq_MPEToIP(\"p_mq_MPEToIP\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_mpetsl::~cfm_mpetsl(void) {\n\n}\n\nvoid cfm_mpetsl::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_mpetsl::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_mpetsl::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_mpetsl::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_mpetsl::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_httptcp_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_send_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_httptcp_send: public cf_core::cf_function, public cfm_httptcp_send_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_send, cft_defcall> p_mq_HTTPToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_send, cft_defcall> p_mq_AppToHTTP_t;\n\n\tcfm_httptcp_send(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_httptcp_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_httptcp_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_httptcp_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_httptcp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp_send\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_httptcp_send::cfm_httptcp_send(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_httptcp_send_dp_if()\n, p_mq_HTTPToIP(\"p_mq_HTTPToIP\")\n, p_mq_AppToHTTP(\"p_mq_AppToHTTP\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_httptcp_send::~cfm_httptcp_send(void) {\n\n}\n\nvoid cfm_httptcp_send::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_httptcp_send::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_httptcp_send::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_httptcp_send::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_httptcp_send::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_httptcp_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_receive_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_httptcp_receive: public cf_core::cf_function, public cfm_httptcp_receive_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_receive, cft_defcall> p_mq_IPToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_receive, cft_defcall> p_mq_HTTPToApp_t;\n\n\tcfm_httptcp_receive(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_httptcp_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_httptcp_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_httptcp_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_httptcp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp_receive\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_httptcp_receive::cfm_httptcp_receive(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_httptcp_receive_dp_if()\n, p_mq_IPToHTTP(\"p_mq_IPToHTTP\")\n, p_mq_HTTPToApp(\"p_mq_HTTPToApp\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_httptcp_receive::~cfm_httptcp_receive(void) {\n\n}\n\nvoid cfm_httptcp_receive::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_httptcp_receive::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_httptcp_receive::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_httptcp_receive::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_httptcp_receive::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_ipcall_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_send_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_ipcall_send: public cf_core::cf_function, public cfm_ipcall_send_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_send, cft_defcall> p_mq_IPToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_send, cft_defcall> p_mq_HTTPToIP_t;\n\n\tcfm_ipcall_send(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_ipcall_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_ipcall_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_ipcall_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ipcall\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall_send\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_ipcall_send::cfm_ipcall_send(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_ipcall_send_dp_if()\n, p_mq_IPToUMTS(\"p_mq_IPToUMTS\")\n, p_mq_HTTPToIP(\"p_mq_HTTPToIP\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_ipcall_send::~cfm_ipcall_send(void) {\n\n}\n\nvoid cfm_ipcall_send::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_ipcall_send::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_ipcall_send::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_ipcall_send::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_ENVIRONMENT);\n\n\treturn;\n}\n\nvoid cfm_ipcall_send::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_ipcall_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_receive_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_ipcall_receive: public cf_core::cf_function, public cfm_ipcall_receive_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_receive, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_receive, cft_defcall> p_mq_IPToHTTP_t;\n\n\tcfm_ipcall_receive(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_ipcall_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_ipcall_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_ipcall_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ipcall\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall_receive\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_ipcall_receive::cfm_ipcall_receive(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_ipcall_receive_dp_if()\n, p_mq_UMTSToIP(\"p_mq_UMTSToIP\")\n, p_mq_IPToHTTP(\"p_mq_IPToHTTP\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_ipcall_receive::~cfm_ipcall_receive(void) {\n\n}\n\nvoid cfm_ipcall_receive::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_ipcall_receive::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_ipcall_receive::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_ipcall_receive::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_ipcall_receive::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_umts_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_send_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_umts_send: public cf_core::cf_function, public cfm_umts_send_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_send, cft_defcall> p_mq_IPToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_send, cft_defcall> p_mq_UMTSToNet_t;\n\n\tcfm_umts_send(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_umts_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_umts_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_umts_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_umts\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts_send\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_umts_send::cfm_umts_send(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_umts_send_dp_if()\n, p_mq_IPToUMTS(\"p_mq_IPToUMTS\")\n, p_mq_UMTSToNet(\"p_mq_UMTSToNet\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_umts_send::~cfm_umts_send(void) {\n\n}\n\nvoid cfm_umts_send::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_umts_send::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_umts_send::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_umts_send::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_umts_send::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*!\n * \\class cfm_umts_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_receive_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n\n\nclass cfm_umts_receive: public cf_core::cf_function, public cfm_umts_receive_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_receive, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_receive, cft_defcall> p_mq_NetToUMTS_t;\n\n\tcfm_umts_receive(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_umts_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "/*\n * \\class cfm_umts_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_umts_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_umts\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts_receive\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_umts_receive::cfm_umts_receive(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_umts_receive_dp_if()\n, p_mq_UMTSToIP(\"p_mq_UMTSToIP\")\n, p_mq_NetToUMTS(\"p_mq_NetToUMTS\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_umts_receive::~cfm_umts_receive(void) {\n\n}\n\nvoid cfm_umts_receive::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_umts_receive::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_umts_receive::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_umts_receive::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_umts_receive::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoSimVCSUVMApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'ProcessingFunction', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'read', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProcessingFunction']}, {'name': 'data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProcessingFunction', 'Producer']}]}",
        "Response": [
            "/*!\n * \\class cfm_cosimvcsuvmapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP\n#define COFS_MODEL_COSIMVCSUVMAPP\n\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"uvm_tlm2_sc_bind.h\"\n#include \"wrappers/cfm_data_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_read_tlm2_lt_target.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_cosimvcsuvmapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_data_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_read_t;\n\n\n\tcfm_cosimvcsuvmapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_cosimvcsuvmapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_data_t mq_data;\n\tmq_read_t mq_read;\n\nprotected:\n\tcfm_data_tlm2_lt_initiator data_tlm2_lt_initiator;\n\tcfm_read_tlm2_lt_target read_tlm2_lt_target;\n\n\n\n\n};\n\n#endif // COFS_MODEL_COSIMVCSUVMAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoSimVCSUVMApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'ProcessingFunction', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'read', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProcessingFunction']}, {'name': 'data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProcessingFunction', 'Producer']}]}",
        "Response": [
            "/*\n * \\class cfm_cosimvcsuvmapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_cosimvcsuvmapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_cosimvcsuvmapp::cfm_cosimvcsuvmapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_data(\"data\"\n)\n, mq_read(\"read\"\n)\n, data_tlm2_lt_initiator(\"data_tlm2_lt_initiator\")\n, read_tlm2_lt_target(\"read_tlm2_lt_target\")\n\n{\n\tcf_application::init();\n\tConsumer = new cfm_consumer\n\t(\"Consumer\");\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\n\tConsumer->p_mq_read\n\t(mq_read\n\t\t\t.p_target_socket\n\t);\n\n\tuvm_tlm2_bind_sc_target(read_tlm2_lt_target.p_tlm2, UVM_TLM_B, \"port_read\");\n\tuvm_tlm2_bind_sc_initiator(data_tlm2_lt_initiator.p_tlm2, UVM_TLM_B, \"port_data\", true);\n\n\tProducer->p_mq_data\n\t(mq_data\n\t\t\t.p_target_socket\n\t);\n\n\tdata_tlm2_lt_initiator\n\t.p_mq_data(mq_data.p_target_socket);\n\tread_tlm2_lt_target\n\t.p_mq_read(mq_read.p_target_socket);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_cosimvcsuvmapp::~cfm_cosimvcsuvmapp(void) {\n\n\tdelete Consumer;\t///ddd\n\tdelete Producer;\t///ddd\n}\n\nvoid cfm_cosimvcsuvmapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_cosimvcsuvmapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_cosimvcsuvmapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_cosimvcsuvmapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_data.cfa_send_time.init(cf_expr_duration(2, CF_NS));\n\tmq_data.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_data.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_data.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_data.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_read.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_read.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_read.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_read.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_read.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_read.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_read.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_cosimvcsuvmapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'read', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n#define COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cf_core::cf_payload_int> p_mq_read_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_read_t p_mq_read;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'read', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimvcsuvmapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_read(\"p_mq_read\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n#define COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_int> p_mq_data_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_data_t p_mq_data;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tunsigned int datalen;\n\n};\n\n#endif // COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimvcsuvmapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_data(\"p_mq_data\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example1App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "/*!\n * \\class cfm_inheritance_example1app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP\n\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_f1.h\"\n#include \"cfm_f2.h\"\n\n\n\nclass cfm_inheritance_example1app: public cf_core::cf_application {\npublic:\n\n\n\tcfm_inheritance_example1app(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inheritance_example1app(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_f1* F1;\n\tcfm_f2* F2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example1App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "/*\n * \\class cfm_inheritance_example1app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inheritance_example1app.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inheritance_example1app::cfm_inheritance_example1app(sc_core::sc_module_name name)\ncf_application(name)\n\n{\n\tcf_application::init();\n\tF1 = new cfm_f1\n\t(\"F1\");\n\tF2 = new cfm_f2\n\t(\"F2\");\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_inheritance_example1app::~cfm_inheritance_example1app(void) {\n\n\tdelete F1;\t///ddd\n\tdelete F2;\t///ddd\n}\n\nvoid cfm_inheritance_example1app::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inheritance_example1app::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inheritance_example1app::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inheritance_example1app::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n\nvoid cfm_inheritance_example1app::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "/*!\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_f1: public cf_core::cf_function {\npublic:\n\n\n\tcfm_f1(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_f1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "/*\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_f1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example1app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f1\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_f1::cfm_f1(sc_core::sc_module_name name)\ncf_function(name)\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_f1::~cfm_f1(void) {\n\n}\n\nvoid cfm_f1::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_f1::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_f1::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_f1::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_f1::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_f2: public cf_core::cf_function {\npublic:\n\n\n\tcfm_f2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_f2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example1app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_f2::cfm_f2(sc_core::sc_module_name name)\ncf_function(name)\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_f2::~cfm_f2(void) {\n\n}\n\nvoid cfm_f2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_f2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_f2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_f2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_f2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CopyPayloadNonPod', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "/*!\n * \\class cfm_copypayloadnonpod\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD\n#define COFS_MODEL_COPYPAYLOADNONPOD\n\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"dt/cft_defmsgq.h\"\n\n\n\nclass cfm_copypayloadnonpod: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgQ_t;\n\n\n\tcfm_copypayloadnonpod(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_copypayloadnonpod(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQ_t mq_MsgQ;\n\n\n\n\n};\n\n#endif // COFS_MODEL_COPYPAYLOADNONPOD\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CopyPayloadNonPod', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "/*\n * \\class cfm_copypayloadnonpod\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_copypayloadnonpod.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_copypayloadnonpod::cfm_copypayloadnonpod(sc_core::sc_module_name name)\ncf_application(name)\n, mq_MsgQ(\"MsgQ\"\n)\n\n{\n\tcf_application::init();\n\tConsumer = new cfm_consumer\n\t(\"Consumer\");\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\n\tConsumer->p_mq_MsgQ\n\t(mq_MsgQ\n\t\t\t.p_target_socket\n\t);\n\n\tProducer->p_mq_MsgQ\n\t(mq_MsgQ\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_copypayloadnonpod::~cfm_copypayloadnonpod(void) {\n\n\tdelete Consumer;\t///ddd\n\tdelete Producer;\t///ddd\n}\n\nvoid cfm_copypayloadnonpod::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_copypayloadnonpod::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_copypayloadnonpod::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_copypayloadnonpod::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_MsgQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQ.cfa_queue_capacity.init((cf_nonzero_count) 10);\n\tmq_MsgQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_copypayloadnonpod::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n#define COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cft_defmsgq> p_mq_MsgQ_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_copypayloadnonpod\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n#define COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defmsgq> p_mq_MsgQ_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint cpt;\n\tint Value[100];\n\n};\n\n#endif // COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_copypayloadnonpod\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoFluentAPIFromExternalIP', 'models': [{'name': 'iUart', 'type': 'cofluent:SystemCIP'}, {'name': 'CoF_Initiator', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgFwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}, {'name': 'MsgBwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}]}",
        "Response": [
            "/*!\n * \\class cfm_cofluentapifromexternalip\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n#define COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n\n#include \"cfm_cofluentapifromexternalip_global.h\"\n#include \"cfm_cofluentapifromexternalip_global_types.h\"\n#include \"cofluent.h\"\n#include \"Uart.h\"\n#include \"cfm_cof_initiator.h\"\n#include \"dt/cft_defmsgq.h\"\n\n\n\nclass cfm_cofluentapifromexternalip: public cf_core::cf_application {\npublic:\n\ttypedef Uart iUart_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgBwQ_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgFwQ_t;\n\n\n\tcfm_cofluentapifromexternalip(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_cofluentapifromexternalip(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_cof_initiator* CoF_Initiator;\n\tiUart_t* iUart;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgBwQ_t mq_MsgBwQ;\n\tmq_MsgFwQ_t mq_MsgFwQ;\n\n\n\n\n};\n\n#endif // COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoFluentAPIFromExternalIP', 'models': [{'name': 'iUart', 'type': 'cofluent:SystemCIP'}, {'name': 'CoF_Initiator', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgFwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}, {'name': 'MsgBwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}]}",
        "Response": [
            "/*\n * \\class cfm_cofluentapifromexternalip\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_cofluentapifromexternalip.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_cofluentapifromexternalip::cfm_cofluentapifromexternalip(sc_core::sc_module_name name)\ncf_application(name)\n, mq_MsgBwQ(\"MsgBwQ\"\n)\n, mq_MsgFwQ(\"MsgFwQ\"\n)\n\n{\n\tcf_application::init();\n\tCoF_Initiator = new cfm_cof_initiator\n\t(\"CoF_Initiator\");\n\tiUart = new iUart_t\n\t(\"iUart\");\n\n\tCoF_Initiator->p_mq_MsgFwQ\n\t(mq_MsgFwQ\n\t\t\t.p_target_socket\n\t);\n\tCoF_Initiator->p_mq_MsgBwQ\n\t(mq_MsgBwQ\n\t\t\t.p_target_socket\n\t);\n\n\tiUart->p_mq_request\n\t(mq_MsgFwQ\n\t\t\t.p_target_socket\n\t);\n\tiUart->p_mq_response\n\t(mq_MsgBwQ\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_cofluentapifromexternalip::~cfm_cofluentapifromexternalip(void) {\n\n\tdelete CoF_Initiator;\t///ddd\n\tdelete iUart;\t///ddd\n}\n\nvoid cfm_cofluentapifromexternalip::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_cofluentapifromexternalip::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_cofluentapifromexternalip::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_cofluentapifromexternalip::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_MsgBwQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgBwQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgBwQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgBwQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgBwQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgBwQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgBwQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgFwQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgFwQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgFwQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_cofluentapifromexternalip::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoF_Initiator', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgFwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'MsgBwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CoFluentAPIFromExternalIP'}",
        "Response": [
            "/*!\n * \\class cfm_cof_initiator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n#define COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n\n#include \"cfm_cofluentapifromexternalip_global.h\"\n#include \"cfm_cofluentapifromexternalip_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n\n\nclass cfm_cof_initiator: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_cof_initiator, cft_defmsgq> p_mq_MsgFwQ_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_cof_initiator, cft_defmsgq> p_mq_MsgBwQ_t;\n\n\tcfm_cof_initiator(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_cof_initiator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgFwQ_t p_mq_MsgFwQ;\n\tp_mq_MsgBwQ_t p_mq_MsgBwQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoF_Initiator', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgFwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'MsgBwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CoFluentAPIFromExternalIP'}",
        "Response": [
            "/*\n * \\class cfm_cof_initiator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_cof_initiator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cofluentapifromexternalip\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_cof_initiator\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_cof_initiator::cfm_cof_initiator(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgFwQ(\"p_mq_MsgFwQ\")\n, p_mq_MsgBwQ(\"p_mq_MsgBwQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_cof_initiator::~cfm_cof_initiator(void) {\n\n}\n\nvoid cfm_cof_initiator::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_cof_initiator::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_cof_initiator::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_cof_initiator::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_cof_initiator::cb_init_local_vars(void) {\n\n\tMsgFwQ = 0;\n\tMsgBwQ = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TransactionTrackerMsgQApp', 'models': [{'name': 'Consumer1', 'type': 'cofluent:Function'}, {'name': 'Consumer2', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'MessageRouting', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQOut2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer2', 'MessageRouting']}, {'name': 'MsgQIn', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'MessageRouting']}, {'name': 'MsgQOut1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer1', 'MessageRouting']}]}",
        "Response": [
            "/*!\n * \\class cfm_transactiontrackermsgqapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer1.h\"\n#include \"cfm_consumer2.h\"\n#include \"cfm_messagerouting.h\"\n#include \"cfm_producer.h\"\n\n\n\nclass cfm_transactiontrackermsgqapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQIn_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQOut1_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQOut2_t;\n\n\n\tcfm_transactiontrackermsgqapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_transactiontrackermsgqapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumer1* Consumer1;\n\tcfm_consumer2* Consumer2;\n\tcfm_messagerouting* MessageRouting;\n\tcfm_producer* Producer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQIn_t mq_MsgQIn;\n\tmq_MsgQOut1_t mq_MsgQOut1;\n\tmq_MsgQOut2_t mq_MsgQOut2;\n\n\n\n\n};\n\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TransactionTrackerMsgQApp', 'models': [{'name': 'Consumer1', 'type': 'cofluent:Function'}, {'name': 'Consumer2', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'MessageRouting', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQOut2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer2', 'MessageRouting']}, {'name': 'MsgQIn', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'MessageRouting']}, {'name': 'MsgQOut1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer1', 'MessageRouting']}]}",
        "Response": [
            "/*\n * \\class cfm_transactiontrackermsgqapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_transactiontrackermsgqapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_transactiontrackermsgqapp::cfm_transactiontrackermsgqapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_MsgQIn(\"MsgQIn\"\n)\n, mq_MsgQOut1(\"MsgQOut1\"\n)\n, mq_MsgQOut2(\"MsgQOut2\"\n)\n\n{\n\tcf_application::init();\n\tConsumer1 = new cfm_consumer1\n\t(\"Consumer1\");\n\tConsumer2 = new cfm_consumer2\n\t(\"Consumer2\");\n\tMessageRouting = new cfm_messagerouting\n\t(\"MessageRouting\");\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\n\tConsumer1->p_mq_MsgQOut1\n\t(mq_MsgQOut1\n\t\t\t.p_target_socket\n\t);\n\n\tConsumer2->p_mq_MsgQOut2\n\t(mq_MsgQOut2\n\t\t\t.p_target_socket\n\t);\n\n\tMessageRouting->p_mq_MsgQIn\n\t(mq_MsgQIn\n\t\t\t.p_target_socket\n\t);\n\tMessageRouting->p_mq_MsgQOut2\n\t(mq_MsgQOut2\n\t\t\t.p_target_socket\n\t);\n\tMessageRouting->p_mq_MsgQOut1\n\t(mq_MsgQOut1\n\t\t\t.p_target_socket\n\t);\n\n\tProducer->p_mq_MsgQIn\n\t(mq_MsgQIn\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_transactiontrackermsgqapp::~cfm_transactiontrackermsgqapp(void) {\n\n\tdelete Consumer1;\t///ddd\n\tdelete Consumer2;\t///ddd\n\tdelete MessageRouting;\t///ddd\n\tdelete Producer;\t///ddd\n}\n\nvoid cfm_transactiontrackermsgqapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_transactiontrackermsgqapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_transactiontrackermsgqapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_transactiontrackermsgqapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_MsgQIn.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQIn.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQIn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQIn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQIn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQIn.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQIn.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut1.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut1.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOut1.cfa_queue_capacity.init((cf_nonzero_count) 3);\n\tmq_MsgQOut1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOut1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut2.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut2.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOut2.cfa_queue_capacity.init((cf_nonzero_count) 3);\n\tmq_MsgQOut2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOut2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_transactiontrackermsgqapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer1', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer1: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer1, cf_core::cf_payload_int> p_mq_MsgQOut1_t;\n\n\tcfm_consumer1(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQOut1_t p_mq_MsgQOut1;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer1', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer1\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer1::cfm_consumer1(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQOut1(\"p_mq_MsgQOut1\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer1::~cfm_consumer1(void) {\n\n}\n\nvoid cfm_consumer1::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer1::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer1::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer1::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer1::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer2', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer2: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer2, cf_core::cf_payload_int> p_mq_MsgQOut2_t;\n\n\tcfm_consumer2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQOut2_t p_mq_MsgQOut2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer2', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer2::cfm_consumer2(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQOut2(\"p_mq_MsgQOut2\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer2::~cfm_consumer2(void) {\n\n}\n\nvoid cfm_consumer2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n#include <sstream>\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_int> p_mq_MsgQIn_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQIn_t p_mq_MsgQIn;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint TempInt;\n\n};\n\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQIn(\"p_mq_MsgQIn\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\tTempInt = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MessageRouting', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*!\n * \\class cfm_messagerouting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_messagerouting: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_messagerouting, cf_core::cf_payload_int> p_mq_MsgQIn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_messagerouting, cf_core::cf_payload_int> p_mq_MsgQOut2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_messagerouting, cf_core::cf_payload_int> p_mq_MsgQOut1_t;\n\n\tcfm_messagerouting(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_messagerouting(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQIn_t p_mq_MsgQIn;\n\tp_mq_MsgQOut2_t p_mq_MsgQOut2;\n\tp_mq_MsgQOut1_t p_mq_MsgQOut1;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tbool CondOut1 = false;\n\n};\n\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MessageRouting', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "/*\n * \\class cfm_messagerouting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_messagerouting.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_messagerouting\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_messagerouting::cfm_messagerouting(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQIn(\"p_mq_MsgQIn\")\n, p_mq_MsgQOut2(\"p_mq_MsgQOut2\")\n, p_mq_MsgQOut1(\"p_mq_MsgQOut1\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_messagerouting::~cfm_messagerouting(void) {\n\n}\n\nvoid cfm_messagerouting::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_messagerouting::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_messagerouting::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_messagerouting::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_messagerouting::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolMapDataTypeApp', 'models': [{'name': 'ProtocolSend', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'ProtocolReceive', 'type': 'cofluent:Function'}], 'relations': [{'name': 'protocol_data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'ProtocolReceive']}, {'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'Producer']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProtocolReceive']}]}",
        "Response": [
            "/*!\n * \\class cfm_protocolmapdatatypeapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_protocolreceive.h\"\n#include \"cfm_protocolsend.h\"\n\n\n\nclass cfm_protocolmapdatatypeapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_protocol_data_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_user_data_in_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_user_data_out_t;\n\n\n\tcfm_protocolmapdatatypeapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_protocolmapdatatypeapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\tcfm_protocolreceive* ProtocolReceive;\n\tcfm_protocolsend* ProtocolSend;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_protocol_data_t mq_protocol_data;\n\tmq_user_data_in_t mq_user_data_in;\n\tmq_user_data_out_t mq_user_data_out;\n\n\n\n\n};\n\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolMapDataTypeApp', 'models': [{'name': 'ProtocolSend', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'ProtocolReceive', 'type': 'cofluent:Function'}], 'relations': [{'name': 'protocol_data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'ProtocolReceive']}, {'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'Producer']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProtocolReceive']}]}",
        "Response": [
            "/*\n * \\class cfm_protocolmapdatatypeapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_protocolmapdatatypeapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_protocolmapdatatypeapp::cfm_protocolmapdatatypeapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_protocol_data(\"protocol_data\"\n)\n, mq_user_data_in(\"user_data_in\"\n)\n, mq_user_data_out(\"user_data_out\"\n)\n\n{\n\tcf_application::init();\n\tConsumer = new cfm_consumer\n\t(\"Consumer\");\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\tProtocolReceive = new cfm_protocolreceive\n\t(\"ProtocolReceive\");\n\tProtocolSend = new cfm_protocolsend\n\t(\"ProtocolSend\");\n\n\tConsumer->p_mq_user_data_out\n\t(mq_user_data_out\n\t\t\t.p_target_socket\n\t);\n\n\tProducer->p_mq_user_data_in\n\t(mq_user_data_in\n\t\t\t.p_target_socket\n\t);\n\n\tProtocolReceive->p_mq_protocol_data\n\t(mq_protocol_data\n\t\t\t.p_target_socket\n\t);\n\tProtocolReceive->p_mq_user_data_out\n\t(mq_user_data_out\n\t\t\t.p_target_socket\n\t);\n\n\tProtocolSend->p_mq_protocol_data\n\t(mq_protocol_data\n\t\t\t.p_target_socket\n\t);\n\tProtocolSend->p_mq_user_data_in\n\t(mq_user_data_in\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_protocolmapdatatypeapp::~cfm_protocolmapdatatypeapp(void) {\n\n\tdelete Consumer;\t///ddd\n\tdelete Producer;\t///ddd\n\tdelete ProtocolReceive;\t///ddd\n\tdelete ProtocolSend;\t///ddd\n}\n\nvoid cfm_protocolmapdatatypeapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_protocolmapdatatypeapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_protocolmapdatatypeapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_protocolmapdatatypeapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_protocol_data.cfa_send_time.init(cf_expr_duration(2, CF_NS));\n\tmq_protocol_data.cfa_receive_time.init(cf_expr_duration(3, CF_NS));\n\tmq_protocol_data.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_protocol_data.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_protocol_data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_protocol_data.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_protocol_data.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_in.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_protocolmapdatatypeapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolSend', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*!\n * \\class cfm_protocolsend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_protocolsend: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolsend, cf_core::cf_payload_map> p_mq_protocol_data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolsend, cf_core::cf_payload_map> p_mq_user_data_in_t;\n\n\tcfm_protocolsend(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_protocolsend(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_protocol_data_t p_mq_protocol_data;\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint number_of_packets;\n\n};\n\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolSend', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*\n * \\class cfm_protocolsend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_protocolsend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_protocolsend\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_protocolsend::cfm_protocolsend(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_protocol_data(\"p_mq_protocol_data\")\n, p_mq_user_data_in(\"p_mq_user_data_in\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_protocolsend::~cfm_protocolsend(void) {\n\n}\n\nvoid cfm_protocolsend::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_protocolsend::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_protocolsend::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_protocolsend::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_protocolsend::cb_init_local_vars(void) {\n\n\tnumber_of_packets = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cf_core::cf_payload_map> p_mq_user_data_out_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_user_data_out(\"p_mq_user_data_out\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_map> p_mq_user_data_in_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_user_data_in(\"p_mq_user_data_in\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolReceive', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*!\n * \\class cfm_protocolreceive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_protocolreceive: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolreceive, cf_core::cf_payload_map> p_mq_protocol_data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolreceive, cf_core::cf_payload_map> p_mq_user_data_out_t;\n\n\tcfm_protocolreceive(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_protocolreceive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_protocol_data_t p_mq_protocol_data;\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint number_of_packets;\n\n};\n\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolReceive', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "/*\n * \\class cfm_protocolreceive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_protocolreceive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_protocolreceive\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_protocolreceive::cfm_protocolreceive(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_protocol_data(\"p_mq_protocol_data\")\n, p_mq_user_data_out(\"p_mq_user_data_out\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_protocolreceive::~cfm_protocolreceive(void) {\n\n}\n\nvoid cfm_protocolreceive::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_protocolreceive::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_protocolreceive::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_protocolreceive::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_protocolreceive::cb_init_local_vars(void) {\n\n\tnumber_of_packets = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MapDataTypeAPIApp', 'models': [{'name': 'ProducerMap', 'type': 'cofluent:Function'}, {'name': 'ConsumerMap', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQMap', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerMap', 'ConsumerMap']}]}",
        "Response": [
            "/*!\n * \\class cfm_mapdatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP\n#define COFS_MODEL_MAPDATATYPEAPIAPP\n\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumermap.h\"\n#include \"cfm_producermap.h\"\n\n\n\nclass cfm_mapdatatypeapiapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_MsgQMap_t;\n\n\n\tcfm_mapdatatypeapiapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_mapdatatypeapiapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumermap* ConsumerMap;\n\tcfm_producermap* ProducerMap;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQMap_t mq_MsgQMap;\n\n\n\n\n};\n\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MapDataTypeAPIApp', 'models': [{'name': 'ProducerMap', 'type': 'cofluent:Function'}, {'name': 'ConsumerMap', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQMap', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerMap', 'ConsumerMap']}]}",
        "Response": [
            "/*\n * \\class cfm_mapdatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_mapdatatypeapiapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_mapdatatypeapiapp::cfm_mapdatatypeapiapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_MsgQMap(\"MsgQMap\"\n)\n\n{\n\tcf_application::init();\n\tConsumerMap = new cfm_consumermap\n\t(\"ConsumerMap\");\n\tProducerMap = new cfm_producermap\n\t(\"ProducerMap\");\n\n\tConsumerMap->p_mq_MsgQMap\n\t(mq_MsgQMap\n\t\t\t.p_target_socket\n\t);\n\n\tProducerMap->p_mq_MsgQMap\n\t(mq_MsgQMap\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_mapdatatypeapiapp::~cfm_mapdatatypeapiapp(void) {\n\n\tdelete ConsumerMap;\t///ddd\n\tdelete ProducerMap;\t///ddd\n}\n\nvoid cfm_mapdatatypeapiapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_mapdatatypeapiapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_mapdatatypeapiapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_mapdatatypeapiapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_MsgQMap.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQMap.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQMap.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQMap.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQMap.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQMap.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQMap.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_mapdatatypeapiapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProducerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "/*!\n * \\class cfm_producermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n#define COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producermap: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producermap, cf_core::cf_payload_map> p_mq_MsgQMap_t;\n\n\tcfm_producermap(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producermap(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQMap_t p_mq_MsgQMap;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProducerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "/*\n * \\class cfm_producermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producermap.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mapdatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producermap\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producermap::cfm_producermap(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQMap(\"p_mq_MsgQMap\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producermap::~cfm_producermap(void) {\n\n}\n\nvoid cfm_producermap::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producermap::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producermap::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producermap::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producermap::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ConsumerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n#define COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumermap: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumermap, cf_core::cf_payload_map> p_mq_MsgQMap_t;\n\n\tcfm_consumermap(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumermap(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQMap_t p_mq_MsgQMap;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ConsumerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "/*\n * \\class cfm_consumermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumermap.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mapdatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumermap\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumermap::cfm_consumermap(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQMap(\"p_mq_MsgQMap\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumermap::~cfm_consumermap(void) {\n\n}\n\nvoid cfm_consumermap::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumermap::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumermap::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumermap::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumermap::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VectorDataTypeAPIApp', 'models': [{'name': 'ProducerVector', 'type': 'cofluent:Function'}, {'name': 'ConsumerVector', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQVector', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerVector', 'ConsumerVector']}]}",
        "Response": [
            "/*!\n * \\class cfm_vectordatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP\n#define COFS_MODEL_VECTORDATATYPEAPIAPP\n\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumervector.h\"\n#include \"cfm_producervector.h\"\n\n\n\nclass cfm_vectordatatypeapiapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_vector> mq_MsgQVector_t;\n\n\n\tcfm_vectordatatypeapiapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_vectordatatypeapiapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumervector* ConsumerVector;\n\tcfm_producervector* ProducerVector;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQVector_t mq_MsgQVector;\n\n\n\n\n};\n\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VectorDataTypeAPIApp', 'models': [{'name': 'ProducerVector', 'type': 'cofluent:Function'}, {'name': 'ConsumerVector', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQVector', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerVector', 'ConsumerVector']}]}",
        "Response": [
            "/*\n * \\class cfm_vectordatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_vectordatatypeapiapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_vectordatatypeapiapp::cfm_vectordatatypeapiapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_MsgQVector(\"MsgQVector\"\n)\n\n{\n\tcf_application::init();\n\tConsumerVector = new cfm_consumervector\n\t(\"ConsumerVector\");\n\tProducerVector = new cfm_producervector\n\t(\"ProducerVector\");\n\n\tConsumerVector->p_mq_MsgQVector\n\t(mq_MsgQVector\n\t\t\t.p_target_socket\n\t);\n\n\tProducerVector->p_mq_MsgQVector\n\t(mq_MsgQVector\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_vectordatatypeapiapp::~cfm_vectordatatypeapiapp(void) {\n\n\tdelete ConsumerVector;\t///ddd\n\tdelete ProducerVector;\t///ddd\n}\n\nvoid cfm_vectordatatypeapiapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_vectordatatypeapiapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_vectordatatypeapiapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_vectordatatypeapiapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_MsgQVector.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQVector.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQVector.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQVector.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQVector.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQVector.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQVector.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_vectordatatypeapiapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProducerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "/*!\n * \\class cfm_producervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n#define COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producervector: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producervector, cf_core::cf_payload_vector> p_mq_MsgQVector_t;\n\n\tcfm_producervector(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producervector(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQVector_t p_mq_MsgQVector;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProducerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "/*\n * \\class cfm_producervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producervector.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_vectordatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producervector\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producervector::cfm_producervector(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQVector(\"p_mq_MsgQVector\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producervector::~cfm_producervector(void) {\n\n}\n\nvoid cfm_producervector::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producervector::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producervector::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producervector::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producervector::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ConsumerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n#define COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumervector: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumervector, cf_core::cf_payload_vector> p_mq_MsgQVector_t;\n\n\tcfm_consumervector(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumervector(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQVector_t p_mq_MsgQVector;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ConsumerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "/*\n * \\class cfm_consumervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumervector.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_vectordatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumervector\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumervector::cfm_consumervector(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQVector(\"p_mq_MsgQVector\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumervector::~cfm_consumervector(void) {\n\n}\n\nvoid cfm_consumervector::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumervector::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumervector::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumervector::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumervector::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationVectorDataType', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Processing', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Processing']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Processing', 'Consumer']}]}",
        "Response": [
            "/*!\n * \\class cfm_applicationvectordatatype\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE\n\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_processing.h\"\n#include \"cfm_producer.h\"\n\n\n\nclass cfm_applicationvectordatatype: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_vector> mq_user_data_in_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_vector> mq_user_data_out_t;\n\n\n\tcfm_applicationvectordatatype(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_applicationvectordatatype(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumer* Consumer;\n\tcfm_processing* Processing;\n\tcfm_producer* Producer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_user_data_in_t mq_user_data_in;\n\tmq_user_data_out_t mq_user_data_out;\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationVectorDataType', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Processing', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Processing']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Processing', 'Consumer']}]}",
        "Response": [
            "/*\n * \\class cfm_applicationvectordatatype\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_applicationvectordatatype.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_applicationvectordatatype::cfm_applicationvectordatatype(sc_core::sc_module_name name)\ncf_application(name)\n, mq_user_data_in(\"user_data_in\"\n)\n, mq_user_data_out(\"user_data_out\"\n)\n\n{\n\tcf_application::init();\n\tConsumer = new cfm_consumer\n\t(\"Consumer\");\n\tProcessing = new cfm_processing\n\t(\"Processing\");\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\n\tConsumer->p_mq_user_data_out\n\t(mq_user_data_out\n\t\t\t.p_target_socket\n\t);\n\n\tProcessing->p_mq_user_data_in\n\t(mq_user_data_in\n\t\t\t.p_target_socket\n\t);\n\tProcessing->p_mq_user_data_out\n\t(mq_user_data_out\n\t\t\t.p_target_socket\n\t);\n\n\tProducer->p_mq_user_data_in\n\t(mq_user_data_in\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_applicationvectordatatype::~cfm_applicationvectordatatype(void) {\n\n\tdelete Consumer;\t///ddd\n\tdelete Processing;\t///ddd\n\tdelete Producer;\t///ddd\n}\n\nvoid cfm_applicationvectordatatype::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_applicationvectordatatype::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_applicationvectordatatype::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_applicationvectordatatype::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_user_data_in.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_in.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_applicationvectordatatype::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_vector> p_mq_user_data_in_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint value;\n\n};\n\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_user_data_in(\"p_mq_user_data_in\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\tvalue = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Processing', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "/*!\n * \\class cfm_processing\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_processing: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_processing, cf_core::cf_payload_vector> p_mq_user_data_in_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_processing, cf_core::cf_payload_vector> p_mq_user_data_out_t;\n\n\tcfm_processing(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_processing(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint block_index;\n\n};\n\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Processing', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "/*\n * \\class cfm_processing\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_processing.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_processing\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_processing::cfm_processing(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_user_data_in(\"p_mq_user_data_in\")\n, p_mq_user_data_out(\"p_mq_user_data_out\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_processing::~cfm_processing(void) {\n\n}\n\nvoid cfm_processing::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_processing::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_processing::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_processing::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_processing::cb_init_local_vars(void) {\n\n\tblock_index = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cf_core::cf_payload_vector> p_mq_user_data_out_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_user_data_out(\"p_mq_user_data_out\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoSimVerilatorChiselApp', 'models': [{'name': 'Producer1', 'type': 'cofluent:Function'}, {'name': 'Producer2', 'type': 'cofluent:Function'}, {'name': 'adder', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'sum', 'type': 'cofluent:MessageQueue', 'dataType': 'Defsum', 'connectTo': ['adder', 'Consumer']}, {'name': 'data1', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer1', 'adder']}, {'name': 'data2', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer2', 'adder']}]}",
        "Response": [
            "/*!\n * \\class cfm_cosimverilatorchiselapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP\n#define COFS_MODEL_COSIMVERILATORCHISELAPP\n\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer1.h\"\n#include \"cfm_producer2.h\"\n#include \"wrappers/cfm_data1_initiator.h\"\n#include \"wrappers/cfm_data2_initiator.h\"\n#include \"wrappers/cfm_sum_target.h\"\n#include \"dpi/cofluent_dpi.h\"\n#include \"dt/cft_defsum.h\"\n#include \"dt/cft_defdata1.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_cosimverilatorchiselapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defdata1> mq_data1_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata1> mq_data2_t;\n\ttypedef cf_core::cf_message_queue<cft_defsum> mq_sum_t;\n\n\n\tcfm_cosimverilatorchiselapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_cosimverilatorchiselapp(void);\n\tvirtual void cb_before_elaboration(void);\n\tstatic void data1DPI(ContextHandle self, bool resetn,\n\t/* Write address channel.  */\n\tbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA1>* sig_awaddr, sc_bv<3>* sig_awprot,\n\t/* Write data channel.  */\n\tbool* sig_wvalid, bool sig_wready, sc_bv<DATA_WIDTH_DATA1>* sig_wdata, sc_bv<DATA_WIDTH_DATA1 / 8>* sig_wstrb,\n\t/* Write response channel.  */\n\tbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n\t/* Read address channel.  */\n\tbool* sig_arvalid, bool sig_arready, sc_bv<ADDR_WIDTH_DATA1>* sig_araddr, sc_bv<3>* sig_arprot,\n\t/* Read data channel.  */\n\tbool sig_rvalid, bool* sig_rready, sc_bv<DATA_WIDTH_DATA1> sig_rdata, sc_bv<2> sig_rresp);\n\tstatic void data2DPI(ContextHandle self, bool resetn,\n\t/* Write address channel.  */\n\tbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA2>* sig_awaddr, sc_bv<3>* sig_awprot,\n\t/* Write data channel.  */\n\tbool* sig_wvalid, bool sig_wready, sc_bv<DATA_WIDTH_DATA2>* sig_wdata, sc_bv<DATA_WIDTH_DATA2 / 8>* sig_wstrb,\n\t/* Write response channel.  */\n\tbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n\t/* Read address channel.  */\n\tbool* sig_arvalid, bool sig_arready, sc_bv<ADDR_WIDTH_DATA2>* sig_araddr, sc_bv<3>* sig_arprot,\n\t/* Read data channel.  */\n\tbool sig_rvalid, bool* sig_rready, sc_bv<DATA_WIDTH_DATA2> sig_rdata, sc_bv<2> sig_rresp);\n\tstatic void sumDPI(ContextHandle self, bool resetn,\n\t/* Write address channel.  */\n\tbool sig_awvalid, bool* sig_awready, sc_bv<ADDR_WIDTH_SUM> sig_awaddr, sc_bv<3> sig_awprot,\n\t/* Write data channel.  */\n\tbool sig_wvalid, bool* sig_wready, sc_bv<DATA_WIDTH_SUM> sig_wdata, sc_bv<DATA_WIDTH_SUM / 8> sig_wstrb,\n\t/* Write response channel.  */\n\tbool* sig_bvalid, bool sig_bready, sc_bv<2>* sig_bresp,\n\t/* Read address channel.  */\n\tbool sig_arvalid, bool* sig_arready, sc_bv<ADDR_WIDTH_SUM> sig_araddr, sc_bv<3> sig_arprot,\n\t/* Read data channel.  */\n\tbool* sig_rvalid, bool sig_rready, sc_bv<DATA_WIDTH_SUM>* sig_rdata, sc_bv<2>* sig_rresp);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumer* Consumer;\n\tcfm_producer1* Producer1;\n\tcfm_producer2* Producer2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_data1_t mq_data1;\n\tmq_data2_t mq_data2;\n\tmq_sum_t mq_sum;\n\npublic:\n\tcfm_data1_initiator data1_initiator;\n\tcfm_data2_initiator data2_initiator;\n\tcfm_sum_target sum_target;\n\tsc_clock clk { \"clk\", 1, SC_NS, 0.5, 0, SC_NS, true };\n\n\n\n\n};\n\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoSimVerilatorChiselApp', 'models': [{'name': 'Producer1', 'type': 'cofluent:Function'}, {'name': 'Producer2', 'type': 'cofluent:Function'}, {'name': 'adder', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'sum', 'type': 'cofluent:MessageQueue', 'dataType': 'Defsum', 'connectTo': ['adder', 'Consumer']}, {'name': 'data1', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer1', 'adder']}, {'name': 'data2', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer2', 'adder']}]}",
        "Response": [
            "/*\n * \\class cfm_cosimverilatorchiselapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_cosimverilatorchiselapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_cosimverilatorchiselapp::cfm_cosimverilatorchiselapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_data1(\"data1\"\n)\n, mq_data2(\"data2\"\n)\n, mq_sum(\"sum\"\n)\n, data1_initiator(\"data1_initiator\")\n, data2_initiator(\"data2_initiator\")\n, sum_target(\"sum_target\")\n\n{\n\tcf_application::init();\n\tConsumer = new cfm_consumer\n\t(\"Consumer\");\n\tProducer1 = new cfm_producer1\n\t(\"Producer1\");\n\tProducer2 = new cfm_producer2\n\t(\"Producer2\");\n\n\tConsumer->p_mq_sum\n\t(mq_sum\n\t\t\t.p_target_socket\n\t);\n\n\tProducer1->p_mq_data1\n\t(mq_data1\n\t\t\t.p_target_socket\n\t);\n\n\tProducer2->p_mq_data2\n\t(mq_data2\n\t\t\t.p_target_socket\n\t);\n\n\tdata1_initiator\n\t.p_mq_data1(mq_data1.p_target_socket);\n\tdata2_initiator\n\t.p_mq_data2(mq_data2.p_target_socket);\n\tsum_target\n\t.p_mq_sum(mq_sum.p_target_socket);\n\n\tDPIInit(this,data1DPI,data2DPI,sumDPI);\n\tdata1_initiator.axi_bridge.clk(clk);\n\tdata2_initiator.axi_bridge.clk(clk);\n\tsum_target.axi_bridge.clk(clk);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_cosimverilatorchiselapp::~cfm_cosimverilatorchiselapp(void) {\n\n\tdelete Consumer;\t///ddd\n\tdelete Producer1;\t///ddd\n\tdelete Producer2;\t///ddd\n}\n\nvoid cfm_cosimverilatorchiselapp::data1DPI(ContextHandle self, bool resetn,\n/* Write address channel.  */\nbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA1>* sig_awaddr, sc_bv<3>* sig_awprot,\n/* Write data channel.  */\nbool* sig_wvalid, bool sig_wready, sc_bv<DATA_WIDTH_DATA1>* sig_wdata, sc_bv<DATA_WIDTH_DATA1 / 8>* sig_wstrb,\n/* Write response channel.  */\nbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n/* Read address channel.  */\nbool* sig_arvalid, bool sig_arready, sc_bv<ADDR_WIDTH_DATA1>* sig_araddr, sc_bv<3>* sig_arprot,\n/* Read data channel.  */\nbool sig_rvalid, bool* sig_rready, sc_bv<DATA_WIDTH_DATA1> sig_rdata, sc_bv<2> sig_rresp) {\n\tstatic_cast<cfm_cosimverilatorchiselapp*>(self)->data1_initiator.axiSignals(resetn,\n\t\t\tsig_awvalid, sig_awready, sig_awaddr, sig_awprot,\n\t\t\tsig_wvalid, sig_wready, sig_wdata, sig_wstrb,\n\t\t\tsig_bvalid, sig_bready, sig_bresp,\n\t\t\tsig_arvalid, sig_arready, sig_araddr, sig_arprot,\n\t\t\tsig_rvalid, sig_rready, sig_rdata, sig_rresp);\n}\nvoid cfm_cosimverilatorchiselapp::data2DPI(ContextHandle self, bool resetn,\n/* Write address channel.  */\nbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA2>* sig_awaddr, sc_bv<3>* sig_awprot,\n/* Write data channel.  */\nbool* sig_wvalid, bool sig_wready, sc_bv<DATA_WIDTH_DATA2>* sig_wdata, sc_bv<DATA_WIDTH_DATA2 / 8>* sig_wstrb,\n/* Write response channel.  */\nbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n/* Read address channel.  */\nbool* sig_arvalid, bool sig_arready, sc_bv<ADDR_WIDTH_DATA2>* sig_araddr, sc_bv<3>* sig_arprot,\n/* Read data channel.  */\nbool sig_rvalid, bool* sig_rready, sc_bv<DATA_WIDTH_DATA2> sig_rdata, sc_bv<2> sig_rresp) {\n\tstatic_cast<cfm_cosimverilatorchiselapp*>(self)->data2_initiator.axiSignals(resetn,\n\t\t\tsig_awvalid, sig_awready, sig_awaddr, sig_awprot,\n\t\t\tsig_wvalid, sig_wready, sig_wdata, sig_wstrb,\n\t\t\tsig_bvalid, sig_bready, sig_bresp,\n\t\t\tsig_arvalid, sig_arready, sig_araddr, sig_arprot,\n\t\t\tsig_rvalid, sig_rready, sig_rdata, sig_rresp);\n}\nvoid cfm_cosimverilatorchiselapp::sumDPI(ContextHandle self, bool resetn,\n/* Write address channel.  */\nbool sig_awvalid, bool* sig_awready, sc_bv<ADDR_WIDTH_SUM> sig_awaddr, sc_bv<3> sig_awprot,\n/* Write data channel.  */\nbool sig_wvalid, bool* sig_wready, sc_bv<DATA_WIDTH_SUM> sig_wdata, sc_bv<DATA_WIDTH_SUM / 8> sig_wstrb,\n/* Write response channel.  */\nbool* sig_bvalid, bool sig_bready, sc_bv<2>* sig_bresp,\n/* Read address channel.  */\nbool sig_arvalid, bool* sig_arready, sc_bv<ADDR_WIDTH_SUM> sig_araddr, sc_bv<3> sig_arprot,\n/* Read data channel.  */\nbool* sig_rvalid, bool sig_rready, sc_bv<DATA_WIDTH_SUM>* sig_rdata, sc_bv<2>* sig_rresp) {\n\tstatic_cast<cfm_cosimverilatorchiselapp*>(self)->sum_target.axiSignals(resetn,\n\t\t\tsig_awvalid, sig_awready, sig_awaddr, sig_awprot,\n\t\t\tsig_wvalid, sig_wready, sig_wdata, sig_wstrb,\n\t\t\tsig_bvalid, sig_bready, sig_bresp,\n\t\t\tsig_arvalid, sig_arready, sig_araddr, sig_arprot,\n\t\t\tsig_rvalid, sig_rready, sig_rdata, sig_rresp);\n}\n\nvoid cfm_cosimverilatorchiselapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_cosimverilatorchiselapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_cosimverilatorchiselapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_cosimverilatorchiselapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_data1.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data1.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_data1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_data1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_data1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_data1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data2.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_data2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_sum.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_sum.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_sum.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_sum.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_sum.set_one_side_concurrency();\n\tmq_sum.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_sum.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_sum.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_cosimverilatorchiselapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer1', 'type': 'cofluent:Function', 'ports': [{'name': 'data1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata1.h\"\n\n\n\nclass cfm_producer1: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer1, cft_defdata1> p_mq_data1_t;\n\n\tcfm_producer1(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_data1_t p_mq_data1;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint i = 1;\n\n};\n\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer1', 'type': 'cofluent:Function', 'ports': [{'name': 'data1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "/*\n * \\class cfm_producer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer1\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer1::cfm_producer1(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_data1(\"p_mq_data1\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer1::~cfm_producer1(void) {\n\n}\n\nvoid cfm_producer1::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer1::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer1::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer1::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer1::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer2', 'type': 'cofluent:Function', 'ports': [{'name': 'data2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata1.h\"\n\n\n\nclass cfm_producer2: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer2, cft_defdata1> p_mq_data2_t;\n\n\tcfm_producer2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_data2_t p_mq_data2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint i = 1;\n\n};\n\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer2', 'type': 'cofluent:Function', 'ports': [{'name': 'data2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "/*\n * \\class cfm_producer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer2::cfm_producer2(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_data2(\"p_mq_data2\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer2::~cfm_producer2(void) {\n\n}\n\nvoid cfm_producer2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'sum', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Defsum'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defsum.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cft_defsum> p_mq_sum_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_sum_t p_mq_sum;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint i = 1;\n\n};\n\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'sum', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Defsum'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_sum(\"p_mq_sum\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TLM2LT', 'models': [{'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "/*!\n * \\class cfm_tlm2lt\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT\n#define COFS_MODEL_TLM2LT\n\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_reader.h\"\n#include \"cfm_target.h\"\n#include \"cfm_target_2.h\"\n#include \"cfm_writer.h\"\n#include \"lt_top.h\"\n#include \"wrappers/cfm_initiatorreader_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_initiatorwriter_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_targetrequest_tlm2_lt_target.h\"\n#include \"wrappers/cfm_targetwrapper_tlm2_lt_target.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_tlm2lt: public cf_core::cf_application {\npublic:\n\ttypedef lt_top TLM2Platfom_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorReader_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_ReaderResponse_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_event ev_Sync_t;\n\ttypedef cf_core::cf_event ev_Sync2_t;\n\ttypedef cf_core::cf_event ev_Sync3_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetRequest_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetResponse_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetWrapper_t;\n\n\n\tcfm_tlm2lt(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_tlm2lt(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_reader* Reader;\n\tTLM2Platfom_t* TLM2Platfom;\n\tcfm_target* Target;\n\tcfm_target_2* Target_2;\n\tcfm_writer* Writer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_InitiatorReader_t mq_InitiatorReader;\n\tmq_InitiatorWriter_t mq_InitiatorWriter;\n\tmq_ReaderResponse_t mq_ReaderResponse;\n\tmq_ReferenceQueue_t mq_ReferenceQueue;\n\tmq_ReferenceQueue2_t mq_ReferenceQueue2;\n\tmq_ReferenceQueue3_t mq_ReferenceQueue3;\n\tev_Sync_t ev_Sync;\n\tev_Sync2_t ev_Sync2;\n\tev_Sync3_t ev_Sync3;\n\tmq_TargetRequest_t mq_TargetRequest;\n\tmq_TargetResponse_t mq_TargetResponse;\n\tmq_TargetWrapper_t mq_TargetWrapper;\n\nprotected:\n\tcfm_initiatorreader_tlm2_lt_initiator initiatorreader_tlm2_lt_initiator;\n\tcfm_initiatorwriter_tlm2_lt_initiator initiatorwriter_tlm2_lt_initiator;\n\tcfm_targetrequest_tlm2_lt_target targetrequest_tlm2_lt_target;\n\tcfm_targetwrapper_tlm2_lt_target targetwrapper_tlm2_lt_target;\n\n\n\n\n};\n\n#endif // COFS_MODEL_TLM2LT\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TLM2LT', 'models': [{'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "/*\n * \\class cfm_tlm2lt\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_tlm2lt.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_tlm2lt::cfm_tlm2lt(sc_core::sc_module_name name)\ncf_application(name)\n, mq_InitiatorReader(\"InitiatorReader\"\n)\n, mq_InitiatorWriter(\"InitiatorWriter\"\n)\n, mq_ReaderResponse(\"ReaderResponse\"\n)\n, mq_ReferenceQueue(\"ReferenceQueue\"\n)\n, mq_ReferenceQueue2(\"ReferenceQueue2\"\n)\n, mq_ReferenceQueue3(\"ReferenceQueue3\"\n)\n, ev_Sync(\"Sync\"\n)\n, ev_Sync2(\"Sync2\"\n)\n, ev_Sync3(\"Sync3\"\n)\n, mq_TargetRequest(\"TargetRequest\"\n)\n, mq_TargetResponse(\"TargetResponse\"\n)\n, mq_TargetWrapper(\"TargetWrapper\"\n)\n, initiatorreader_tlm2_lt_initiator(\"initiatorreader_tlm2_lt_initiator\")\n, initiatorwriter_tlm2_lt_initiator(\"initiatorwriter_tlm2_lt_initiator\")\n, targetrequest_tlm2_lt_target(\"targetrequest_tlm2_lt_target\")\n, targetwrapper_tlm2_lt_target(\"targetwrapper_tlm2_lt_target\")\n\n{\n\tcf_application::init();\n\tReader = new cfm_reader\n\t(\"Reader\");\n\tTLM2Platfom = new TLM2Platfom_t\n\t(\"TLM2Platfom\");\n\tTarget = new cfm_target\n\t(\"Target\");\n\tTarget_2 = new cfm_target_2\n\t(\"Target_2\");\n\tWriter = new cfm_writer\n\t(\"Writer\");\n\n\tReader->p_mq_ReferenceQueue3\n\t(mq_ReferenceQueue3\n\t\t\t.p_target_socket\n\t);\n\tReader->p_mq_InitiatorReader\n\t(mq_InitiatorReader\n\t\t\t.p_target_socket\n\t);\n\tReader->p_mq_ReaderResponse\n\t(mq_ReaderResponse\n\t\t\t.p_target_socket\n\t);\n\tReader->p_ev_Sync\n\t(ev_Sync\n\t\t\t.p_target_socket\n\t);\n\n\tinitiatorwriter_tlm2_lt_initiator.p_tlm2\n\t(TLM2Platfom->m_bus.target_socket[2]);\n\tTLM2Platfom->m_bus.initiator_socket[2]\n\t(targetwrapper_tlm2_lt_target.p_tlm2\n\t);\n\tinitiatorreader_tlm2_lt_initiator.p_tlm2\n\t(TLM2Platfom->m_bus.target_socket[3]);\n\tTLM2Platfom->m_bus.initiator_socket[3]\n\t(targetrequest_tlm2_lt_target.p_tlm2\n\t);\n\n\tTarget->p_mq_ReferenceQueue2\n\t(mq_ReferenceQueue2\n\t\t\t.p_target_socket\n\t);\n\tTarget->p_mq_TargetWrapper\n\t(mq_TargetWrapper\n\t\t\t.p_target_socket\n\t);\n\tTarget->p_ev_Sync2\n\t(ev_Sync2\n\t\t\t.p_target_socket\n\t);\n\n\tTarget_2->p_mq_TargetRequest\n\t(mq_TargetRequest\n\t\t\t.p_target_socket\n\t);\n\tTarget_2->p_mq_TargetResponse\n\t(mq_TargetResponse\n\t\t\t.p_target_socket\n\t);\n\tTarget_2->p_mq_ReferenceQueue\n\t(mq_ReferenceQueue\n\t\t\t.p_target_socket\n\t);\n\tTarget_2->p_ev_Sync3\n\t(ev_Sync3\n\t\t\t.p_target_socket\n\t);\n\n\tWriter->p_mq_InitiatorWriter\n\t(mq_InitiatorWriter\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_mq_ReferenceQueue\n\t(mq_ReferenceQueue\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_mq_ReferenceQueue2\n\t(mq_ReferenceQueue2\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_mq_ReferenceQueue3\n\t(mq_ReferenceQueue3\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_ev_Sync\n\t(ev_Sync\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_ev_Sync2\n\t(ev_Sync2\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_ev_Sync3\n\t(ev_Sync3\n\t\t\t.p_target_socket\n\t);\n\n\tinitiatorreader_tlm2_lt_initiator\n\t.p_mq_request(mq_InitiatorReader.p_target_socket);\n\tinitiatorreader_tlm2_lt_initiator.p_mq_response(mq_ReaderResponse\n\t\t\t.p_target_socket);\n\tinitiatorwriter_tlm2_lt_initiator\n\t.p_mq_request(mq_InitiatorWriter.p_target_socket);\n\ttargetrequest_tlm2_lt_target\n\t.p_mq_request(mq_TargetRequest.p_target_socket);\n\ttargetrequest_tlm2_lt_target.p_mq_response(mq_TargetResponse\n\t\t\t.p_target_socket);\n\ttargetwrapper_tlm2_lt_target\n\t.p_mq_request(mq_TargetWrapper.p_target_socket);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_tlm2lt::~cfm_tlm2lt(void) {\n\n\tdelete Reader;\t///ddd\n\tdelete TLM2Platfom;\t///ddd\n\tdelete Target;\t///ddd\n\tdelete Target_2;\t///ddd\n\tdelete Writer;\t///ddd\n}\n\nvoid cfm_tlm2lt::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_tlm2lt::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_tlm2lt::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_tlm2lt::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_InitiatorReader.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorReader.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_InitiatorReader.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_InitiatorWriter.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_InitiatorWriter.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_InitiatorWriter.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReaderResponse.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_ReaderResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReaderResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue3.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_Sync.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync2.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync3.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tmq_TargetRequest.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetResponse.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetWrapper.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetWrapper.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetWrapper.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\n\treturn;\n}\n\nvoid cfm_tlm2lt::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*!\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_WRITER\n#define COFS_MODEL_TLM2LT_WRITER\n\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_writer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cf_core::cf_payload_tlm2> p_mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync2_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync3_t;\n\n\tcfm_writer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_writer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_InitiatorWriter_t p_mq_InitiatorWriter;\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_ev_Sync_t p_ev_Sync;\n\tp_ev_Sync2_t p_ev_Sync2;\n\tp_ev_Sync3_t p_ev_Sync3;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint data;\n\n};\n\n#endif // COFS_MODEL_TLM2LT_WRITER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_writer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_writer::cfm_writer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_InitiatorWriter(\"p_mq_InitiatorWriter\")\n, p_mq_ReferenceQueue(\"p_mq_ReferenceQueue\")\n, p_mq_ReferenceQueue2(\"p_mq_ReferenceQueue2\")\n, p_mq_ReferenceQueue3(\"p_mq_ReferenceQueue3\")\n, p_ev_Sync(\"p_ev_Sync\")\n, p_ev_Sync2(\"p_ev_Sync2\")\n, p_ev_Sync3(\"p_ev_Sync3\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_writer::~cfm_writer(void) {\n\n}\n\nvoid cfm_writer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_writer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_writer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_writer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_writer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_TARGET\n#define COFS_MODEL_TLM2LT_TARGET\n\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_target: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cf_core::cf_payload_tlm2> p_mq_TargetWrapper_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target> p_ev_Sync2_t;\n\n\tcfm_target(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_target(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_mq_TargetWrapper_t p_mq_TargetWrapper;\n\tp_ev_Sync2_t p_ev_Sync2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_TLM2LT_TARGET\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_target::cfm_target(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_ReferenceQueue2(\"p_mq_ReferenceQueue2\")\n, p_mq_TargetWrapper(\"p_mq_TargetWrapper\")\n, p_ev_Sync2(\"p_ev_Sync2\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_target::~cfm_target(void) {\n\n}\n\nvoid cfm_target::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_target::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_target::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_target::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_target::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*!\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_READER\n#define COFS_MODEL_TLM2LT_READER\n\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_reader: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_InitiatorReader_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_ReaderResponse_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_reader> p_ev_Sync_t;\n\n\tcfm_reader(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_reader(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_mq_InitiatorReader_t p_mq_InitiatorReader;\n\tp_mq_ReaderResponse_t p_mq_ReaderResponse;\n\tp_ev_Sync_t p_ev_Sync;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint data;\n\n};\n\n#endif // COFS_MODEL_TLM2LT_READER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_reader.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reader\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_reader::cfm_reader(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_ReferenceQueue3(\"p_mq_ReferenceQueue3\")\n, p_mq_InitiatorReader(\"p_mq_InitiatorReader\")\n, p_mq_ReaderResponse(\"p_mq_ReaderResponse\")\n, p_ev_Sync(\"p_ev_Sync\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_reader::~cfm_reader(void) {\n\n}\n\nvoid cfm_reader::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_reader::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_reader::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_reader::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_reader::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*!\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_TARGET_2\n#define COFS_MODEL_TLM2LT_TARGET_2\n\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_target_2: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cf_core::cf_payload_tlm2> p_mq_TargetRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cf_core::cf_payload_tlm2> p_mq_TargetResponse_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target_2> p_ev_Sync3_t;\n\n\tcfm_target_2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_target_2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_TargetRequest_t p_mq_TargetRequest;\n\tp_mq_TargetResponse_t p_mq_TargetResponse;\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_ev_Sync3_t p_ev_Sync3;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_TLM2LT_TARGET_2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "/*\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_target_2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target_2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_target_2::cfm_target_2(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_TargetRequest(\"p_mq_TargetRequest\")\n, p_mq_TargetResponse(\"p_mq_TargetResponse\")\n, p_mq_ReferenceQueue(\"p_mq_ReferenceQueue\")\n, p_ev_Sync3(\"p_ev_Sync3\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_target_2::~cfm_target_2(void) {\n\n}\n\nvoid cfm_target_2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_target_2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_target_2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_target_2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_target_2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'AutomatedPayloadTrackers', 'models': [{'name': 'C2', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}, {'name': 'F12', 'type': 'cofluent:Function'}, {'name': 'P1', 'type': 'cofluent:Function'}, {'name': 'P2', 'type': 'cofluent:Function'}, {'name': 'C1', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M1_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P1']}, {'name': 'M1_3', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'C1']}, {'name': 'M2_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P2']}, {'name': 'M2_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['C2', 'F12']}, {'name': 'M1_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'F12']}]}",
        "Response": [
            "/*!\n * \\class cfm_automatedpayloadtrackers\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_c1.h\"\n#include \"cfm_c2.h\"\n#include \"cfm_f12.h\"\n#include \"cfm_f2.h\"\n#include \"cfm_p1.h\"\n#include \"cfm_p2.h\"\n\n\n\nclass cfm_automatedpayloadtrackers: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_1_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_2_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_3_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M2_1_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M2_2_t;\n\n\n\tcfm_automatedpayloadtrackers(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_automatedpayloadtrackers(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_c1* C1;\n\tcfm_c2* C2;\n\tcfm_f12* F12;\n\tcfm_f2* F2;\n\tcfm_p1* P1;\n\tcfm_p2* P2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_M1_1_t mq_M1_1;\n\tmq_M1_2_t mq_M1_2;\n\tmq_M1_3_t mq_M1_3;\n\tmq_M2_1_t mq_M2_1;\n\tmq_M2_2_t mq_M2_2;\n\n\n\n\n};\n\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'AutomatedPayloadTrackers', 'models': [{'name': 'C2', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}, {'name': 'F12', 'type': 'cofluent:Function'}, {'name': 'P1', 'type': 'cofluent:Function'}, {'name': 'P2', 'type': 'cofluent:Function'}, {'name': 'C1', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M1_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P1']}, {'name': 'M1_3', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'C1']}, {'name': 'M2_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P2']}, {'name': 'M2_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['C2', 'F12']}, {'name': 'M1_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'F12']}]}",
        "Response": [
            "/*\n * \\class cfm_automatedpayloadtrackers\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_automatedpayloadtrackers.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_automatedpayloadtrackers::cfm_automatedpayloadtrackers(sc_core::sc_module_name name)\ncf_application(name)\n, mq_M1_1(\"M1_1\"\n)\n, mq_M1_2(\"M1_2\"\n)\n, mq_M1_3(\"M1_3\"\n)\n, mq_M2_1(\"M2_1\"\n)\n, mq_M2_2(\"M2_2\"\n)\n\n{\n\tcf_application::init();\n\tC1 = new cfm_c1\n\t(\"C1\");\n\tC2 = new cfm_c2\n\t(\"C2\");\n\tF12 = new cfm_f12\n\t(\"F12\");\n\tF2 = new cfm_f2\n\t(\"F2\");\n\tP1 = new cfm_p1\n\t(\"P1\");\n\tP2 = new cfm_p2\n\t(\"P2\");\n\n\tC1->p_mq_M1_3\n\t(mq_M1_3\n\t\t\t.p_target_socket\n\t);\n\n\tC2->p_mq_M2_2\n\t(mq_M2_2\n\t\t\t.p_target_socket\n\t);\n\n\tF12->p_mq_M1_1\n\t(mq_M1_1\n\t\t\t.p_target_socket\n\t);\n\tF12->p_mq_M2_1\n\t(mq_M2_1\n\t\t\t.p_target_socket\n\t);\n\tF12->p_mq_M1_2\n\t(mq_M1_2\n\t\t\t.p_target_socket\n\t);\n\tF12->p_mq_M2_2\n\t(mq_M2_2\n\t\t\t.p_target_socket\n\t);\n\n\tF2->p_mq_M1_2\n\t(mq_M1_2\n\t\t\t.p_target_socket\n\t);\n\tF2->p_mq_M1_3\n\t(mq_M1_3\n\t\t\t.p_target_socket\n\t);\n\n\tP1->p_mq_M1_1\n\t(mq_M1_1\n\t\t\t.p_target_socket\n\t);\n\n\tP2->p_mq_M2_1\n\t(mq_M2_1\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_automatedpayloadtrackers::~cfm_automatedpayloadtrackers(void) {\n\n\tdelete C1;\t///ddd\n\tdelete C2;\t///ddd\n\tdelete F12;\t///ddd\n\tdelete F2;\t///ddd\n\tdelete P1;\t///ddd\n\tdelete P2;\t///ddd\n}\n\nvoid cfm_automatedpayloadtrackers::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_automatedpayloadtrackers::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_automatedpayloadtrackers::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_automatedpayloadtrackers::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_M1_1.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_1.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M1_1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M1_1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M1_1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_2.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M1_2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_3.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_3.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M1_3.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_1.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M2_1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_2.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M2_2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_automatedpayloadtrackers::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'C2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*!\n * \\class cfm_c2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_c2: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_c2, cf_core::cf_payload_int> p_mq_M2_2_t;\n\n\tcfm_c2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_c2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_M2_2_t p_mq_M2_2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'C2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*\n * \\class cfm_c2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_c2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_c2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_c2::cfm_c2(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_M2_2(\"p_mq_M2_2\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_c2::~cfm_c2(void) {\n\n}\n\nvoid cfm_c2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_c2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_c2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_c2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_c2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_f2: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f2, cf_core::cf_payload_int> p_mq_M1_2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f2, cf_core::cf_payload_int> p_mq_M1_3_t;\n\n\tcfm_f2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_f2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_M1_2_t p_mq_M1_2;\n\tp_mq_M1_3_t p_mq_M1_3;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_f2::cfm_f2(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_M1_2(\"p_mq_M1_2\")\n, p_mq_M1_3(\"p_mq_M1_3\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_f2::~cfm_f2(void) {\n\n}\n\nvoid cfm_f2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_f2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_f2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_f2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_f2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F12', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*!\n * \\class cfm_f12\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_f12: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M1_1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M2_1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M1_2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M2_2_t;\n\n\tcfm_f12(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_f12(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_M1_1_t p_mq_M1_1;\n\tp_mq_M2_1_t p_mq_M2_1;\n\tp_mq_M1_2_t p_mq_M1_2;\n\tp_mq_M2_2_t p_mq_M2_2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F12', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*\n * \\class cfm_f12\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_f12.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f12\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_f12::cfm_f12(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_M1_1(\"p_mq_M1_1\")\n, p_mq_M2_1(\"p_mq_M2_1\")\n, p_mq_M1_2(\"p_mq_M1_2\")\n, p_mq_M2_2(\"p_mq_M2_2\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_f12::~cfm_f12(void) {\n\n}\n\nvoid cfm_f12::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_f12::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_f12::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_f12::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_f12::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'P1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*!\n * \\class cfm_p1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_p1: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_p1, cf_core::cf_payload_int> p_mq_M1_1_t;\n\n\tcfm_p1(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_p1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_M1_1_t p_mq_M1_1;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'P1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*\n * \\class cfm_p1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_p1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_p1\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_p1::cfm_p1(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_M1_1(\"p_mq_M1_1\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_p1::~cfm_p1(void) {\n\n}\n\nvoid cfm_p1::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_p1::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_p1::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_p1::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_p1::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'P2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*!\n * \\class cfm_p2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_p2: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_p2, cf_core::cf_payload_int> p_mq_M2_1_t;\n\n\tcfm_p2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_p2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_M2_1_t p_mq_M2_1;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'P2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*\n * \\class cfm_p2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_p2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_p2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_p2::cfm_p2(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_M2_1(\"p_mq_M2_1\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_p2::~cfm_p2(void) {\n\n}\n\nvoid cfm_p2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_p2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_p2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_p2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_p2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'C1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*!\n * \\class cfm_c1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_c1: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_c1, cf_core::cf_payload_int> p_mq_M1_3_t;\n\n\tcfm_c1(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_c1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_M1_3_t p_mq_M1_3;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'C1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "/*\n * \\class cfm_c1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_c1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_c1\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_c1::cfm_c1(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_M1_3(\"p_mq_M1_3\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_c1::~cfm_c1(void) {\n\n}\n\nvoid cfm_c1::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_c1::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_c1::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_c1::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_c1::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DDRMemory', 'models': [{'name': 'ClientSide', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}], 'relations': [{'name': 'AWADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAWADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'WDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefWDATAchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'BRESPchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBRESPchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'ARADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefARADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'RDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRDATAchn', 'connectTo': ['ClientSide', 'Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ddrmemory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY\n#define COFS_MODEL_DDRMEMORY\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ddrmemory_dp_if.h\"\n#include \"cfm_clientside.h\"\n#include \"cfm_target.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRMemory includes' algorithm generated code\n\n//End of 'DDRMemory includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDDRMemory Function DDRMemory\n//@{\n///        \\page dxpDDRMemory\n//@{\n///    \\brief DDRMemory function model start\nclass cfm_ddrmemory: public cf_core::cf_application, public cfm_ddrmemory_dp_if {\npublic:\n\t/// cfm_ddrmemory type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defaraddrchn> mq_ARADDRchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defawaddrchn> mq_AWADDRchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defbrespchn> mq_BRESPchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defrdatachn> mq_RDATAchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defwdatachn> mq_WDATAchn_t;\n\n\t/// cfm_ddrmemory type define end\n\n\t/// constructor\n\tcfm_ddrmemory(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ddrmemory(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_clientside* ClientSide;\n\tcfm_target* Target;\n\t//@}\n\npublic:\n\t/// Overload function for mq_WDATAchn message queue send time\n\tcf_dt::cf_duration mq_WDATAchn_cb_send_time(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_ARADDRchn_t mq_ARADDRchn;\n\tmq_AWADDRchn_t mq_AWADDRchn;\n\tmq_BRESPchn_t mq_BRESPchn;\n\tmq_RDATAchn_t mq_RDATAchn;\n\tmq_WDATAchn_t mq_WDATAchn;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory local declarations' algorithm generated code\n\n\t//End of 'DDRMemory local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief DDRMemory function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DDRMemory', 'models': [{'name': 'ClientSide', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}], 'relations': [{'name': 'AWADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAWADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'WDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefWDATAchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'BRESPchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBRESPchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'ARADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefARADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'RDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRDATAchn', 'connectTo': ['ClientSide', 'Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ddrmemory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ddrmemory.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRMemory definitions' algorithm generated code\n\n//End of 'DDRMemory definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ddrmemory::cfm_ddrmemory(sc_core::sc_module_name name)\ncf_application(name)\n, cfm_ddrmemory_dp_if()\n, mq_ARADDRchn(\"ARADDRchn\"\n)\n, mq_AWADDRchn(\"AWADDRchn\"\n)\n, mq_BRESPchn(\"BRESPchn\"\n)\n, mq_RDATAchn(\"RDATAchn\"\n)\n, mq_WDATAchn(\"WDATAchn\"\n)\n\n{\n\tcf_application::init();\n\tClientSide = new cfm_clientside\n\t(\"ClientSide\");\n\tTarget = new cfm_target\n\t(\"Target\");\n\n\t// connections\n\tClientSide->p_mq_RDATAchn\n\t(mq_RDATAchn\n\t\t\t.p_target_socket\n\t);\n\tfor (cf_count i = 0; i < (cf_count)ClientSide\n\t\t\t->p_mq_ARADDRchn_vec.size(); i++)\n\t{\n\t\tcfm_clientside\n\t\t::p_mq_ARADDRchn_t* port= ClientSide\n\t\t->p_mq_ARADDRchn_vec[i]\n\t\t;\n\t\tif(port != nullptr) {\n\t\t\tport->bind(mq_ARADDRchn\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t}\n\t}\n\tClientSide->p_mq_BRESPchn\n\t(mq_BRESPchn\n\t\t\t.p_target_socket\n\t);\n\tfor (cf_count i = 0; i < (cf_count)ClientSide\n\t\t\t->p_mq_WDATAchn_vec.size(); i++)\n\t{\n\t\tcfm_clientside\n\t\t::p_mq_WDATAchn_t* port= ClientSide\n\t\t->p_mq_WDATAchn_vec[i]\n\t\t;\n\t\tif(port != nullptr) {\n\t\t\tport->bind(mq_WDATAchn\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count)ClientSide\n\t\t\t->p_mq_AWADDRchn_vec.size(); i++)\n\t{\n\t\tcfm_clientside\n\t\t::p_mq_AWADDRchn_t* port= ClientSide\n\t\t->p_mq_AWADDRchn_vec[i]\n\t\t;\n\t\tif(port != nullptr) {\n\t\t\tport->bind(mq_AWADDRchn\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)Target\n\t\t\t->p_mq_RDATAchn_vec.size(); i++)\n\t{\n\t\tcfm_target\n\t\t::p_mq_RDATAchn_t* port= Target\n\t\t->p_mq_RDATAchn_vec[i]\n\t\t;\n\t\tif(port != nullptr) {\n\t\t\tport->bind(mq_RDATAchn\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t}\n\t}\n\tTarget->p_mq_ARADDRchn\n\t(mq_ARADDRchn\n\t\t\t.p_target_socket\n\t);\n\tfor (cf_count i = 0; i < (cf_count)Target\n\t\t\t->p_mq_BRESPchn_vec.size(); i++)\n\t{\n\t\tcfm_target\n\t\t::p_mq_BRESPchn_t* port= Target\n\t\t->p_mq_BRESPchn_vec[i]\n\t\t;\n\t\tif(port != nullptr) {\n\t\t\tport->bind(mq_BRESPchn\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t}\n\t}\n\tTarget->p_mq_WDATAchn\n\t(mq_WDATAchn\n\t\t\t.p_target_socket\n\t);\n\tTarget->p_mq_AWADDRchn\n\t(mq_AWADDRchn\n\t\t\t.p_target_socket\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory constructor' algorithm generated code\n\n\t//End of 'DDRMemory constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tCF_COMM_CB_MQ_SEND(mq_WDATAchn\n\t\t\t, cfm_ddrmemory::mq_WDATAchn_cb_send_time\n\t);\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ddrmemory::~cfm_ddrmemory(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory destructor' algorithm generated code\n\n\t//End of 'DDRMemory destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ClientSide;\t///ddd\n\tdelete Target;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ddrmemory::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory pre elaboration' algorithm generated code\n\n\t//End of 'DDRMemory pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ddrmemory::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRMemory post elaboration' algorithm generated code\n\n//End of 'DDRMemory post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ddrmemory::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory post simulation' algorithm generated code\n\tAverageReadLatency = TotalReadLatency / NbTotalReadRequests;\n\tAverageWriteLatency = TotalWriteLatency / NbTotalWriteRequests;\n\tAverageWriteBandwidth = TotalWriteData * 1000 / TotalWriteLatency;\n\tAverageReadBandwidth = TotalReadData * 1000 / TotalReadLatency;\n\tAverageCombinedBandwidth = (TotalWriteData + TotalReadData) * 1000 / (TotalReadLatency + TotalWriteLatency);\n\tcf_trace_gui_f_t(\"AverageReadLatency\", AverageReadLatency);\n\tcf_trace_report(\"AverageReadLatency = %f ns, %f Cycles\", AverageReadLatency, (AverageReadLatency / (CyclePeriod)));\n\tcf_trace_gui_f_t(\"AverageWriteLatency\", AverageWriteLatency, \"ns\");\n\tcf_trace_report(\"AverageWriteLatency = %f ns, %f Cycles\", AverageWriteLatency, (AverageWriteLatency / (CyclePeriod)));\n\tcf_trace_gui_f_t(\"AverageReadBandwidth\", AverageReadBandwidth, \"Mb/s\");\n\tcf_trace_gui_f_t(\"AverageWriteBandwidth\", AverageWriteBandwidth, \"Mb/s\");\n\tcf_trace_gui_f_t(\"AverageCombinedBandwidth\", AverageCombinedBandwidth, \"Mb/s\");\n\tcf_trace_report(\"AverageReadBandwidth = %f Mb/s\", AverageReadBandwidth);\n\tcf_trace_report(\"AverageWriteBandwidth = %f Mb/s\", AverageWriteBandwidth);\n\tcf_trace_report(\"AverageCombinedBandwidth = %f Mb/s\", AverageCombinedBandwidth);\n\t//End of 'DDRMemory post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ddrmemory::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(CyclePeriod, CF_NS));\n// initialize relations attributes\n\tmq_ARADDRchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_ARADDRchn.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_ARADDRchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ARADDRchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ARADDRchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_AWADDRchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_AWADDRchn.cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_AWADDRchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_AWADDRchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_AWADDRchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_BRESPchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_BRESPchn.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_BRESPchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_BRESPchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_BRESPchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RDATAchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_RDATAchn.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_RDATAchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RDATAchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RDATAchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_WDATAchn.cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_WDATAchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_WDATAchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_WDATAchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ddrmemory::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory initializations' algorithm generated code\n\n\t//End of 'DDRMemory initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for mq_WDATAchn message queue send time\n//@{\ncf_duration cfm_ddrmemory::mq_WDATAchn_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defwdatachn, WDATAchn_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN\n\treturn cf_expr_duration(BurstLength, CF_CYCLE);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_END\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ClientSide', 'type': 'cofluent:Function', 'models': [{'name': 'Device', 'type': 'cofluent:Function'}, {'name': 'WRDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RDDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'relations': [{'name': 'BRESPin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefBRESPchn', 'connectTo': ['Device', 'WRDmux']}, {'name': 'RDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefRDATAchn', 'connectTo': ['Device', 'RDDmux']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_clientside\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_CLIENTSIDE\n#define COFS_MODEL_DDRMEMORY_CLIENTSIDE\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_clientside_dp_if.h\"\n#include \"cfm_device.h\"\n#include \"cfm_rddmux.h\"\n#include \"cfm_wrdmux.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ClientSide includes' algorithm generated code\n\n//End of 'ClientSide includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgClientSide Function ClientSide\n//@{\n///        \\page dxpClientSide\n//@{\n///    \\brief ClientSide function model start\nclass cfm_clientside: public cf_core::cf_function_container, public cfm_clientside_dp_if {\npublic:\n\t/// cfm_clientside type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defbrespchn> mq_BRESPin_t;\n\ttypedef cf_core::cf_message_queue<cft_defrdatachn> mq_RDATAin_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_clientside type define end\n\n\t/// constructor\n\tcfm_clientside(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_clientside(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tstd::vector<p_mq_ARADDRchn_t*> p_mq_ARADDRchn_vec;\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\tstd::vector<p_mq_WDATAchn_t*> p_mq_WDATAchn_vec;\n\tstd::vector<p_mq_AWADDRchn_t*> p_mq_AWADDRchn_vec;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_device*> Device_vec;\n\tcfm_rddmux* RDDmux;\n\tcfm_wrdmux* WRDmux;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_BRESPin_t*> mq_BRESPin_vec;\n\tstd::vector<mq_RDATAin_t*> mq_RDATAin_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide local declarations' algorithm generated code\n\n\t//End of 'ClientSide local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ClientSide function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_CLIENTSIDE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ClientSide', 'type': 'cofluent:Function', 'models': [{'name': 'Device', 'type': 'cofluent:Function'}, {'name': 'WRDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RDDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'relations': [{'name': 'BRESPin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefBRESPchn', 'connectTo': ['Device', 'WRDmux']}, {'name': 'RDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefRDATAchn', 'connectTo': ['Device', 'RDDmux']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_clientside\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_clientside.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ddrmemory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_clientside\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ClientSide definitions' algorithm generated code\n\n//End of 'ClientSide definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_clientside::cfm_clientside(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_clientside_dp_if()\n, p_mq_RDATAchn(\"p_mq_RDATAchn\")\n, p_mq_BRESPchn(\"p_mq_BRESPchn\")\n\n{\n\tcf_function_container::init();\n\tRDDmux = new cfm_rddmux\n\t(\"RDDmux\");\n\tWRDmux = new cfm_wrdmux\n\t(\"WRDmux\");\n\n\t// instantiation of Device_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++)\n\t{\n\t\tcfm_device* module=new cfm_device(cf_string(\"Device[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tDevice_vec.push_back(module);\n\t}\n\t// instantiation of mq_BRESPin_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++)\n\t{\n\t\tmq_BRESPin_t* module=new mq_BRESPin_t(cf_string(\"BRESPin[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_BRESPin_vec.push_back(module);\n\t}\n\t// instantiation of mq_RDATAin_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++)\n\t{\n\t\tmq_RDATAin_t* module=new mq_RDATAin_t(cf_string(\"RDATAin[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_RDATAin_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_ARADDRchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr+1); i++)\n\t{\n\t\tp_mq_ARADDRchn_t* module=new p_mq_ARADDRchn_t(cf_string(\"p_mq_ARADDRchn[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_ARADDRchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_AWADDRchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr+1); i++)\n\t{\n\t\tp_mq_AWADDRchn_t* module=new p_mq_AWADDRchn_t(cf_string(\"p_mq_AWADDRchn[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_AWADDRchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_WDATAchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr+1); i++)\n\t{\n\t\tp_mq_WDATAchn_t* module=new p_mq_WDATAchn_t(cf_string(\"p_mq_WDATAchn[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_WDATAchn_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tcfm_device* module\n\t\t=Device_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(C_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_RDATAin\n\t\t\t\t(mq_RDATAin_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(C_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_BRESPin\n\t\t\t\t(mq_BRESPin_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tmodule->p_mq_ARADDRchn\n\t\t\t((*p_mq_ARADDRchn_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tmodule->p_mq_WDATAchn\n\t\t\t((*p_mq_WDATAchn_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tmodule->p_mq_AWADDRchn\n\t\t\t((*p_mq_AWADDRchn_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tRDDmux->p_mq_RDATAchn\n\t(p_mq_RDATAchn\n\t);\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tRDDmux->p_mq_RDATAin\n\t\t(mq_RDATAin_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\n\tWRDmux->p_mq_BRESPchn\n\t(p_mq_BRESPchn\n\t);\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tWRDmux->p_mq_BRESPin\n\t\t(mq_BRESPin_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide constructor' algorithm generated code\n\n\t//End of 'ClientSide constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_clientside::~cfm_clientside(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide destructor' algorithm generated code\n\n\t//End of 'ClientSide destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_device*>::const_iterator vi = Device_vec.begin(); vi != Device_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_BRESPin_t*>::const_iterator vi = mq_BRESPin_vec.begin(); vi != mq_BRESPin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_RDATAin_t*>::const_iterator vi = mq_RDATAin_vec.begin(); vi != mq_RDATAin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_ARADDRchn_t*>::const_iterator vi = p_mq_ARADDRchn_vec.begin(); vi != p_mq_ARADDRchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_AWADDRchn_t*>::const_iterator vi = p_mq_AWADDRchn_vec.begin(); vi != p_mq_AWADDRchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_WDATAchn_t*>::const_iterator vi = p_mq_WDATAchn_vec.begin(); vi != p_mq_WDATAchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete RDDmux;\t///ddd\n\tdelete WRDmux;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_clientside::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide pre elaboration' algorithm generated code\n\n\t//End of 'ClientSide pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_clientside::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide post elaboration' algorithm generated code\n\n\t//End of 'ClientSide post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_clientside::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide post simulation' algorithm generated code\n\n\t//End of 'ClientSide post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_clientside::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\t(*mq_BRESPin_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_BRESPin_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_BRESPin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_BRESPin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_BRESPin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\t(*mq_RDATAin_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_RDATAin_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_RDATAin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_RDATAin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_RDATAin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_clientside::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide initializations' algorithm generated code\n\n\t//End of 'ClientSide initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryController', 'type': 'cofluent:Function'}, {'name': 'Memory', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'relations': [{'name': 'DQs', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDQs', 'connectTo': ['MemoryController', 'Memory']}, {'name': 'DDRCommand', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryController', 'Memory']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_TARGET\n#define COFS_MODEL_DDRMEMORY_TARGET\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_target_dp_if.h\"\n#include \"cfm_memory.h\"\n#include \"cfm_memorycontroller.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target includes' algorithm generated code\n\n//End of 'Target includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget Function Target\n//@{\n///        \\page dxpTarget\n//@{\n///    \\brief Target function model start\nclass cfm_target: public cf_core::cf_function_container, public cfm_target_dp_if {\npublic:\n\t/// cfm_target type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defddrcommand> mq_DDRCommand_t;\n\ttypedef cf_core::cf_message_queue<cft_defdqs> mq_DQs_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_target type define end\n\n\t/// constructor\n\tcfm_target(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_target(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tstd::vector<p_mq_RDATAchn_t*> p_mq_RDATAchn_vec;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tstd::vector<p_mq_BRESPchn_t*> p_mq_BRESPchn_vec;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_memory*> Memory_vec;\n\tcfm_memorycontroller* MemoryController;\n\t//@}\n\npublic:\n\t/// Overload function for mq_DQs message queue receive time\n\tcf_dt::cf_duration mq_DQs_cb_receive_time(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_DDRCommand_t*> mq_DDRCommand_vec;\n\tstd::vector<mq_DQs_t*> mq_DQs_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target local declarations' algorithm generated code\n\n\t//End of 'Target local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Target function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_TARGET\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryController', 'type': 'cofluent:Function'}, {'name': 'Memory', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'relations': [{'name': 'DQs', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDQs', 'connectTo': ['MemoryController', 'Memory']}, {'name': 'DDRCommand', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryController', 'Memory']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ddrmemory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target definitions' algorithm generated code\n\n//End of 'Target definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target::cfm_target(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_target_dp_if()\n, p_mq_ARADDRchn(\"p_mq_ARADDRchn\")\n, p_mq_WDATAchn(\"p_mq_WDATAchn\")\n, p_mq_AWADDRchn(\"p_mq_AWADDRchn\")\n\n{\n\tcf_function_container::init();\n\tMemoryController = new cfm_memorycontroller\n\t(\"MemoryController\");\n\n\t// instantiation of Memory_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++)\n\t{\n\t\tcfm_memory* module=new cfm_memory(cf_string(\"Memory[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tMemory_vec.push_back(module);\n\t}\n\t// instantiation of mq_DDRCommand_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++)\n\t{\n\t\tmq_DDRCommand_t* module=new mq_DDRCommand_t(cf_string(\"DDRCommand[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_DDRCommand_vec.push_back(module);\n\t}\n\t// instantiation of mq_DQs_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++)\n\t{\n\t\tmq_DQs_t* module=new mq_DQs_t(cf_string(\"DQs[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_DQs_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_BRESPchn_vec\n\tfor (cf_count i = 0; i < (cf_count)MemoryController->p_mq_BRESPchn_vec.size(); i++)\n\t{\n\t\tp_mq_BRESPchn_t* module=new p_mq_BRESPchn_t(cf_string(\"p_mq_BRESPchn[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_BRESPchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_RDATAchn_vec\n\tfor (cf_count i = 0; i < (cf_count)MemoryController->p_mq_RDATAchn_vec.size(); i++)\n\t{\n\t\tp_mq_RDATAchn_t* module=new p_mq_RDATAchn_t(cf_string(\"p_mq_RDATAchn[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_RDATAchn_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tcfm_memory* module\n\t\t=Memory_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(M_Nbr + 1); j++) {\n\t\t\t\tfor (cf_count k = 0; k < (cf_count)module\n\t\t\t\t\t\t->p_mq_DQs_vec.size(); k++)\n\t\t\t\t{\n\t\t\t\t\tcfm_memory\n\t\t\t\t\t::p_mq_DQs_t* port= module\n\t\t\t\t\t->p_mq_DQs_vec[k]\n\t\t\t\t\t;\n\t\t\t\t\tif(port != nullptr) {\n\t\t\t\t\t\tport->bind(mq_DQs_vec[j]\n\t\t\t\t\t\t\t\t->p_target_socket\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(M_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_DDRCommand\n\t\t\t\t(mq_DDRCommand_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tMemoryController->p_mq_DQs\n\t\t(mq_DQs_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)MemoryController\n\t\t\t->p_mq_RDATAchn_vec.size(); i++)\n\t{\n\t\tcfm_memorycontroller\n\t\t::p_mq_RDATAchn_t* port= MemoryController\n\t\t->p_mq_RDATAchn_vec[i]\n\t\t;\n\t\tif(port != nullptr) {\n\t\t\tport->bind((*p_mq_RDATAchn_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\tMemoryController->p_mq_ARADDRchn\n\t(p_mq_ARADDRchn\n\t);\n\tfor (cf_count i = 0; i < (cf_count)MemoryController\n\t\t\t->p_mq_BRESPchn_vec.size(); i++)\n\t{\n\t\tcfm_memorycontroller\n\t\t::p_mq_BRESPchn_t* port= MemoryController\n\t\t->p_mq_BRESPchn_vec[i]\n\t\t;\n\t\tif(port != nullptr) {\n\t\t\tport->bind((*p_mq_BRESPchn_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\tMemoryController->p_mq_WDATAchn\n\t(p_mq_WDATAchn\n\t);\n\tMemoryController->p_mq_AWADDRchn\n\t(p_mq_AWADDRchn\n\t);\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tMemoryController->p_mq_DDRCommand\n\t\t(mq_DDRCommand_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target constructor' algorithm generated code\n\n\t//End of 'Target constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_DQs_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_target::mq_DQs_cb_receive_time\n\t\t);\n\t}\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target::~cfm_target(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target destructor' algorithm generated code\n\n\t//End of 'Target destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_memory*>::const_iterator vi = Memory_vec.begin(); vi != Memory_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DDRCommand_t*>::const_iterator vi = mq_DDRCommand_vec.begin(); vi != mq_DDRCommand_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DQs_t*>::const_iterator vi = mq_DQs_vec.begin(); vi != mq_DQs_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_BRESPchn_t*>::const_iterator vi = p_mq_BRESPchn_vec.begin(); vi != p_mq_BRESPchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_RDATAchn_t*>::const_iterator vi = p_mq_RDATAchn_vec.begin(); vi != p_mq_RDATAchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete MemoryController;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_target::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target pre elaboration' algorithm generated code\n\n\t//End of 'Target pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_target::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post elaboration' algorithm generated code\n\n\t//End of 'Target post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_target::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post simulation' algorithm generated code\n\n\t//End of 'Target post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_target::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\t(*mq_DDRCommand_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DDRCommand_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DDRCommand_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);\n\t\t(*mq_DDRCommand_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\t(*mq_DQs_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_DQs_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_DQs_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_DQs_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_target::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target initializations' algorithm generated code\n\n\t//End of 'Target initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for mq_DQs message queue receive time\n//@{\ncf_duration cfm_target::mq_DQs_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defdqs, DQs_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(DQPutTime, CF_CYCLE);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Device', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'ReceiverRData', 'type': 'cofluent:Function'}, {'name': 'ReceiveWACK', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_DEVICE\n#define COFS_MODEL_DDRMEMORY_DEVICE\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_device_dp_if.h\"\n#include \"cfm_receiverrdata.h\"\n#include \"cfm_receivewack.h\"\n#include \"cfm_sender.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Device includes' algorithm generated code\n\n//End of 'Device includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDevice Function Device\n//@{\n///        \\page dxpDevice\n//@{\n///    \\brief Device function model start\nclass cfm_device: public cf_core::cf_function_container, public cfm_device_dp_if {\npublic:\n\t/// cfm_device type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defrdatachn> p_mq_RDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defbrespchn> p_mq_BRESPin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_device type define end\n\n\t/// constructor\n\tcfm_device(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_device(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAin_t p_mq_RDATAin;\n\tp_mq_BRESPin_t p_mq_BRESPin;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_receivewack* ReceiveWACK;\n\tcfm_receiverrdata* ReceiverRData;\n\tcfm_sender* Sender;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device local declarations' algorithm generated code\n\n\t//End of 'Device local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Device function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_DEVICE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Device', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'ReceiverRData', 'type': 'cofluent:Function'}, {'name': 'ReceiveWACK', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_device.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_clientside\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_device\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Device definitions' algorithm generated code\n\n//End of 'Device definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_device::cfm_device(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_device_dp_if()\n, p_mq_RDATAin(\"p_mq_RDATAin\")\n, p_mq_BRESPin(\"p_mq_BRESPin\")\n, p_mq_ARADDRchn(\"p_mq_ARADDRchn\")\n, p_mq_WDATAchn(\"p_mq_WDATAchn\")\n, p_mq_AWADDRchn(\"p_mq_AWADDRchn\")\n\n{\n\tcf_function_container::init();\n\tReceiveWACK = new cfm_receivewack\n\t(\"ReceiveWACK\");\n\tReceiverRData = new cfm_receiverrdata\n\t(\"ReceiverRData\");\n\tSender = new cfm_sender\n\t(\"Sender\");\n\n\t// connections\n\tReceiveWACK->p_mq_BRESPin\n\t(p_mq_BRESPin\n\t);\n\n\tReceiverRData->p_mq_RDATAin\n\t(p_mq_RDATAin\n\t);\n\n\tSender->p_mq_ARADDRchn\n\t(p_mq_ARADDRchn\n\t);\n\tSender->p_mq_WDATAchn\n\t(p_mq_WDATAchn\n\t);\n\tSender->p_mq_AWADDRchn\n\t(p_mq_AWADDRchn\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device constructor' algorithm generated code\n\n\t//End of 'Device constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_device::~cfm_device(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device destructor' algorithm generated code\n\n\t//End of 'Device destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ReceiveWACK;\t///ddd\n\tdelete ReceiverRData;\t///ddd\n\tdelete Sender;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_device::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device pre elaboration' algorithm generated code\n\n\t//End of 'Device pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_device::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device post elaboration' algorithm generated code\n\n\t//End of 'Device post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_device::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device post simulation' algorithm generated code\n\n\t//End of 'Device post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_device::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_device::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device initializations' algorithm generated code\n\n\t//End of 'Device initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WRDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_wrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WRDMUX\n#define COFS_MODEL_DDRMEMORY_WRDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_wrdmux_dp_if.h\"\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WRDmux includes' algorithm generated code\n\n//End of 'WRDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWRDmux Function WRDmux\n//@{\n///        \\page dxpWRDmux\n//@{\n///    \\brief WRDmux function model start\nclass cfm_wrdmux: public cf_core::cf_function_router, public cfm_wrdmux_dp_if {\npublic:\n\t/// cfm_wrdmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wrdmux, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wrdmux, cft_defbrespchn> p_mq_BRESPin_t;\n\t/// cfm_wrdmux type define end\n\n\t/// constructor\n\tcfm_wrdmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_wrdmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\tp_mq_BRESPin_t p_mq_BRESPin;\n\t//@}\n\npublic:\n\t/// Overload function for WRDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux local declarations' algorithm generated code\n\n\t//End of 'WRDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WRDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WRDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_wrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_wrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WRDmux definitions' algorithm generated code\n\n//End of 'WRDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_wrdmux::cfm_wrdmux(sc_core::sc_module_name name)\ncf_function_router(name)\n, cfm_wrdmux_dp_if()\n, p_mq_BRESPchn(\"p_mq_BRESPchn\")\n, p_mq_BRESPin(\"p_mq_BRESPin\")\n\n{\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_BRESPchn);\n\tadd_output_port (&p_mq_BRESPin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux constructor' algorithm generated code\n\n\t//End of 'WRDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_wrdmux::~cfm_wrdmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux destructor' algorithm generated code\n\n\t//End of 'WRDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_wrdmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux pre elaboration' algorithm generated code\n\n\t//End of 'WRDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_wrdmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux post simulation' algorithm generated code\n\n\t//End of 'WRDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_wrdmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(1, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_wrdmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux initializations' algorithm generated code\n\n\t//End of 'WRDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for WRDmux router destination method\n//@{\nstring cfm_wrdmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defbrespchn*) _trans)->get_data().ID;\n\tstd::stringstream ss;\n\tss << \"BRESPin[\" << sourceID << \"]\";\n\treturn ss.str();\n\treturn \"\";\n\t//End of 'WRDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RDDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rddmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RDDMUX\n#define COFS_MODEL_DDRMEMORY_RDDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_rddmux_dp_if.h\"\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RDDmux includes' algorithm generated code\n\n//End of 'RDDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRDDmux Function RDDmux\n//@{\n///        \\page dxpRDDmux\n//@{\n///    \\brief RDDmux function model start\nclass cfm_rddmux: public cf_core::cf_function_router, public cfm_rddmux_dp_if {\npublic:\n\t/// cfm_rddmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rddmux, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rddmux, cft_defrdatachn> p_mq_RDATAin_t;\n\t/// cfm_rddmux type define end\n\n\t/// constructor\n\tcfm_rddmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rddmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tp_mq_RDATAin_t p_mq_RDATAin;\n\t//@}\n\npublic:\n\t/// Overload function for RDDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux local declarations' algorithm generated code\n\n\t//End of 'RDDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RDDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RDDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RDDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rddmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rddmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RDDmux definitions' algorithm generated code\n\n//End of 'RDDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rddmux::cfm_rddmux(sc_core::sc_module_name name)\ncf_function_router(name)\n, cfm_rddmux_dp_if()\n, p_mq_RDATAchn(\"p_mq_RDATAchn\")\n, p_mq_RDATAin(\"p_mq_RDATAin\")\n\n{\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_RDATAchn);\n\tadd_output_port (&p_mq_RDATAin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux constructor' algorithm generated code\n\n\t//End of 'RDDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rddmux::~cfm_rddmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux destructor' algorithm generated code\n\n\t//End of 'RDDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rddmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux pre elaboration' algorithm generated code\n\n\t//End of 'RDDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rddmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux post simulation' algorithm generated code\n\n\t//End of 'RDDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rddmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(1, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rddmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux initializations' algorithm generated code\n\n\t//End of 'RDDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for RDDmux router destination method\n//@{\nstring cfm_rddmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defrdatachn*) _trans)->get_data().ID;\n\n\tstd::stringstream ss;\n\tss << \"RDATAin[\" << sourceID << \"]\";\n\treturn ss.str();\n\t//End of 'RDDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MemoryController', 'type': 'cofluent:Function', 'models': [{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'FrontEnd', 'type': 'cofluent:Function'}, {'name': 'BackEnd', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'relations': [{'name': 'AWADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux', 'FrontEnd']}, {'name': 'WDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux', 'FrontEnd']}, {'name': 'ARADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux', 'FrontEnd']}, {'name': 'MemWriteRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemWriteRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'WriteAck', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWriteAck', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemReadRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemReadRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'DataRead', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefDataRead', 'connectTo': ['FrontEnd', 'BackEnd']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memorycontroller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n#define COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memorycontroller_dp_if.h\"\n#include \"cfm_backend.h\"\n#include \"cfm_frontend.h\"\n#include \"cfm_raddrdmux.h\"\n#include \"cfm_waddrdmux.h\"\n#include \"cfm_wdatadmux.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defdataread.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryController includes' algorithm generated code\n\n//End of 'MemoryController includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemoryController Function MemoryController\n//@{\n///        \\page dxpMemoryController\n//@{\n///    \\brief MemoryController function model start\nclass cfm_memorycontroller: public cf_core::cf_function_container, public cfm_memorycontroller_dp_if {\npublic:\n\t/// cfm_memorycontroller type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defaraddrchn> mq_ARADDRin_t;\n\ttypedef cf_core::cf_message_queue<cft_defawaddrchn> mq_AWADDRin_t;\n\ttypedef cf_core::cf_message_queue<cft_defdataread> mq_DataRead_t;\n\ttypedef cf_core::cf_message_queue<cft_defmemreadrequest> mq_MemReadRequest_t;\n\ttypedef cf_core::cf_message_queue<cft_defmemwriterequest> mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_message_queue<cft_defwdatachn> mq_WDATAin_t;\n\ttypedef cf_core::cf_message_queue<cft_defwriteack> mq_WriteAck_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_memorycontroller type define end\n\n\t/// constructor\n\tcfm_memorycontroller(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_memorycontroller(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tstd::vector<p_mq_RDATAchn_t*> p_mq_RDATAchn_vec;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tstd::vector<p_mq_BRESPchn_t*> p_mq_BRESPchn_vec;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_backend* BackEnd;\n\tstd::vector<cfm_frontend*> FrontEnd_vec;\n\tcfm_raddrdmux* RAddrDmux;\n\tcfm_waddrdmux* WAddrDmux;\n\tcfm_wdatadmux* WdataDmux;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_ARADDRin_t*> mq_ARADDRin_vec;\n\tstd::vector<mq_AWADDRin_t*> mq_AWADDRin_vec;\n\tstd::vector<mq_DataRead_t*> mq_DataRead_vec;\n\tmq_MemReadRequest_t mq_MemReadRequest;\n\tmq_MemWriteRequest_t mq_MemWriteRequest;\n\tstd::vector<mq_WDATAin_t*> mq_WDATAin_vec;\n\tstd::vector<mq_WriteAck_t*> mq_WriteAck_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController local declarations' algorithm generated code\n\n\t//End of 'MemoryController local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MemoryController function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MemoryController', 'type': 'cofluent:Function', 'models': [{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'FrontEnd', 'type': 'cofluent:Function'}, {'name': 'BackEnd', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'relations': [{'name': 'AWADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux', 'FrontEnd']}, {'name': 'WDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux', 'FrontEnd']}, {'name': 'ARADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux', 'FrontEnd']}, {'name': 'MemWriteRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemWriteRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'WriteAck', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWriteAck', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemReadRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemReadRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'DataRead', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefDataRead', 'connectTo': ['FrontEnd', 'BackEnd']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memorycontroller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memorycontroller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_target\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memorycontroller\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryController definitions' algorithm generated code\n\n//End of 'MemoryController definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memorycontroller::cfm_memorycontroller(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_memorycontroller_dp_if()\n, p_mq_DQs(\"p_mq_DQs\")\n, p_mq_ARADDRchn(\"p_mq_ARADDRchn\")\n, p_mq_WDATAchn(\"p_mq_WDATAchn\")\n, p_mq_AWADDRchn(\"p_mq_AWADDRchn\")\n, p_mq_DDRCommand(\"p_mq_DDRCommand\")\n, mq_MemReadRequest(\"MemReadRequest\"\n)\n, mq_MemWriteRequest(\"MemWriteRequest\"\n)\n\n{\n\tcf_function_container::init();\n\tBackEnd = new cfm_backend\n\t(\"BackEnd\");\n\tRAddrDmux = new cfm_raddrdmux\n\t(\"RAddrDmux\");\n\tWAddrDmux = new cfm_waddrdmux\n\t(\"WAddrDmux\");\n\tWdataDmux = new cfm_wdatadmux\n\t(\"WdataDmux\");\n\n\t// instantiation of FrontEnd_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++)\n\t{\n\t\tcfm_frontend* module=new cfm_frontend(cf_string(\"FrontEnd[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tFrontEnd_vec.push_back(module);\n\t}\n\t// instantiation of mq_ARADDRin_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++)\n\t{\n\t\tmq_ARADDRin_t* module=new mq_ARADDRin_t(cf_string(\"ARADDRin[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_ARADDRin_vec.push_back(module);\n\t}\n\t// instantiation of mq_AWADDRin_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++)\n\t{\n\t\tmq_AWADDRin_t* module=new mq_AWADDRin_t(cf_string(\"AWADDRin[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_AWADDRin_vec.push_back(module);\n\t}\n\t// instantiation of mq_DataRead_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++)\n\t{\n\t\tmq_DataRead_t* module=new mq_DataRead_t(cf_string(\"DataRead[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_DataRead_vec.push_back(module);\n\t}\n\t// instantiation of mq_WDATAin_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++)\n\t{\n\t\tmq_WDATAin_t* module=new mq_WDATAin_t(cf_string(\"WDATAin[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_WDATAin_vec.push_back(module);\n\t}\n\t// instantiation of mq_WriteAck_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++)\n\t{\n\t\tmq_WriteAck_t* module=new mq_WriteAck_t(cf_string(\"WriteAck[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_WriteAck_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_BRESPchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr+1); i++)\n\t{\n\t\tp_mq_BRESPchn_t* module=new p_mq_BRESPchn_t(cf_string(\"p_mq_BRESPchn[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_BRESPchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_RDATAchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr+1); i++)\n\t{\n\t\tp_mq_RDATAchn_t* module=new p_mq_RDATAchn_t(cf_string(\"p_mq_RDATAchn[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_RDATAchn_vec.push_back(module);\n\t}\n\t// connections\n\tBackEnd->p_mq_DQs\n\t(p_mq_DQs\n\t);\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tBackEnd->p_mq_DataRead\n\t\t(mq_DataRead_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tBackEnd->p_mq_WriteAck_0\n\t\t(mq_WriteAck_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tBackEnd->p_mq_MemReadRequest\n\t(mq_MemReadRequest\n\t\t\t.p_target_socket\n\t);\n\tBackEnd->p_mq_MemWriteRequest\n\t(mq_MemWriteRequest\n\t\t\t.p_target_socket\n\t);\n\tBackEnd->p_mq_DDRCommand\n\t(p_mq_DDRCommand\n\t);\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tBackEnd->p_mq_WriteAck_1\n\t\t(mq_WriteAck_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tcfm_frontend* module\n\t\t=FrontEnd_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_DataRead\n\t\t\t\t(mq_DataRead_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_WriteAck\n\t\t\t\t(mq_WriteAck_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tmodule->p_mq_RDATAchn\n\t\t\t((*p_mq_RDATAchn_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tmodule->p_mq_BRESPchn\n\t\t\t((*p_mq_BRESPchn_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tmodule->p_mq_MemReadRequest\n\t\t\t(mq_MemReadRequest\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t\tmodule->p_mq_MemWriteRequest\n\t\t\t(mq_MemWriteRequest\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_ARADDRin\n\t\t\t\t(mq_ARADDRin_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_WDATAin\n\t\t\t\t(mq_WDATAin_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_AWADDRin\n\t\t\t\t(mq_AWADDRin_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tRAddrDmux->p_mq_ARADDRin\n\t\t(mq_ARADDRin_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tRAddrDmux->p_mq_ARADDRchn\n\t(p_mq_ARADDRchn\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tWAddrDmux->p_mq_AWADDRin\n\t\t(mq_AWADDRin_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tWAddrDmux->p_mq_AWADDRchn\n\t(p_mq_AWADDRchn\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tWdataDmux->p_mq_WDATAin\n\t\t(mq_WDATAin_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tWdataDmux->p_mq_WDATAchn\n\t(p_mq_WDATAchn\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController constructor' algorithm generated code\n\n\t//End of 'MemoryController constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memorycontroller::~cfm_memorycontroller(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController destructor' algorithm generated code\n\n\t//End of 'MemoryController destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_frontend*>::const_iterator vi = FrontEnd_vec.begin(); vi != FrontEnd_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_ARADDRin_t*>::const_iterator vi = mq_ARADDRin_vec.begin(); vi != mq_ARADDRin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_AWADDRin_t*>::const_iterator vi = mq_AWADDRin_vec.begin(); vi != mq_AWADDRin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DataRead_t*>::const_iterator vi = mq_DataRead_vec.begin(); vi != mq_DataRead_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_WDATAin_t*>::const_iterator vi = mq_WDATAin_vec.begin(); vi != mq_WDATAin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_WriteAck_t*>::const_iterator vi = mq_WriteAck_vec.begin(); vi != mq_WriteAck_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_BRESPchn_t*>::const_iterator vi = p_mq_BRESPchn_vec.begin(); vi != p_mq_BRESPchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_RDATAchn_t*>::const_iterator vi = p_mq_RDATAchn_vec.begin(); vi != p_mq_RDATAchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete BackEnd;\t///ddd\n\tdelete RAddrDmux;\t///ddd\n\tdelete WAddrDmux;\t///ddd\n\tdelete WdataDmux;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_memorycontroller::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController pre elaboration' algorithm generated code\n\n\t//End of 'MemoryController pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_memorycontroller::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController post elaboration' algorithm generated code\n\n\t//End of 'MemoryController post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_memorycontroller::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController post simulation' algorithm generated code\n\n\t//End of 'MemoryController post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_memorycontroller::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_ARADDRin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_ARADDRin_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_ARADDRin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_ARADDRin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_ARADDRin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_AWADDRin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_AWADDRin_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_AWADDRin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_AWADDRin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_AWADDRin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_DataRead_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DataRead_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DataRead_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_DataRead_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_DataRead_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tmq_MemReadRequest.cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemReadRequest.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemReadRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);\n\tmq_MemReadRequest.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MemWriteRequest.cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemWriteRequest.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemWriteRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);\n\tmq_MemWriteRequest.cfa_concurrency.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_WDATAin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_WDATAin_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_WDATAin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_WDATAin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_WDATAin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_WriteAck_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_WriteAck_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_WriteAck_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_WriteAck_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_WriteAck_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_memorycontroller::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController initializations' algorithm generated code\n\n\t//End of 'MemoryController initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Memory', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function'}, {'name': 'BankDmuxer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'relations': [{'name': 'DDRAction', 'type': 'cofluent:MessageQueue', 'vector': '0, NbBanksperMemory', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryCommandExecution', 'BankDmuxer']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORY\n#define COFS_MODEL_DDRMEMORY_MEMORY\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memory_dp_if.h\"\n#include \"cfm_bankdmuxer.h\"\n#include \"cfm_memorycommandexecution.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Memory includes' algorithm generated code\n\n//End of 'Memory includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemory Function Memory\n//@{\n///        \\page dxpMemory\n//@{\n///    \\brief Memory function model start\nclass cfm_memory: public cf_core::cf_function_container, public cfm_memory_dp_if {\npublic:\n\t/// cfm_memory type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defddrcommand> mq_DDRAction_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memory, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memory, cft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_memory type define end\n\n\t/// constructor\n\tcfm_memory(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_memory(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tstd::vector<p_mq_DQs_t*> p_mq_DQs_vec;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bankdmuxer* BankDmuxer;\n\tstd::vector<cfm_memorycommandexecution*> MemoryCommandExecution_vec;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_DDRAction_t*> mq_DDRAction_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory local declarations' algorithm generated code\n\n\t//End of 'Memory local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Memory function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORY\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Memory', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function'}, {'name': 'BankDmuxer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'relations': [{'name': 'DDRAction', 'type': 'cofluent:MessageQueue', 'vector': '0, NbBanksperMemory', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryCommandExecution', 'BankDmuxer']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memory.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_target\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memory\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Memory definitions' algorithm generated code\n\n//End of 'Memory definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memory::cfm_memory(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_memory_dp_if()\n, p_mq_DDRCommand(\"p_mq_DDRCommand\")\n\n{\n\tcf_function_container::init();\n\tBankDmuxer = new cfm_bankdmuxer\n\t(\"BankDmuxer\");\n\n\t// instantiation of MemoryCommandExecution_vec\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++)\n\t{\n\t\tcfm_memorycommandexecution* module=new cfm_memorycommandexecution(cf_string(\"MemoryCommandExecution[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tMemoryCommandExecution_vec.push_back(module);\n\t}\n\t// instantiation of mq_DDRAction_vec\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++)\n\t{\n\t\tmq_DDRAction_t* module=new mq_DDRAction_t(cf_string(\"DDRAction[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_DDRAction_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_DQs_vec\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory+1); i++)\n\t{\n\t\tp_mq_DQs_t* module=new p_mq_DQs_t(cf_string(\"p_mq_DQs[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_DQs_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\tBankDmuxer->p_mq_DDRAction\n\t\t(mq_DDRAction_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tBankDmuxer->p_mq_DDRCommand\n\t(p_mq_DDRCommand\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\tcfm_memorycommandexecution* module\n\t\t=MemoryCommandExecution_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tmodule->p_mq_DQs\n\t\t\t((*p_mq_DQs_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tfor (cf_count j = 0; j < (cf_count)(NbBanksperMemory + 1); j++) {\n\t\t\t\tmodule->p_mq_DDRAction\n\t\t\t\t(mq_DDRAction_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory constructor' algorithm generated code\n\n\t//End of 'Memory constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memory::~cfm_memory(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory destructor' algorithm generated code\n\n\t//End of 'Memory destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_memorycommandexecution*>::const_iterator vi = MemoryCommandExecution_vec.begin(); vi != MemoryCommandExecution_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DDRAction_t*>::const_iterator vi = mq_DDRAction_vec.begin(); vi != mq_DDRAction_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_DQs_t*>::const_iterator vi = p_mq_DQs_vec.begin(); vi != p_mq_DQs_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete BankDmuxer;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_memory::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory pre elaboration' algorithm generated code\n\n\t//End of 'Memory pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_memory::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory post elaboration' algorithm generated code\n\n\t//End of 'Memory post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_memory::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory post simulation' algorithm generated code\n\n\t//End of 'Memory post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_memory::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\t(*mq_DDRAction_vec[i]).cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\t\t(*mq_DDRAction_vec[i]).cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_DDRAction_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_DDRAction_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_DDRAction_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_memory::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory initializations' algorithm generated code\n\n\t//End of 'Memory initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_SENDER\n#define COFS_MODEL_DDRMEMORY_SENDER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender includes' algorithm generated code\n\n//End of 'Sender includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSender Function Sender\n//@{\n///        \\page dxpSender\n//@{\n///    \\brief Sender function model start\nclass cfm_sender: public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n\t/// cfm_sender type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_sender type define end\n\n\t/// constructor\n\tcfm_sender(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_sender(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender local declarations' algorithm generated code\n\tDefMemCmd Cmd;\n\tint dataValue;\n\tint myIndex;\n\tlong SendInitDuration;\n\tint burstLength;\n\tint size;\n\tfloat startTime;\n\tlong address;\n\tint test;\n\tint SelectCmdDuration;\n\n\tint cptTabTest;\n\tint cptTabSelectCmd;\n\tint cptTabAdressRead;\n\tint cptTabAdressWrite;\n\t//End of 'Sender local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Sender function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_SENDER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender definitions' algorithm generated code\n\n//End of 'Sender definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sender::cfm_sender(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_sender_dp_if()\n, p_mq_ARADDRchn(\"p_mq_ARADDRchn\")\n, p_mq_WDATAchn(\"p_mq_WDATAchn\")\n, p_mq_AWADDRchn(\"p_mq_AWADDRchn\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender constructor' algorithm generated code\n\n\t//End of 'Sender constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sender::~cfm_sender(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender destructor' algorithm generated code\n\n\t//End of 'Sender destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_sender::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender pre elaboration' algorithm generated code\n\n\t//End of 'Sender pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_sender::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post elaboration' algorithm generated code\n\n\t//End of 'Sender post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_sender::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post simulation' algorithm generated code\n\n\t//End of 'Sender post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_sender::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_sender::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender initializations' algorithm generated code\n\tcptTabTest = 0;\n\tcptTabSelectCmd = 0;\n\tcptTabAdressRead = 0;\n\tcptTabAdressWrite = 0;\n\t//End of 'Sender initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReceiverRData', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receiverrdata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n#define COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiverrdata_dp_if.h\"\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiverRData includes' algorithm generated code\n\n//End of 'ReceiverRData includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiverRData Function ReceiverRData\n//@{\n///        \\page dxpReceiverRData\n//@{\n///    \\brief ReceiverRData function model start\nclass cfm_receiverrdata: public cf_core::cf_function, public cfm_receiverrdata_dp_if {\npublic:\n\t/// cfm_receiverrdata type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiverrdata, cft_defrdatachn> p_mq_RDATAin_t;\n\t/// cfm_receiverrdata type define end\n\n\t/// constructor\n\tcfm_receiverrdata(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_receiverrdata(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAin_t p_mq_RDATAin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData local declarations' algorithm generated code\n\tint burstLength;\n\tint myIndex;\n\tlong ReceiveInitDuration;\n\tfloat startTime;\n\tfloat ReadLatency;\n\tint NbDataTransfer;\n\tint RemainingDataTransfer;\n\t//End of 'ReceiverRData local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReceiverRData function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReceiverRData', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receiverrdata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receiverrdata.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiverrdata\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiverRData definitions' algorithm generated code\n\n//End of 'ReceiverRData definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receiverrdata::cfm_receiverrdata(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_receiverrdata_dp_if()\n, p_mq_RDATAin(\"p_mq_RDATAin\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData constructor' algorithm generated code\n\n\t//End of 'ReceiverRData constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receiverrdata::~cfm_receiverrdata(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData destructor' algorithm generated code\n\n\t//End of 'ReceiverRData destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_receiverrdata::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData pre elaboration' algorithm generated code\n\n\t//End of 'ReceiverRData pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_receiverrdata::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData post elaboration' algorithm generated code\n\n\t//End of 'ReceiverRData post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_receiverrdata::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData post simulation' algorithm generated code\n\n\t//End of 'ReceiverRData post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_receiverrdata::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_receiverrdata::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData initializations' algorithm generated code\n\n\t//End of 'ReceiverRData initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReceiveWACK', 'type': 'cofluent:Function', 'ports': [{'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receivewack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RECEIVEWACK\n#define COFS_MODEL_DDRMEMORY_RECEIVEWACK\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receivewack_dp_if.h\"\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiveWACK includes' algorithm generated code\n\n//End of 'ReceiveWACK includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiveWACK Function ReceiveWACK\n//@{\n///        \\page dxpReceiveWACK\n//@{\n///    \\brief ReceiveWACK function model start\nclass cfm_receivewack: public cf_core::cf_function, public cfm_receivewack_dp_if {\npublic:\n\t/// cfm_receivewack type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receivewack, cft_defbrespchn> p_mq_BRESPin_t;\n\t/// cfm_receivewack type define end\n\n\t/// constructor\n\tcfm_receivewack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_receivewack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BRESPin_t p_mq_BRESPin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK local declarations' algorithm generated code\n\tint myIndex;\n\tlong ReceiveWACKInitDuration;\n\tfloat WriteLatency;\n\tfloat startTime;\n\tint burstLength;\n\t//End of 'ReceiveWACK local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReceiveWACK function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RECEIVEWACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReceiveWACK', 'type': 'cofluent:Function', 'ports': [{'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receivewack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receivewack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receivewack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiveWACK definitions' algorithm generated code\n\n//End of 'ReceiveWACK definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receivewack::cfm_receivewack(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_receivewack_dp_if()\n, p_mq_BRESPin(\"p_mq_BRESPin\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK constructor' algorithm generated code\n\n\t//End of 'ReceiveWACK constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receivewack::~cfm_receivewack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK destructor' algorithm generated code\n\n\t//End of 'ReceiveWACK destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_receivewack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK pre elaboration' algorithm generated code\n\n\t//End of 'ReceiveWACK pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_receivewack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK post elaboration' algorithm generated code\n\n\t//End of 'ReceiveWACK post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_receivewack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK post simulation' algorithm generated code\n\n\t//End of 'ReceiveWACK post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_receivewack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_receivewack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK initializations' algorithm generated code\n\n\t//End of 'ReceiveWACK initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_waddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WADDRDMUX\n#define COFS_MODEL_DDRMEMORY_WADDRDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_waddrdmux_dp_if.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WAddrDmux includes' algorithm generated code\n\n//End of 'WAddrDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWAddrDmux Function WAddrDmux\n//@{\n///        \\page dxpWAddrDmux\n//@{\n///    \\brief WAddrDmux function model start\nclass cfm_waddrdmux: public cf_core::cf_function_router, public cfm_waddrdmux_dp_if {\npublic:\n\t/// cfm_waddrdmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_waddrdmux, cft_defawaddrchn> p_mq_AWADDRin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_waddrdmux, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_waddrdmux type define end\n\n\t/// constructor\n\tcfm_waddrdmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_waddrdmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_AWADDRin_t p_mq_AWADDRin;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\npublic:\n\t/// Overload function for WAddrDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux local declarations' algorithm generated code\n\tint Port_ID;\n\t//End of 'WAddrDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WAddrDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WADDRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_waddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_waddrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WAddrDmux definitions' algorithm generated code\n\n//End of 'WAddrDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_waddrdmux::cfm_waddrdmux(sc_core::sc_module_name name)\ncf_function_router(name)\n, cfm_waddrdmux_dp_if()\n, p_mq_AWADDRin(\"p_mq_AWADDRin\")\n, p_mq_AWADDRchn(\"p_mq_AWADDRchn\")\n\n{\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_AWADDRchn);\n\tadd_output_port (&p_mq_AWADDRin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux constructor' algorithm generated code\n\n\t//End of 'WAddrDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_waddrdmux::~cfm_waddrdmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux destructor' algorithm generated code\n\n\t//End of 'WAddrDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_waddrdmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux pre elaboration' algorithm generated code\n\n\t//End of 'WAddrDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_waddrdmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux post simulation' algorithm generated code\n\n\t//End of 'WAddrDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_waddrdmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(0, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_waddrdmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux initializations' algorithm generated code\n\n\t//End of 'WAddrDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for WAddrDmux router destination method\n//@{\nstring cfm_waddrdmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defawaddrchn*) _trans)->get_data().ID;\n\n\tstd::stringstream ss;\n\tss << \"AWADDRin[\" << sourceID << \"]\";\n\tcout << ss.str();\n\treturn ss.str();\n\t//End of 'WAddrDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_wdatadmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WDATADMUX\n#define COFS_MODEL_DDRMEMORY_WDATADMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_wdatadmux_dp_if.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WdataDmux includes' algorithm generated code\n\n//End of 'WdataDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWdataDmux Function WdataDmux\n//@{\n///        \\page dxpWdataDmux\n//@{\n///    \\brief WdataDmux function model start\nclass cfm_wdatadmux: public cf_core::cf_function_router, public cfm_wdatadmux_dp_if {\npublic:\n\t/// cfm_wdatadmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wdatadmux, cft_defwdatachn> p_mq_WDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wdatadmux, cft_defwdatachn> p_mq_WDATAchn_t;\n\t/// cfm_wdatadmux type define end\n\n\t/// constructor\n\tcfm_wdatadmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_wdatadmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_WDATAin_t p_mq_WDATAin;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\t//@}\n\npublic:\n\t/// Overload function for WdataDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux local declarations' algorithm generated code\n\tint Port_ID;\n\t//End of 'WdataDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WdataDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WDATADMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_wdatadmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_wdatadmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WdataDmux definitions' algorithm generated code\n\n//End of 'WdataDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_wdatadmux::cfm_wdatadmux(sc_core::sc_module_name name)\ncf_function_router(name)\n, cfm_wdatadmux_dp_if()\n, p_mq_WDATAin(\"p_mq_WDATAin\")\n, p_mq_WDATAchn(\"p_mq_WDATAchn\")\n\n{\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_WDATAchn);\n\tadd_output_port (&p_mq_WDATAin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux constructor' algorithm generated code\n\n\t//End of 'WdataDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_wdatadmux::~cfm_wdatadmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux destructor' algorithm generated code\n\n\t//End of 'WdataDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_wdatadmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux pre elaboration' algorithm generated code\n\n\t//End of 'WdataDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_wdatadmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux post simulation' algorithm generated code\n\n\t//End of 'WdataDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_wdatadmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(0, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_wdatadmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux initializations' algorithm generated code\n\n\t//End of 'WdataDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for WdataDmux router destination method\n//@{\nstring cfm_wdatadmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defwdatachn*) _trans)->get_data().ID;\n\tstd::stringstream ss;\n\tss << \"WDATAin[\" << sourceID << \"]\";\n\treturn ss.str();\n\t//End of 'WdataDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_raddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RADDRDMUX\n#define COFS_MODEL_DDRMEMORY_RADDRDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_raddrdmux_dp_if.h\"\n#include \"dt/cft_defaraddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RAddrDmux includes' algorithm generated code\n\n//End of 'RAddrDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRAddrDmux Function RAddrDmux\n//@{\n///        \\page dxpRAddrDmux\n//@{\n///    \\brief RAddrDmux function model start\nclass cfm_raddrdmux: public cf_core::cf_function_router, public cfm_raddrdmux_dp_if {\npublic:\n\t/// cfm_raddrdmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_raddrdmux, cft_defaraddrchn> p_mq_ARADDRin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_raddrdmux, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\t/// cfm_raddrdmux type define end\n\n\t/// constructor\n\tcfm_raddrdmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_raddrdmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ARADDRin_t p_mq_ARADDRin;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\t//@}\n\npublic:\n\t/// Overload function for RAddrDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux local declarations' algorithm generated code\n\tint Port_ID;\n\t//End of 'RAddrDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RAddrDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RADDRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_raddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_raddrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RAddrDmux definitions' algorithm generated code\n\n//End of 'RAddrDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_raddrdmux::cfm_raddrdmux(sc_core::sc_module_name name)\ncf_function_router(name)\n, cfm_raddrdmux_dp_if()\n, p_mq_ARADDRin(\"p_mq_ARADDRin\")\n, p_mq_ARADDRchn(\"p_mq_ARADDRchn\")\n\n{\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_ARADDRchn);\n\tadd_output_port (&p_mq_ARADDRin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux constructor' algorithm generated code\n\n\t//End of 'RAddrDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_raddrdmux::~cfm_raddrdmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux destructor' algorithm generated code\n\n\t//End of 'RAddrDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_raddrdmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux pre elaboration' algorithm generated code\n\n\t//End of 'RAddrDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_raddrdmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux post simulation' algorithm generated code\n\n\t//End of 'RAddrDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_raddrdmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(0, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_raddrdmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux initializations' algorithm generated code\n\n\t//End of 'RAddrDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for RAddrDmux router destination method\n//@{\nstring cfm_raddrdmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defaraddrchn*) _trans)->get_data().ID;\n\tstd::stringstream ss;\n\tss << \"ARADDRin[\" << sourceID << \"]\";\n\treturn ss.str();\n\t//End of 'RAddrDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'FrontEnd', 'type': 'cofluent:Function', 'models': [{'name': 'WriteDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDriver', 'type': 'cofluent:Function'}, {'name': 'SendWAckDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDataDriver', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_frontend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_FRONTEND\n#define COFS_MODEL_DDRMEMORY_FRONTEND\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_frontend_dp_if.h\"\n#include \"cfm_readdatadriver.h\"\n#include \"cfm_readdriver.h\"\n#include \"cfm_sendwackdriver.h\"\n#include \"cfm_writedriver.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FrontEnd includes' algorithm generated code\n\n//End of 'FrontEnd includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgFrontEnd Function FrontEnd\n//@{\n///        \\page dxpFrontEnd\n//@{\n///    \\brief FrontEnd function model start\nclass cfm_frontend: public cf_core::cf_function_container, public cfm_frontend_dp_if {\npublic:\n\t/// cfm_frontend type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defdataread> p_mq_DataRead_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defwriteack> p_mq_WriteAck_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defaraddrchn> p_mq_ARADDRin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defwdatachn> p_mq_WDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defawaddrchn> p_mq_AWADDRin_t;\n\t/// cfm_frontend type define end\n\n\t/// constructor\n\tcfm_frontend(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_frontend(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DataRead_t p_mq_DataRead;\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\tp_mq_ARADDRin_t p_mq_ARADDRin;\n\tp_mq_WDATAin_t p_mq_WDATAin;\n\tp_mq_AWADDRin_t p_mq_AWADDRin;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_readdatadriver* ReadDataDriver;\n\tcfm_readdriver* ReadDriver;\n\tcfm_sendwackdriver* SendWAckDriver;\n\tcfm_writedriver* WriteDriver;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd local declarations' algorithm generated code\n\n\t//End of 'FrontEnd local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief FrontEnd function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_FRONTEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'FrontEnd', 'type': 'cofluent:Function', 'models': [{'name': 'WriteDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDriver', 'type': 'cofluent:Function'}, {'name': 'SendWAckDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDataDriver', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_frontend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_frontend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memorycontroller\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_frontend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FrontEnd definitions' algorithm generated code\n\n//End of 'FrontEnd definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_frontend::cfm_frontend(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_frontend_dp_if()\n, p_mq_DataRead(\"p_mq_DataRead\")\n, p_mq_WriteAck(\"p_mq_WriteAck\")\n, p_mq_RDATAchn(\"p_mq_RDATAchn\")\n, p_mq_BRESPchn(\"p_mq_BRESPchn\")\n, p_mq_MemReadRequest(\"p_mq_MemReadRequest\")\n, p_mq_MemWriteRequest(\"p_mq_MemWriteRequest\")\n, p_mq_ARADDRin(\"p_mq_ARADDRin\")\n, p_mq_WDATAin(\"p_mq_WDATAin\")\n, p_mq_AWADDRin(\"p_mq_AWADDRin\")\n\n{\n\tcf_function_container::init();\n\tReadDataDriver = new cfm_readdatadriver\n\t(\"ReadDataDriver\");\n\tReadDriver = new cfm_readdriver\n\t(\"ReadDriver\");\n\tSendWAckDriver = new cfm_sendwackdriver\n\t(\"SendWAckDriver\");\n\tWriteDriver = new cfm_writedriver\n\t(\"WriteDriver\");\n\n\t// connections\n\tReadDataDriver->p_mq_RDATAchn\n\t(p_mq_RDATAchn\n\t);\n\tReadDataDriver->p_mq_DataRead\n\t(p_mq_DataRead\n\t);\n\n\tReadDriver->p_mq_MemReadRequest\n\t(p_mq_MemReadRequest\n\t);\n\tReadDriver->p_mq_ARADDRin\n\t(p_mq_ARADDRin\n\t);\n\n\tSendWAckDriver->p_mq_WriteAck\n\t(p_mq_WriteAck\n\t);\n\tSendWAckDriver->p_mq_BRESPchn\n\t(p_mq_BRESPchn\n\t);\n\n\tWriteDriver->p_mq_MemWriteRequest\n\t(p_mq_MemWriteRequest\n\t);\n\tWriteDriver->p_mq_WDATAin\n\t(p_mq_WDATAin\n\t);\n\tWriteDriver->p_mq_AWADDRin\n\t(p_mq_AWADDRin\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd constructor' algorithm generated code\n\n\t//End of 'FrontEnd constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_frontend::~cfm_frontend(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd destructor' algorithm generated code\n\n\t//End of 'FrontEnd destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ReadDataDriver;\t///ddd\n\tdelete ReadDriver;\t///ddd\n\tdelete SendWAckDriver;\t///ddd\n\tdelete WriteDriver;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_frontend::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd pre elaboration' algorithm generated code\n\n\t//End of 'FrontEnd pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_frontend::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd post elaboration' algorithm generated code\n\n\t//End of 'FrontEnd post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_frontend::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd post simulation' algorithm generated code\n\n\t//End of 'FrontEnd post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_frontend::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_frontend::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd initializations' algorithm generated code\n\n\t//End of 'FrontEnd initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BackEnd', 'type': 'cofluent:Function', 'models': [{'name': 'CollectRequests', 'type': 'cofluent:Function'}, {'name': 'ResponseForward', 'type': 'cofluent:Function'}, {'name': 'Arbitration', 'type': 'cofluent:Function'}, {'name': 'DDRCommandGeneration', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'relations': [{'name': 'RequestCounter', 'type': 'cofluent:Event', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'ListRequestsPtr', 'type': 'cofluent:SharedVariable', 'dataType': 'DefListRequestsPtr', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'RequestInformation', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequestInformation', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'Requests2Memory', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequests2Memory', 'connectTo': ['Arbitration', 'DDRCommandGeneration']}, {'name': 'MemoryStatus', 'type': 'cofluent:SharedVariable', 'vector': '0, M_Nbr', 'dataType': 'DefMemoryStatus', 'connectTo': ['DDRCommandGeneration']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_backend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_BACKEND\n#define COFS_MODEL_DDRMEMORY_BACKEND\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_backend_dp_if.h\"\n#include \"cfm_arbitration.h\"\n#include \"cfm_collectrequests.h\"\n#include \"cfm_ddrcommandgeneration.h\"\n#include \"cfm_responseforward.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_defrequests2memory.h\"\n#include \"dt/cft_defmemorystatus.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BackEnd includes' algorithm generated code\n\n//End of 'BackEnd includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBackEnd Function BackEnd\n//@{\n///        \\page dxpBackEnd\n//@{\n///    \\brief BackEnd function model start\nclass cfm_backend: public cf_core::cf_function_container, public cfm_backend_dp_if {\npublic:\n\t/// cfm_backend type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_deflistrequestsptr> sv_ListRequestsPtr_t;\n\ttypedef cf_core::cf_shared_variable<cft_defmemorystatus> sv_MemoryStatus_t;\n\ttypedef cf_core::cf_event ev_RequestCounter_t;\n\ttypedef cf_core::cf_message_queue<cft_defrequestinformation> mq_RequestInformation_t;\n\ttypedef cf_core::cf_message_queue<cft_defrequests2memory> mq_Requests2Memory_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defdataread> p_mq_DataRead_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defwriteack> p_mq_WriteAck_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defddrcommand> p_mq_DDRCommand_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defwriteack> p_mq_WriteAck_1_t;\n\t/// cfm_backend type define end\n\n\t/// constructor\n\tcfm_backend(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_backend(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tp_mq_DataRead_t p_mq_DataRead;\n\tp_mq_WriteAck_0_t p_mq_WriteAck_0;\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\tp_mq_WriteAck_1_t p_mq_WriteAck_1;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_arbitration* Arbitration;\n\tcfm_collectrequests* CollectRequests;\n\tcfm_ddrcommandgeneration* DDRCommandGeneration;\n\tcfm_responseforward* ResponseForward;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_ListRequestsPtr_t sv_ListRequestsPtr;\n\tstd::vector<sv_MemoryStatus_t*> sv_MemoryStatus_vec;\n\tev_RequestCounter_t ev_RequestCounter;\n\tmq_RequestInformation_t mq_RequestInformation;\n\tmq_Requests2Memory_t mq_Requests2Memory;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd local declarations' algorithm generated code\n\n\t//End of 'BackEnd local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BackEnd function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_BACKEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BackEnd', 'type': 'cofluent:Function', 'models': [{'name': 'CollectRequests', 'type': 'cofluent:Function'}, {'name': 'ResponseForward', 'type': 'cofluent:Function'}, {'name': 'Arbitration', 'type': 'cofluent:Function'}, {'name': 'DDRCommandGeneration', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'relations': [{'name': 'RequestCounter', 'type': 'cofluent:Event', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'ListRequestsPtr', 'type': 'cofluent:SharedVariable', 'dataType': 'DefListRequestsPtr', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'RequestInformation', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequestInformation', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'Requests2Memory', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequests2Memory', 'connectTo': ['Arbitration', 'DDRCommandGeneration']}, {'name': 'MemoryStatus', 'type': 'cofluent:SharedVariable', 'vector': '0, M_Nbr', 'dataType': 'DefMemoryStatus', 'connectTo': ['DDRCommandGeneration']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_backend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_backend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memorycontroller\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_backend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BackEnd definitions' algorithm generated code\n\n//End of 'BackEnd definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_backend::cfm_backend(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_backend_dp_if()\n, p_mq_DQs(\"p_mq_DQs\")\n, p_mq_DataRead(\"p_mq_DataRead\")\n, p_mq_WriteAck_0(\"p_mq_WriteAck_0\")\n, p_mq_MemReadRequest(\"p_mq_MemReadRequest\")\n, p_mq_MemWriteRequest(\"p_mq_MemWriteRequest\")\n, p_mq_DDRCommand(\"p_mq_DDRCommand\")\n, p_mq_WriteAck_1(\"p_mq_WriteAck_1\")\n, sv_ListRequestsPtr(\"ListRequestsPtr\"\n)\n, ev_RequestCounter(\"RequestCounter\"\n)\n, mq_RequestInformation(\"RequestInformation\"\n)\n, mq_Requests2Memory(\"Requests2Memory\"\n)\n\n{\n\tcf_function_container::init();\n\tArbitration = new cfm_arbitration\n\t(\"Arbitration\");\n\tCollectRequests = new cfm_collectrequests\n\t(\"CollectRequests\");\n\tDDRCommandGeneration = new cfm_ddrcommandgeneration\n\t(\"DDRCommandGeneration\");\n\tResponseForward = new cfm_responseforward\n\t(\"ResponseForward\");\n\n\t// instantiation of sv_MemoryStatus_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++)\n\t{\n\t\tsv_MemoryStatus_t* module=new sv_MemoryStatus_t(cf_string(\"MemoryStatus[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tsv_MemoryStatus_vec.push_back(module);\n\t}\n\t// connections\n\tArbitration->p_mq_WriteAck\n\t(p_mq_WriteAck_1\n\t);\n\tArbitration->p_mq_RequestInformation\n\t(mq_RequestInformation\n\t\t\t.p_target_socket\n\t);\n\tArbitration->p_sv_ListRequestsPtr\n\t(sv_ListRequestsPtr\n\t\t\t.p_target_socket\n\t);\n\tArbitration->p_mq_Requests2Memory\n\t(mq_Requests2Memory\n\t\t\t.p_target_socket\n\t);\n\tArbitration->p_ev_RequestCounter\n\t(ev_RequestCounter\n\t\t\t.p_target_socket\n\t);\n\n\tCollectRequests->p_sv_ListRequestsPtr\n\t(sv_ListRequestsPtr\n\t\t\t.p_target_socket\n\t);\n\tCollectRequests->p_ev_RequestCounter\n\t(ev_RequestCounter\n\t\t\t.p_target_socket\n\t);\n\tCollectRequests->p_mq_MemReadRequest\n\t(p_mq_MemReadRequest\n\t);\n\tCollectRequests->p_mq_MemWriteRequest\n\t(p_mq_MemWriteRequest\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tDDRCommandGeneration->p_sv_MemoryStatus\n\t\t(sv_MemoryStatus_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tDDRCommandGeneration->p_mq_Requests2Memory\n\t(mq_Requests2Memory\n\t\t\t.p_target_socket\n\t);\n\tDDRCommandGeneration->p_mq_DDRCommand\n\t(p_mq_DDRCommand\n\t);\n\n\tResponseForward->p_mq_DQs\n\t(p_mq_DQs\n\t);\n\tResponseForward->p_mq_RequestInformation\n\t(mq_RequestInformation\n\t\t\t.p_target_socket\n\t);\n\tResponseForward->p_mq_DataRead\n\t(p_mq_DataRead\n\t);\n\tResponseForward->p_mq_WriteAck\n\t(p_mq_WriteAck_0\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd constructor' algorithm generated code\n\n\t//End of 'BackEnd constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_backend::~cfm_backend(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd destructor' algorithm generated code\n\n\t//End of 'BackEnd destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<sv_MemoryStatus_t*>::const_iterator vi = sv_MemoryStatus_vec.begin(); vi != sv_MemoryStatus_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete Arbitration;\t///ddd\n\tdelete CollectRequests;\t///ddd\n\tdelete DDRCommandGeneration;\t///ddd\n\tdelete ResponseForward;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_backend::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd pre elaboration' algorithm generated code\n\n\t//End of 'BackEnd pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_backend::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd post elaboration' algorithm generated code\n\n\t//End of 'BackEnd post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_backend::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd post simulation' algorithm generated code\n\n\t//End of 'BackEnd post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_backend::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tsv_ListRequestsPtr.cfa_write_time.init(cf_expr_duration(0, CF_CYCLE));\n\tsv_ListRequestsPtr.cfa_read_time.init(cf_expr_duration(0, CF_CYCLE));\n\tsv_ListRequestsPtr.cfa_semaphore.init(false);\n\tsv_ListRequestsPtr.cfa_concurrency.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\t(*sv_MemoryStatus_vec[i]).cfa_write_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*sv_MemoryStatus_vec[i]).cfa_read_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*sv_MemoryStatus_vec[i]).cfa_semaphore.init(false);\n\t\t(*sv_MemoryStatus_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tev_RequestCounter.cfa_set_time.init(cf_expr_duration(0, CF_CYCLE));\n\tev_RequestCounter.cfa_get_time.init(cf_expr_duration(0, CF_CYCLE));\n\tev_RequestCounter.cfa_event_policy.init(CF_EV_POLICY_COUNTER);\n\tmq_RequestInformation.cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_RequestInformation.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_RequestInformation.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);\n\tmq_RequestInformation.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Requests2Memory.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_Requests2Memory.cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_Requests2Memory.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Requests2Memory.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Requests2Memory.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_backend::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd initializations' algorithm generated code\n\n\t//End of 'BackEnd initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memorycommandexecution\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n#define COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memorycommandexecution_dp_if.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryCommandExecution includes' algorithm generated code\n\n//End of 'MemoryCommandExecution includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemoryCommandExecution Function MemoryCommandExecution\n//@{\n///        \\page dxpMemoryCommandExecution\n//@{\n///    \\brief MemoryCommandExecution function model start\nclass cfm_memorycommandexecution: public cf_core::cf_function, public cfm_memorycommandexecution_dp_if {\npublic:\n\t/// cfm_memorycommandexecution type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycommandexecution, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycommandexecution, cft_defddrcommand> p_mq_DDRAction_t;\n\t/// cfm_memorycommandexecution type define end\n\n\t/// constructor\n\tcfm_memorycommandexecution(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_memorycommandexecution(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tp_mq_DDRAction_t p_mq_DDRAction;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution local declarations' algorithm generated code\n\tint ExecuteCommandDuration;\n\tbool SendDQ;\n\tint AutoPrechargedDuration;\n\tint memID;\n\tint InitBankDuration;\n\tint PowerConsumption;\n\tdouble StaticPowerConsumption;\n\t// 4 because of a maximum of 4 banks per memory\n\tint StartBank[4];\n\tint Instance;\n\t//End of 'MemoryCommandExecution local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MemoryCommandExecution function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memorycommandexecution\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memorycommandexecution.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memorycommandexecution\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryCommandExecution definitions' algorithm generated code\n\n//End of 'MemoryCommandExecution definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memorycommandexecution::cfm_memorycommandexecution(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_memorycommandexecution_dp_if()\n, p_mq_DQs(\"p_mq_DQs\")\n, p_mq_DDRAction(\"p_mq_DDRAction\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution constructor' algorithm generated code\n\n\t//End of 'MemoryCommandExecution constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memorycommandexecution::~cfm_memorycommandexecution(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution destructor' algorithm generated code\n\n\t//End of 'MemoryCommandExecution destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_memorycommandexecution::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution pre elaboration' algorithm generated code\n\n\t//End of 'MemoryCommandExecution pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_memorycommandexecution::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution post elaboration' algorithm generated code\n\n\t//End of 'MemoryCommandExecution post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_memorycommandexecution::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution post simulation' algorithm generated code\n\n\t//End of 'MemoryCommandExecution post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_memorycommandexecution::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_memorycommandexecution::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution initializations' algorithm generated code\n\tStartBank[0] = 0;\n\tStartBank[1] = 0;\n\tStartBank[2] = 0;\n\tStartBank[3] = 0;\n\tmemID = 0;\n\t//End of 'MemoryCommandExecution initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BankDmuxer', 'type': 'cofluent:Function', 'ports': [{'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bankdmuxer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_BANKDMUXER\n#define COFS_MODEL_DDRMEMORY_BANKDMUXER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bankdmuxer_dp_if.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BankDmuxer includes' algorithm generated code\n\n//End of 'BankDmuxer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBankDmuxer Function BankDmuxer\n//@{\n///        \\page dxpBankDmuxer\n//@{\n///    \\brief BankDmuxer function model start\nclass cfm_bankdmuxer: public cf_core::cf_function, public cfm_bankdmuxer_dp_if {\npublic:\n\t/// cfm_bankdmuxer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bankdmuxer, cft_defddrcommand> p_mq_DDRAction_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bankdmuxer, cft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_bankdmuxer type define end\n\n\t/// constructor\n\tcfm_bankdmuxer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bankdmuxer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DDRAction_t p_mq_DDRAction;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer local declarations' algorithm generated code\n\tbool RcvRequest;\n\tint Bank;\n\tfloat LastActivate, CurrentActivate;\n\tint LastBank;\n\tint Send2BankDuration;\n\tint DDRActionSend;\n\t//End of 'BankDmuxer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BankDmuxer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_BANKDMUXER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BankDmuxer', 'type': 'cofluent:Function', 'ports': [{'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bankdmuxer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bankdmuxer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bankdmuxer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BankDmuxer definitions' algorithm generated code\n\n//End of 'BankDmuxer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bankdmuxer::cfm_bankdmuxer(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_bankdmuxer_dp_if()\n, p_mq_DDRAction(\"p_mq_DDRAction\")\n, p_mq_DDRCommand(\"p_mq_DDRCommand\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer constructor' algorithm generated code\n\n\t//End of 'BankDmuxer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bankdmuxer::~cfm_bankdmuxer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer destructor' algorithm generated code\n\n\t//End of 'BankDmuxer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bankdmuxer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer pre elaboration' algorithm generated code\n\n\t//End of 'BankDmuxer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bankdmuxer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer post elaboration' algorithm generated code\n\n\t//End of 'BankDmuxer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bankdmuxer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer post simulation' algorithm generated code\n\n\t//End of 'BankDmuxer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bankdmuxer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bankdmuxer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer initializations' algorithm generated code\n\n\t//End of 'BankDmuxer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WriteDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_writedriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WRITEDRIVER\n#define COFS_MODEL_DDRMEMORY_WRITEDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_writedriver_dp_if.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WriteDriver includes' algorithm generated code\n\n//End of 'WriteDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWriteDriver Function WriteDriver\n//@{\n///        \\page dxpWriteDriver\n//@{\n///    \\brief WriteDriver function model start\nclass cfm_writedriver: public cf_core::cf_function, public cfm_writedriver_dp_if {\npublic:\n\t/// cfm_writedriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writedriver, cft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writedriver, cft_defwdatachn> p_mq_WDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writedriver, cft_defawaddrchn> p_mq_AWADDRin_t;\n\t/// cfm_writedriver type define end\n\n\t/// constructor\n\tcfm_writedriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_writedriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\tp_mq_WDATAin_t p_mq_WDATAin;\n\tp_mq_AWADDRin_t p_mq_AWADDRin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver local declarations' algorithm generated code\n\tint burstLength;\n\tfloat startTime;\n\tint address;\n\tint ID;\n\tint size;\n\tlong WriteInitDuration;\n\tint myIndex;\n\t//End of 'WriteDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WriteDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WRITEDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WriteDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_writedriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_writedriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writedriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WriteDriver definitions' algorithm generated code\n\n//End of 'WriteDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_writedriver::cfm_writedriver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_writedriver_dp_if()\n, p_mq_MemWriteRequest(\"p_mq_MemWriteRequest\")\n, p_mq_WDATAin(\"p_mq_WDATAin\")\n, p_mq_AWADDRin(\"p_mq_AWADDRin\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver constructor' algorithm generated code\n\n\t//End of 'WriteDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_writedriver::~cfm_writedriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver destructor' algorithm generated code\n\n\t//End of 'WriteDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_writedriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver pre elaboration' algorithm generated code\n\n\t//End of 'WriteDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_writedriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver post elaboration' algorithm generated code\n\n\t//End of 'WriteDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_writedriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver post simulation' algorithm generated code\n\n\t//End of 'WriteDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_writedriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_writedriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver initializations' algorithm generated code\n\n\t//End of 'WriteDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReadDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_readdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_READDRIVER\n#define COFS_MODEL_DDRMEMORY_READDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_readdriver_dp_if.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defaraddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDriver includes' algorithm generated code\n\n//End of 'ReadDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReadDriver Function ReadDriver\n//@{\n///        \\page dxpReadDriver\n//@{\n///    \\brief ReadDriver function model start\nclass cfm_readdriver: public cf_core::cf_function, public cfm_readdriver_dp_if {\npublic:\n\t/// cfm_readdriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdriver, cft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdriver, cft_defaraddrchn> p_mq_ARADDRin_t;\n\t/// cfm_readdriver type define end\n\n\t/// constructor\n\tcfm_readdriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_readdriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_ARADDRin_t p_mq_ARADDRin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver local declarations' algorithm generated code\n\tint burstLength;\n\tfloat startTime;\n\tint address;\n\tint ID;\n\tint size;\n\tbool First;\n\tlong RdInitDuration;\n\tint myIndex;\n\t//End of 'ReadDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReadDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_READDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReadDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_readdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_readdriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_readdriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDriver definitions' algorithm generated code\n\n//End of 'ReadDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_readdriver::cfm_readdriver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_readdriver_dp_if()\n, p_mq_MemReadRequest(\"p_mq_MemReadRequest\")\n, p_mq_ARADDRin(\"p_mq_ARADDRin\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver constructor' algorithm generated code\n\n\t//End of 'ReadDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_readdriver::~cfm_readdriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver destructor' algorithm generated code\n\n\t//End of 'ReadDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_readdriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver pre elaboration' algorithm generated code\n\n\t//End of 'ReadDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_readdriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver post elaboration' algorithm generated code\n\n\t//End of 'ReadDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_readdriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver post simulation' algorithm generated code\n\n\t//End of 'ReadDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_readdriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_readdriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver initializations' algorithm generated code\n\n\t//End of 'ReadDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'SendWAckDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sendwackdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n#define COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sendwackdriver_dp_if.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'SendWAckDriver includes' algorithm generated code\n\n//End of 'SendWAckDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSendWAckDriver Function SendWAckDriver\n//@{\n///        \\page dxpSendWAckDriver\n//@{\n///    \\brief SendWAckDriver function model start\nclass cfm_sendwackdriver: public cf_core::cf_function, public cfm_sendwackdriver_dp_if {\npublic:\n\t/// cfm_sendwackdriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sendwackdriver, cft_defwriteack> p_mq_WriteAck_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sendwackdriver, cft_defbrespchn> p_mq_BRESPchn_t;\n\t/// cfm_sendwackdriver type define end\n\n\t/// constructor\n\tcfm_sendwackdriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_sendwackdriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver local declarations' algorithm generated code\n\tlong WACKInitDuration;\n\tint myIndex;\n\t//End of 'SendWAckDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief SendWAckDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'SendWAckDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sendwackdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sendwackdriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sendwackdriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'SendWAckDriver definitions' algorithm generated code\n\n//End of 'SendWAckDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sendwackdriver::cfm_sendwackdriver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_sendwackdriver_dp_if()\n, p_mq_WriteAck(\"p_mq_WriteAck\")\n, p_mq_BRESPchn(\"p_mq_BRESPchn\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver constructor' algorithm generated code\n\n\t//End of 'SendWAckDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sendwackdriver::~cfm_sendwackdriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver destructor' algorithm generated code\n\n\t//End of 'SendWAckDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_sendwackdriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver pre elaboration' algorithm generated code\n\n\t//End of 'SendWAckDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_sendwackdriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver post elaboration' algorithm generated code\n\n\t//End of 'SendWAckDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_sendwackdriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver post simulation' algorithm generated code\n\n\t//End of 'SendWAckDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_sendwackdriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_sendwackdriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver initializations' algorithm generated code\n\n\t//End of 'SendWAckDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReadDataDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_readdatadriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_READDATADRIVER\n#define COFS_MODEL_DDRMEMORY_READDATADRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_readdatadriver_dp_if.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defdataread.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDataDriver includes' algorithm generated code\n\n//End of 'ReadDataDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReadDataDriver Function ReadDataDriver\n//@{\n///        \\page dxpReadDataDriver\n//@{\n///    \\brief ReadDataDriver function model start\nclass cfm_readdatadriver: public cf_core::cf_function, public cfm_readdatadriver_dp_if {\npublic:\n\t/// cfm_readdatadriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdatadriver, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdatadriver, cft_defdataread> p_mq_DataRead_t;\n\t/// cfm_readdatadriver type define end\n\n\t/// constructor\n\tcfm_readdatadriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_readdatadriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tp_mq_DataRead_t p_mq_DataRead;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver local declarations' algorithm generated code\n\tfloat startTime;\n\tint ID;\n\tint burstLength;\n\tlong ReadDataInitDuration;\n\tint myIndex;\n\t//End of 'ReadDataDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReadDataDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_READDATADRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReadDataDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_readdatadriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_readdatadriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_readdatadriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDataDriver definitions' algorithm generated code\n\n//End of 'ReadDataDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_readdatadriver::cfm_readdatadriver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_readdatadriver_dp_if()\n, p_mq_RDATAchn(\"p_mq_RDATAchn\")\n, p_mq_DataRead(\"p_mq_DataRead\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver constructor' algorithm generated code\n\n\t//End of 'ReadDataDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_readdatadriver::~cfm_readdatadriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver destructor' algorithm generated code\n\n\t//End of 'ReadDataDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_readdatadriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver pre elaboration' algorithm generated code\n\n\t//End of 'ReadDataDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_readdatadriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver post elaboration' algorithm generated code\n\n\t//End of 'ReadDataDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_readdatadriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver post simulation' algorithm generated code\n\n\t//End of 'ReadDataDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_readdatadriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_readdatadriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver initializations' algorithm generated code\n\n\t//End of 'ReadDataDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CollectRequests', 'type': 'cofluent:Function', 'ports': [{'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_collectrequests\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n#define COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_collectrequests_dp_if.h\"\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CollectRequests includes' algorithm generated code\n\n//End of 'CollectRequests includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCollectRequests Function CollectRequests\n//@{\n///        \\page dxpCollectRequests\n//@{\n///    \\brief CollectRequests function model start\nclass cfm_collectrequests: public cf_core::cf_function, public cfm_collectrequests_dp_if {\npublic:\n\t/// cfm_collectrequests type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_collectrequests, cft_deflistrequestsptr> p_sv_ListRequestsPtr_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_collectrequests> p_ev_RequestCounter_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_collectrequests, cft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_collectrequests, cft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\t/// cfm_collectrequests type define end\n\n\t/// constructor\n\tcfm_collectrequests(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_collectrequests(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_ListRequestsPtr_t p_sv_ListRequestsPtr;\n\tp_ev_RequestCounter_t p_ev_RequestCounter;\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests local declarations' algorithm generated code\n\tDefListRequestsPtr currentRequestPtr;\n\tDefListRequestsPtr prevRequestPtr;\n\tint memID;\n\t//End of 'CollectRequests local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CollectRequests function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CollectRequests', 'type': 'cofluent:Function', 'ports': [{'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_collectrequests\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_collectrequests.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_collectrequests\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CollectRequests definitions' algorithm generated code\n\n//End of 'CollectRequests definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_collectrequests::cfm_collectrequests(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_collectrequests_dp_if()\n, p_sv_ListRequestsPtr(\"p_sv_ListRequestsPtr\")\n, p_ev_RequestCounter(\"p_ev_RequestCounter\")\n, p_mq_MemReadRequest(\"p_mq_MemReadRequest\")\n, p_mq_MemWriteRequest(\"p_mq_MemWriteRequest\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests constructor' algorithm generated code\n\n\t//End of 'CollectRequests constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_collectrequests::~cfm_collectrequests(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests destructor' algorithm generated code\n\n\t//End of 'CollectRequests destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_collectrequests::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests pre elaboration' algorithm generated code\n\n\t//End of 'CollectRequests pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_collectrequests::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests post elaboration' algorithm generated code\n\n\t//End of 'CollectRequests post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_collectrequests::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests post simulation' algorithm generated code\n\n\t//End of 'CollectRequests post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_collectrequests::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_collectrequests::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests initializations' algorithm generated code\n\n\t//End of 'CollectRequests initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ResponseForward', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequestInformation'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_responseforward\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n#define COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_responseforward_dp_if.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ResponseForward includes' algorithm generated code\n\n//End of 'ResponseForward includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgResponseForward Function ResponseForward\n//@{\n///        \\page dxpResponseForward\n//@{\n///    \\brief ResponseForward function model start\nclass cfm_responseforward: public cf_core::cf_function, public cfm_responseforward_dp_if {\npublic:\n\t/// cfm_responseforward type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward, cft_defrequestinformation> p_mq_RequestInformation_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward, cft_defdataread> p_mq_DataRead_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward, cft_defwriteack> p_mq_WriteAck_t;\n\t/// cfm_responseforward type define end\n\n\t/// constructor\n\tcfm_responseforward(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_responseforward(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tp_mq_RequestInformation_t p_mq_RequestInformation;\n\tp_mq_DataRead_t p_mq_DataRead;\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward local declarations' algorithm generated code\n\tbool IS_WRITE_ACK;\n\tbool IS_DATA_READ;\n\tint NbDataTransfer;\n\t// delay expected before data is available on dq signals\n\tint DqReadyDuration;\n\tbool NORMAL_ACK;\n\tbool SEND_NORMAL_ACK;\n\tlong PrepareResponseDuration;\n\tint BankAccessed;\n\tint RowAccessed;\n\tint ColumnAccessed;\n\tint NbMemRcvTransactions;\n\t// Table used to count the number data transfers already processed within a burst for each master and each command Write/Read\n\tint RemainingData[10][2];\n\tint ID;\n\tint Length;\n\tint Command;\n\t//End of 'ResponseForward local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ResponseForward function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ResponseForward', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequestInformation'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_responseforward\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_responseforward.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_responseforward\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ResponseForward definitions' algorithm generated code\n\n//End of 'ResponseForward definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_responseforward::cfm_responseforward(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_responseforward_dp_if()\n, p_mq_DQs(\"p_mq_DQs\")\n, p_mq_RequestInformation(\"p_mq_RequestInformation\")\n, p_mq_DataRead(\"p_mq_DataRead\")\n, p_mq_WriteAck(\"p_mq_WriteAck\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward constructor' algorithm generated code\n\n\t//End of 'ResponseForward constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_responseforward::~cfm_responseforward(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward destructor' algorithm generated code\n\n\t//End of 'ResponseForward destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_responseforward::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward pre elaboration' algorithm generated code\n\n\t//End of 'ResponseForward pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_responseforward::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward post elaboration' algorithm generated code\n\n\t//End of 'ResponseForward post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_responseforward::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward post simulation' algorithm generated code\n\n\t//End of 'ResponseForward post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_responseforward::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_responseforward::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward initializations' algorithm generated code\n\n\t//End of 'ResponseForward initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Arbitration', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequestInformation'}, {'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequests2Memory'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_arbitration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_ARBITRATION\n#define COFS_MODEL_DDRMEMORY_ARBITRATION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_arbitration_dp_if.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defrequests2memory.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Arbitration includes' algorithm generated code\n\n//End of 'Arbitration includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgArbitration Function Arbitration\n//@{\n///        \\page dxpArbitration\n//@{\n///    \\brief Arbitration function model start\nclass cfm_arbitration: public cf_core::cf_function, public cfm_arbitration_dp_if {\npublic:\n\t/// cfm_arbitration type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_arbitration, cft_defwriteack> p_mq_WriteAck_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_arbitration, cft_defrequestinformation> p_mq_RequestInformation_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_arbitration, cft_deflistrequestsptr> p_sv_ListRequestsPtr_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_arbitration, cft_defrequests2memory> p_mq_Requests2Memory_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_arbitration> p_ev_RequestCounter_t;\n\t/// cfm_arbitration type define end\n\n\t/// constructor\n\tcfm_arbitration(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_arbitration(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\tp_mq_RequestInformation_t p_mq_RequestInformation;\n\tp_sv_ListRequestsPtr_t p_sv_ListRequestsPtr;\n\tp_mq_Requests2Memory_t p_mq_Requests2Memory;\n\tp_ev_RequestCounter_t p_ev_RequestCounter;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration local declarations' algorithm generated code\n\tDefListRequestsPtr SelectedRequestPtr;\n\tDefListRequestsPtr CurrentRequestPtr;\n\tDefListRequestsPtr NextRequestPtr;\n\tint memID;\n\tint RemainingRequests;\n\tint BurstID;\n\tint RequestID;\n\tbool RequestIDerror;\n\tint NbRequestsCk;\n\tDefMemCmd CMDRef;\n\tDefMemCmd CMDCurrent;\n\tint NbMemoryTransactions;\n\tbool SendFastAck;\n\t//End of 'Arbitration local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Arbitration function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_ARBITRATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Arbitration', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequestInformation'}, {'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequests2Memory'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_arbitration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_arbitration.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_arbitration\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Arbitration definitions' algorithm generated code\n\n//End of 'Arbitration definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_arbitration::cfm_arbitration(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_arbitration_dp_if()\n, p_mq_WriteAck(\"p_mq_WriteAck\")\n, p_mq_RequestInformation(\"p_mq_RequestInformation\")\n, p_sv_ListRequestsPtr(\"p_sv_ListRequestsPtr\")\n, p_mq_Requests2Memory(\"p_mq_Requests2Memory\")\n, p_ev_RequestCounter(\"p_ev_RequestCounter\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration constructor' algorithm generated code\n\n\t//End of 'Arbitration constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_arbitration::~cfm_arbitration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration destructor' algorithm generated code\n\n\t//End of 'Arbitration destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_arbitration::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration pre elaboration' algorithm generated code\n\n\t//End of 'Arbitration pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_arbitration::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration post elaboration' algorithm generated code\n\n\t//End of 'Arbitration post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_arbitration::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration post simulation' algorithm generated code\n\n\t//End of 'Arbitration post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_arbitration::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_arbitration::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration initializations' algorithm generated code\n\n\t//End of 'Arbitration initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DDRCommandGeneration', 'type': 'cofluent:Function', 'ports': [{'name': 'MemoryStatus', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefMemoryStatus'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequests2Memory'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ddrcommandgeneration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n#define COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ddrcommandgeneration_dp_if.h\"\n#include \"dt/cft_defmemorystatus.h\"\n#include \"dt/cft_defrequests2memory.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRCommandGeneration includes' algorithm generated code\n\n//End of 'DDRCommandGeneration includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDDRCommandGeneration Function DDRCommandGeneration\n//@{\n///        \\page dxpDDRCommandGeneration\n//@{\n///    \\brief DDRCommandGeneration function model start\nclass cfm_ddrcommandgeneration: public cf_core::cf_function, public cfm_ddrcommandgeneration_dp_if {\npublic:\n\t/// cfm_ddrcommandgeneration type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_ddrcommandgeneration, cft_defmemorystatus> p_sv_MemoryStatus_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ddrcommandgeneration, cft_defrequests2memory> p_mq_Requests2Memory_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ddrcommandgeneration, cft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_ddrcommandgeneration type define end\n\n\t/// constructor\n\tcfm_ddrcommandgeneration(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ddrcommandgeneration(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_MemoryStatus_t p_sv_MemoryStatus;\n\tp_mq_Requests2Memory_t p_mq_Requests2Memory;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration local declarations' algorithm generated code\n\tint BankAccessed, RowAccessed, ColumnAccessed;\n\tbool NeedActive, NeedPrecharge;\n\tDefMemoryMode MemoryState;\n\tunsigned int memID;\n\t//End of 'DDRCommandGeneration local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief DDRCommandGeneration function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DDRCommandGeneration', 'type': 'cofluent:Function', 'ports': [{'name': 'MemoryStatus', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefMemoryStatus'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequests2Memory'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ddrcommandgeneration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ddrcommandgeneration.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ddrcommandgeneration\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRCommandGeneration definitions' algorithm generated code\n\n//End of 'DDRCommandGeneration definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ddrcommandgeneration::cfm_ddrcommandgeneration(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_ddrcommandgeneration_dp_if()\n, p_sv_MemoryStatus(\"p_sv_MemoryStatus\")\n, p_mq_Requests2Memory(\"p_mq_Requests2Memory\")\n, p_mq_DDRCommand(\"p_mq_DDRCommand\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration constructor' algorithm generated code\n\n\t//End of 'DDRCommandGeneration constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ddrcommandgeneration::~cfm_ddrcommandgeneration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration destructor' algorithm generated code\n\n\t//End of 'DDRCommandGeneration destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ddrcommandgeneration::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration pre elaboration' algorithm generated code\n\n\t//End of 'DDRCommandGeneration pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ddrcommandgeneration::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration post elaboration' algorithm generated code\n\n\t//End of 'DDRCommandGeneration post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ddrcommandgeneration::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration post simulation' algorithm generated code\n\n\t//End of 'DDRCommandGeneration post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ddrcommandgeneration::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ddrcommandgeneration::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration initializations' algorithm generated code\n\n\t//End of 'DDRCommandGeneration initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example3App', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'OS', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "/*!\n * \\class cfm_inheritance_example3app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP\n\n#include <vector>\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_os.h\"\n#include \"cfm_producer.h\"\n\n\n\nclass cfm_inheritance_example3app: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\n\tcfm_inheritance_example3app(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inheritance_example3app(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tstd::vector<cfm_consumer*> Consumer_vec;\n\tcfm_os* OS;\n\tstd::vector<cfm_producer*> Producer_vec;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tstd::vector<mq_MsgQ_t*> mq_MsgQ_vec;\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example3App', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'OS', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "/*\n * \\class cfm_inheritance_example3app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inheritance_example3app.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inheritance_example3app::cfm_inheritance_example3app(sc_core::sc_module_name name)\ncf_application(name)\n\n{\n\tcf_application::init();\n\tOS = new cfm_os\n\t(\"OS\");\n\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tcfm_consumer* module=new cfm_consumer(cf_string(\"Consumer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tConsumer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tcfm_producer* module=new cfm_producer(cf_string(\"Producer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tProducer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tmq_MsgQ_t* module=new mq_MsgQ_t(cf_string(\"MsgQ[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQ_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++) {\n\t\tcfm_consumer* module\n\t\t=Consumer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ\n\t\t\t\t(mq_MsgQ_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)2; i++) {\n\t\tcfm_producer* module\n\t\t=Producer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ\n\t\t\t\t(mq_MsgQ_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_inheritance_example3app::~cfm_inheritance_example3app(void) {\n\n\tfor (vector<cfm_consumer*>::const_iterator vi = Consumer_vec.begin(); vi != Consumer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_producer*>::const_iterator vi = Producer_vec.begin(); vi != Producer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQ_t*>::const_iterator vi = mq_MsgQ_vec.begin(); vi != mq_MsgQ_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete OS;\t///ddd\n}\n\nvoid cfm_inheritance_example3app::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inheritance_example3app::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inheritance_example3app::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inheritance_example3app::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\t(*mq_MsgQ_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_inheritance_example3app::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OS', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "/*!\n * \\class cfm_os\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n#include \"user_processor_base_class.h\"\n\nclass cfm_os: public cf_core::cf_function {\npublic:\n\n\n\tcfm_os(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_os(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tcf_core::cf_cp_selection<cf_core::cf_processor>* sel_processor;\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OS', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "/*\n * \\class cfm_os\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_os.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_os\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_os::cfm_os(sc_core::sc_module_name name)\ncf_function(name)\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_os::~cfm_os(void) {\n\tdelete sel_processor;\n}\n\nvoid cfm_os::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_os::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_os::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_os::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_os::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'datacenter', 'models': [{'name': 'ServerRoom', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'DataCenterSwitch', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQToDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}]}",
        "Response": [
            "/*!\n * \\class cfm_datacenter\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER\n#define COFS_MODEL_DATACENTER\n\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_datacenter_dp_if.h\"\n#include \"cfm_datacenterswitch.h\"\n#include \"cfm_serverroom.h\"\n#include \"dt/cft_defpacket.h\"\n\n#include <chrono>\n\nclass cfm_datacenter: public cf_core::cf_application, public cfm_datacenter_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToDataCenterSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToServerRoom_t;\n\n\n\tcfm_datacenter(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_datacenter(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_datacenterswitch* DataCenterSwitch;\n\tstd::vector<cfm_serverroom*> ServerRoom_vec;\n\npublic:\n\tcf_dt::cf_duration mq_MsgQToDataCenterSwitch_cb_send_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToDataCenterSwitch_cb_receive_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToServerRoom_cb_send_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToServerRoom_cb_receive_time(cf_core::cf_payload_b* _trans);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tstd::vector<mq_MsgQToDataCenterSwitch_t*> mq_MsgQToDataCenterSwitch_vec;\n\tstd::vector<mq_MsgQToServerRoom_t*> mq_MsgQToServerRoom_vec;\n\n\n\tstd::chrono::high_resolution_clock::time_point t_start;\n\n};\n\n#endif // COFS_MODEL_DATACENTER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'datacenter', 'models': [{'name': 'ServerRoom', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'DataCenterSwitch', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQToDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}]}",
        "Response": [
            "/*\n * \\class cfm_datacenter\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_datacenter.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\nvoid merge_and_sort_vector(std::vector<cf_dt::cf_time>& vect1, std::vector<cf_dt::cf_time>& vect2) {\n\tvect1.insert(vect1.begin(), vect2.begin(), vect2.end());\n}\n\ncfm_datacenter::cfm_datacenter(sc_core::sc_module_name name)\ncf_application(name)\n, cfm_datacenter_dp_if()\n\n{\n\tcf_application::init();\n\tDataCenterSwitch = new cfm_datacenterswitch\n\t(\"DataCenterSwitch\");\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++)\n\t{\n\t\tcfm_serverroom* module=new cfm_serverroom(cf_string(\"ServerRoom[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tServerRoom_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++)\n\t{\n\t\tmq_MsgQToDataCenterSwitch_t* module=new mq_MsgQToDataCenterSwitch_t(cf_string(\"MsgQToDataCenterSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQToDataCenterSwitch_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++)\n\t{\n\t\tmq_MsgQToServerRoom_t* module=new mq_MsgQToServerRoom_t(cf_string(\"MsgQToServerRoom[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQToServerRoom_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tfor (cf_count j = 0; j < (cf_count)DataCenterSwitch\n\t\t\t\t->p_mq_MsgQToDataCenterSwitch_vec.size(); j++)\n\t\t{\n\t\t\tcfm_datacenterswitch\n\t\t\t::p_mq_MsgQToDataCenterSwitch_t* port= DataCenterSwitch\n\t\t\t->p_mq_MsgQToDataCenterSwitch_vec[j]\n\t\t\t;\n\t\t\tif(port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToDataCenterSwitch_vec[i]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tfor (cf_count j = 0; j < (cf_count)DataCenterSwitch\n\t\t\t\t->p_mq_MsgQToServerRoom_vec.size(); j++)\n\t\t{\n\t\t\tcfm_datacenterswitch\n\t\t\t::p_mq_MsgQToServerRoom_t* port= DataCenterSwitch\n\t\t\t->p_mq_MsgQToServerRoom_vec[j]\n\t\t\t;\n\t\t\tif(port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToServerRoom_vec[i]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_serverroom* module\n\t\t=ServerRoom_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToDataCenterSwitch\n\t\t\t\t(mq_MsgQToDataCenterSwitch_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToServerRoom\n\t\t\t\t(mq_MsgQToServerRoom_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToDataCenterSwitch_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_send_time\n\t\t);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToDataCenterSwitch_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_receive_time\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToServerRoom_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_datacenter::mq_MsgQToServerRoom_cb_send_time\n\t\t);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToServerRoom_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_datacenter::mq_MsgQToServerRoom_cb_receive_time\n\t\t);\n\t}\n\n\tcf_application::elab_end();\n}\n\ncfm_datacenter::~cfm_datacenter(void) {\n\n\tfor (vector<cfm_serverroom*>::const_iterator vi = ServerRoom_vec.begin(); vi != ServerRoom_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToDataCenterSwitch_t*>::const_iterator vi = mq_MsgQToDataCenterSwitch_vec.begin(); vi != mq_MsgQToDataCenterSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToServerRoom_t*>::const_iterator vi = mq_MsgQToServerRoom_vec.begin(); vi != mq_MsgQToServerRoom_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete DataCenterSwitch;\t///ddd\n}\n\nvoid cfm_datacenter::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_datacenter::cb_end_of_elaboration(void) {\n\tt_start = std::chrono::high_resolution_clock::now();\n}\n\nvoid cfm_datacenter::cb_end_of_simulation(void) {\n#ifndef COF_LSS_CONTROLLER\n\tstd::chrono::high_resolution_clock::time_point t_end = std::chrono::high_resolution_clock::now();\n\tstd::chrono::duration<double> time_span = std::chrono::duration_cast < std::chrono::duration<double> > (t_end - t_start);\n\tcf_mon_ostream << \"Wall-clock simulation time: \" << time_span.count() << \" sec\" << cf_mon_endl;\n#endif\n\n\tstd::map<int, int> graph;\n\tfor (auto it : producer_exec_time) {\n\t\tint t = (int) it.to_scalar(CF_NS) / 100;\n\t\tauto s = graph.find(t);\n\t\tif (s != graph.end())\n\t\t\ts->second = s->second + 1;\n\t\telse\n\t\t\tgraph.insert(std::pair<int, int>(t, 1));\n\t}\n\n\tfor (auto it : graph) {\n\t\tcf_trace_gui_f_x(\"latency\", \"nb_func\", it.first, it.second);\n\t}\n\n\tcf_trace_report(\"Total number of transaction sent is %d\", total_requests_sent);\n\tcf_trace_report(\"Transaction number routed by ToR switches : %d\", nb_trans_routed_by_ToR_Switch);\n\tcf_trace_report(\"Transaction number routed by AGG switches : %d\", nb_trans_routed_by_AGG_Switch);\n\tcf_trace_report(\"Transaction number routed by Data Center switch : %d\", nb_trans_routed_by_Data_Center_Switch);\n\tcf_trace_report(\"Total number of transaction received is %d\", total_requests_received);\n\n#if defined(COF_LSS_CONTROLLER) || !defined(COF_LSS)\n\n\tcf_trace_report(\"Assert number of requests sent and received are the same.\");\n\tcf_assert((total_requests_sent == total_requests_received), \"Post-Simulation\", CF_ERROR_USER_ASSERT,\n\t\t\t\"The number of transactions received (%d) is not the same as the number of transactions sent (%d). \\nIncrease simulation time to get full simulation results.\",\n\t\t\ttotal_requests_received, total_requests_sent);\n\n\tcf_trace_report(\"Rate of outside server room transaction is %.2f \", ((float) nb_trans_routed_by_Data_Center_Switch / total_requests_received) * 100);\n\tcf_trace_report(\"Rate of outside rack transaction is %.2f \",\n\t\t\t((float) (nb_trans_routed_by_AGG_Switch - (nb_trans_routed_by_Data_Center_Switch)) / total_requests_received) * 100);\n\tcf_trace_report(\"simulation_duration %s\", simulation_duration.to_string());\n\tdata_center_switch_load = (data_center_switch_running_time.to_scalar(CF_MS) * 100) / simulation_duration.to_scalar(CF_MS);\n\tcf_trace_report(\"Data center switch load = %.2f%%\", data_center_switch_load);\n\tagg_switch_load = ((agg_switch_running_time.to_scalar(CF_MS) * 100) / simulation_duration.to_scalar(CF_MS)) / (dpServerRoomNb + 1);\n\tcf_trace_report(\"Agg switch average load = %.2f%%\", agg_switch_load);\n\ttor_switch_load = ((tor_switch_running_time.to_scalar(CF_MS) * 100) / simulation_duration.to_scalar(CF_MS)) / ((dpServerRoomNb + 1) * (dpRackNb + 1));\n\tcf_trace_report(\"ToR switch average load = %.2f%%\", tor_switch_load);\n\n\taverage_latency = total_latency / ((double) total_requests_received);\n\tcf_trace_report(\"Average latency = %.0f ns\", average_latency.to_scalar(CF_NS));\n\tintra_rack_average_latency = intra_rack_total_latency / ((double) intra_rack_total_requests_received);\n\tcf_trace_report(\"Intra rack requests average latency = %.0f ns\", intra_rack_average_latency.to_scalar(CF_NS));\n\tintra_server_room_average_latency = intra_server_room_total_latency / ((double) intra_server_room_total_requests_received);\n\tcf_trace_report(\"Intra server room requests average latency = %.0f ns\", intra_server_room_average_latency.to_scalar(CF_NS));\n\toutside_server_room_average_latency = outside_server_room_total_latency / ((double) outside_server_room_total_requests_received);\n\tcf_trace_report(\"Outside server room requests average latency = %.0f ns\", outside_server_room_average_latency.to_scalar(CF_NS));\n\n#endif\n}\n\nvoid cfm_datacenter::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_datacenter::cb_init_local_vars(void) {\n\n\tmin_waiting_time = 1000000000 / (dpTransactionRate + dpTransactionRateInterval);\n\tmax_waiting_time = 1000000000 / (dpTransactionRate - dpTransactionRateInterval);\n\n\tnb_trans_routed_by_ToR_Switch = 0;\n\tnb_trans_routed_by_AGG_Switch = 0;\n\tnb_trans_routed_by_Data_Center_Switch = 0;\n\n\ttotal_latency = cf_dt::cf_time(0, CF_SEC);\n\taverage_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_rack_total_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_rack_average_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);\n\toutside_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);\n\toutside_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);\n\n\t/*total_requests_sent = (dpServerRoomNb + 1) * (dpRackNb + 1)\n\t * (dpServerPerRackNb + 1) * dpNbTransPerServer;*/\n\ttotal_requests_received = 0;\n\tintra_rack_total_requests_received = 0;\n\tintra_server_room_total_requests_received = 0;\n\n\tsimulation_duration = cf_dt::cf_time(0, CF_SEC);\n\tdata_center_switch_running_time = cf_dt::cf_time(0, CF_SEC);\n\tdata_center_switch_load = 0;\n\tagg_switch_running_time = cf_dt::cf_time(0, CF_SEC);\n\tagg_switch_load = 0;\n\ttor_switch_running_time = cf_dt::cf_time(0, CF_SEC);\n\ttor_switch_load = 0;\n}\n\ncf_duration cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToDataCenterSwitch_trans, _trans);\n\treturn cf_expr_duration(dpServerRoomToDataCenterTime / 2, CF_NS);\n}\ncf_duration cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToDataCenterSwitch_trans, _trans);\n\treturn cf_expr_duration(dpServerRoomToDataCenterTime / 2, CF_NS);\n}\ncf_duration cfm_datacenter::mq_MsgQToServerRoom_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServerRoom_trans, _trans);\n\treturn cf_expr_duration(dpDataCenterToServerRoomTime / 2, CF_NS);\n}\ncf_duration cfm_datacenter::mq_MsgQToServerRoom_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServerRoom_trans, _trans);\n\treturn cf_expr_duration(dpDataCenterToServerRoomTime / 2, CF_NS);\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ServerRoom', 'type': 'cofluent:Function', 'models': [{'name': 'AGGSwitch', 'type': 'cofluent:Function'}, {'name': 'Rack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQToAggSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}, {'name': 'MsgQToRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_serverroom\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_SERVERROOM\n#define COFS_MODEL_DATACENTER_SERVERROOM\n\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_serverroom_dp_if.h\"\n#include \"cfm_aggswitch.h\"\n#include \"cfm_rack.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_serverroom: public cf_core::cf_function_container, public cfm_serverroom_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToAggSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToRack_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_serverroom, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_serverroom, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\n\tcfm_serverroom(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_serverroom(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\npublic:\n\tcfm_aggswitch* AGGSwitch;\n\tstd::vector<cfm_rack*> Rack_vec;\n\npublic:\n\tcf_dt::cf_duration mq_MsgQToAggSwitch_cb_send_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToAggSwitch_cb_receive_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToRack_cb_send_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToRack_cb_receive_time(cf_core::cf_payload_b* _trans);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tstd::vector<mq_MsgQToAggSwitch_t*> mq_MsgQToAggSwitch_vec;\n\tstd::vector<mq_MsgQToRack_t*> mq_MsgQToRack_vec;\n\n\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_SERVERROOM\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ServerRoom', 'type': 'cofluent:Function', 'models': [{'name': 'AGGSwitch', 'type': 'cofluent:Function'}, {'name': 'Rack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQToAggSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}, {'name': 'MsgQToRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_serverroom\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_serverroom.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenter\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_serverroom\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_serverroom::cfm_serverroom(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_serverroom_dp_if()\n, p_mq_MsgQToDataCenterSwitch(\"p_mq_MsgQToDataCenterSwitch\")\n, p_mq_MsgQToServerRoom(\"p_mq_MsgQToServerRoom\")\n\n{\n\tcf_function_container::init();\n\tAGGSwitch = new cfm_aggswitch\n\t(\"AGGSwitch\");\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++)\n\t{\n\t\tcfm_rack* module=new cfm_rack(cf_string(\"Rack[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tRack_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++)\n\t{\n\t\tmq_MsgQToAggSwitch_t* module=new mq_MsgQToAggSwitch_t(cf_string(\"MsgQToAggSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQToAggSwitch_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++)\n\t{\n\t\tmq_MsgQToRack_t* module=new mq_MsgQToRack_t(cf_string(\"MsgQToRack[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQToRack_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tfor (cf_count j = 0; j < (cf_count)AGGSwitch\n\t\t\t\t->p_mq_MsgQToAggSwitch_vec.size(); j++)\n\t\t{\n\t\t\tcfm_aggswitch\n\t\t\t::p_mq_MsgQToAggSwitch_t* port= AGGSwitch\n\t\t\t->p_mq_MsgQToAggSwitch_vec[j]\n\t\t\t;\n\t\t\tif(port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToAggSwitch_vec[i]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tfor (cf_count j = 0; j < (cf_count)AGGSwitch\n\t\t\t\t->p_mq_MsgQToRack_vec.size(); j++)\n\t\t{\n\t\t\tcfm_aggswitch\n\t\t\t::p_mq_MsgQToRack_t* port= AGGSwitch\n\t\t\t->p_mq_MsgQToRack_vec[j]\n\t\t\t;\n\t\t\tif(port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToRack_vec[i]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tAGGSwitch->p_mq_MsgQToServerRoom\n\t(p_mq_MsgQToServerRoom\n\t);\n\tAGGSwitch->p_mq_MsgQToDataCenterSwitch\n\t(p_mq_MsgQToDataCenterSwitch\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_rack* module\n\t\t=Rack_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToRack\n\t\t\t\t(mq_MsgQToRack_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToAggSwitch\n\t\t\t\t(mq_MsgQToAggSwitch_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToAggSwitch_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_serverroom::mq_MsgQToAggSwitch_cb_send_time\n\t\t);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToAggSwitch_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_serverroom::mq_MsgQToAggSwitch_cb_receive_time\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToRack_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_serverroom::mq_MsgQToRack_cb_send_time\n\t\t);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToRack_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_serverroom::mq_MsgQToRack_cb_receive_time\n\t\t);\n\t}\n\n\tcf_function_container::elab_end();\n}\n\ncfm_serverroom::~cfm_serverroom(void) {\n\n\tfor (vector<cfm_rack*>::const_iterator vi = Rack_vec.begin(); vi != Rack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToAggSwitch_t*>::const_iterator vi = mq_MsgQToAggSwitch_vec.begin(); vi != mq_MsgQToAggSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToRack_t*>::const_iterator vi = mq_MsgQToRack_vec.begin(); vi != mq_MsgQToRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete AGGSwitch;\t///ddd\n}\n\nvoid cfm_serverroom::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_serverroom::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_serverroom::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_serverroom::cb_init_attributes() {\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQToRack_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_serverroom::cb_init_local_vars(void) {\n\n\n}\n\ncf_duration cfm_serverroom::mq_MsgQToAggSwitch_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToAggSwitch_trans, _trans);\n\treturn cf_expr_duration(dpRackToSwitchTime / 2, CF_NS);\n}\ncf_duration cfm_serverroom::mq_MsgQToAggSwitch_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToAggSwitch_trans, _trans);\n\treturn cf_expr_duration(dpRackToSwitchTime / 2, CF_NS);\n}\ncf_duration cfm_serverroom::mq_MsgQToRack_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToRack_trans, _trans);\n\treturn cf_expr_duration(dpSwitchToRackTime / 2, CF_NS);\n}\ncf_duration cfm_serverroom::mq_MsgQToRack_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToRack_trans, _trans);\n\treturn cf_expr_duration(dpSwitchToRackTime / 2, CF_NS);\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DataCenterSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'Inbound', 'type': 'cofluent:Function'}, {'name': 'Outbound', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQRouting_out', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Outbound', 'RoutingFunction']}, {'name': 'MsgQRouting_in', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Inbound', 'RoutingFunction']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_datacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_DATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_DATACENTERSWITCH\n\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_datacenterswitch_dp_if.h\"\n#include \"cfm_datacenterswitch_routingfunction.h\"\n#include \"cfm_inbound.h\"\n#include \"cfm_outbound.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_datacenterswitch: public cf_core::cf_function_container, public cfm_datacenterswitch_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQRouting_in_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQRouting_out_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_datacenterswitch, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_datacenterswitch, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\n\tcfm_datacenterswitch(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_datacenterswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tstd::vector<p_mq_MsgQToDataCenterSwitch_t*> p_mq_MsgQToDataCenterSwitch_vec;\n\tstd::vector<p_mq_MsgQToServerRoom_t*> p_mq_MsgQToServerRoom_vec;\n\npublic:\n\tstd::vector<cfm_inbound*> Inbound_vec;\n\tstd::vector<cfm_outbound*> Outbound_vec;\n\tcfm_datacenterswitch_routingfunction* RoutingFunction;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tstd::vector<mq_MsgQRouting_in_t*> mq_MsgQRouting_in_vec;\n\tstd::vector<mq_MsgQRouting_out_t*> mq_MsgQRouting_out_vec;\n\n\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_DATACENTERSWITCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DataCenterSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'Inbound', 'type': 'cofluent:Function'}, {'name': 'Outbound', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQRouting_out', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Outbound', 'RoutingFunction']}, {'name': 'MsgQRouting_in', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Inbound', 'RoutingFunction']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_datacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_datacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenter\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_datacenterswitch\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_datacenterswitch::cfm_datacenterswitch(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_datacenterswitch_dp_if()\n\n{\n\tcf_function_container::init();\n\tRoutingFunction = new cfm_datacenterswitch_routingfunction\n\t(\"RoutingFunction\");\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++)\n\t{\n\t\tcfm_inbound* module=new cfm_inbound(cf_string(\"Inbound[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tInbound_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++)\n\t{\n\t\tcfm_outbound* module=new cfm_outbound(cf_string(\"Outbound[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tOutbound_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++)\n\t{\n\t\tmq_MsgQRouting_in_t* module=new mq_MsgQRouting_in_t(cf_string(\"MsgQRouting_in[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQRouting_in_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++)\n\t{\n\t\tmq_MsgQRouting_out_t* module=new mq_MsgQRouting_out_t(cf_string(\"MsgQRouting_out[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQRouting_out_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb+1); i++)\n\t{\n\t\tp_mq_MsgQToDataCenterSwitch_t* module=new p_mq_MsgQToDataCenterSwitch_t(cf_string(\"p_mq_MsgQToDataCenterSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_MsgQToDataCenterSwitch_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb+1); i++)\n\t{\n\t\tp_mq_MsgQToServerRoom_t* module=new p_mq_MsgQToServerRoom_t(cf_string(\"p_mq_MsgQToServerRoom[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_MsgQToServerRoom_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_inbound* module\n\t\t=Inbound_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQRouting_in\n\t\t\t\t(mq_MsgQRouting_in_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tmodule->p_mq_MsgQToDataCenterSwitch\n\t\t\t((*p_mq_MsgQToDataCenterSwitch_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_outbound* module\n\t\t=Outbound_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tmodule->p_mq_MsgQToServerRoom\n\t\t\t((*p_mq_MsgQToServerRoom_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQRouting_out\n\t\t\t\t(mq_MsgQRouting_out_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQRouting_in\n\t\t(mq_MsgQRouting_in_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQRouting_out\n\t\t(mq_MsgQRouting_out_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_datacenterswitch::~cfm_datacenterswitch(void) {\n\n\tfor (vector<cfm_inbound*>::const_iterator vi = Inbound_vec.begin(); vi != Inbound_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_outbound*>::const_iterator vi = Outbound_vec.begin(); vi != Outbound_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQRouting_in_t*>::const_iterator vi = mq_MsgQRouting_in_vec.begin(); vi != mq_MsgQRouting_in_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQRouting_out_t*>::const_iterator vi = mq_MsgQRouting_out_vec.begin(); vi != mq_MsgQRouting_out_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToDataCenterSwitch_t*>::const_iterator vi = p_mq_MsgQToDataCenterSwitch_vec.begin(); vi != p_mq_MsgQToDataCenterSwitch_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToServerRoom_t*>::const_iterator vi = p_mq_MsgQToServerRoom_vec.begin(); vi != p_mq_MsgQToServerRoom_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete RoutingFunction;\t///ddd\n}\n\nvoid cfm_datacenterswitch::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_datacenterswitch::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_datacenterswitch::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_datacenterswitch::cb_init_attributes() {\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpDataCenterSwitchPortBufferSize);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpDataCenterSwitchPortBufferSize);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_datacenterswitch::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'AGGSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundRack', 'type': 'cofluent:Function'}, {'name': 'OutboundRack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundDataCenterSwitch']}, {'name': 'MsgQOutboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundRack']}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundDataCenterSwitch']}, {'name': 'MsgQInboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundRack']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_aggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_AGGSWITCH\n#define COFS_MODEL_DATACENTER_AGGSWITCH\n\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_aggswitch_dp_if.h\"\n#include \"cfm_aggswitch_routingfunction.h\"\n#include \"cfm_inbounddatacenterswitch.h\"\n#include \"cfm_inboundrack.h\"\n#include \"cfm_outbounddatacenterswitch.h\"\n#include \"cfm_outboundrack.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_aggswitch: public cf_core::cf_function_container, public cfm_aggswitch_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundDataCenterSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundRack_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundDataCenterSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundRack_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\n\tcfm_aggswitch(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_aggswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tstd::vector<p_mq_MsgQToAggSwitch_t*> p_mq_MsgQToAggSwitch_vec;\n\tstd::vector<p_mq_MsgQToRack_t*> p_mq_MsgQToRack_vec;\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\npublic:\n\tcfm_inbounddatacenterswitch* InboundDataCenterSwitch;\n\tstd::vector<cfm_inboundrack*> InboundRack_vec;\n\tcfm_outbounddatacenterswitch* OutboundDataCenterSwitch;\n\tstd::vector<cfm_outboundrack*> OutboundRack_vec;\n\tcfm_aggswitch_routingfunction* RoutingFunction;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQInboundDataCenterSwitch_t mq_MsgQInboundDataCenterSwitch;\n\tstd::vector<mq_MsgQInboundRack_t*> mq_MsgQInboundRack_vec;\n\tmq_MsgQOutboundDataCenterSwitch_t mq_MsgQOutboundDataCenterSwitch;\n\tstd::vector<mq_MsgQOutboundRack_t*> mq_MsgQOutboundRack_vec;\n\n\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_AGGSWITCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'AGGSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundRack', 'type': 'cofluent:Function'}, {'name': 'OutboundRack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundDataCenterSwitch']}, {'name': 'MsgQOutboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundRack']}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundDataCenterSwitch']}, {'name': 'MsgQInboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundRack']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_aggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_aggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_serverroom\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_aggswitch\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_aggswitch::cfm_aggswitch(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_aggswitch_dp_if()\n, p_mq_MsgQToServerRoom(\"p_mq_MsgQToServerRoom\")\n, p_mq_MsgQToDataCenterSwitch(\"p_mq_MsgQToDataCenterSwitch\")\n, mq_MsgQInboundDataCenterSwitch(\"MsgQInboundDataCenterSwitch\"\n)\n, mq_MsgQOutboundDataCenterSwitch(\"MsgQOutboundDataCenterSwitch\"\n)\n\n{\n\tcf_function_container::init();\n\tInboundDataCenterSwitch = new cfm_inbounddatacenterswitch\n\t(\"InboundDataCenterSwitch\");\n\tOutboundDataCenterSwitch = new cfm_outbounddatacenterswitch\n\t(\"OutboundDataCenterSwitch\");\n\tRoutingFunction = new cfm_aggswitch_routingfunction\n\t(\"RoutingFunction\");\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++)\n\t{\n\t\tcfm_inboundrack* module=new cfm_inboundrack(cf_string(\"InboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tInboundRack_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++)\n\t{\n\t\tcfm_outboundrack* module=new cfm_outboundrack(cf_string(\"OutboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tOutboundRack_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++)\n\t{\n\t\tmq_MsgQInboundRack_t* module=new mq_MsgQInboundRack_t(cf_string(\"MsgQInboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQInboundRack_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++)\n\t{\n\t\tmq_MsgQOutboundRack_t* module=new mq_MsgQOutboundRack_t(cf_string(\"MsgQOutboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQOutboundRack_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb+1); i++)\n\t{\n\t\tp_mq_MsgQToAggSwitch_t* module=new p_mq_MsgQToAggSwitch_t(cf_string(\"p_mq_MsgQToAggSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_MsgQToAggSwitch_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb+1); i++)\n\t{\n\t\tp_mq_MsgQToRack_t* module=new p_mq_MsgQToRack_t(cf_string(\"p_mq_MsgQToRack[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_MsgQToRack_vec.push_back(module);\n\t}\n\tInboundDataCenterSwitch->p_mq_MsgQToServerRoom\n\t(p_mq_MsgQToServerRoom\n\t);\n\tInboundDataCenterSwitch->p_mq_MsgQInboundDataCenterSwitch\n\t(mq_MsgQInboundDataCenterSwitch\n\t\t\t.p_target_socket\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_inboundrack* module\n\t\t=InboundRack_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQInboundRack\n\t\t\t\t(mq_MsgQInboundRack_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tmodule->p_mq_MsgQToAggSwitch\n\t\t\t((*p_mq_MsgQToAggSwitch_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tOutboundDataCenterSwitch->p_mq_MsgQOutboundDataCenterSwitch\n\t(mq_MsgQOutboundDataCenterSwitch\n\t\t\t.p_target_socket\n\t);\n\tOutboundDataCenterSwitch->p_mq_MsgQToDataCenterSwitch\n\t(p_mq_MsgQToDataCenterSwitch\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_outboundrack* module\n\t\t=OutboundRack_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tmodule->p_mq_MsgQToRack\n\t\t\t((*p_mq_MsgQToRack_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQOutboundRack\n\t\t\t\t(mq_MsgQOutboundRack_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQInboundRack\n\t\t(mq_MsgQInboundRack_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQOutboundRack\n\t\t(mq_MsgQOutboundRack_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tRoutingFunction->p_mq_MsgQInboundDataCenterSwitch\n\t(mq_MsgQInboundDataCenterSwitch\n\t\t\t.p_target_socket\n\t);\n\tRoutingFunction->p_mq_MsgQOutboundDataCenterSwitch\n\t(mq_MsgQOutboundDataCenterSwitch\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_aggswitch::~cfm_aggswitch(void) {\n\n\tfor (vector<cfm_inboundrack*>::const_iterator vi = InboundRack_vec.begin(); vi != InboundRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_outboundrack*>::const_iterator vi = OutboundRack_vec.begin(); vi != OutboundRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQInboundRack_t*>::const_iterator vi = mq_MsgQInboundRack_vec.begin(); vi != mq_MsgQInboundRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQOutboundRack_t*>::const_iterator vi = mq_MsgQOutboundRack_vec.begin(); vi != mq_MsgQOutboundRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToAggSwitch_t*>::const_iterator vi = p_mq_MsgQToAggSwitch_vec.begin(); vi != p_mq_MsgQToAggSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToRack_t*>::const_iterator vi = p_mq_MsgQToRack_vec.begin(); vi != p_mq_MsgQToRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete InboundDataCenterSwitch;\t///ddd\n\tdelete OutboundDataCenterSwitch;\t///ddd\n\tdelete RoutingFunction;\t///ddd\n}\n\nvoid cfm_aggswitch::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_aggswitch::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_aggswitch::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_aggswitch::cb_init_attributes() {\n\n\tmq_MsgQInboundDataCenterSwitch.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundDataCenterSwitch.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundDataCenterSwitch.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQInboundDataCenterSwitch.cfa_queue_capacity.init((cf_nonzero_count) dpAggSwitchPortBufferSize);\n\tmq_MsgQInboundDataCenterSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQInboundDataCenterSwitch.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQInboundDataCenterSwitch.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpAggSwitchPortBufferSize);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\tmq_MsgQOutboundDataCenterSwitch.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundDataCenterSwitch.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundDataCenterSwitch.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_queue_capacity.init((cf_nonzero_count) dpAggSwitchPortBufferSize);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpAggSwitchPortBufferSize);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_aggswitch::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Rack', 'type': 'cofluent:Function', 'models': [{'name': 'Server', 'type': 'cofluent:Function'}, {'name': 'ToRSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQServerToToRSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}, {'name': 'MsgQToServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_rack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_RACK\n#define COFS_MODEL_DATACENTER_RACK\n\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rack_dp_if.h\"\n#include \"cfm_server.h\"\n#include \"cfm_torswitch.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_rack: public cf_core::cf_function_container, public cfm_rack_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQServerToToRSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToServer_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rack, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rack, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\n\tcfm_rack(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_rack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\npublic:\n\tstd::vector<cfm_server*> Server_vec;\n\tcfm_torswitch* ToRSwitch;\n\npublic:\n\tcf_dt::cf_duration mq_MsgQServerToToRSwitch_cb_receive_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToServer_cb_send_time(cf_core::cf_payload_b* _trans);\n\tcf_dt::cf_duration mq_MsgQToServer_cb_receive_time(cf_core::cf_payload_b* _trans);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tstd::vector<mq_MsgQServerToToRSwitch_t*> mq_MsgQServerToToRSwitch_vec;\n\tstd::vector<mq_MsgQToServer_t*> mq_MsgQToServer_vec;\n\n\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_RACK\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Rack', 'type': 'cofluent:Function', 'models': [{'name': 'Server', 'type': 'cofluent:Function'}, {'name': 'ToRSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQServerToToRSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}, {'name': 'MsgQToServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_rack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_rack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_serverroom\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rack\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_rack::cfm_rack(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_rack_dp_if()\n, p_mq_MsgQToRack(\"p_mq_MsgQToRack\")\n, p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\")\n\n{\n\tcf_function_container::init();\n\tToRSwitch = new cfm_torswitch\n\t(\"ToRSwitch\");\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++)\n\t{\n\t\tcfm_server* module=new cfm_server(cf_string(\"Server[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tServer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++)\n\t{\n\t\tmq_MsgQServerToToRSwitch_t* module=new mq_MsgQServerToToRSwitch_t(cf_string(\"MsgQServerToToRSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQServerToToRSwitch_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++)\n\t{\n\t\tmq_MsgQToServer_t* module=new mq_MsgQToServer_t(cf_string(\"MsgQToServer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQToServer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_server* module\n\t\t=Server_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQServerToToRSwitch\n\t\t\t\t(mq_MsgQServerToToRSwitch_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToServer\n\t\t\t\t(mq_MsgQToServer_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tToRSwitch->p_mq_MsgQToRack\n\t(p_mq_MsgQToRack\n\t);\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tfor (cf_count j = 0; j < (cf_count)ToRSwitch\n\t\t\t\t->p_mq_MsgQServerToToRSwitch_vec.size(); j++)\n\t\t{\n\t\t\tcfm_torswitch\n\t\t\t::p_mq_MsgQServerToToRSwitch_t* port= ToRSwitch\n\t\t\t->p_mq_MsgQServerToToRSwitch_vec[j]\n\t\t\t;\n\t\t\tif(port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQServerToToRSwitch_vec[i]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tfor (cf_count j = 0; j < (cf_count)ToRSwitch\n\t\t\t\t->p_mq_MsgQToServer_vec.size(); j++)\n\t\t{\n\t\t\tcfm_torswitch\n\t\t\t::p_mq_MsgQToServer_t* port= ToRSwitch\n\t\t\t->p_mq_MsgQToServer_vec[j]\n\t\t\t;\n\t\t\tif(port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToServer_vec[i]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tToRSwitch->p_mq_MsgQToAggSwitch\n\t(p_mq_MsgQToAggSwitch\n\t);\n\n\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQServerToToRSwitch_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_rack::mq_MsgQServerToToRSwitch_cb_receive_time\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToServer_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_rack::mq_MsgQToServer_cb_send_time\n\t\t);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToServer_vec[i]\n\t\t\t\t)\n\t\t\t\t, cfm_rack::mq_MsgQToServer_cb_receive_time\n\t\t);\n\t}\n\n\tcf_function_container::elab_end();\n}\n\ncfm_rack::~cfm_rack(void) {\n\n\tfor (vector<cfm_server*>::const_iterator vi = Server_vec.begin(); vi != Server_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQServerToToRSwitch_t*>::const_iterator vi = mq_MsgQServerToToRSwitch_vec.begin(); vi != mq_MsgQServerToToRSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToServer_t*>::const_iterator vi = mq_MsgQToServer_vec.begin(); vi != mq_MsgQToServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete ToRSwitch;\t///ddd\n}\n\nvoid cfm_rack::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_rack::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_rack::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_rack::cb_init_attributes() {\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpServerToToRSwitchBufferSize);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQToServer_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpToRSwitchToServerBufferSize);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_rack::cb_init_local_vars(void) {\n\n\n}\n\ncf_duration cfm_rack::mq_MsgQServerToToRSwitch_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQServerToToRSwitch_trans, _trans);\n\treturn cf_expr_duration(dpServerToToRSwitchTime, CF_NS);\n}\ncf_duration cfm_rack::mq_MsgQToServer_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServer_trans, _trans);\n\treturn cf_expr_duration(dpToRSwitchToServerTime / 2, CF_NS);\n}\ncf_duration cfm_rack::mq_MsgQToServer_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServer_trans, _trans);\n\treturn cf_expr_duration(dpToRSwitchToServerTime / 2, CF_NS);\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQRouting_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_inbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUND\n#define COFS_MODEL_DATACENTER_INBOUND\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inbound_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_inbound: public cf_core::cf_function, public cfm_inbound_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbound, cft_defpacket> p_mq_MsgQRouting_in_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbound, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\n\tcfm_inbound(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inbound(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQRouting_in_t p_mq_MsgQRouting_in;\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_INBOUND\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQRouting_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_inbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inbound.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenterswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inbound\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inbound::cfm_inbound(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_inbound_dp_if()\n, p_mq_MsgQRouting_in(\"p_mq_MsgQRouting_in\")\n, p_mq_MsgQToDataCenterSwitch(\"p_mq_MsgQToDataCenterSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_inbound::~cfm_inbound(void) {\n\n}\n\nvoid cfm_inbound::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inbound::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inbound::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inbound::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_inbound::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Outbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQRouting_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_outbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUND\n#define COFS_MODEL_DATACENTER_OUTBOUND\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outbound_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_outbound: public cf_core::cf_function, public cfm_outbound_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbound, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbound, cft_defpacket> p_mq_MsgQRouting_out_t;\n\n\tcfm_outbound(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_outbound(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\tp_mq_MsgQRouting_out_t p_mq_MsgQRouting_out;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\t/*int outIndex;*/\n\n};\n\n#endif // COFS_MODEL_DATACENTER_OUTBOUND\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Outbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQRouting_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_outbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_outbound.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenterswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outbound\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_outbound::cfm_outbound(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_outbound_dp_if()\n, p_mq_MsgQToServerRoom(\"p_mq_MsgQToServerRoom\")\n, p_mq_MsgQRouting_out(\"p_mq_MsgQRouting_out\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_outbound::~cfm_outbound(void) {\n\n}\n\nvoid cfm_outbound::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_outbound::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_outbound::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_outbound::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_outbound::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_outbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outbounddatacenterswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_outbounddatacenterswitch: public cf_core::cf_function, public cfm_outbounddatacenterswitch_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbounddatacenterswitch, cft_defpacket> p_mq_MsgQOutboundDataCenterSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbounddatacenterswitch, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\n\tcfm_outbounddatacenterswitch(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_outbounddatacenterswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQOutboundDataCenterSwitch_t p_mq_MsgQOutboundDataCenterSwitch;\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint server_room_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_outbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_outbounddatacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outbounddatacenterswitch\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_outbounddatacenterswitch::cfm_outbounddatacenterswitch(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_outbounddatacenterswitch_dp_if()\n, p_mq_MsgQOutboundDataCenterSwitch(\"p_mq_MsgQOutboundDataCenterSwitch\")\n, p_mq_MsgQToDataCenterSwitch(\"p_mq_MsgQToDataCenterSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_outbounddatacenterswitch::~cfm_outbounddatacenterswitch(void) {\n\n}\n\nvoid cfm_outbounddatacenterswitch::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_outbounddatacenterswitch::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_outbounddatacenterswitch::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_outbounddatacenterswitch::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_outbounddatacenterswitch::cb_init_local_vars(void) {\n\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_inbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inbounddatacenterswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_inbounddatacenterswitch: public cf_core::cf_function, public cfm_inbounddatacenterswitch_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbounddatacenterswitch, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbounddatacenterswitch, cft_defpacket> p_mq_MsgQInboundDataCenterSwitch_t;\n\n\tcfm_inbounddatacenterswitch(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inbounddatacenterswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\tp_mq_MsgQInboundDataCenterSwitch_t p_mq_MsgQInboundDataCenterSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint server_room_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_inbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inbounddatacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inbounddatacenterswitch\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inbounddatacenterswitch::cfm_inbounddatacenterswitch(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_inbounddatacenterswitch_dp_if()\n, p_mq_MsgQToServerRoom(\"p_mq_MsgQToServerRoom\")\n, p_mq_MsgQInboundDataCenterSwitch(\"p_mq_MsgQInboundDataCenterSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_inbounddatacenterswitch::~cfm_inbounddatacenterswitch(void) {\n\n}\n\nvoid cfm_inbounddatacenterswitch::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inbounddatacenterswitch::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inbounddatacenterswitch::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inbounddatacenterswitch::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_inbounddatacenterswitch::cb_init_local_vars(void) {\n\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_inboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDRACK\n#define COFS_MODEL_DATACENTER_INBOUNDRACK\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundrack_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_inboundrack: public cf_core::cf_function, public cfm_inboundrack_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundrack, cft_defpacket> p_mq_MsgQInboundRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundrack, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\n\tcfm_inboundrack(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inboundrack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQInboundRack_t p_mq_MsgQInboundRack;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint server_room_id;\n\tint rack_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_INBOUNDRACK\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_inboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inboundrack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundrack\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inboundrack::cfm_inboundrack(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_inboundrack_dp_if()\n, p_mq_MsgQInboundRack(\"p_mq_MsgQInboundRack\")\n, p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_inboundrack::~cfm_inboundrack(void) {\n\n}\n\nvoid cfm_inboundrack::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inboundrack::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inboundrack::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inboundrack::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_inboundrack::cb_init_local_vars(void) {\n\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n\track_id = get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_outboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDRACK\n#define COFS_MODEL_DATACENTER_OUTBOUNDRACK\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundrack_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_outboundrack: public cf_core::cf_function, public cfm_outboundrack_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundrack, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundrack, cft_defpacket> p_mq_MsgQOutboundRack_t;\n\n\tcfm_outboundrack(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_outboundrack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tp_mq_MsgQOutboundRack_t p_mq_MsgQOutboundRack;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint server_room_id;\n\tint rack_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDRACK\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_outboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_outboundrack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundrack\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_outboundrack::cfm_outboundrack(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_outboundrack_dp_if()\n, p_mq_MsgQToRack(\"p_mq_MsgQToRack\")\n, p_mq_MsgQOutboundRack(\"p_mq_MsgQOutboundRack\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_outboundrack::~cfm_outboundrack(void) {\n\n}\n\nvoid cfm_outboundrack::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_outboundrack::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_outboundrack::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_outboundrack::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_outboundrack::cb_init_local_vars(void) {\n\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n\track_id = get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Server', 'type': 'cofluent:Function', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_server\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_SERVER\n#define COFS_MODEL_DATACENTER_SERVER\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_server_dp_if.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_server: public cf_core::cf_function_container, public cfm_server_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_server, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_server, cft_defpacket> p_mq_MsgQToServer_t;\n\n\tcfm_server(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_server(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n\tp_mq_MsgQToServer_t p_mq_MsgQToServer;\n\npublic:\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_SERVER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Server', 'type': 'cofluent:Function', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_server\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_server.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_server\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_server::cfm_server(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_server_dp_if()\n, p_mq_MsgQServerToToRSwitch(\"p_mq_MsgQServerToToRSwitch\")\n, p_mq_MsgQToServer(\"p_mq_MsgQToServer\")\n\n{\n\tcf_function_container::init();\n\tConsumer = new cfm_consumer\n\t(\"Consumer\");\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\n\tConsumer->p_mq_MsgQToServer\n\t(p_mq_MsgQToServer\n\t);\n\n\tProducer->p_mq_MsgQServerToToRSwitch\n\t(p_mq_MsgQServerToToRSwitch\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_server::~cfm_server(void) {\n\n\tdelete Consumer;\t///ddd\n\tdelete Producer;\t///ddd\n}\n\nvoid cfm_server::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_server::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_server::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_server::cb_init_attributes() {\n\n\n\treturn;\n}\n\nvoid cfm_server::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ToRSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundServer', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundServer', 'type': 'cofluent:Function'}, {'name': 'InboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQInboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundAGGSwitch']}, {'name': 'MsgQInboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['InboundServer', 'RoutingFunction']}, {'name': 'MsgQOutboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundServer']}, {'name': 'MsgQOutboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundAGGSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_torswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_TORSWITCH\n#define COFS_MODEL_DATACENTER_TORSWITCH\n\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_torswitch_dp_if.h\"\n#include \"cfm_inboundaggswitch.h\"\n#include \"cfm_inboundserver.h\"\n#include \"cfm_outboundaggswitch.h\"\n#include \"cfm_outboundserver.h\"\n#include \"cfm_torswitch_routingfunction.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_torswitch: public cf_core::cf_function_container, public cfm_torswitch_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundAGGSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundServer_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundAGGSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundServer_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQToServer_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\n\tcfm_torswitch(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_torswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tstd::vector<p_mq_MsgQServerToToRSwitch_t*> p_mq_MsgQServerToToRSwitch_vec;\n\tstd::vector<p_mq_MsgQToServer_t*> p_mq_MsgQToServer_vec;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\npublic:\n\tcfm_inboundaggswitch* InboundAGGSwitch;\n\tstd::vector<cfm_inboundserver*> InboundServer_vec;\n\tcfm_outboundaggswitch* OutboundAGGSwitch;\n\tstd::vector<cfm_outboundserver*> OutboundServer_vec;\n\tcfm_torswitch_routingfunction* RoutingFunction;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQInboundAGGSwitch_t mq_MsgQInboundAGGSwitch;\n\tstd::vector<mq_MsgQInboundServer_t*> mq_MsgQInboundServer_vec;\n\tmq_MsgQOutboundAGGSwitch_t mq_MsgQOutboundAGGSwitch;\n\tstd::vector<mq_MsgQOutboundServer_t*> mq_MsgQOutboundServer_vec;\n\n\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_TORSWITCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ToRSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundServer', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundServer', 'type': 'cofluent:Function'}, {'name': 'InboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'relations': [{'name': 'MsgQInboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundAGGSwitch']}, {'name': 'MsgQInboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['InboundServer', 'RoutingFunction']}, {'name': 'MsgQOutboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundServer']}, {'name': 'MsgQOutboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundAGGSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_torswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_torswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_torswitch\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_torswitch::cfm_torswitch(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_torswitch_dp_if()\n, p_mq_MsgQToRack(\"p_mq_MsgQToRack\")\n, p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\")\n, mq_MsgQInboundAGGSwitch(\"MsgQInboundAGGSwitch\"\n)\n, mq_MsgQOutboundAGGSwitch(\"MsgQOutboundAGGSwitch\"\n)\n\n{\n\tcf_function_container::init();\n\tInboundAGGSwitch = new cfm_inboundaggswitch\n\t(\"InboundAGGSwitch\");\n\tOutboundAGGSwitch = new cfm_outboundaggswitch\n\t(\"OutboundAGGSwitch\");\n\tRoutingFunction = new cfm_torswitch_routingfunction\n\t(\"RoutingFunction\");\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++)\n\t{\n\t\tcfm_inboundserver* module=new cfm_inboundserver(cf_string(\"InboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tInboundServer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++)\n\t{\n\t\tcfm_outboundserver* module=new cfm_outboundserver(cf_string(\"OutboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tOutboundServer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++)\n\t{\n\t\tmq_MsgQInboundServer_t* module=new mq_MsgQInboundServer_t(cf_string(\"MsgQInboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQInboundServer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++)\n\t{\n\t\tmq_MsgQOutboundServer_t* module=new mq_MsgQOutboundServer_t(cf_string(\"MsgQOutboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQOutboundServer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb+1); i++)\n\t{\n\t\tp_mq_MsgQServerToToRSwitch_t* module=new p_mq_MsgQServerToToRSwitch_t(cf_string(\"p_mq_MsgQServerToToRSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_MsgQServerToToRSwitch_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb+1); i++)\n\t{\n\t\tp_mq_MsgQToServer_t* module=new p_mq_MsgQToServer_t(cf_string(\"p_mq_MsgQToServer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tp_mq_MsgQToServer_vec.push_back(module);\n\t}\n\tInboundAGGSwitch->p_mq_MsgQToRack\n\t(p_mq_MsgQToRack\n\t);\n\tInboundAGGSwitch->p_mq_MsgQInboundAGGSwitch\n\t(mq_MsgQInboundAGGSwitch\n\t\t\t.p_target_socket\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_inboundserver* module\n\t\t=InboundServer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQInboundServer\n\t\t\t\t(mq_MsgQInboundServer_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t\tmodule->p_mq_MsgQServerToToRSwitch\n\t\t\t((*p_mq_MsgQServerToToRSwitch_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tOutboundAGGSwitch->p_mq_MsgQOutboundAGGSwitch\n\t(mq_MsgQOutboundAGGSwitch\n\t\t\t.p_target_socket\n\t);\n\tOutboundAGGSwitch->p_mq_MsgQToAggSwitch\n\t(p_mq_MsgQToAggSwitch\n\t);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_outboundserver* module\n\t\t=OutboundServer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tmodule->p_mq_MsgQToServer\n\t\t\t((*p_mq_MsgQToServer_vec[\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQOutboundServer\n\t\t\t\t(mq_MsgQOutboundServer_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQInboundServer\n\t\t(mq_MsgQInboundServer_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQOutboundServer\n\t\t(mq_MsgQOutboundServer_vec[i]\n\t\t\t\t->p_target_socket\n\t\t);\n\t}\n\tRoutingFunction->p_mq_MsgQInboundAGGSwitch\n\t(mq_MsgQInboundAGGSwitch\n\t\t\t.p_target_socket\n\t);\n\tRoutingFunction->p_mq_MsgQOutboundAGGSwitch\n\t(mq_MsgQOutboundAGGSwitch\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_torswitch::~cfm_torswitch(void) {\n\n\tfor (vector<cfm_inboundserver*>::const_iterator vi = InboundServer_vec.begin(); vi != InboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_outboundserver*>::const_iterator vi = OutboundServer_vec.begin(); vi != OutboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQInboundServer_t*>::const_iterator vi = mq_MsgQInboundServer_vec.begin(); vi != mq_MsgQInboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQOutboundServer_t*>::const_iterator vi = mq_MsgQOutboundServer_vec.begin(); vi != mq_MsgQOutboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQServerToToRSwitch_t*>::const_iterator vi = p_mq_MsgQServerToToRSwitch_vec.begin(); vi != p_mq_MsgQServerToToRSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToServer_t*>::const_iterator vi = p_mq_MsgQToServer_vec.begin(); vi != p_mq_MsgQToServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete InboundAGGSwitch;\t///ddd\n\tdelete OutboundAGGSwitch;\t///ddd\n\tdelete RoutingFunction;\t///ddd\n}\n\nvoid cfm_torswitch::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_torswitch::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_torswitch::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_torswitch::cb_init_attributes() {\n\n\tmq_MsgQInboundAGGSwitch.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundAGGSwitch.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundAGGSwitch.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQInboundAGGSwitch.cfa_queue_capacity.init((cf_nonzero_count) dpToRSwitchPortBufferSize);\n\tmq_MsgQInboundAGGSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQInboundAGGSwitch.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQInboundAGGSwitch.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpToRSwitchPortBufferSize);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\tmq_MsgQOutboundAGGSwitch.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundAGGSwitch.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundAGGSwitch.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOutboundAGGSwitch.cfa_queue_capacity.init((cf_nonzero_count) dpToRSwitchPortBufferSize);\n\tmq_MsgQOutboundAGGSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOutboundAGGSwitch.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOutboundAGGSwitch.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) dpToRSwitchPortBufferSize);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_torswitch::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_PRODUCER\n#define COFS_MODEL_DATACENTER_PRODUCER\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function, public cfm_producer_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint server_room_id;\n\tint rack_id;\n\tint server_id;\n\tint local_transaction_count;\n\tint local_transaction_outside_rack_count;\n\tint local_transaction_outside_server_room_count;\n\tint waiting_time;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_server\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_producer_dp_if()\n, p_mq_MsgQServerToToRSwitch(\"p_mq_MsgQServerToToRSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\tserver_room_id = get_container()->get_container()->get_container()->get_cp_index();\n\track_id = get_container()->get_container()->get_cp_index();\n\tserver_id = get_container()->get_cp_index();\n\n\tlocal_transaction_count = 0;\n\tlocal_transaction_outside_rack_count = 0;\n\tlocal_transaction_outside_server_room_count = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_CONSUMER\n#define COFS_MODEL_DATACENTER_CONSUMER\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_consumer_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function, public cfm_consumer_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cft_defpacket> p_mq_MsgQToServer_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToServer_t p_mq_MsgQToServer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint server_room_id;\n\tint rack_id;\n\tint server_id;\n\n\tcf_dt::cf_time latency;\n\n\n};\n\n#endif // COFS_MODEL_DATACENTER_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_server\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_consumer_dp_if()\n, p_mq_MsgQToServer(\"p_mq_MsgQToServer\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\tserver_room_id = get_container()->get_container()->get_container()->get_cp_index();\n\track_id = get_container()->get_container()->get_cp_index();\n\tserver_id = get_container()->get_cp_index();\n\tlatency = cf_dt::cf_time(0, CF_SEC);\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_inboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDSERVER\n#define COFS_MODEL_DATACENTER_INBOUNDSERVER\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundserver_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_inboundserver: public cf_core::cf_function, public cfm_inboundserver_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundserver, cft_defpacket> p_mq_MsgQInboundServer_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundserver, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\n\tcfm_inboundserver(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inboundserver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQInboundServer_t p_mq_MsgQInboundServer;\n\tp_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint rack_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_INBOUNDSERVER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_inboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inboundserver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundserver\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inboundserver::cfm_inboundserver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_inboundserver_dp_if()\n, p_mq_MsgQInboundServer(\"p_mq_MsgQInboundServer\")\n, p_mq_MsgQServerToToRSwitch(\"p_mq_MsgQServerToToRSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_inboundserver::~cfm_inboundserver(void) {\n\n}\n\nvoid cfm_inboundserver::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inboundserver::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inboundserver::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inboundserver::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_inboundserver::cb_init_local_vars(void) {\n\n\track_id = get_container()->get_container()->get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_outboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n#define COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundserver_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_outboundserver: public cf_core::cf_function, public cfm_outboundserver_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundserver, cft_defpacket> p_mq_MsgQToServer_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundserver, cft_defpacket> p_mq_MsgQOutboundServer_t;\n\n\tcfm_outboundserver(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_outboundserver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToServer_t p_mq_MsgQToServer;\n\tp_mq_MsgQOutboundServer_t p_mq_MsgQOutboundServer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint rack_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_outboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_outboundserver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundserver\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_outboundserver::cfm_outboundserver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_outboundserver_dp_if()\n, p_mq_MsgQToServer(\"p_mq_MsgQToServer\")\n, p_mq_MsgQOutboundServer(\"p_mq_MsgQOutboundServer\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_outboundserver::~cfm_outboundserver(void) {\n\n}\n\nvoid cfm_outboundserver::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_outboundserver::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_outboundserver::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_outboundserver::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_outboundserver::cb_init_local_vars(void) {\n\n\track_id = get_container()->get_container()->get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_inboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n#define COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundaggswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_inboundaggswitch: public cf_core::cf_function, public cfm_inboundaggswitch_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundaggswitch, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundaggswitch, cft_defpacket> p_mq_MsgQInboundAGGSwitch_t;\n\n\tcfm_inboundaggswitch(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inboundaggswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tp_mq_MsgQInboundAGGSwitch_t p_mq_MsgQInboundAGGSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint rack_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_inboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inboundaggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundaggswitch\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inboundaggswitch::cfm_inboundaggswitch(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_inboundaggswitch_dp_if()\n, p_mq_MsgQToRack(\"p_mq_MsgQToRack\")\n, p_mq_MsgQInboundAGGSwitch(\"p_mq_MsgQInboundAGGSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_inboundaggswitch::~cfm_inboundaggswitch(void) {\n\n}\n\nvoid cfm_inboundaggswitch::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inboundaggswitch::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inboundaggswitch::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inboundaggswitch::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_inboundaggswitch::cb_init_local_vars(void) {\n\n\track_id = get_container()->get_container()->get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*!\n * \\class cfm_outboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n#define COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundaggswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_outboundaggswitch: public cf_core::cf_function, public cfm_outboundaggswitch_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundaggswitch, cft_defpacket> p_mq_MsgQOutboundAGGSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundaggswitch, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\n\tcfm_outboundaggswitch(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_outboundaggswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQOutboundAGGSwitch_t p_mq_MsgQOutboundAGGSwitch;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint rack_id;\n\n};\n\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "/*\n * \\class cfm_outboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_outboundaggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundaggswitch\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_outboundaggswitch::cfm_outboundaggswitch(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_outboundaggswitch_dp_if()\n, p_mq_MsgQOutboundAGGSwitch(\"p_mq_MsgQOutboundAGGSwitch\")\n, p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_outboundaggswitch::~cfm_outboundaggswitch(void) {\n\n}\n\nvoid cfm_outboundaggswitch::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_outboundaggswitch::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_outboundaggswitch::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_outboundaggswitch::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_outboundaggswitch::cb_init_local_vars(void) {\n\n\track_id = get_container()->get_container()->get_cp_index();\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationModel', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "/*!\n * \\class cfm_applicationmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL\n#define COFS_MODEL_APPLICATIONMODEL\n\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationmodel_dp_if.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_receiver.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n\n\n\nclass cfm_applicationmodel: public cf_core::cf_application, public cfm_applicationmodel_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defack> mq_Ack_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsg> mq_Msg_t;\n\n\n\tcfm_applicationmodel(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_applicationmodel(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_producer* Producer;\n\tcfm_receiver* Receiver;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_Ack_t mq_Ack;\n\tmq_Msg_t mq_Msg;\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODEL\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationModel', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "/*\n * \\class cfm_applicationmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_applicationmodel.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_applicationmodel::cfm_applicationmodel(sc_core::sc_module_name name)\ncf_application(name)\n, cfm_applicationmodel_dp_if()\n, mq_Ack(\"Ack\"\n)\n, mq_Msg(\"Msg\"\n)\n\n{\n\tcf_application::init();\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\tReceiver = new cfm_receiver\n\t(\"Receiver\");\n\n\tProducer->p_mq_Msg\n\t(mq_Msg\n\t\t\t.p_target_socket\n\t);\n\tProducer->p_mq_Ack\n\t(mq_Ack\n\t\t\t.p_target_socket\n\t);\n\n\tReceiver->p_mq_Ack\n\t(mq_Ack\n\t\t\t.p_target_socket\n\t);\n\tReceiver->p_mq_Msg\n\t(mq_Msg\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_applicationmodel::~cfm_applicationmodel(void) {\n\n\tdelete Producer;\t///ddd\n\tdelete Receiver;\t///ddd\n}\n\nvoid cfm_applicationmodel::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_applicationmodel::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_applicationmodel::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_applicationmodel::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_Ack.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Ack.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Msg.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_applicationmodel::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}], 'relations': [{'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Generator', 'Sender']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Generator', 'Sender']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_PRODUCER\n#define COFS_MODEL_APPLICATIONMODEL_PRODUCER\n\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n#include \"cfm_generator.h\"\n#include \"cfm_sender.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function_container, public cfm_producer_dp_if {\npublic:\n\ttypedef cf_core::cf_shared_variable<cft_defdatavar> sv_DataVar_t;\n\ttypedef cf_core::cf_event ev_Req_t;\n\ttypedef cf_core::cf_shared_variable<cft_deftestprod> sv_TestProd_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defack> p_mq_Ack_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\npublic:\n\tcfm_generator* Generator;\n\tcfm_sender* Sender;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tsv_DataVar_t sv_DataVar;\n\tev_Req_t ev_Req;\n\tsv_TestProd_t sv_TestProd;\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODEL_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}], 'relations': [{'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Generator', 'Sender']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Generator', 'Sender']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_producer_dp_if()\n, p_mq_Msg(\"p_mq_Msg\")\n, p_mq_Ack(\"p_mq_Ack\")\n, sv_DataVar(\"DataVar\"\n)\n, ev_Req(\"Req\"\n)\n, sv_TestProd(\"TestProd\"\n)\n\n{\n\tcf_function_container::init();\n\tGenerator = new cfm_generator\n\t(\"Generator\");\n\tSender = new cfm_sender\n\t(\"Sender\");\n\n\tGenerator->p_ev_Req\n\t(ev_Req\n\t\t\t.p_target_socket\n\t);\n\tGenerator->p_sv_DataVar\n\t(sv_DataVar\n\t\t\t.p_target_socket\n\t);\n\tGenerator->p_sv_TestProd\n\t(sv_TestProd\n\t\t\t.p_target_socket\n\t);\n\n\tSender->p_ev_Req\n\t(ev_Req\n\t\t\t.p_target_socket\n\t);\n\tSender->p_mq_Msg\n\t(p_mq_Msg\n\t);\n\tSender->p_mq_Ack\n\t(p_mq_Ack\n\t);\n\tSender->p_sv_DataVar\n\t(sv_DataVar\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n\tdelete Generator;\t///ddd\n\tdelete Sender;\t///ddd\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tsv_DataVar.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_semaphore.init(false);\n\tsv_DataVar.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_Req.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tsv_TestProd.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_semaphore.init(false);\n\tsv_TestProd.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*!\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_RECEIVER\n#define COFS_MODEL_APPLICATIONMODEL_RECEIVER\n\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiver_dp_if.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n\n\nclass cfm_receiver: public cf_core::cf_function, public cfm_receiver_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defmsg> p_mq_Msg_t;\n\n\tcfm_receiver(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_receiver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Ack_t p_mq_Ack;\n\tp_mq_Msg_t p_mq_Msg;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tDefValue noise;\n\tDefValue TestCons;\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODEL_RECEIVER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_receiver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiver\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_receiver::cfm_receiver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_receiver_dp_if()\n, p_mq_Ack(\"p_mq_Ack\")\n, p_mq_Msg(\"p_mq_Msg\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_receiver::~cfm_receiver(void) {\n\n}\n\nvoid cfm_receiver::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_receiver::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_receiver::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_receiver::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_receiver::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*!\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_GENERATOR\n#define COFS_MODEL_APPLICATIONMODEL_GENERATOR\n\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_generator_dp_if.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n\n\nclass cfm_generator: public cf_core::cf_function, public cfm_generator_dp_if {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_generator> p_ev_Req_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_defdatavar> p_sv_DataVar_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_deftestprod> p_sv_TestProd_t;\n\n\tcfm_generator(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_generator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_Req_t p_ev_Req;\n\tp_sv_DataVar_t p_sv_DataVar;\n\tp_sv_TestProd_t p_sv_TestProd;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODEL_GENERATOR\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_generator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_generator\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_generator::cfm_generator(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_generator_dp_if()\n, p_ev_Req(\"p_ev_Req\")\n, p_sv_DataVar(\"p_sv_DataVar\")\n, p_sv_TestProd(\"p_sv_TestProd\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_generator::~cfm_generator(void) {\n\n}\n\nvoid cfm_generator::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_generator::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_generator::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_generator::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_generator::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_SENDER\n#define COFS_MODEL_APPLICATIONMODEL_SENDER\n\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n\n\n\nclass cfm_sender: public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_sender> p_ev_Req_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_sender, cft_defdatavar> p_sv_DataVar_t;\n\n\tcfm_sender(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_sender(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_Req_t p_ev_Req;\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\tp_sv_DataVar_t p_sv_DataVar;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODEL_SENDER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_sender::cfm_sender(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_sender_dp_if()\n, p_ev_Req(\"p_ev_Req\")\n, p_mq_Msg(\"p_mq_Msg\")\n, p_mq_Ack(\"p_mq_Ack\")\n, p_sv_DataVar(\"p_sv_DataVar\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_sender::~cfm_sender(void) {\n\n}\n\nvoid cfm_sender::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_sender::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_sender::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_sender::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_sender::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationModelRefinement', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "/*!\n * \\class cfm_applicationmodelrefinement\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT\n\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationmodelrefinement_dp_if.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_receiver.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n\n\nclass cfm_applicationmodelrefinement: public cf_core::cf_application, public cfm_applicationmodelrefinement_dp_if {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defack> mq_Ack_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsg> mq_Msg_t;\n\n\n\tcfm_applicationmodelrefinement(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_applicationmodelrefinement(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_producer* Producer;\n\tcfm_receiver* Receiver;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_Ack_t mq_Ack;\n\tmq_Msg_t mq_Msg;\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationModelRefinement', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "/*\n * \\class cfm_applicationmodelrefinement\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_applicationmodelrefinement.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_applicationmodelrefinement::cfm_applicationmodelrefinement(sc_core::sc_module_name name)\ncf_application(name)\n, cfm_applicationmodelrefinement_dp_if()\n, mq_Ack(\"Ack\"\n)\n, mq_Msg(\"Msg\"\n)\n\n{\n\tcf_application::init();\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\tReceiver = new cfm_receiver\n\t(\"Receiver\");\n\n\tProducer->p_mq_Msg\n\t(mq_Msg\n\t\t\t.p_target_socket\n\t);\n\tProducer->p_mq_Ack\n\t(mq_Ack\n\t\t\t.p_target_socket\n\t);\n\n\tReceiver->p_mq_Ack\n\t(mq_Ack\n\t\t\t.p_target_socket\n\t);\n\tReceiver->p_mq_Msg\n\t(mq_Msg\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_applicationmodelrefinement::~cfm_applicationmodelrefinement(void) {\n\n\tdelete Producer;\t///ddd\n\tdelete Receiver;\t///ddd\n}\n\nvoid cfm_applicationmodelrefinement::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_applicationmodelrefinement::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_applicationmodelrefinement::cb_end_of_simulation(void) {\n\tif (TotalNbMsg != 0) {\n\t\tcf_trace_report(\"Total number of messages : %i\", TotalNbMsg);\n\t\tcf_trace_report(\"Average data size : %f bytes\", (float) TotalDataSize.to_scalar(CF_BYTE) / (float) TotalNbMsg);\n\t\tcf_trace_report(\"AverageLatency = %f ns\", (float) AverageLatency.to_scalar(CF_NS) / (float) TotalNbMsg);\n\t\tAverageThroughput = cf_dt::cf_throughput(TotalDataSize, AverageLatency);\n\t\tcf_trace_report(\"AverageThroughput = %f MBps\", (float) AverageThroughput.to_scalar(CF_MBYPS) / (float) TotalNbMsg);\n\t}\n\n\tcf_trace_gui_f_param(\"AverageLatency\", (float) AverageLatency.to_scalar(CF_NS) / (float) TotalNbMsg);\n\tcf_trace_gui_f_param(\"AverageThroughput\", (float) AverageThroughput.to_scalar(CF_MBYPS) / (float) TotalNbMsg);\n}\n\nvoid cfm_applicationmodelrefinement::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_Ack.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Ack.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Msg.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_applicationmodelrefinement::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'Generator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}], 'relations': [{'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Sender', 'Generator']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Sender', 'Generator']}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n#include \"cfm_generator.h\"\n#include \"cfm_sender.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_deftestprod.h\"\n#include \"dt/cft_defdatavar.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function_container, public cfm_producer_dp_if {\npublic:\n\ttypedef cf_core::cf_shared_variable<cft_defdatavar> sv_DataVar_t;\n\ttypedef cf_core::cf_event ev_Req_t;\n\ttypedef cf_core::cf_shared_variable<cft_deftestprod> sv_TestProd_t;\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defack> p_mq_Ack_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\npublic:\n\tcfm_generator* Generator;\n\tcfm_sender* Sender;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tsv_DataVar_t sv_DataVar;\n\tev_Req_t ev_Req;\n\tsv_TestProd_t sv_TestProd;\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'Generator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}], 'relations': [{'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Sender', 'Generator']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Sender', 'Generator']}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodelrefinement\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_producer_dp_if()\n, p_mq_Msg(\"p_mq_Msg\")\n, p_mq_Ack(\"p_mq_Ack\")\n, sv_DataVar(\"DataVar\"\n)\n, ev_Req(\"Req\"\n)\n, sv_TestProd(\"TestProd\"\n)\n\n{\n\tcf_function_container::init();\n\tGenerator = new cfm_generator\n\t(\"Generator\");\n\tSender = new cfm_sender\n\t(\"Sender\");\n\n\tGenerator->p_ev_Req\n\t(ev_Req\n\t\t\t.p_target_socket\n\t);\n\tGenerator->p_sv_DataVar\n\t(sv_DataVar\n\t\t\t.p_target_socket\n\t);\n\tGenerator->p_sv_TestProd\n\t(sv_TestProd\n\t\t\t.p_target_socket\n\t);\n\n\tSender->p_ev_Req\n\t(ev_Req\n\t\t\t.p_target_socket\n\t);\n\tSender->p_mq_Msg\n\t(p_mq_Msg\n\t);\n\tSender->p_mq_Ack\n\t(p_mq_Ack\n\t);\n\tSender->p_sv_DataVar\n\t(sv_DataVar\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n\tdelete Generator;\t///ddd\n\tdelete Sender;\t///ddd\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tsv_DataVar.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_semaphore.init(false);\n\tsv_DataVar.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_Req.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tsv_TestProd.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_semaphore.init(false);\n\tsv_TestProd.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*!\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiver_dp_if.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n\n\nclass cfm_receiver: public cf_core::cf_function, public cfm_receiver_dp_if {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defmsg> p_mq_Msg_t;\n\n\tcfm_receiver(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_receiver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_Ack_t p_mq_Ack;\n\tp_mq_Msg_t p_mq_Msg;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tDefValue noise;\n\tDefValue TestCons;\n\tint DecodeTime;\n\tint errorGen;\n\tbool Error; // OR branch condition\n\tcf_dt::cf_time Latency;\n\tcf_dt::cf_throughput Throughput;\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_receiver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodelrefinement\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiver\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_receiver::cfm_receiver(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_receiver_dp_if()\n, p_mq_Ack(\"p_mq_Ack\")\n, p_mq_Msg(\"p_mq_Msg\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_receiver::~cfm_receiver(void) {\n\n}\n\nvoid cfm_receiver::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_receiver::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_receiver::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_receiver::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_receiver::cb_init_local_vars(void) {\n\n\tDecodeTime = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n\n\n\nclass cfm_sender: public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_sender> p_ev_Req_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_sender, cft_defdatavar> p_sv_DataVar_t;\n\n\tcfm_sender(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_sender(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_Req_t p_ev_Req;\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\tp_sv_DataVar_t p_sv_DataVar;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint r;\n\tbool Resend;\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_sender::cfm_sender(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_sender_dp_if()\n, p_ev_Req(\"p_ev_Req\")\n, p_mq_Msg(\"p_mq_Msg\")\n, p_mq_Ack(\"p_mq_Ack\")\n, p_sv_DataVar(\"p_sv_DataVar\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_sender::~cfm_sender(void) {\n\n}\n\nvoid cfm_sender::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_sender::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_sender::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_sender::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_sender::cb_init_local_vars(void) {\n\n\tr = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*!\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_generator_dp_if.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n\n\nclass cfm_generator: public cf_core::cf_function, public cfm_generator_dp_if {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_generator> p_ev_Req_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_defdatavar> p_sv_DataVar_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_deftestprod> p_sv_TestProd_t;\n\n\tcfm_generator(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_generator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_Req_t p_ev_Req;\n\tp_sv_DataVar_t p_sv_DataVar;\n\tp_sv_TestProd_t p_sv_TestProd;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "/*\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_generator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_generator\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_generator::cfm_generator(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_generator_dp_if()\n, p_ev_Req(\"p_ev_Req\")\n, p_sv_DataVar(\"p_sv_DataVar\")\n, p_sv_TestProd(\"p_sv_TestProd\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_generator::~cfm_generator(void) {\n\n}\n\nvoid cfm_generator::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_generator::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_generator::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_generator::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_generator::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HybridSchedulingApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "/*!\n * \\class cfm_hybridschedulingapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP\n\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_controller.h\"\n#include \"cfm_producer.h\"\n\n\n\nclass cfm_hybridschedulingapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\n\tcfm_hybridschedulingapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_hybridschedulingapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_consumer* Consumer;\n\tcfm_controller* Controller;\n\tcfm_producer* Producer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQ_t mq_MsgQ;\n\n\n\n\n};\n\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HybridSchedulingApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "/*\n * \\class cfm_hybridschedulingapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_hybridschedulingapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_hybridschedulingapp::cfm_hybridschedulingapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_MsgQ(\"MsgQ\"\n)\n\n{\n\tcf_application::init();\n\tConsumer = new cfm_consumer\n\t(\"Consumer\");\n\tController = new cfm_controller\n\t(\"Controller\");\n\tProducer = new cfm_producer\n\t(\"Producer\");\n\n\tConsumer->p_mq_MsgQ\n\t(mq_MsgQ\n\t\t\t.p_target_socket\n\t);\n\n\tProducer->p_mq_MsgQ\n\t(mq_MsgQ\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_hybridschedulingapp::~cfm_hybridschedulingapp(void) {\n\n\tdelete Consumer;\t///ddd\n\tdelete Controller;\t///ddd\n\tdelete Producer;\t///ddd\n}\n\nvoid cfm_hybridschedulingapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_hybridschedulingapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_hybridschedulingapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_hybridschedulingapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_MsgQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_hybridschedulingapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "/*!\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_controller: public cf_core::cf_function {\npublic:\n\n\n\tcfm_controller(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_controller(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "/*\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_controller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_controller\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_controller::cfm_controller(sc_core::sc_module_name name)\ncf_function(name)\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_controller::~cfm_controller(void) {\n\n}\n\nvoid cfm_controller::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_controller::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_controller::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_controller::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_controller::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example2App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "/*!\n * \\class cfm_inheritance_example2app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP\n\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_f1.h\"\n#include \"cfm_f2.h\"\n\n\n\nclass cfm_inheritance_example2app: public cf_core::cf_application {\npublic:\n\n\n\tcfm_inheritance_example2app(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_inheritance_example2app(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_f1* F1;\n\tcfm_f2* F2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example2App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "/*\n * \\class cfm_inheritance_example2app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_inheritance_example2app.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_inheritance_example2app::cfm_inheritance_example2app(sc_core::sc_module_name name)\ncf_application(name)\n\n{\n\tcf_application::init();\n\tF1 = new cfm_f1\n\t(\"F1\");\n\tF2 = new cfm_f2\n\t(\"F2\");\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_inheritance_example2app::~cfm_inheritance_example2app(void) {\n\n\tdelete F1;\t///ddd\n\tdelete F2;\t///ddd\n}\n\nvoid cfm_inheritance_example2app::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_inheritance_example2app::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_inheritance_example2app::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_inheritance_example2app::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n\nvoid cfm_inheritance_example2app::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "/*!\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n\n/*Start of 'Inherited classes header' from F1's model property generated code*/\n#include \"camera_class.h\"\n/*End of 'Inherited classes header' from F1's model property generated code*/\nclass cfm_f1:\n/*Start of 'Inherited classes declaration' from F1's property generated code*/\npublic camera_class, public cf_core::cf_function\n/*End of 'Inherited classes declaration' from F1's property generated code*/\n{\npublic:\n\n\n\tcfm_f1(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_f1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "/*\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_f1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example2app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f1\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_f1::cfm_f1(sc_core::sc_module_name name)\n/*Start of 'Inherited classes call' from F1's model property generated code*/\ncamera_class(640,\n\t\t480),\ncf_function(name)\n/*End of 'Inherited classes call' from F1's model property generated code*/\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_f1::~cfm_f1(void) {\n\n}\n\nvoid cfm_f1::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_f1::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_f1::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_f1::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_f1::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_f2: public cf_core::cf_function {\npublic:\n\n\n\tcfm_f2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_f2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example2app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_f2::cfm_f2(sc_core::sc_module_name name)\ncf_function(name)\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_f2::~cfm_f2(void) {\n\n}\n\nvoid cfm_f2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_f2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_f2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_f2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_f2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CustomizedDispatcherApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "/*!\n * \\class cfm_customizeddispatcherapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n\n#include <vector>\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n\n\n\nclass cfm_customizeddispatcherapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\n\tcfm_customizeddispatcherapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_customizeddispatcherapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tstd::vector<cfm_consumer*> Consumer_vec;\n\tstd::vector<cfm_producer*> Producer_vec;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tstd::vector<mq_MsgQ_t*> mq_MsgQ_vec;\n\n\n\n\n};\n\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CustomizedDispatcherApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "/*\n * \\class cfm_customizeddispatcherapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_customizeddispatcherapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_customizeddispatcherapp::cfm_customizeddispatcherapp(sc_core::sc_module_name name)\ncf_application(name)\n\n{\n\tcf_application::init();\n\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tcfm_consumer* module=new cfm_consumer(cf_string(\"Consumer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tConsumer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tcfm_producer* module=new cfm_producer(cf_string(\"Producer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tProducer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tmq_MsgQ_t* module=new mq_MsgQ_t(cf_string(\"MsgQ[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tmq_MsgQ_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++) {\n\t\tcfm_consumer* module\n\t\t=Consumer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ\n\t\t\t\t(mq_MsgQ_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)2; i++) {\n\t\tcfm_producer* module\n\t\t=Producer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ\n\t\t\t\t(mq_MsgQ_vec[j]\n\t\t\t\t\t\t->p_target_socket\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_customizeddispatcherapp::~cfm_customizeddispatcherapp(void) {\n\n\tfor (vector<cfm_consumer*>::const_iterator vi = Consumer_vec.begin(); vi != Consumer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_producer*>::const_iterator vi = Producer_vec.begin(); vi != Producer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQ_t*>::const_iterator vi = mq_MsgQ_vec.begin(); vi != mq_MsgQ_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n}\n\nvoid cfm_customizeddispatcherapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_customizeddispatcherapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_customizeddispatcherapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_customizeddispatcherapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\t(*mq_MsgQ_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n\nvoid cfm_customizeddispatcherapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizeddispatcherapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizeddispatcherapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CustomizedSchedulerApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "/*!\n * \\class cfm_customizedschedulerapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n\n#include <vector>\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n\n\n\nclass cfm_customizedschedulerapp: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\n\tcfm_customizedschedulerapp(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_customizedschedulerapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tstd::vector<cfm_consumer*> Consumer_vec;\n\tstd::vector<cfm_producer*> Producer_vec;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_MsgQ_t mq_MsgQ;\n\n\n\n\n};\n\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CustomizedSchedulerApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "/*\n * \\class cfm_customizedschedulerapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_customizedschedulerapp.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_customizedschedulerapp::cfm_customizedschedulerapp(sc_core::sc_module_name name)\ncf_application(name)\n, mq_MsgQ(\"MsgQ\"\n)\n\n{\n\tcf_application::init();\n\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tcfm_consumer* module=new cfm_consumer(cf_string(\"Consumer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tConsumer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++)\n\t{\n\t\tcfm_producer* module=new cfm_producer(cf_string(\"Producer[%d]\", i).c_str());\n\t\tCF_ASSERT( module )\n\t\tProducer_vec.push_back(module);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)2; i++) {\n\t\tcfm_consumer* module\n\t\t=Consumer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tmodule->p_mq_MsgQ\n\t\t\t(mq_MsgQ\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)2; i++) {\n\t\tcfm_producer* module\n\t\t=Producer_vec[i];\n\t\tif(module\n\t\t\t\t!= nullptr) {\n\t\t\tmodule->p_mq_MsgQ\n\t\t\t(mq_MsgQ\n\t\t\t\t\t.p_target_socket\n\t\t\t);\n\t\t}\n\t}\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_customizedschedulerapp::~cfm_customizedschedulerapp(void) {\n\n\tfor (vector<cfm_consumer*>::const_iterator vi = Consumer_vec.begin(); vi != Consumer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_producer*>::const_iterator vi = Producer_vec.begin(); vi != Producer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n}\n\nvoid cfm_customizedschedulerapp::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_customizedschedulerapp::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_customizedschedulerapp::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_customizedschedulerapp::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_MsgQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_customizedschedulerapp::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_producer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizedschedulerapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_producer::cfm_producer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_producer::~cfm_producer(void) {\n\n}\n\nvoid cfm_producer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_producer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_producer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n\n\n\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cf_core::cf_payload_int> p_mq_MsgQ_t;\n\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizedschedulerapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_MsgQ(\"p_mq_MsgQ\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_consumer::~cfm_consumer(void) {\n\n}\n\nvoid cfm_consumer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_consumer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MyModel', 'models': [{'name': 'packet_in', 'type': 'cofluent:Function'}, {'name': 'packet_out', 'type': 'cofluent:Function'}, {'name': 'packet_process', 'type': 'cofluent:Function'}], 'relations': [{'name': 'p_in', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_in', 'packet_process']}, {'name': 'p_out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_out', 'packet_process']}]}",
        "Response": [
            "/*!\n * \\class cfm_mymodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL\n#define COFS_MODEL_MYMODEL\n\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_packet_in.h\"\n#include \"cfm_packet_out.h\"\n#include \"cfm_packet_process.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_mymodel: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_p_in_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_p_out_t;\n\n\n\tcfm_mymodel(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_mymodel(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_packet_in* packet_in;\n\tcfm_packet_out* packet_out;\n\tcfm_packet_process* packet_process;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_p_in_t mq_p_in;\n\tmq_p_out_t mq_p_out;\n\n\n\n\n};\n\n#endif // COFS_MODEL_MYMODEL\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MyModel', 'models': [{'name': 'packet_in', 'type': 'cofluent:Function'}, {'name': 'packet_out', 'type': 'cofluent:Function'}, {'name': 'packet_process', 'type': 'cofluent:Function'}], 'relations': [{'name': 'p_in', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_in', 'packet_process']}, {'name': 'p_out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_out', 'packet_process']}]}",
        "Response": [
            "/*\n * \\class cfm_mymodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_mymodel.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_mymodel::cfm_mymodel(sc_core::sc_module_name name)\ncf_application(name)\n, mq_p_in(\"p_in\"\n)\n, mq_p_out(\"p_out\"\n)\n\n{\n\tcf_application::init();\n\tpacket_in = new cfm_packet_in\n\t(\"packet_in\");\n\tpacket_out = new cfm_packet_out\n\t(\"packet_out\");\n\tpacket_process = new cfm_packet_process\n\t(\"packet_process\");\n\n\tpacket_in->p_mq_p_in\n\t(mq_p_in\n\t\t\t.p_target_socket\n\t);\n\n\tpacket_out->p_mq_p_out\n\t(mq_p_out\n\t\t\t.p_target_socket\n\t);\n\n\tpacket_process->p_mq_p_in\n\t(mq_p_in\n\t\t\t.p_target_socket\n\t);\n\tpacket_process->p_mq_p_out\n\t(mq_p_out\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_mymodel::~cfm_mymodel(void) {\n\n\tdelete packet_in;\t///ddd\n\tdelete packet_out;\t///ddd\n\tdelete packet_process;\t///ddd\n}\n\nvoid cfm_mymodel::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_mymodel::cb_end_of_elaboration(void) {\n\tcf_csl::cf_csl_init_socket_server(\"1250\");\n}\n\nvoid cfm_mymodel::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_mymodel::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_p_in.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_in.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_in.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_p_in.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_p_in.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_p_in.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_p_in.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_out.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_p_out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_mymodel::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_in', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "/*!\n * \\class cfm_packet_in\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_IN\n#define COFS_MODEL_MYMODEL_PACKET_IN\n\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_packet_in: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_in, cft_defpacket> p_mq_p_in_t;\n\n\tcfm_packet_in(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_packet_in(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_p_in_t p_mq_p_in;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tvoid my_callback();\n\tCSL_SYNC_EV_DECL\n\n};\n\n#endif // COFS_MODEL_MYMODEL_PACKET_IN\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_in', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "/*\n * \\class cfm_packet_in\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_packet_in.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_in\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\nvoid cfm_packet_in::my_callback() {\n\tCF_CSL_NOTIFY_SYNC_EV\n}\n\ncfm_packet_in::cfm_packet_in(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_p_in(\"p_mq_p_in\")\n\n{\n\tcf_function::init();\n\n\tCF_CSL_SET_SYNC_CB( cfm_packet_in::my_callback )\n\n\tcf_function::elab_end();\n}\n\ncfm_packet_in::~cfm_packet_in(void) {\n\n}\n\nvoid cfm_packet_in::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_packet_in::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_packet_in::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_packet_in::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_packet_in::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_out', 'type': 'cofluent:Function', 'ports': [{'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "/*!\n * \\class cfm_packet_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_OUT\n#define COFS_MODEL_MYMODEL_PACKET_OUT\n\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_packet_out: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_out, cft_defpacket> p_mq_p_out_t;\n\n\tcfm_packet_out(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_packet_out(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_p_out_t p_mq_p_out;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_MYMODEL_PACKET_OUT\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_out', 'type': 'cofluent:Function', 'ports': [{'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "/*\n * \\class cfm_packet_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_packet_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_out\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_packet_out::cfm_packet_out(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_p_out(\"p_mq_p_out\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_packet_out::~cfm_packet_out(void) {\n\n}\n\nvoid cfm_packet_out::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_packet_out::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_packet_out::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_packet_out::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_packet_out::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_process', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "/*!\n * \\class cfm_packet_process\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_PROCESS\n#define COFS_MODEL_MYMODEL_PACKET_PROCESS\n\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defpacket.h\"\n\n\n\nclass cfm_packet_process: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_process, cft_defpacket> p_mq_p_in_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_process, cft_defpacket> p_mq_p_out_t;\n\n\tcfm_packet_process(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_packet_process(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_p_in_t p_mq_p_in;\n\tp_mq_p_out_t p_mq_p_out;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_MYMODEL_PACKET_PROCESS\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_process', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "/*\n * \\class cfm_packet_process\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_packet_process.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_process\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_packet_process::cfm_packet_process(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_p_in(\"p_mq_p_in\")\n, p_mq_p_out(\"p_mq_p_out\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_packet_process::~cfm_packet_process(void) {\n\n}\n\nvoid cfm_packet_process::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_packet_process::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_packet_process::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_packet_process::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_packet_process::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TLM2AT', 'models': [{'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "/*!\n * \\class cfm_tlm2at\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT\n#define COFS_MODEL_TLM2AT\n\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"at_top.h\"\n#include \"cfm_reader.h\"\n#include \"cfm_target.h\"\n#include \"cfm_target_2.h\"\n#include \"cfm_writer.h\"\n#include \"wrappers/cfm_initiatorreader_tlm2_at_initiator.h\"\n#include \"wrappers/cfm_initiatorwriter_tlm2_at_initiator.h\"\n#include \"wrappers/cfm_targetrequest_tlm2_at_target.h\"\n#include \"wrappers/cfm_targetwrapper_tlm2_at_target.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_tlm2at: public cf_core::cf_application {\npublic:\n\ttypedef at_top TLM2Platfom_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorReader_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_ReaderResponse_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_event ev_Sync_t;\n\ttypedef cf_core::cf_event ev_Sync2_t;\n\ttypedef cf_core::cf_event ev_Sync3_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetRequest_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetResponse_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetWrapper_t;\n\n\n\tcfm_tlm2at(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_tlm2at(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_reader* Reader;\n\tTLM2Platfom_t* TLM2Platfom;\n\tcfm_target* Target;\n\tcfm_target_2* Target_2;\n\tcfm_writer* Writer;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_InitiatorReader_t mq_InitiatorReader;\n\tmq_InitiatorWriter_t mq_InitiatorWriter;\n\tmq_ReaderResponse_t mq_ReaderResponse;\n\tmq_ReferenceQueue_t mq_ReferenceQueue;\n\tmq_ReferenceQueue2_t mq_ReferenceQueue2;\n\tmq_ReferenceQueue3_t mq_ReferenceQueue3;\n\tev_Sync_t ev_Sync;\n\tev_Sync2_t ev_Sync2;\n\tev_Sync3_t ev_Sync3;\n\tmq_TargetRequest_t mq_TargetRequest;\n\tmq_TargetResponse_t mq_TargetResponse;\n\tmq_TargetWrapper_t mq_TargetWrapper;\n\nprotected:\n\tcfm_initiatorreader_tlm2_at_initiator initiatorreader_tlm2_at_initiator;\n\tcfm_initiatorwriter_tlm2_at_initiator initiatorwriter_tlm2_at_initiator;\n\tcfm_targetrequest_tlm2_at_target targetrequest_tlm2_at_target;\n\tcfm_targetwrapper_tlm2_at_target targetwrapper_tlm2_at_target;\n\n\n\n\n};\n\n#endif // COFS_MODEL_TLM2AT\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TLM2AT', 'models': [{'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "/*\n * \\class cfm_tlm2at\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_tlm2at.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_tlm2at::cfm_tlm2at(sc_core::sc_module_name name)\ncf_application(name)\n, mq_InitiatorReader(\"InitiatorReader\"\n)\n, mq_InitiatorWriter(\"InitiatorWriter\"\n)\n, mq_ReaderResponse(\"ReaderResponse\"\n)\n, mq_ReferenceQueue(\"ReferenceQueue\"\n)\n, mq_ReferenceQueue2(\"ReferenceQueue2\"\n)\n, mq_ReferenceQueue3(\"ReferenceQueue3\"\n)\n, ev_Sync(\"Sync\"\n)\n, ev_Sync2(\"Sync2\"\n)\n, ev_Sync3(\"Sync3\"\n)\n, mq_TargetRequest(\"TargetRequest\"\n)\n, mq_TargetResponse(\"TargetResponse\"\n)\n, mq_TargetWrapper(\"TargetWrapper\"\n)\n, initiatorreader_tlm2_at_initiator(\"initiatorreader_tlm2_at_initiator\")\n, initiatorwriter_tlm2_at_initiator(\"initiatorwriter_tlm2_at_initiator\")\n, targetrequest_tlm2_at_target(\"targetrequest_tlm2_at_target\")\n, targetwrapper_tlm2_at_target(\"targetwrapper_tlm2_at_target\")\n\n{\n\tcf_application::init();\n\tReader = new cfm_reader\n\t(\"Reader\");\n\tTLM2Platfom = new TLM2Platfom_t\n\t(\"TLM2Platfom\");\n\tTarget = new cfm_target\n\t(\"Target\");\n\tTarget_2 = new cfm_target_2\n\t(\"Target_2\");\n\tWriter = new cfm_writer\n\t(\"Writer\");\n\n\tReader->p_mq_ReferenceQueue3\n\t(mq_ReferenceQueue3\n\t\t\t.p_target_socket\n\t);\n\tReader->p_mq_InitiatorReader\n\t(mq_InitiatorReader\n\t\t\t.p_target_socket\n\t);\n\tReader->p_mq_ReaderResponse\n\t(mq_ReaderResponse\n\t\t\t.p_target_socket\n\t);\n\tReader->p_ev_Sync\n\t(ev_Sync\n\t\t\t.p_target_socket\n\t);\n\n\tinitiatorwriter_tlm2_at_initiator.p_tlm2\n\t(TLM2Platfom->interconnect->targ_socket);\n\tTLM2Platfom->interconnect->init_socket\n\t(targetwrapper_tlm2_at_target.p_tlm2\n\t);\n\tinitiatorreader_tlm2_at_initiator.p_tlm2\n\t(TLM2Platfom->interconnect->targ_socket);\n\tTLM2Platfom->interconnect->init_socket\n\t(targetrequest_tlm2_at_target.p_tlm2\n\t);\n\n\tTarget->p_mq_ReferenceQueue2\n\t(mq_ReferenceQueue2\n\t\t\t.p_target_socket\n\t);\n\tTarget->p_mq_TargetWrapper\n\t(mq_TargetWrapper\n\t\t\t.p_target_socket\n\t);\n\tTarget->p_ev_Sync2\n\t(ev_Sync2\n\t\t\t.p_target_socket\n\t);\n\n\tTarget_2->p_mq_TargetRequest\n\t(mq_TargetRequest\n\t\t\t.p_target_socket\n\t);\n\tTarget_2->p_mq_TargetResponse\n\t(mq_TargetResponse\n\t\t\t.p_target_socket\n\t);\n\tTarget_2->p_mq_ReferenceQueue\n\t(mq_ReferenceQueue\n\t\t\t.p_target_socket\n\t);\n\tTarget_2->p_ev_Sync3\n\t(ev_Sync3\n\t\t\t.p_target_socket\n\t);\n\n\tWriter->p_mq_ReferenceQueue\n\t(mq_ReferenceQueue\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_mq_InitiatorWriter\n\t(mq_InitiatorWriter\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_mq_ReferenceQueue2\n\t(mq_ReferenceQueue2\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_ev_Sync\n\t(ev_Sync\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_mq_ReferenceQueue3\n\t(mq_ReferenceQueue3\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_ev_Sync2\n\t(ev_Sync2\n\t\t\t.p_target_socket\n\t);\n\tWriter->p_ev_Sync3\n\t(ev_Sync3\n\t\t\t.p_target_socket\n\t);\n\n\tinitiatorreader_tlm2_at_initiator\n\t.p_mq_request(mq_InitiatorReader.p_target_socket);\n\tinitiatorreader_tlm2_at_initiator.p_mq_response(mq_ReaderResponse\n\t\t\t.p_target_socket);\n\tinitiatorwriter_tlm2_at_initiator\n\t.p_mq_request(mq_InitiatorWriter.p_target_socket);\n\ttargetrequest_tlm2_at_target\n\t.p_mq_request(mq_TargetRequest.p_target_socket);\n\ttargetrequest_tlm2_at_target.p_mq_response(mq_TargetResponse\n\t\t\t.p_target_socket);\n\ttargetwrapper_tlm2_at_target\n\t.p_mq_request(mq_TargetWrapper.p_target_socket);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_tlm2at::~cfm_tlm2at(void) {\n\n\tdelete Reader;\t///ddd\n\tdelete TLM2Platfom;\t///ddd\n\tdelete Target;\t///ddd\n\tdelete Target_2;\t///ddd\n\tdelete Writer;\t///ddd\n}\n\nvoid cfm_tlm2at::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_tlm2at::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_tlm2at::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_tlm2at::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tmq_InitiatorReader.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorReader.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorReader.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_InitiatorWriter.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorWriter.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorWriter.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReaderResponse.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReaderResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReaderResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue3.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tev_Sync.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync2.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync3.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tmq_TargetRequest.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetResponse.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetWrapper.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetWrapper.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetWrapper.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\n\treturn;\n}\n\nvoid cfm_tlm2at::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*!\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_WRITER\n#define COFS_MODEL_TLM2AT_WRITER\n\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_writer: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cf_core::cf_payload_tlm2> p_mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync2_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync3_t;\n\n\tcfm_writer(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_writer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_mq_InitiatorWriter_t p_mq_InitiatorWriter;\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_ev_Sync_t p_ev_Sync;\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_ev_Sync2_t p_ev_Sync2;\n\tp_ev_Sync3_t p_ev_Sync3;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint data;\n\tmy_ext ext;\n\n};\n\n#endif // COFS_MODEL_TLM2AT_WRITER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_writer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writer\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_writer::cfm_writer(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_ReferenceQueue(\"p_mq_ReferenceQueue\")\n, p_mq_InitiatorWriter(\"p_mq_InitiatorWriter\")\n, p_mq_ReferenceQueue2(\"p_mq_ReferenceQueue2\")\n, p_ev_Sync(\"p_ev_Sync\")\n, p_mq_ReferenceQueue3(\"p_mq_ReferenceQueue3\")\n, p_ev_Sync2(\"p_ev_Sync2\")\n, p_ev_Sync3(\"p_ev_Sync3\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_writer::~cfm_writer(void) {\n\n}\n\nvoid cfm_writer::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_writer::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_writer::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_writer::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_writer::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_TARGET\n#define COFS_MODEL_TLM2AT_TARGET\n\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_target: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cf_core::cf_payload_tlm2> p_mq_TargetWrapper_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target> p_ev_Sync2_t;\n\n\tcfm_target(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_target(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_mq_TargetWrapper_t p_mq_TargetWrapper;\n\tp_ev_Sync2_t p_ev_Sync2;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_TLM2AT_TARGET\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_target::cfm_target(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_ReferenceQueue2(\"p_mq_ReferenceQueue2\")\n, p_mq_TargetWrapper(\"p_mq_TargetWrapper\")\n, p_ev_Sync2(\"p_ev_Sync2\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_target::~cfm_target(void) {\n\n}\n\nvoid cfm_target::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_target::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_target::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_target::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_target::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*!\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_READER\n#define COFS_MODEL_TLM2AT_READER\n\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_reader: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_InitiatorReader_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_ReaderResponse_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_reader> p_ev_Sync_t;\n\n\tcfm_reader(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_reader(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_mq_InitiatorReader_t p_mq_InitiatorReader;\n\tp_mq_ReaderResponse_t p_mq_ReaderResponse;\n\tp_ev_Sync_t p_ev_Sync;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tint data;\n\n};\n\n#endif // COFS_MODEL_TLM2AT_READER\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_reader.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reader\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_reader::cfm_reader(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_ReferenceQueue3(\"p_mq_ReferenceQueue3\")\n, p_mq_InitiatorReader(\"p_mq_InitiatorReader\")\n, p_mq_ReaderResponse(\"p_mq_ReaderResponse\")\n, p_ev_Sync(\"p_ev_Sync\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_reader::~cfm_reader(void) {\n\n}\n\nvoid cfm_reader::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_reader::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_reader::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_reader::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_reader::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*!\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_TARGET_2\n#define COFS_MODEL_TLM2AT_TARGET_2\n\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n\n\nclass cfm_target_2: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cf_core::cf_payload_tlm2> p_mq_TargetRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cf_core::cf_payload_tlm2> p_mq_TargetResponse_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target_2> p_ev_Sync3_t;\n\n\tcfm_target_2(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_target_2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_TargetRequest_t p_mq_TargetRequest;\n\tp_mq_TargetResponse_t p_mq_TargetResponse;\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_ev_Sync3_t p_ev_Sync3;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_TLM2AT_TARGET_2\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "/*\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_target_2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target_2\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_target_2::cfm_target_2(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_TargetRequest(\"p_mq_TargetRequest\")\n, p_mq_TargetResponse(\"p_mq_TargetResponse\")\n, p_mq_ReferenceQueue(\"p_mq_ReferenceQueue\")\n, p_ev_Sync3(\"p_ev_Sync3\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_target_2::~cfm_target_2(void) {\n\n}\n\nvoid cfm_target_2::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_target_2::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_target_2::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_target_2::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_target_2::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HwDeviceModel', 'models': [{'name': 'hwDeviceTest', 'type': 'cofluent:Function'}], 'relations': [{'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}]}",
        "Response": [
            "/*!\n * \\class cfm_hwdevicemodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL\n#define COFS_MODEL_HWDEVICEMODEL\n\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_hwdevicetest.h\"\n#include \"dt/cft_defframe.h\"\n\n\n\nclass cfm_hwdevicemodel: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_inputStream_t;\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_outputStream_t;\n\n\n\tcfm_hwdevicemodel(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_hwdevicemodel(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_hwdevicetest* hwDeviceTest;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tsv_inputStream_t sv_inputStream;\n\tsv_outputStream_t sv_outputStream;\n\n\n\n\n};\n\n#endif // COFS_MODEL_HWDEVICEMODEL\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HwDeviceModel', 'models': [{'name': 'hwDeviceTest', 'type': 'cofluent:Function'}], 'relations': [{'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}]}",
        "Response": [
            "/*\n * \\class cfm_hwdevicemodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_hwdevicemodel.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_hwdevicemodel::cfm_hwdevicemodel(sc_core::sc_module_name name)\ncf_application(name)\n, sv_inputStream(\"inputStream\"\n)\n, sv_outputStream(\"outputStream\"\n)\n\n{\n\tcf_application::init();\n\thwDeviceTest = new cfm_hwdevicetest\n\t(\"hwDeviceTest\");\n\n\thwDeviceTest->p_sv_inputStream\n\t(sv_inputStream\n\t\t\t.p_target_socket\n\t);\n\thwDeviceTest->p_sv_outputStream\n\t(sv_outputStream\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_hwdevicemodel::~cfm_hwdevicemodel(void) {\n\n\tdelete hwDeviceTest;\t///ddd\n}\n\nvoid cfm_hwdevicemodel::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_hwdevicemodel::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_hwdevicemodel::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_hwdevicemodel::cb_init_attributes() {\n\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tsv_inputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_semaphore.init(false);\n\tsv_inputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\tsv_outputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_semaphore.init(false);\n\tsv_outputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_hwdevicemodel::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwDeviceTest', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'hwTestBench', 'type': 'cofluent:Function'}], 'ports': [{'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'hwTestBench']}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "/*!\n * \\class cfm_hwdevicetest\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n#define COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_hwmodel.h\"\n#include \"cfm_hwtestbench.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n\n\nclass cfm_hwdevicetest: public cf_core::cf_function_container {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_inputFrame_t;\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_outputFrame_t;\n\ttypedef cf_core::cf_shared_variable<cft_defprocessingmode> sv_processingMode_t;\n\ttypedef cf_core::cf_event ev_startProcess_t;\n\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwdevicetest, cft_defframe> p_sv_inputStream_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwdevicetest, cft_defframe> p_sv_outputStream_t;\n\n\tcfm_hwdevicetest(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_hwdevicetest(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_sv_inputStream_t p_sv_inputStream;\n\tp_sv_outputStream_t p_sv_outputStream;\n\npublic:\n\tcfm_hwmodel* hwModel;\n\tcfm_hwtestbench* hwTestBench;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_inputFrame_t mq_inputFrame;\n\tmq_outputFrame_t mq_outputFrame;\n\tsv_processingMode_t sv_processingMode;\n\tev_startProcess_t ev_startProcess;\n\n\n\n\n};\n\n#endif // COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwDeviceTest', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'hwTestBench', 'type': 'cofluent:Function'}], 'ports': [{'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'hwTestBench']}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "/*\n * \\class cfm_hwdevicetest\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_hwdevicetest.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicemodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwdevicetest\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_hwdevicetest::cfm_hwdevicetest(sc_core::sc_module_name name)\ncf_function_container(name)\n, p_sv_inputStream(\"p_sv_inputStream\")\n, p_sv_outputStream(\"p_sv_outputStream\")\n, mq_inputFrame(\"inputFrame\"\n)\n, mq_outputFrame(\"outputFrame\"\n)\n, sv_processingMode(\"processingMode\"\n)\n, ev_startProcess(\"startProcess\"\n)\n\n{\n\tcf_function_container::init();\n\thwModel = new cfm_hwmodel\n\t(\"hwModel\");\n\thwTestBench = new cfm_hwtestbench\n\t(\"hwTestBench\");\n\n\thwModel->p_ev_startProcess\n\t(ev_startProcess\n\t\t\t.p_target_socket\n\t);\n\thwModel->p_mq_inputFrame\n\t(mq_inputFrame\n\t\t\t.p_target_socket\n\t);\n\thwModel->p_mq_outputFrame\n\t(mq_outputFrame\n\t\t\t.p_target_socket\n\t);\n\thwModel->p_sv_processingMode\n\t(sv_processingMode\n\t\t\t.p_target_socket\n\t);\n\n\thwTestBench->p_ev_startProcess\n\t(ev_startProcess\n\t\t\t.p_target_socket\n\t);\n\thwTestBench->p_mq_inputFrame\n\t(mq_inputFrame\n\t\t\t.p_target_socket\n\t);\n\thwTestBench->p_sv_processingMode\n\t(sv_processingMode\n\t\t\t.p_target_socket\n\t);\n\thwTestBench->p_mq_outputFrame\n\t(mq_outputFrame\n\t\t\t.p_target_socket\n\t);\n\thwTestBench->p_sv_inputStream\n\t(p_sv_inputStream\n\t);\n\thwTestBench->p_sv_outputStream\n\t(p_sv_outputStream\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_hwdevicetest::~cfm_hwdevicetest(void) {\n\n\tdelete hwModel;\t///ddd\n\tdelete hwTestBench;\t///ddd\n}\n\nvoid cfm_hwdevicetest::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_hwdevicetest::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_hwdevicetest::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_hwdevicetest::cb_init_attributes() {\n\n\tmq_inputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_inputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_outputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tsv_processingMode.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_semaphore.init(false);\n\tsv_processingMode.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_startProcess.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n\nvoid cfm_hwdevicetest::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "/*!\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWMODEL\n#define COFS_MODEL_HWDEVICEMODEL_HWMODEL\n\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n\n\nclass cfm_hwmodel: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_hwmodel> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwmodel, cft_defprocessingmode> p_sv_processingMode_t;\n\n\tcfm_hwmodel(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_hwmodel(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tvoid revert_frame();\n\n};\n\n#endif // COFS_MODEL_HWDEVICEMODEL_HWMODEL\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "/*\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_hwmodel.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicetest\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwmodel\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\nvoid cfm_hwmodel::revert_frame() {\n\n\t/* Reverting the image means that Pixel 0 becomes Pixel N-1, where N is the frame size (in Pixels)\n\t * In YUV 422 format, it implies to:\n\t *   - Revert the Y table, located at offset 0\n\t *   - Revert the U table, located at offset N\n\t *   - Revert the V table, located at offset N*1.5\n\t */\n\tunsigned char* outpayload = outputFrame.payload;\n\tunsigned char* inpayload = inputFrame.payload;\n\n\tint offsetU = (int) (NbPixelsPerLineMax * NbLinesMax);\n\tint offsetV = (int) (NbPixelsPerLineMax * NbLinesMax * 1.5);\n\n\tint pixel_block_idx = 0;\n\n\tint line_idx;\n\n\tint current_block_ofs = 0;\n\n\tfor (line_idx = 0; line_idx < NbLinesMax; line_idx++) {\n\t\tfor (pixel_block_idx = 0; pixel_block_idx < NbPixelsPerLineMax / 4; pixel_block_idx++) {\n\n\t\t\toutpayload[offsetU - 1 - current_block_ofs] = inpayload[current_block_ofs + 0];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 1] = inpayload[current_block_ofs + 1];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 2] = inpayload[current_block_ofs + 2];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 3] = inpayload[current_block_ofs + 3];\n\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 0] = inpayload[offsetU + current_block_ofs / 2 + 0];\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 1] = inpayload[offsetU + current_block_ofs / 2 + 1];\n\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1 - current_block_ofs / 2 - 0] = inpayload[offsetV + current_block_ofs / 2 + 0];\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1 - current_block_ofs / 2 - 1] = inpayload[offsetV + current_block_ofs / 2 + 1];\n\n\t\t\tcurrent_block_ofs += 4;\n\n\t\t}\n\t}\n}\n\ncfm_hwmodel::cfm_hwmodel(sc_core::sc_module_name name)\ncf_function(name)\n, p_ev_startProcess(\"p_ev_startProcess\")\n, p_mq_inputFrame(\"p_mq_inputFrame\")\n, p_mq_outputFrame(\"p_mq_outputFrame\")\n, p_sv_processingMode(\"p_sv_processingMode\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_hwmodel::~cfm_hwmodel(void) {\n\n}\n\nvoid cfm_hwmodel::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_hwmodel::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_hwmodel::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_hwmodel::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_hwmodel::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwTestBench', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "/*!\n * \\class cfm_hwtestbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n#define COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n\n\nclass cfm_hwtestbench: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_hwtestbench> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwtestbench, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwtestbench, cft_defprocessingmode> p_sv_processingMode_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwtestbench, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwtestbench, cft_defframe> p_sv_inputStream_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwtestbench, cft_defframe> p_sv_outputStream_t;\n\n\tcfm_hwtestbench(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_hwtestbench(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tp_sv_inputStream_t p_sv_inputStream;\n\tp_sv_outputStream_t p_sv_outputStream;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tstd::string movieInputFile;\n\tint ProducerNbPicture;\n\tint ConsumerNbPicture;\n\tFILE* movieInputFile_f;\n\tint VideoFrameNumber;\n\tint numread;\n\n};\n\n#endif // COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwTestBench', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "/*\n * \\class cfm_hwtestbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_hwtestbench.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicetest\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwtestbench\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_hwtestbench::cfm_hwtestbench(sc_core::sc_module_name name)\ncf_function(name)\n, p_ev_startProcess(\"p_ev_startProcess\")\n, p_mq_inputFrame(\"p_mq_inputFrame\")\n, p_sv_processingMode(\"p_sv_processingMode\")\n, p_mq_outputFrame(\"p_mq_outputFrame\")\n, p_sv_inputStream(\"p_sv_inputStream\")\n, p_sv_outputStream(\"p_sv_outputStream\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_hwtestbench::~cfm_hwtestbench(void) {\n\n}\n\nvoid cfm_hwtestbench::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_hwtestbench::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_hwtestbench::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_hwtestbench::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_hwtestbench::cb_init_local_vars(void) {\n\n\tmovieInputFile = \"../../../video_file/susie422.40.qcif\";\n\tcf_trace_report(\"TEST file name = %s\", movieInputFile.c_str());\n\tProducerNbPicture = 0;\n\tConsumerNbPicture = 0;\n\tnumread = 0;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CompleteDevice', 'models': [{'name': 'device', 'type': 'cofluent:Function'}, {'name': 'testBench', 'type': 'cofluent:Function'}], 'relations': [{'name': 'dpv', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['device', 'testBench']}, {'name': 'newFrame', 'type': 'cofluent:Event', 'connectTo': ['device', 'testBench']}, {'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}]}",
        "Response": [
            "/*!\n * \\class cfm_completedevice\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE\n#define COFS_MODEL_COMPLETEDEVICE\n\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_device.h\"\n#include \"cfm_testbench.h\"\n#include \"dt/cft_defframe.h\"\n\n\n\nclass cfm_completedevice: public cf_core::cf_application {\npublic:\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_inputStream_t;\n\ttypedef cf_core::cf_event ev_newFrame_t;\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_outputStream_t;\n\n\n\tcfm_completedevice(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_completedevice(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\tcfm_device* device;\n\tcfm_testbench* testBench;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tsv_inputStream_t sv_inputStream;\n\tev_newFrame_t ev_newFrame;\n\tsv_outputStream_t sv_outputStream;\n\n\n\n\n};\n\n#endif // COFS_MODEL_COMPLETEDEVICE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CompleteDevice', 'models': [{'name': 'device', 'type': 'cofluent:Function'}, {'name': 'testBench', 'type': 'cofluent:Function'}], 'relations': [{'name': 'dpv', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['device', 'testBench']}, {'name': 'newFrame', 'type': 'cofluent:Event', 'connectTo': ['device', 'testBench']}, {'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}]}",
        "Response": [
            "/*\n * \\class cfm_completedevice\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_completedevice.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_completedevice::cfm_completedevice(sc_core::sc_module_name name)\ncf_application(name)\n, sv_inputStream(\"inputStream\"\n)\n, ev_newFrame(\"newFrame\"\n)\n, sv_outputStream(\"outputStream\"\n)\n\n{\n\tcf_application::init();\n\tdevice = new cfm_device\n\t(\"device\");\n\ttestBench = new cfm_testbench\n\t(\"testBench\");\n\n\tdevice->p_ev_newFrame\n\t(ev_newFrame\n\t\t\t.p_target_socket\n\t);\n\n\ttestBench\n\t->dpv(device\n\t\t\t->dpv\n\t);\n\ttestBench->p_ev_newFrame\n\t(ev_newFrame\n\t\t\t.p_target_socket\n\t);\n\ttestBench->p_sv_inputStream\n\t(sv_inputStream\n\t\t\t.p_target_socket\n\t);\n\ttestBench->p_sv_outputStream\n\t(sv_outputStream\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_application::elab_end();\n}\n\ncfm_completedevice::~cfm_completedevice(void) {\n\n\tdelete device;\t///ddd\n\tdelete testBench;\t///ddd\n}\n\nvoid cfm_completedevice::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_completedevice::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_completedevice::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_completedevice::cb_init_attributes() {\n\n\tsv_inputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_semaphore.init(false);\n\tsv_inputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_newFrame.cfa_set_time.init(cf_expr_duration(0, CF_NS));\n\tev_newFrame.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_newFrame.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tsv_outputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_semaphore.init(false);\n\tsv_outputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n\nvoid cfm_completedevice::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'device', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView'}, {'name': 'mqToCommand', 'type': 'cofluent:Function'}], 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT'}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'mqToCommand']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'storeFrame', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['swInterface', 'mqToCommand']}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*!\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_DEVICE\n#define COFS_MODEL_COMPLETEDEVICE_DEVICE\n\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_hwmodel.h\"\n#include \"cfm_mqtocommand.h\"\n#include \"cfm_swinterface.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n#include \"mci/cfm_dpv.h\"\n\n\nclass cfm_device: public cf_core::cf_function_container {\npublic:\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_inputFrame_t;\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_outputFrame_t;\n\ttypedef cf_core::cf_shared_variable<cft_defprocessingmode> sv_processingMode_t;\n\ttypedef cf_core::cf_event ev_startProcess_t;\n\n\ttypedef cf_core::cf_mci_port<cfm_dpv> dpv_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_device> p_ev_newFrame_t;\n\n\tcfm_device(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_device(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tdpv_t dpv;\n\tp_ev_newFrame_t p_ev_newFrame;\n\npublic:\n\tcfm_hwmodel* hwModel;\n\tcfm_mqtocommand* mqToCommand;\n\tcfm_swinterface* swInterface;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\npublic:\n\tmq_inputFrame_t mq_inputFrame;\n\tmq_outputFrame_t mq_outputFrame;\n\tsv_processingMode_t sv_processingMode;\n\tev_startProcess_t ev_startProcess;\n\n\n\n\n};\n\n#endif // COFS_MODEL_COMPLETEDEVICE_DEVICE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'device', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView'}, {'name': 'mqToCommand', 'type': 'cofluent:Function'}], 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT'}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'mqToCommand']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'storeFrame', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['swInterface', 'mqToCommand']}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_device.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_completedevice\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_device\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_device::cfm_device(sc_core::sc_module_name name)\ncf_function_container(name)\n, dpv(\"dpv\")\n, p_ev_newFrame(\"p_ev_newFrame\")\n, mq_inputFrame(\"inputFrame\"\n)\n, mq_outputFrame(\"outputFrame\"\n)\n, sv_processingMode(\"processingMode\"\n)\n, ev_startProcess(\"startProcess\"\n)\n\n{\n\tcf_function_container::init();\n\thwModel = new cfm_hwmodel\n\t(\"hwModel\");\n\tmqToCommand = new cfm_mqtocommand\n\t(\"mqToCommand\");\n\tswInterface = new cfm_swinterface\n\t(\"swInterface\");\n\n\thwModel->p_ev_startProcess\n\t(ev_startProcess\n\t\t\t.p_target_socket\n\t);\n\thwModel->p_mq_inputFrame\n\t(mq_inputFrame\n\t\t\t.p_target_socket\n\t);\n\thwModel->p_mq_outputFrame\n\t(mq_outputFrame\n\t\t\t.p_target_socket\n\t);\n\thwModel->p_sv_processingMode\n\t(sv_processingMode\n\t\t\t.p_target_socket\n\t);\n\n\tmqToCommand->p_mq_outputFrame\n\t(mq_outputFrame\n\t\t\t.p_target_socket\n\t);\n\tmqToCommand\n\t->storeFrame(*swInterface\n\t);\n\n\tswInterface->p_ev_startProcess\n\t(ev_startProcess\n\t\t\t.p_target_socket\n\t);\n\tdpv(*swInterface);\n\tswInterface->p_mq_inputFrame\n\t(mq_inputFrame\n\t\t\t.p_target_socket\n\t);\n\tswInterface->p_ev_newFrame\n\t(p_ev_newFrame\n\t);\n\tswInterface->p_sv_processingMode\n\t(sv_processingMode\n\t\t\t.p_target_socket\n\t);\n\n\n\n\tcf_function_container::elab_end();\n}\n\ncfm_device::~cfm_device(void) {\n\n\tdelete hwModel;\t///ddd\n\tdelete mqToCommand;\t///ddd\n\tdelete swInterface;\t///ddd\n}\n\nvoid cfm_device::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_device::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_device::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_device::cb_init_attributes() {\n\n\tmq_inputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_inputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_outputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tsv_processingMode.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_semaphore.init(false);\n\tsv_processingMode.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_startProcess.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n\nvoid cfm_device::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'testBench', 'type': 'cofluent:Function', 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*!\n * \\class cfm_testbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_TESTBENCH\n#define COFS_MODEL_COMPLETEDEVICE_TESTBENCH\n\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n\n#include \"mci/cfm_dpv.h\"\n\n\nclass cfm_testbench: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mci_port<cfm_dpv> dpv_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_testbench> p_ev_newFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_testbench, cft_defframe> p_sv_inputStream_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_testbench, cft_defframe> p_sv_outputStream_t;\n\n\tcfm_testbench(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_testbench(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tdpv_t dpv;\n\tp_ev_newFrame_t p_ev_newFrame;\n\tp_sv_inputStream_t p_sv_inputStream;\n\tp_sv_outputStream_t p_sv_outputStream;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\t/* Register address definition */\n#define PROCESSED_FRAME_COUNT_REGISTER_ADDR 0x200\n#define PROCESSING_MODE_REGISTER_ADDR 0x100\n\n\tDefFrame inputFrame, outputFrame;\n\tstd::string movieInputFile;\n\tint ProducerNbPicture;\n\tint ConsumerNbPicture;\n\tFILE* movieInputFile_f;\n\tint VideoFrameNumber;\n\tint new_mode;\n\tint numread;\n\n};\n\n#endif // COFS_MODEL_COMPLETEDEVICE_TESTBENCH\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'testBench', 'type': 'cofluent:Function', 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*\n * \\class cfm_testbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_testbench.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_completedevice\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_testbench\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_testbench::cfm_testbench(sc_core::sc_module_name name)\ncf_function(name)\n, dpv(\"dpv\")\n, p_ev_newFrame(\"p_ev_newFrame\")\n, p_sv_inputStream(\"p_sv_inputStream\")\n, p_sv_outputStream(\"p_sv_outputStream\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_testbench::~cfm_testbench(void) {\n\n}\n\nvoid cfm_testbench::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_testbench::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_testbench::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_testbench::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_testbench::cb_init_local_vars(void) {\n\n\tmovieInputFile = \"../../../video_file/susie422.40.qcif\";\n\tcf_trace_report(\"TEST file name = %s\", movieInputFile.c_str());\n\tProducerNbPicture = 0;\n\tConsumerNbPicture = 0;\n\tnew_mode = REVERT_MODE;\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*!\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_HWMODEL\n#define COFS_MODEL_COMPLETEDEVICE_HWMODEL\n\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n\n\nclass cfm_hwmodel: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_hwmodel> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwmodel, cft_defprocessingmode> p_sv_processingMode_t;\n\n\tcfm_hwmodel(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_hwmodel(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tvoid revert_frame();\n\n};\n\n#endif // COFS_MODEL_COMPLETEDEVICE_HWMODEL\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_hwmodel.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwmodel\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\nvoid cfm_hwmodel::revert_frame() {\n\n\t/* Reverting the image means that Pixel 0 becomes Pixel N-1, where N is the frame size (in Pixels)\n\t * In YUV 422 format, it implies to:\n\t *   - Revert the Y table, located at offset 0\n\t *   - Revert the U table, located at offset N\n\t *   - Revert the V table, located at offset N*1.5\n\t */\n\tunsigned char* outpayload = outputFrame.payload;\n\tunsigned char* inpayload = inputFrame.payload;\n\n\tint offsetU = (int) (NbPixelsPerLineMax * NbLinesMax);\n\tint offsetV = (int) (NbPixelsPerLineMax * NbLinesMax * 1.5);\n\n\tint pixel_block_idx = 0;\n\n\tint line_idx;\n\n\tint current_block_ofs = 0;\n\n\tfor (line_idx = 0; line_idx < NbLinesMax; line_idx++) {\n\t\tfor (pixel_block_idx = 0; pixel_block_idx < NbPixelsPerLineMax / 4; pixel_block_idx++) {\n\n\t\t\toutpayload[offsetU - 1 - current_block_ofs] = inpayload[current_block_ofs + 0];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 1] = inpayload[current_block_ofs + 1];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 2] = inpayload[current_block_ofs + 2];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 3] = inpayload[current_block_ofs + 3];\n\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 0] = inpayload[offsetU + current_block_ofs / 2 + 0];\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 1] = inpayload[offsetU + current_block_ofs / 2 + 1];\n\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1 - current_block_ofs / 2 - 0] = inpayload[offsetV + current_block_ofs / 2 + 0];\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1 - current_block_ofs / 2 - 1] = inpayload[offsetV + current_block_ofs / 2 + 1];\n\n\t\t\tcurrent_block_ofs += 4;\n\n\t\t}\n\t}\n}\n\ncfm_hwmodel::cfm_hwmodel(sc_core::sc_module_name name)\ncf_function(name)\n, p_ev_startProcess(\"p_ev_startProcess\")\n, p_mq_inputFrame(\"p_mq_inputFrame\")\n, p_mq_outputFrame(\"p_mq_outputFrame\")\n, p_sv_processingMode(\"p_sv_processingMode\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_hwmodel::~cfm_hwmodel(void) {\n\n}\n\nvoid cfm_hwmodel::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_hwmodel::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_hwmodel::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_hwmodel::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_hwmodel::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*!\n * \\class cfm_swinterface\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_SWINTERFACE\n#define COFS_MODEL_COMPLETEDEVICE_SWINTERFACE\n\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n#include \"mci/cfm_dpv.h\"\n#include \"mci/cfm_storeframe.h\"\n#include <list>\n\nclass cfm_swinterface: public cf_core::cf_dpv_container, public virtual cfm_dpv, public virtual cfm_storeframe {\npublic:\n\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_swinterface> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_swinterface, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_swinterface> p_ev_newFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_swinterface, cft_defprocessingmode> p_sv_processingMode_t;\n\n\tcfm_swinterface(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_swinterface(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tCF_DPV_REGISTER_IF_IMPL;\n\tCF_DPV_REGISTER_INT_IF_IMPL;\n\tCF_DPV_INTERRUPT_IF_IMPL;\n\tCF_DPV_INTERRUPT_INT_IF_IMPL;\n\tCF_DPV_COMMAND_IF_IMPL;\n\npublic:\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_ev_newFrame_t p_ev_newFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\tstd::list<DefFrame> frame_memory;\n\tvoid storeOutputFrame(DefFrame* frame);\n\nprivate:\nprivate:\n\tDefFrame inputFrame;\n\tcft_defframe inputFrame_trans;\n\tDefProcessingMode processingMode;\n\tcft_defprocessingmode processingMode_trans;\n\n};\n\n#endif // COFS_MODEL_COMPLETEDEVICE_SWINTERFACE\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*\n * \\class cfm_swinterface\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_swinterface.h\"\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\nvoid cfm_swinterface::storeOutputFrame(DefFrame* frame) {\n\tframe_memory.push_back(*frame);\n\tprocessedFrameCount.write(processedFrameCount.read() + 1);\n\traise_interrupt_int(\"newFrameInt\");\n}\n\ncfm_swinterface::cfm_swinterface(sc_core::sc_module_name name)\ncf_dpv_container(name)\n, p_ev_startProcess(\"p_ev_startProcess\")\n, p_mq_inputFrame(\"p_mq_inputFrame\")\n, p_ev_newFrame(\"p_ev_newFrame\")\n, p_sv_processingMode(\"p_sv_processingMode\")\n\n{\n\tcf_dpv_container::init();\n\n\n\n\tcfa_endianess.init(cf_dt::CF_DPV_ENDIANESS_BIG\n\t);\n\n\tinputFrame_trans.set_data_ptr(&inputFrame);\n\tprocessingMode_trans.set_data_ptr(&processingMode);\n\n\tcf_dpv_container::elab_end();\n}\n\ncfm_swinterface::~cfm_swinterface(void) {\n\n}\n\nvoid cfm_swinterface::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_swinterface::cb_init_attributes() {\n\n\treturn;\n}\n\nvoid cfm_swinterface::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'mqToCommand', 'type': 'cofluent:Function', 'ports': [{'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*!\n * \\class cfm_mqtocommand\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_MQTOCOMMAND\n#define COFS_MODEL_COMPLETEDEVICE_MQTOCOMMAND\n\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n\n#include \"mci/cfm_storeframe.h\"\n\n\nclass cfm_mqtocommand: public cf_core::cf_function {\npublic:\n\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mqtocommand, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_mci_port<cfm_storeframe> storeFrame_t;\n\n\tcfm_mqtocommand(sc_core::sc_module_name name);\n\n\tvirtual ~cfm_mqtocommand(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tstoreFrame_t storeFrame;\n\nprotected:\n\tvoid cb_init_attributes(void);\n\tvoid cb_init_local_vars(void);\n\n\n\n\n};\n\n#endif // COFS_MODEL_COMPLETEDEVICE_MQTOCOMMAND\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'mqToCommand', 'type': 'cofluent:Function', 'ports': [{'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "/*\n * \\class cfm_mqtocommand\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#include \"cfm_mqtocommand.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mqtocommand\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n\n\ncfm_mqtocommand::cfm_mqtocommand(sc_core::sc_module_name name)\ncf_function(name)\n, p_mq_outputFrame(\"p_mq_outputFrame\")\n, storeFrame(\"storeFrame\")\n\n{\n\tcf_function::init();\n\n\n\n\tcf_function::elab_end();\n}\n\ncfm_mqtocommand::~cfm_mqtocommand(void) {\n\n}\n\nvoid cfm_mqtocommand::cb_before_elaboration(void) {\n\n}\n\nvoid cfm_mqtocommand::cb_end_of_elaboration(void) {\n\n}\n\nvoid cfm_mqtocommand::cb_end_of_simulation(void) {\n\n}\n\nvoid cfm_mqtocommand::cb_init_attributes() {\n\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n\nvoid cfm_mqtocommand::cb_init_local_vars(void) {\n\n\n}\n\n\n"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Bluetooth_IPs', 'models': [{'name': 'Slave_Stub', 'type': 'cofluent:Function'}, {'name': 'BT_System', 'type': 'cofluent:Function'}, {'name': 'Start', 'type': 'cofluent:Function'}], 'relations': [{'name': 'BaseBand_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'startEv', 'type': 'cofluent:Event', 'connectTo': ['BT_System', 'Start']}, {'name': 'BaseBand_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bluetooth_ips\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS\n#define COFS_MODEL_BLUETOOTH_IPS\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bluetooth_ips_dp_if.h\"\n#include \"cfm_bt_system.h\"\n#include \"cfm_slave_stub.h\"\n#include \"cfm_start.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Bluetooth_IPs includes' algorithm generated code\n\n//End of 'Bluetooth_IPs includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBluetooth_IPs Function Bluetooth_IPs\n//@{\n///        \\page dxpBluetooth_IPs\n//@{\n///    \\brief Bluetooth_IPs function model start\nclass cfm_bluetooth_ips: public cf_core::cf_application, public cfm_bluetooth_ips_dp_if {\npublic:\n\t/// cfm_bluetooth_ips type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_BaseBand_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_event ev_startEv_t;\n\n\t/// cfm_bluetooth_ips type define end\n\n\t/// constructor\n\tcfm_bluetooth_ips(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bluetooth_ips(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bt_system* BT_System;\n\tcfm_slave_stub* Slave_Stub;\n\tcfm_start* Start;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_BaseBand_In_t mq_BaseBand_In;\n\tmq_BaseBand_Out_t mq_BaseBand_Out;\n\tev_startEv_t ev_startEv;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs local declarations' algorithm generated code\n\n\t//End of 'Bluetooth_IPs local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Bluetooth_IPs function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Bluetooth_IPs', 'models': [{'name': 'Slave_Stub', 'type': 'cofluent:Function'}, {'name': 'BT_System', 'type': 'cofluent:Function'}, {'name': 'Start', 'type': 'cofluent:Function'}], 'relations': [{'name': 'BaseBand_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'startEv', 'type': 'cofluent:Event', 'connectTo': ['BT_System', 'Start']}, {'name': 'BaseBand_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bluetooth_ips\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bluetooth_ips.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Bluetooth_IPs definitions' algorithm generated code\n\n//End of 'Bluetooth_IPs definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bluetooth_ips::cfm_bluetooth_ips(sc_core::sc_module_name name)\ncf_application(name)\n, cfm_bluetooth_ips_dp_if()\n, mq_BaseBand_In(\"BaseBand_In\"\n)\n, mq_BaseBand_Out(\"BaseBand_Out\"\n)\n, ev_startEv(\"startEv\"\n)\n\n{\n\tcf_application::init();\n\tBT_System = new cfm_bt_system\n\t(\"BT_System\");\n\tSlave_Stub = new cfm_slave_stub\n\t(\"Slave_Stub\");\n\tStart = new cfm_start\n\t(\"Start\");\n\n\t// connections\n\tBT_System->p_mq_BaseBand_Out\n\t(mq_BaseBand_Out\n\t\t\t.p_target_socket\n\t);\n\tBT_System->p_mq_BaseBand_In\n\t(mq_BaseBand_In\n\t\t\t.p_target_socket\n\t);\n\tBT_System->p_ev_startEv\n\t(ev_startEv\n\t\t\t.p_target_socket\n\t);\n\n\tSlave_Stub->p_mq_BaseBand_In\n\t(mq_BaseBand_In\n\t\t\t.p_target_socket\n\t);\n\tSlave_Stub->p_mq_BaseBand_Out\n\t(mq_BaseBand_Out\n\t\t\t.p_target_socket\n\t);\n\n\tStart->p_ev_startEv\n\t(ev_startEv\n\t\t\t.p_target_socket\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs constructor' algorithm generated code\n\n\t//End of 'Bluetooth_IPs constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bluetooth_ips::~cfm_bluetooth_ips(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs destructor' algorithm generated code\n\n\t//End of 'Bluetooth_IPs destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BT_System;\t///ddd\n\tdelete Slave_Stub;\t///ddd\n\tdelete Start;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bluetooth_ips::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs pre elaboration' algorithm generated code\n\n\t//End of 'Bluetooth_IPs pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bluetooth_ips::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Bluetooth_IPs post elaboration' algorithm generated code\n\tnb_file_parts = 0;\n\tnb_OBEX_df = 0;\n\tnb_RFCOMM_df = 0;\n\ttotal_delay_FILE = 0;\n\ttotal_delay_OBEX = 0;\n\ttotal_delay_RFCOMM = 0;\n\tnb_cdts_req = 0;\n\ttotal_L2CAP_data = 0;\n//End of 'Bluetooth_IPs post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bluetooth_ips::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs post simulation' algorithm generated code\n\n\t//End of 'Bluetooth_IPs post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bluetooth_ips::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_BaseBand_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_BaseBand_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_BaseBand_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_BaseBand_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_BaseBand_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_BaseBand_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_startEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_startEv.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_startEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bluetooth_ips::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs initializations' algorithm generated code\n\n\t//End of 'Bluetooth_IPs initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Slave_Stub', 'type': 'cofluent:Function', 'models': [{'name': 'In_Stub', 'type': 'cofluent:Function'}, {'name': 'Out_Stub', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_slave_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_slave_stub_dp_if.h\"\n#include \"cfm_in_stub.h\"\n#include \"cfm_out_stub.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Slave_Stub includes' algorithm generated code\n\n//End of 'Slave_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSlave_Stub Function Slave_Stub\n//@{\n///        \\page dxpSlave_Stub\n//@{\n///    \\brief Slave_Stub function model start\nclass cfm_slave_stub: public cf_core::cf_function_container, public cfm_slave_stub_dp_if {\npublic:\n\t/// cfm_slave_stub type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_slave_stub, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_slave_stub, cft_defbaseband> p_mq_BaseBand_Out_t;\n\t/// cfm_slave_stub type define end\n\n\t/// constructor\n\tcfm_slave_stub(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_slave_stub(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_in_stub* In_Stub;\n\tcfm_out_stub* Out_Stub;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub local declarations' algorithm generated code\n\n\t//End of 'Slave_Stub local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Slave_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Slave_Stub', 'type': 'cofluent:Function', 'models': [{'name': 'In_Stub', 'type': 'cofluent:Function'}, {'name': 'Out_Stub', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_slave_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_slave_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_slave_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Slave_Stub definitions' algorithm generated code\n\n//End of 'Slave_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_slave_stub::cfm_slave_stub(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_slave_stub_dp_if()\n, p_mq_BaseBand_In(\"p_mq_BaseBand_In\")\n, p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\")\n\n{\n\tcf_function_container::init();\n\tIn_Stub = new cfm_in_stub\n\t(\"In_Stub\");\n\tOut_Stub = new cfm_out_stub\n\t(\"Out_Stub\");\n\n\t// connections\n\tIn_Stub->p_mq_BaseBand_In\n\t(p_mq_BaseBand_In\n\t);\n\n\tOut_Stub->p_mq_BaseBand_Out\n\t(p_mq_BaseBand_Out\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub constructor' algorithm generated code\n\n\t//End of 'Slave_Stub constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_slave_stub::~cfm_slave_stub(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub destructor' algorithm generated code\n\n\t//End of 'Slave_Stub destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete In_Stub;\t///ddd\n\tdelete Out_Stub;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_slave_stub::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub pre elaboration' algorithm generated code\n\n\t//End of 'Slave_Stub pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_slave_stub::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub post elaboration' algorithm generated code\n\n\t//End of 'Slave_Stub post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_slave_stub::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub post simulation' algorithm generated code\n\n\t//End of 'Slave_Stub post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_slave_stub::cb_init_attributes() {\n\n// initialize function attributes\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_slave_stub::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub initializations' algorithm generated code\n\n\t//End of 'Slave_Stub initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BT_System', 'type': 'cofluent:Function', 'models': [{'name': 'FileSystem', 'type': 'cofluent:Function'}, {'name': 'BT_Stack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'relations': [{'name': 'DataOut', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataOut', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'WrOK', 'type': 'cofluent:Event', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'Data', 'type': 'cofluent:SharedVariable', 'dataType': 'DefData', 'connectTo': ['FileSystem']}, {'name': 'DataIn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataIn', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'ReadWrite', 'type': 'cofluent:MessageQueue', 'dataType': 'DefReadWrite', 'connectTo': ['FileSystem', 'BT_Stack']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bt_system\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n#define COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bt_system_dp_if.h\"\n#include \"cfm_bt_stack.h\"\n#include \"cfm_filesystem.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_System includes' algorithm generated code\n\n//End of 'BT_System includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBT_System Function BT_System\n//@{\n///        \\page dxpBT_System\n//@{\n///    \\brief BT_System function model start\nclass cfm_bt_system: public cf_core::cf_function_container, public cfm_bt_system_dp_if {\npublic:\n\t/// cfm_bt_system type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_defdata> sv_Data_t;\n\ttypedef cf_core::cf_message_queue<cft_defdatain> mq_DataIn_t;\n\ttypedef cf_core::cf_message_queue<cft_defdataout> mq_DataOut_t;\n\ttypedef cf_core::cf_message_queue<cft_defreadwrite> mq_ReadWrite_t;\n\ttypedef cf_core::cf_event ev_WrOK_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_system, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_system, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_bt_system> p_ev_startEv_t;\n\t/// cfm_bt_system type define end\n\n\t/// constructor\n\tcfm_bt_system(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bt_system(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_ev_startEv_t p_ev_startEv;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bt_stack* BT_Stack;\n\tcfm_filesystem* FileSystem;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_Data_t sv_Data;\n\tmq_DataIn_t mq_DataIn;\n\tmq_DataOut_t mq_DataOut;\n\tmq_ReadWrite_t mq_ReadWrite;\n\tev_WrOK_t ev_WrOK;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System local declarations' algorithm generated code\n\n\t//End of 'BT_System local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BT_System function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BT_System', 'type': 'cofluent:Function', 'models': [{'name': 'FileSystem', 'type': 'cofluent:Function'}, {'name': 'BT_Stack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'relations': [{'name': 'DataOut', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataOut', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'WrOK', 'type': 'cofluent:Event', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'Data', 'type': 'cofluent:SharedVariable', 'dataType': 'DefData', 'connectTo': ['FileSystem']}, {'name': 'DataIn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataIn', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'ReadWrite', 'type': 'cofluent:MessageQueue', 'dataType': 'DefReadWrite', 'connectTo': ['FileSystem', 'BT_Stack']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bt_system\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bt_system.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bt_system\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_System definitions' algorithm generated code\n\n//End of 'BT_System definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bt_system::cfm_bt_system(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_bt_system_dp_if()\n, p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\")\n, p_mq_BaseBand_In(\"p_mq_BaseBand_In\")\n, p_ev_startEv(\"p_ev_startEv\")\n, sv_Data(\"Data\"\n)\n, mq_DataIn(\"DataIn\"\n)\n, mq_DataOut(\"DataOut\"\n)\n, mq_ReadWrite(\"ReadWrite\"\n)\n, ev_WrOK(\"WrOK\"\n)\n\n{\n\tcf_function_container::init();\n\tBT_Stack = new cfm_bt_stack\n\t(\"BT_Stack\");\n\tFileSystem = new cfm_filesystem\n\t(\"FileSystem\");\n\n\t// connections\n\tBT_Stack->p_mq_BaseBand_Out\n\t(p_mq_BaseBand_Out\n\t);\n\tBT_Stack->p_mq_BaseBand_In\n\t(p_mq_BaseBand_In\n\t);\n\tBT_Stack->p_mq_ReadWrite_0\n\t(mq_ReadWrite\n\t\t\t.p_target_socket\n\t);\n\tBT_Stack->p_mq_DataIn\n\t(mq_DataIn\n\t\t\t.p_target_socket\n\t);\n\tBT_Stack->p_ev_WrOK\n\t(ev_WrOK\n\t\t\t.p_target_socket\n\t);\n\tBT_Stack->p_mq_DataOut\n\t(mq_DataOut\n\t\t\t.p_target_socket\n\t);\n\tBT_Stack->p_ev_startEv\n\t(p_ev_startEv\n\t);\n\tBT_Stack->p_mq_ReadWrite_1\n\t(mq_ReadWrite\n\t\t\t.p_target_socket\n\t);\n\n\tFileSystem->p_sv_Data\n\t(sv_Data\n\t\t\t.p_target_socket\n\t);\n\tFileSystem->p_ev_WrOK\n\t(ev_WrOK\n\t\t\t.p_target_socket\n\t);\n\tFileSystem->p_mq_DataOut\n\t(mq_DataOut\n\t\t\t.p_target_socket\n\t);\n\tFileSystem->p_mq_DataIn\n\t(mq_DataIn\n\t\t\t.p_target_socket\n\t);\n\tFileSystem->p_mq_ReadWrite\n\t(mq_ReadWrite\n\t\t\t.p_target_socket\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System constructor' algorithm generated code\n\n\t//End of 'BT_System constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bt_system::~cfm_bt_system(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System destructor' algorithm generated code\n\n\t//End of 'BT_System destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BT_Stack;\t///ddd\n\tdelete FileSystem;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bt_system::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System pre elaboration' algorithm generated code\n\n\t//End of 'BT_System pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bt_system::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System post elaboration' algorithm generated code\n\n\t//End of 'BT_System post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bt_system::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System post simulation' algorithm generated code\n\n\t//End of 'BT_System post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bt_system::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tsv_Data.cfa_write_time.init(cf_expr_duration(0, CF_NS));\n\tsv_Data.cfa_read_time.init(cf_expr_duration(0, CF_NS));\n\tsv_Data.cfa_semaphore.init(false);\n\tsv_Data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_DataIn.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataIn.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataIn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_DataIn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_DataIn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_DataOut.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataOut.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataOut.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_DataOut.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_DataOut.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReadWrite.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_ReadWrite.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_ReadWrite.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReadWrite.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReadWrite.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_WrOK.cfa_set_time.init(cf_expr_duration(0, CF_NS));\n\tev_WrOK.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_WrOK.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bt_system::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System initializations' algorithm generated code\n\n\t//End of 'BT_System initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Start', 'type': 'cofluent:Function', 'ports': [{'name': 'startEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_start\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_START\n#define COFS_MODEL_BLUETOOTH_IPS_START\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_start_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Start includes' algorithm generated code\n\n//End of 'Start includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgStart Function Start\n//@{\n///        \\page dxpStart\n//@{\n///    \\brief Start function model start\nclass cfm_start: public cf_core::cf_function, public cfm_start_dp_if {\npublic:\n\t/// cfm_start type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_start> p_ev_startEv_t;\n\t/// cfm_start type define end\n\n\t/// constructor\n\tcfm_start(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_start(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_startEv_t p_ev_startEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start local declarations' algorithm generated code\n\n\t//End of 'Start local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Start function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_START\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Start', 'type': 'cofluent:Function', 'ports': [{'name': 'startEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_start\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_start.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_start\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Start definitions' algorithm generated code\n\n//End of 'Start definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_start::cfm_start(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_start_dp_if()\n, p_ev_startEv(\"p_ev_startEv\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start constructor' algorithm generated code\n\n\t//End of 'Start constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_start::~cfm_start(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start destructor' algorithm generated code\n\n\t//End of 'Start destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_start::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start pre elaboration' algorithm generated code\n\n\t//End of 'Start pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_start::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start post elaboration' algorithm generated code\n\n\t//End of 'Start post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_start::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start post simulation' algorithm generated code\n\n\t//End of 'Start post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_start::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_start::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start initializations' algorithm generated code\n\n\t//End of 'Start initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'In_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_in_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_in_stub_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'In_Stub includes' algorithm generated code\n\n//End of 'In_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIn_Stub Function In_Stub\n//@{\n///        \\page dxpIn_Stub\n//@{\n///    \\brief In_Stub function model start\nclass cfm_in_stub: public cf_core::cf_function, public cfm_in_stub_dp_if {\npublic:\n\t/// cfm_in_stub type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_in_stub, cft_defbaseband> p_mq_BaseBand_In_t;\n\t/// cfm_in_stub type define end\n\n\t/// constructor\n\tcfm_in_stub(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_in_stub(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub local declarations' algorithm generated code\n\n\t//End of 'In_Stub local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief In_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'In_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_in_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_in_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_slave_stub\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_in_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'In_Stub definitions' algorithm generated code\n\n//End of 'In_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_in_stub::cfm_in_stub(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_in_stub_dp_if()\n, p_mq_BaseBand_In(\"p_mq_BaseBand_In\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub constructor' algorithm generated code\n\n\t//End of 'In_Stub constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_in_stub::~cfm_in_stub(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub destructor' algorithm generated code\n\n\t//End of 'In_Stub destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_in_stub::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub pre elaboration' algorithm generated code\n\n\t//End of 'In_Stub pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_in_stub::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub post elaboration' algorithm generated code\n\n\t//End of 'In_Stub post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_in_stub::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub post simulation' algorithm generated code\n\n\t//End of 'In_Stub post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_in_stub::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_in_stub::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub initializations' algorithm generated code\n\n\t//End of 'In_Stub initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Out_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_out_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_out_stub_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Out_Stub includes' algorithm generated code\n\n//End of 'Out_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOut_Stub Function Out_Stub\n//@{\n///        \\page dxpOut_Stub\n//@{\n///    \\brief Out_Stub function model start\nclass cfm_out_stub: public cf_core::cf_function, public cfm_out_stub_dp_if {\npublic:\n\t/// cfm_out_stub type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_out_stub, cft_defbaseband> p_mq_BaseBand_Out_t;\n\t/// cfm_out_stub type define end\n\n\t/// constructor\n\tcfm_out_stub(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_out_stub(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub local declarations' algorithm generated code\n\n\t//End of 'Out_Stub local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Out_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Out_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_out_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_out_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_slave_stub\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_out_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Out_Stub definitions' algorithm generated code\n\n//End of 'Out_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_out_stub::cfm_out_stub(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_out_stub_dp_if()\n, p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub constructor' algorithm generated code\n\n\t//End of 'Out_Stub constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_out_stub::~cfm_out_stub(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub destructor' algorithm generated code\n\n\t//End of 'Out_Stub destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_out_stub::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub pre elaboration' algorithm generated code\n\n\t//End of 'Out_Stub pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_out_stub::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub post elaboration' algorithm generated code\n\n\t//End of 'Out_Stub post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_out_stub::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub post simulation' algorithm generated code\n\n\t//End of 'Out_Stub post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_out_stub::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_out_stub::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub initializations' algorithm generated code\n\n\t//End of 'Out_Stub initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'FileSystem', 'type': 'cofluent:Function', 'ports': [{'name': 'Data', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefData'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataOut'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataIn'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefReadWrite'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_filesystem\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n#define COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_filesystem_dp_if.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FileSystem includes' algorithm generated code\n\n//End of 'FileSystem includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgFileSystem Function FileSystem\n//@{\n///        \\page dxpFileSystem\n//@{\n///    \\brief FileSystem function model start\nclass cfm_filesystem: public cf_core::cf_function, public cfm_filesystem_dp_if {\npublic:\n\t/// cfm_filesystem type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_filesystem, cft_defdata> p_sv_Data_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_filesystem> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_filesystem, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_filesystem, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_filesystem, cft_defreadwrite> p_mq_ReadWrite_t;\n\t/// cfm_filesystem type define end\n\n\t/// constructor\n\tcfm_filesystem(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_filesystem(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_Data_t p_sv_Data;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_mq_ReadWrite_t p_mq_ReadWrite;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem local declarations' algorithm generated code\n\t//stop flag is activated when file has been read entirely\n\tbool stop;\n\t//read/write flag\n\tint wr;\n\t//file size\n\tint f_size;\n\t//size of a part\n\tint p_size;\n\t//read operation duration in ms\n\tdouble op_read_duration;\n\t//write operation duration in ms\n\tdouble op_write_duration;\n\t//first read flag\n\tbool first_read;\n\t//End of 'FileSystem local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief FileSystem function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'FileSystem', 'type': 'cofluent:Function', 'ports': [{'name': 'Data', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefData'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataOut'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataIn'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefReadWrite'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_filesystem\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_filesystem.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_system\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_filesystem\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FileSystem definitions' algorithm generated code\n\n//End of 'FileSystem definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_filesystem::cfm_filesystem(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_filesystem_dp_if()\n, p_sv_Data(\"p_sv_Data\")\n, p_ev_WrOK(\"p_ev_WrOK\")\n, p_mq_DataOut(\"p_mq_DataOut\")\n, p_mq_DataIn(\"p_mq_DataIn\")\n, p_mq_ReadWrite(\"p_mq_ReadWrite\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem constructor' algorithm generated code\n\n\t//End of 'FileSystem constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_filesystem::~cfm_filesystem(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem destructor' algorithm generated code\n\n\t//End of 'FileSystem destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_filesystem::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem pre elaboration' algorithm generated code\n\n\t//End of 'FileSystem pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_filesystem::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem post elaboration' algorithm generated code\n\n\t//End of 'FileSystem post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_filesystem::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem post simulation' algorithm generated code\n\n\t//End of 'FileSystem post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_filesystem::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_filesystem::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem initializations' algorithm generated code\n\t//stop flag is activated when file has been read entirely\n\tstop = false;\n\t//read/write flag\n\twr = 0;\n\t//file size\n\tf_size = File_Size * 1000;\n\t//first read flag\n\tfirst_read = true;\n\t//End of 'FileSystem initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BT_Stack', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Layer', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Layer', 'type': 'cofluent:Function'}, {'name': 'BaseBand_Layer', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Layer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'relations': [{'name': 'OBEX_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'OBEX_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'RFCOMM_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'RFCOMM_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_In', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bt_stack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n#define COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bt_stack_dp_if.h\"\n#include \"cfm_baseband_layer.h\"\n#include \"cfm_l2cap_layer.h\"\n#include \"cfm_obex_layer.h\"\n#include \"cfm_rfcomm_layer.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_Stack includes' algorithm generated code\n\n//End of 'BT_Stack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBT_Stack Function BT_Stack\n//@{\n///        \\page dxpBT_Stack\n//@{\n///    \\brief BT_Stack function model start\nclass cfm_bt_stack: public cf_core::cf_function_container, public cfm_bt_stack_dp_if {\npublic:\n\t/// cfm_bt_stack type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defl2cap_in> mq_L2CAP_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defl2cap_out> mq_L2CAP_Out_t;\n\ttypedef cf_core::cf_message_queue<cft_defobex_in> mq_OBEX_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defobex_out> mq_OBEX_Out_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFCOMM_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFCOMM_Out_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defreadwrite> p_mq_ReadWrite_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_bt_stack> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_bt_stack> p_ev_startEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defreadwrite> p_mq_ReadWrite_1_t;\n\t/// cfm_bt_stack type define end\n\n\t/// constructor\n\tcfm_bt_stack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bt_stack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_ReadWrite_0_t p_mq_ReadWrite_0;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_ev_startEv_t p_ev_startEv;\n\tp_mq_ReadWrite_1_t p_mq_ReadWrite_1;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_baseband_layer* BaseBand_Layer;\n\tcfm_l2cap_layer* L2CAP_Layer;\n\tcfm_obex_layer* OBEX_Layer;\n\tcfm_rfcomm_layer* RFCOMM_Layer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_L2CAP_In_t mq_L2CAP_In;\n\tmq_L2CAP_Out_t mq_L2CAP_Out;\n\tmq_OBEX_In_t mq_OBEX_In;\n\tmq_OBEX_Out_t mq_OBEX_Out;\n\tmq_RFCOMM_In_t mq_RFCOMM_In;\n\tmq_RFCOMM_Out_t mq_RFCOMM_Out;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack local declarations' algorithm generated code\n\n\t//End of 'BT_Stack local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BT_Stack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BT_Stack', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Layer', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Layer', 'type': 'cofluent:Function'}, {'name': 'BaseBand_Layer', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Layer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'relations': [{'name': 'OBEX_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'OBEX_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'RFCOMM_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'RFCOMM_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_In', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bt_stack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bt_stack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_system\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bt_stack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_Stack definitions' algorithm generated code\n\n//End of 'BT_Stack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bt_stack::cfm_bt_stack(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_bt_stack_dp_if()\n, p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\")\n, p_mq_BaseBand_In(\"p_mq_BaseBand_In\")\n, p_mq_ReadWrite_0(\"p_mq_ReadWrite_0\")\n, p_mq_DataIn(\"p_mq_DataIn\")\n, p_ev_WrOK(\"p_ev_WrOK\")\n, p_mq_DataOut(\"p_mq_DataOut\")\n, p_ev_startEv(\"p_ev_startEv\")\n, p_mq_ReadWrite_1(\"p_mq_ReadWrite_1\")\n, mq_L2CAP_In(\"L2CAP_In\"\n)\n, mq_L2CAP_Out(\"L2CAP_Out\"\n)\n, mq_OBEX_In(\"OBEX_In\"\n)\n, mq_OBEX_Out(\"OBEX_Out\"\n)\n, mq_RFCOMM_In(\"RFCOMM_In\"\n)\n, mq_RFCOMM_Out(\"RFCOMM_Out\"\n)\n\n{\n\tcf_function_container::init();\n\tBaseBand_Layer = new cfm_baseband_layer\n\t(\"BaseBand_Layer\");\n\tL2CAP_Layer = new cfm_l2cap_layer\n\t(\"L2CAP_Layer\");\n\tOBEX_Layer = new cfm_obex_layer\n\t(\"OBEX_Layer\");\n\tRFCOMM_Layer = new cfm_rfcomm_layer\n\t(\"RFCOMM_Layer\");\n\n\t// connections\n\tBaseBand_Layer->p_mq_BaseBand_Out\n\t(p_mq_BaseBand_Out\n\t);\n\tBaseBand_Layer->p_mq_L2CAP_Out\n\t(mq_L2CAP_Out\n\t\t\t.p_target_socket\n\t);\n\tBaseBand_Layer->p_mq_BaseBand_In\n\t(p_mq_BaseBand_In\n\t);\n\tBaseBand_Layer->p_mq_L2CAP_In\n\t(mq_L2CAP_In\n\t\t\t.p_target_socket\n\t);\n\n\tL2CAP_Layer->p_mq_RFCOMM_Out\n\t(mq_RFCOMM_Out\n\t\t\t.p_target_socket\n\t);\n\tL2CAP_Layer->p_mq_RFCOMM_In\n\t(mq_RFCOMM_In\n\t\t\t.p_target_socket\n\t);\n\tL2CAP_Layer->p_mq_L2CAP_In\n\t(mq_L2CAP_In\n\t\t\t.p_target_socket\n\t);\n\tL2CAP_Layer->p_mq_L2CAP_Out\n\t(mq_L2CAP_Out\n\t\t\t.p_target_socket\n\t);\n\n\tOBEX_Layer->p_mq_ReadWrite_0\n\t(p_mq_ReadWrite_0\n\t);\n\tOBEX_Layer->p_mq_DataIn\n\t(p_mq_DataIn\n\t);\n\tOBEX_Layer->p_ev_WrOK\n\t(p_ev_WrOK\n\t);\n\tOBEX_Layer->p_mq_DataOut\n\t(p_mq_DataOut\n\t);\n\tOBEX_Layer->p_mq_OBEX_In\n\t(mq_OBEX_In\n\t\t\t.p_target_socket\n\t);\n\tOBEX_Layer->p_ev_startEv\n\t(p_ev_startEv\n\t);\n\tOBEX_Layer->p_mq_OBEX_Out\n\t(mq_OBEX_Out\n\t\t\t.p_target_socket\n\t);\n\tOBEX_Layer->p_mq_ReadWrite_1\n\t(p_mq_ReadWrite_1\n\t);\n\n\tRFCOMM_Layer->p_mq_OBEX_In\n\t(mq_OBEX_In\n\t\t\t.p_target_socket\n\t);\n\tRFCOMM_Layer->p_mq_OBEX_Out\n\t(mq_OBEX_Out\n\t\t\t.p_target_socket\n\t);\n\tRFCOMM_Layer->p_mq_RFCOMM_Out\n\t(mq_RFCOMM_Out\n\t\t\t.p_target_socket\n\t);\n\tRFCOMM_Layer->p_mq_RFCOMM_In\n\t(mq_RFCOMM_In\n\t\t\t.p_target_socket\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack constructor' algorithm generated code\n\n\t//End of 'BT_Stack constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bt_stack::~cfm_bt_stack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack destructor' algorithm generated code\n\n\t//End of 'BT_Stack destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BaseBand_Layer;\t///ddd\n\tdelete L2CAP_Layer;\t///ddd\n\tdelete OBEX_Layer;\t///ddd\n\tdelete RFCOMM_Layer;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bt_stack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack pre elaboration' algorithm generated code\n\n\t//End of 'BT_Stack pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bt_stack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack post elaboration' algorithm generated code\n\n\t//End of 'BT_Stack post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bt_stack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack post simulation' algorithm generated code\n\n\t//End of 'BT_Stack post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bt_stack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_L2CAP_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_L2CAP_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_L2CAP_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_L2CAP_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_L2CAP_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_L2CAP_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_OBEX_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OBEX_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OBEX_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_OBEX_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OBEX_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OBEX_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFCOMM_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFCOMM_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bt_stack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack initializations' algorithm generated code\n\n\t//End of 'BT_Stack initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Send', 'type': 'cofluent:Function'}, {'name': 'OBEX_Receive', 'type': 'cofluent:Function'}, {'name': 'OB_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'relations': [{'name': 'continueEv', 'type': 'cofluent:Event', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'OB_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Receive', 'OB_Out']}, {'name': 'OB_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Send', 'OB_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_layer_dp_if.h\"\n#include \"cfm_ob_out.h\"\n#include \"cfm_obex_receive.h\"\n#include \"cfm_obex_send.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Layer includes' algorithm generated code\n\n//End of 'OBEX_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Layer Function OBEX_Layer\n//@{\n///        \\page dxpOBEX_Layer\n//@{\n///    \\brief OBEX_Layer function model start\nclass cfm_obex_layer: public cf_core::cf_function_container, public cfm_obex_layer_dp_if {\npublic:\n\t/// cfm_obex_layer type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defobex_out> mq_OB_Out1_t;\n\ttypedef cf_core::cf_message_queue<cft_defobex_out> mq_OB_Out2_t;\n\ttypedef cf_core::cf_event ev_continueEv_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defreadwrite> p_mq_ReadWrite_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_layer> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defobex_in> p_mq_OBEX_In_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_layer> p_ev_startEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defobex_out> p_mq_OBEX_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defreadwrite> p_mq_ReadWrite_1_t;\n\t/// cfm_obex_layer type define end\n\n\t/// constructor\n\tcfm_obex_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_obex_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ReadWrite_0_t p_mq_ReadWrite_0;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\tp_ev_startEv_t p_ev_startEv;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\tp_mq_ReadWrite_1_t p_mq_ReadWrite_1;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_obex_receive* OBEX_Receive;\n\tcfm_obex_send* OBEX_Send;\n\tcfm_ob_out* OB_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_OB_Out1_t mq_OB_Out1;\n\tmq_OB_Out2_t mq_OB_Out2;\n\tev_continueEv_t ev_continueEv;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer local declarations' algorithm generated code\n\n\t//End of 'OBEX_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OBEX_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Send', 'type': 'cofluent:Function'}, {'name': 'OBEX_Receive', 'type': 'cofluent:Function'}, {'name': 'OB_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'relations': [{'name': 'continueEv', 'type': 'cofluent:Event', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'OB_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Receive', 'OB_Out']}, {'name': 'OB_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Send', 'OB_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Layer definitions' algorithm generated code\n\n//End of 'OBEX_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_layer::cfm_obex_layer(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_obex_layer_dp_if()\n, p_mq_ReadWrite_0(\"p_mq_ReadWrite_0\")\n, p_mq_DataIn(\"p_mq_DataIn\")\n, p_ev_WrOK(\"p_ev_WrOK\")\n, p_mq_DataOut(\"p_mq_DataOut\")\n, p_mq_OBEX_In(\"p_mq_OBEX_In\")\n, p_ev_startEv(\"p_ev_startEv\")\n, p_mq_OBEX_Out(\"p_mq_OBEX_Out\")\n, p_mq_ReadWrite_1(\"p_mq_ReadWrite_1\")\n, mq_OB_Out1(\"OB_Out1\"\n)\n, mq_OB_Out2(\"OB_Out2\"\n)\n, ev_continueEv(\"continueEv\"\n)\n\n{\n\tcf_function_container::init();\n\tOBEX_Receive = new cfm_obex_receive\n\t(\"OBEX_Receive\");\n\tOBEX_Send = new cfm_obex_send\n\t(\"OBEX_Send\");\n\tOB_Out = new cfm_ob_out\n\t(\"OB_Out\");\n\n\t// connections\n\tOBEX_Receive->p_ev_continueEv\n\t(ev_continueEv\n\t\t\t.p_target_socket\n\t);\n\tOBEX_Receive->p_mq_OB_Out1\n\t(mq_OB_Out1\n\t\t\t.p_target_socket\n\t);\n\tOBEX_Receive->p_mq_ReadWrite\n\t(p_mq_ReadWrite_0\n\t);\n\tOBEX_Receive->p_mq_DataIn\n\t(p_mq_DataIn\n\t);\n\tOBEX_Receive->p_ev_WrOK\n\t(p_ev_WrOK\n\t);\n\tOBEX_Receive->p_mq_OBEX_In\n\t(p_mq_OBEX_In\n\t);\n\n\tOBEX_Send->p_ev_continueEv\n\t(ev_continueEv\n\t\t\t.p_target_socket\n\t);\n\tOBEX_Send->p_mq_OB_Out2\n\t(mq_OB_Out2\n\t\t\t.p_target_socket\n\t);\n\tOBEX_Send->p_mq_ReadWrite\n\t(p_mq_ReadWrite_1\n\t);\n\tOBEX_Send->p_mq_DataOut\n\t(p_mq_DataOut\n\t);\n\tOBEX_Send->p_ev_startEv\n\t(p_ev_startEv\n\t);\n\n\tOB_Out->p_mq_OB_Out2\n\t(mq_OB_Out2\n\t\t\t.p_target_socket\n\t);\n\tOB_Out->p_mq_OB_Out1\n\t(mq_OB_Out1\n\t\t\t.p_target_socket\n\t);\n\tOB_Out->p_mq_OBEX_Out\n\t(p_mq_OBEX_Out\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer constructor' algorithm generated code\n\n\t//End of 'OBEX_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_layer::~cfm_obex_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer destructor' algorithm generated code\n\n\t//End of 'OBEX_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete OBEX_Receive;\t///ddd\n\tdelete OBEX_Send;\t///ddd\n\tdelete OB_Out;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_obex_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer pre elaboration' algorithm generated code\n\n\t//End of 'OBEX_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_obex_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer post elaboration' algorithm generated code\n\n\t//End of 'OBEX_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_obex_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer post simulation' algorithm generated code\n\n\t//End of 'OBEX_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_obex_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_OB_Out1.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out1.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OB_Out1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OB_Out1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_OB_Out2.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out2.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OB_Out2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OB_Out2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_continueEv.cfa_set_time.init(cf_expr_duration(0, CF_NS));\n\tev_continueEv.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_continueEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_obex_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer initializations' algorithm generated code\n\n\t//End of 'OBEX_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Send', 'type': 'cofluent:Function'}, {'name': 'CreditsOrData', 'type': 'cofluent:Function'}, {'name': 'RFC_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'relations': [{'name': 'RFC_Data', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Receive', 'CreditsOrData']}, {'name': 'RFC_Cdts', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Send', 'CreditsOrData']}, {'name': 'RFC_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Receive', 'RFC_Out']}, {'name': 'RFC_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Send', 'RFC_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_layer_dp_if.h\"\n#include \"cfm_creditsordata.h\"\n#include \"cfm_rfc_out.h\"\n#include \"cfm_rfcomm_receive.h\"\n#include \"cfm_rfcomm_send.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Layer includes' algorithm generated code\n\n//End of 'RFCOMM_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Layer Function RFCOMM_Layer\n//@{\n///        \\page dxpRFCOMM_Layer\n//@{\n///    \\brief RFCOMM_Layer function model start\nclass cfm_rfcomm_layer: public cf_core::cf_function_container, public cfm_rfcomm_layer_dp_if {\npublic:\n\t/// cfm_rfcomm_layer type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFC_Cdts_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFC_Data_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFC_Out1_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFC_Out2_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defobex_in> p_mq_OBEX_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defobex_out> p_mq_OBEX_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\t/// cfm_rfcomm_layer type define end\n\n\t/// constructor\n\tcfm_rfcomm_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfcomm_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_creditsordata* CreditsOrData;\n\tcfm_rfcomm_receive* RFCOMM_Receive;\n\tcfm_rfcomm_send* RFCOMM_Send;\n\tcfm_rfc_out* RFC_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_RFC_Cdts_t mq_RFC_Cdts;\n\tmq_RFC_Data_t mq_RFC_Data;\n\tmq_RFC_Out1_t mq_RFC_Out1;\n\tmq_RFC_Out2_t mq_RFC_Out2;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer local declarations' algorithm generated code\n\n\t//End of 'RFCOMM_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFCOMM_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Send', 'type': 'cofluent:Function'}, {'name': 'CreditsOrData', 'type': 'cofluent:Function'}, {'name': 'RFC_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'relations': [{'name': 'RFC_Data', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Receive', 'CreditsOrData']}, {'name': 'RFC_Cdts', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Send', 'CreditsOrData']}, {'name': 'RFC_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Receive', 'RFC_Out']}, {'name': 'RFC_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Send', 'RFC_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Layer definitions' algorithm generated code\n\n//End of 'RFCOMM_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_layer::cfm_rfcomm_layer(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_rfcomm_layer_dp_if()\n, p_mq_OBEX_In(\"p_mq_OBEX_In\")\n, p_mq_OBEX_Out(\"p_mq_OBEX_Out\")\n, p_mq_RFCOMM_Out(\"p_mq_RFCOMM_Out\")\n, p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\")\n, mq_RFC_Cdts(\"RFC_Cdts\"\n)\n, mq_RFC_Data(\"RFC_Data\"\n)\n, mq_RFC_Out1(\"RFC_Out1\"\n)\n, mq_RFC_Out2(\"RFC_Out2\"\n)\n\n{\n\tcf_function_container::init();\n\tCreditsOrData = new cfm_creditsordata\n\t(\"CreditsOrData\");\n\tRFCOMM_Receive = new cfm_rfcomm_receive\n\t(\"RFCOMM_Receive\");\n\tRFCOMM_Send = new cfm_rfcomm_send\n\t(\"RFCOMM_Send\");\n\tRFC_Out = new cfm_rfc_out\n\t(\"RFC_Out\");\n\n\t// connections\n\tCreditsOrData->p_mq_RFC_Data\n\t(mq_RFC_Data\n\t\t\t.p_target_socket\n\t);\n\tCreditsOrData->p_mq_RFC_Cdts\n\t(mq_RFC_Cdts\n\t\t\t.p_target_socket\n\t);\n\tCreditsOrData->p_mq_RFCOMM_In\n\t(p_mq_RFCOMM_In\n\t);\n\n\tRFCOMM_Receive->p_mq_RFC_Data\n\t(mq_RFC_Data\n\t\t\t.p_target_socket\n\t);\n\tRFCOMM_Receive->p_mq_RFC_Out1\n\t(mq_RFC_Out1\n\t\t\t.p_target_socket\n\t);\n\tRFCOMM_Receive->p_mq_OBEX_In\n\t(p_mq_OBEX_In\n\t);\n\n\tRFCOMM_Send->p_mq_RFC_Cdts\n\t(mq_RFC_Cdts\n\t\t\t.p_target_socket\n\t);\n\tRFCOMM_Send->p_mq_RFC_Out2\n\t(mq_RFC_Out2\n\t\t\t.p_target_socket\n\t);\n\tRFCOMM_Send->p_mq_OBEX_Out\n\t(p_mq_OBEX_Out\n\t);\n\n\tRFC_Out->p_mq_RFC_Out1\n\t(mq_RFC_Out1\n\t\t\t.p_target_socket\n\t);\n\tRFC_Out->p_mq_RFC_Out2\n\t(mq_RFC_Out2\n\t\t\t.p_target_socket\n\t);\n\tRFC_Out->p_mq_RFCOMM_Out\n\t(p_mq_RFCOMM_Out\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer constructor' algorithm generated code\n\n\t//End of 'RFCOMM_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_layer::~cfm_rfcomm_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer destructor' algorithm generated code\n\n\t//End of 'RFCOMM_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete CreditsOrData;\t///ddd\n\tdelete RFCOMM_Receive;\t///ddd\n\tdelete RFCOMM_Send;\t///ddd\n\tdelete RFC_Out;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfcomm_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer pre elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfcomm_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer post elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfcomm_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer post simulation' algorithm generated code\n\n\t//End of 'RFCOMM_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfcomm_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_RFC_Cdts.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Cdts.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Cdts.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Cdts.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Cdts.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFC_Data.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Data.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Data.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Data.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFC_Out1.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out1.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Out1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Out1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFC_Out2.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out2.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Out2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Out2.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfcomm_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer initializations' algorithm generated code\n\n\t//End of 'RFCOMM_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BaseBand_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'BB_Receive', 'type': 'cofluent:Function'}, {'name': 'BB_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_baseband_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_baseband_layer_dp_if.h\"\n#include \"cfm_bb_receive.h\"\n#include \"cfm_bb_send.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_out.h\"\n#include \"dt/cft_defl2cap_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BaseBand_Layer includes' algorithm generated code\n\n//End of 'BaseBand_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBaseBand_Layer Function BaseBand_Layer\n//@{\n///        \\page dxpBaseBand_Layer\n//@{\n///    \\brief BaseBand_Layer function model start\nclass cfm_baseband_layer: public cf_core::cf_function_container, public cfm_baseband_layer_dp_if {\npublic:\n\t/// cfm_baseband_layer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\t/// cfm_baseband_layer type define end\n\n\t/// constructor\n\tcfm_baseband_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_baseband_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bb_receive* BB_Receive;\n\tcfm_bb_send* BB_Send;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer local declarations' algorithm generated code\n\n\t//End of 'BaseBand_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BaseBand_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BaseBand_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'BB_Receive', 'type': 'cofluent:Function'}, {'name': 'BB_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_baseband_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_baseband_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_baseband_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BaseBand_Layer definitions' algorithm generated code\n\n//End of 'BaseBand_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_baseband_layer::cfm_baseband_layer(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_baseband_layer_dp_if()\n, p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\")\n, p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\")\n, p_mq_BaseBand_In(\"p_mq_BaseBand_In\")\n, p_mq_L2CAP_In(\"p_mq_L2CAP_In\")\n\n{\n\tcf_function_container::init();\n\tBB_Receive = new cfm_bb_receive\n\t(\"BB_Receive\");\n\tBB_Send = new cfm_bb_send\n\t(\"BB_Send\");\n\n\t// connections\n\tBB_Receive->p_mq_BaseBand_In\n\t(p_mq_BaseBand_In\n\t);\n\tBB_Receive->p_mq_L2CAP_In\n\t(p_mq_L2CAP_In\n\t);\n\n\tBB_Send->p_mq_BaseBand_Out\n\t(p_mq_BaseBand_Out\n\t);\n\tBB_Send->p_mq_L2CAP_Out\n\t(p_mq_L2CAP_Out\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer constructor' algorithm generated code\n\n\t//End of 'BaseBand_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_baseband_layer::~cfm_baseband_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer destructor' algorithm generated code\n\n\t//End of 'BaseBand_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BB_Receive;\t///ddd\n\tdelete BB_Send;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_baseband_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer pre elaboration' algorithm generated code\n\n\t//End of 'BaseBand_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_baseband_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer post elaboration' algorithm generated code\n\n\t//End of 'BaseBand_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_baseband_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer post simulation' algorithm generated code\n\n\t//End of 'BaseBand_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_baseband_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_baseband_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer initializations' algorithm generated code\n\n\t//End of 'BaseBand_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'L2CAP_Receive', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_layer_dp_if.h\"\n#include \"cfm_l2cap_receive.h\"\n#include \"cfm_l2cap_send.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Layer includes' algorithm generated code\n\n//End of 'L2CAP_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Layer Function L2CAP_Layer\n//@{\n///        \\page dxpL2CAP_Layer\n//@{\n///    \\brief L2CAP_Layer function model start\nclass cfm_l2cap_layer: public cf_core::cf_function_container, public cfm_l2cap_layer_dp_if {\npublic:\n\t/// cfm_l2cap_layer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\t/// cfm_l2cap_layer type define end\n\n\t/// constructor\n\tcfm_l2cap_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_l2cap_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_l2cap_receive* L2CAP_Receive;\n\tcfm_l2cap_send* L2CAP_Send;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer local declarations' algorithm generated code\n\n\t//End of 'L2CAP_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief L2CAP_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'L2CAP_Receive', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Layer definitions' algorithm generated code\n\n//End of 'L2CAP_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_layer::cfm_l2cap_layer(sc_core::sc_module_name name)\ncf_function_container(name)\n, cfm_l2cap_layer_dp_if()\n, p_mq_RFCOMM_Out(\"p_mq_RFCOMM_Out\")\n, p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\")\n, p_mq_L2CAP_In(\"p_mq_L2CAP_In\")\n, p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\")\n\n{\n\tcf_function_container::init();\n\tL2CAP_Receive = new cfm_l2cap_receive\n\t(\"L2CAP_Receive\");\n\tL2CAP_Send = new cfm_l2cap_send\n\t(\"L2CAP_Send\");\n\n\t// connections\n\tL2CAP_Receive->p_mq_RFCOMM_In\n\t(p_mq_RFCOMM_In\n\t);\n\tL2CAP_Receive->p_mq_L2CAP_In\n\t(p_mq_L2CAP_In\n\t);\n\n\tL2CAP_Send->p_mq_RFCOMM_Out\n\t(p_mq_RFCOMM_Out\n\t);\n\tL2CAP_Send->p_mq_L2CAP_Out\n\t(p_mq_L2CAP_Out\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer constructor' algorithm generated code\n\n\t//End of 'L2CAP_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_layer::~cfm_l2cap_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer destructor' algorithm generated code\n\n\t//End of 'L2CAP_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete L2CAP_Receive;\t///ddd\n\tdelete L2CAP_Send;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_l2cap_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer pre elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_l2cap_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer post elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_l2cap_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer post simulation' algorithm generated code\n\n\t//End of 'L2CAP_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_l2cap_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_l2cap_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer initializations' algorithm generated code\n\n\t//End of 'L2CAP_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_send_dp_if.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdataout.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Send includes' algorithm generated code\n\n//End of 'OBEX_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Send Function OBEX_Send\n//@{\n///        \\page dxpOBEX_Send\n//@{\n///    \\brief OBEX_Send function model start\nclass cfm_obex_send: public cf_core::cf_function, public cfm_obex_send_dp_if {\npublic:\n\t/// cfm_obex_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_send> p_ev_continueEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_send, cft_defobex_out> p_mq_OB_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_send, cft_defreadwrite> p_mq_ReadWrite_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_send, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_send> p_ev_startEv_t;\n\t/// cfm_obex_send type define end\n\n\t/// constructor\n\tcfm_obex_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_obex_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_continueEv_t p_ev_continueEv;\n\tp_mq_OB_Out2_t p_mq_OB_Out2;\n\tp_mq_ReadWrite_t p_mq_ReadWrite;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_ev_startEv_t p_ev_startEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send local declarations' algorithm generated code\n\n\t//End of 'OBEX_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OBEX_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Send definitions' algorithm generated code\n\n//End of 'OBEX_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_send::cfm_obex_send(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_obex_send_dp_if()\n, p_ev_continueEv(\"p_ev_continueEv\")\n, p_mq_OB_Out2(\"p_mq_OB_Out2\")\n, p_mq_ReadWrite(\"p_mq_ReadWrite\")\n, p_mq_DataOut(\"p_mq_DataOut\")\n, p_ev_startEv(\"p_ev_startEv\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send constructor' algorithm generated code\n\n\t//End of 'OBEX_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_send::~cfm_obex_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send destructor' algorithm generated code\n\n\t//End of 'OBEX_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_obex_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send pre elaboration' algorithm generated code\n\n\t//End of 'OBEX_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_obex_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send post elaboration' algorithm generated code\n\n\t//End of 'OBEX_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_obex_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send post simulation' algorithm generated code\n\n\t//End of 'OBEX_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_obex_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_obex_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send initializations' algorithm generated code\n\n\t//End of 'OBEX_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_receive_dp_if.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defobex_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Receive includes' algorithm generated code\n\n//End of 'OBEX_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Receive Function OBEX_Receive\n//@{\n///        \\page dxpOBEX_Receive\n//@{\n///    \\brief OBEX_Receive function model start\nclass cfm_obex_receive: public cf_core::cf_function, public cfm_obex_receive_dp_if {\npublic:\n\t/// cfm_obex_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_receive> p_ev_continueEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defobex_out> p_mq_OB_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defreadwrite> p_mq_ReadWrite_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_receive> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defobex_in> p_mq_OBEX_In_t;\n\t/// cfm_obex_receive type define end\n\n\t/// constructor\n\tcfm_obex_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_obex_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_continueEv_t p_ev_continueEv;\n\tp_mq_OB_Out1_t p_mq_OB_Out1;\n\tp_mq_ReadWrite_t p_mq_ReadWrite;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive local declarations' algorithm generated code\n\tint ack;\n\t//End of 'OBEX_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OBEX_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Receive definitions' algorithm generated code\n\n//End of 'OBEX_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_receive::cfm_obex_receive(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_obex_receive_dp_if()\n, p_ev_continueEv(\"p_ev_continueEv\")\n, p_mq_OB_Out1(\"p_mq_OB_Out1\")\n, p_mq_ReadWrite(\"p_mq_ReadWrite\")\n, p_mq_DataIn(\"p_mq_DataIn\")\n, p_ev_WrOK(\"p_ev_WrOK\")\n, p_mq_OBEX_In(\"p_mq_OBEX_In\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive constructor' algorithm generated code\n\n\t//End of 'OBEX_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_receive::~cfm_obex_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive destructor' algorithm generated code\n\n\t//End of 'OBEX_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_obex_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive pre elaboration' algorithm generated code\n\n\t//End of 'OBEX_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_obex_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive post elaboration' algorithm generated code\n\n\t//End of 'OBEX_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_obex_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive post simulation' algorithm generated code\n\n\t//End of 'OBEX_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_obex_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_obex_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive initializations' algorithm generated code\n\tack = 0;\n\t//End of 'OBEX_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OB_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ob_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n#define COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ob_out_dp_if.h\"\n#include \"dt/cft_defobex_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OB_Out includes' algorithm generated code\n\n//End of 'OB_Out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOB_Out Function OB_Out\n//@{\n///        \\page dxpOB_Out\n//@{\n///    \\brief OB_Out function model start\nclass cfm_ob_out: public cf_core::cf_function, public cfm_ob_out_dp_if {\npublic:\n\t/// cfm_ob_out type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ob_out, cft_defobex_out> p_mq_OB_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ob_out, cft_defobex_out> p_mq_OB_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ob_out, cft_defobex_out> p_mq_OBEX_Out_t;\n\t/// cfm_ob_out type define end\n\n\t/// constructor\n\tcfm_ob_out(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ob_out(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_OB_Out2_t p_mq_OB_Out2;\n\tp_mq_OB_Out1_t p_mq_OB_Out1;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out local declarations' algorithm generated code\n\n\t//End of 'OB_Out local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OB_Out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OB_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ob_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ob_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ob_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OB_Out definitions' algorithm generated code\n\n//End of 'OB_Out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ob_out::cfm_ob_out(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_ob_out_dp_if()\n, p_mq_OB_Out2(\"p_mq_OB_Out2\")\n, p_mq_OB_Out1(\"p_mq_OB_Out1\")\n, p_mq_OBEX_Out(\"p_mq_OBEX_Out\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out constructor' algorithm generated code\n\n\t//End of 'OB_Out constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ob_out::~cfm_ob_out(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out destructor' algorithm generated code\n\n\t//End of 'OB_Out destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ob_out::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out pre elaboration' algorithm generated code\n\n\t//End of 'OB_Out pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ob_out::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out post elaboration' algorithm generated code\n\n\t//End of 'OB_Out post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ob_out::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out post simulation' algorithm generated code\n\n\t//End of 'OB_Out post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ob_out::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ob_out::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out initializations' algorithm generated code\n\n\t//End of 'OB_Out initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_receive_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defobex_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Receive includes' algorithm generated code\n\n//End of 'RFCOMM_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Receive Function RFCOMM_Receive\n//@{\n///        \\page dxpRFCOMM_Receive\n//@{\n///    \\brief RFCOMM_Receive function model start\nclass cfm_rfcomm_receive: public cf_core::cf_function, public cfm_rfcomm_receive_dp_if {\npublic:\n\t/// cfm_rfcomm_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_receive, cft_defrfcomm_in> p_mq_RFC_Data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_receive, cft_defrfcomm_out> p_mq_RFC_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_receive, cft_defobex_in> p_mq_OBEX_In_t;\n\t/// cfm_rfcomm_receive type define end\n\n\t/// constructor\n\tcfm_rfcomm_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfcomm_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Data_t p_mq_RFC_Data;\n\tp_mq_RFC_Out1_t p_mq_RFC_Out1;\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive local declarations' algorithm generated code\n\t//number of credits available for the peer device\n\tint peer_credits;\n\t//flag indicating if peer need credits\n\tbool peer_need_credits;\n\t//flag indicating if OBEX frame reconstruction is finished\n\tbool receive_complete;\n\t//size of the already received RFCOMM payloads\n\tint received_payload_size;\n\t//type of the OBEX packet under reconstruction\n\tunsigned char OBEX_packet_type;\n\t//receive operation time in us\n\tdouble receive_op_time;\n\t//End of 'RFCOMM_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFCOMM_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Receive definitions' algorithm generated code\n\n//End of 'RFCOMM_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_receive::cfm_rfcomm_receive(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_rfcomm_receive_dp_if()\n, p_mq_RFC_Data(\"p_mq_RFC_Data\")\n, p_mq_RFC_Out1(\"p_mq_RFC_Out1\")\n, p_mq_OBEX_In(\"p_mq_OBEX_In\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive constructor' algorithm generated code\n\n\t//End of 'RFCOMM_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_receive::~cfm_rfcomm_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive destructor' algorithm generated code\n\n\t//End of 'RFCOMM_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfcomm_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive pre elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfcomm_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive post elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfcomm_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive post simulation' algorithm generated code\n\n\t//End of 'RFCOMM_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfcomm_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfcomm_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive initializations' algorithm generated code\n\t//number of credits available for the peer device\n\tpeer_credits = RFCOMM_credits;\n\t//flag indicating if peer need credits\n\tpeer_need_credits = false;\n\t//flag indicating if OBEX frame reconstruction is finished\n\treceive_complete = false;\n\t//size of the already received RFCOMM payloads\n\treceived_payload_size = 0;\n\t//receive operation time in us\n\treceive_op_time = 0.0;\n\t//End of 'RFCOMM_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_send_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defobex_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Send includes' algorithm generated code\n\n//End of 'RFCOMM_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Send Function RFCOMM_Send\n//@{\n///        \\page dxpRFCOMM_Send\n//@{\n///    \\brief RFCOMM_Send function model start\nclass cfm_rfcomm_send: public cf_core::cf_function, public cfm_rfcomm_send_dp_if {\npublic:\n\t/// cfm_rfcomm_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_send, cft_defrfcomm_in> p_mq_RFC_Cdts_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_send, cft_defrfcomm_out> p_mq_RFC_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_send, cft_defobex_out> p_mq_OBEX_Out_t;\n\t/// cfm_rfcomm_send type define end\n\n\t/// constructor\n\tcfm_rfcomm_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfcomm_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Cdts_t p_mq_RFC_Cdts;\n\tp_mq_RFC_Out2_t p_mq_RFC_Out2;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send local declarations' algorithm generated code\n\t//number of RFCOMM data packets to send\n\tint nb_packets_to_send;\n\t//size of the last RFCOMM packet payload\n\tint last_payload_size;\n\t//credits\n\tint credits;\n\tbool needCredits;\n\t//type of the OBEX packet under fragmentation\n\tunsigned char OBEX_packet_type;\n\t//End of 'RFCOMM_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFCOMM_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Send definitions' algorithm generated code\n\n//End of 'RFCOMM_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_send::cfm_rfcomm_send(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_rfcomm_send_dp_if()\n, p_mq_RFC_Cdts(\"p_mq_RFC_Cdts\")\n, p_mq_RFC_Out2(\"p_mq_RFC_Out2\")\n, p_mq_OBEX_Out(\"p_mq_OBEX_Out\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send constructor' algorithm generated code\n\n\t//End of 'RFCOMM_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_send::~cfm_rfcomm_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send destructor' algorithm generated code\n\n\t//End of 'RFCOMM_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfcomm_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send pre elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfcomm_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send post elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfcomm_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send post simulation' algorithm generated code\n\n\t//End of 'RFCOMM_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfcomm_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfcomm_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send initializations' algorithm generated code\n\t//credits\n\tcredits = RFCOMM_credits;\n\tneedCredits = false;\n\t//End of 'RFCOMM_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CreditsOrData', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_creditsordata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n#define COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_creditsordata_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CreditsOrData includes' algorithm generated code\n\n//End of 'CreditsOrData includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCreditsOrData Function CreditsOrData\n//@{\n///        \\page dxpCreditsOrData\n//@{\n///    \\brief CreditsOrData function model start\nclass cfm_creditsordata: public cf_core::cf_function, public cfm_creditsordata_dp_if {\npublic:\n\t/// cfm_creditsordata type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_creditsordata, cft_defrfcomm_in> p_mq_RFC_Data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_creditsordata, cft_defrfcomm_in> p_mq_RFC_Cdts_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_creditsordata, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\t/// cfm_creditsordata type define end\n\n\t/// constructor\n\tcfm_creditsordata(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_creditsordata(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Data_t p_mq_RFC_Data;\n\tp_mq_RFC_Cdts_t p_mq_RFC_Cdts;\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData local declarations' algorithm generated code\n\t//data flag\n\tbool data_flag;\n\t//credit flag\n\tbool cdt_flag;\n\t//End of 'CreditsOrData local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CreditsOrData function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CreditsOrData', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_creditsordata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_creditsordata.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_creditsordata\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CreditsOrData definitions' algorithm generated code\n\n//End of 'CreditsOrData definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_creditsordata::cfm_creditsordata(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_creditsordata_dp_if()\n, p_mq_RFC_Data(\"p_mq_RFC_Data\")\n, p_mq_RFC_Cdts(\"p_mq_RFC_Cdts\")\n, p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData constructor' algorithm generated code\n\n\t//End of 'CreditsOrData constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_creditsordata::~cfm_creditsordata(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData destructor' algorithm generated code\n\n\t//End of 'CreditsOrData destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_creditsordata::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData pre elaboration' algorithm generated code\n\n\t//End of 'CreditsOrData pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_creditsordata::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData post elaboration' algorithm generated code\n\n\t//End of 'CreditsOrData post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_creditsordata::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData post simulation' algorithm generated code\n\n\t//End of 'CreditsOrData post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_creditsordata::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_creditsordata::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData initializations' algorithm generated code\n\t//data flag\n\tdata_flag = false;\n\t//credit flag\n\tcdt_flag = false;\n\t//End of 'CreditsOrData initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFC_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfc_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n#define COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfc_out_dp_if.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFC_Out includes' algorithm generated code\n\n//End of 'RFC_Out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFC_Out Function RFC_Out\n//@{\n///        \\page dxpRFC_Out\n//@{\n///    \\brief RFC_Out function model start\nclass cfm_rfc_out: public cf_core::cf_function, public cfm_rfc_out_dp_if {\npublic:\n\t/// cfm_rfc_out type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfc_out, cft_defrfcomm_out> p_mq_RFC_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfc_out, cft_defrfcomm_out> p_mq_RFC_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfc_out, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\t/// cfm_rfc_out type define end\n\n\t/// constructor\n\tcfm_rfc_out(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfc_out(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Out1_t p_mq_RFC_Out1;\n\tp_mq_RFC_Out2_t p_mq_RFC_Out2;\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out local declarations' algorithm generated code\n\n\t//End of 'RFC_Out local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFC_Out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFC_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfc_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfc_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfc_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFC_Out definitions' algorithm generated code\n\n//End of 'RFC_Out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfc_out::cfm_rfc_out(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_rfc_out_dp_if()\n, p_mq_RFC_Out1(\"p_mq_RFC_Out1\")\n, p_mq_RFC_Out2(\"p_mq_RFC_Out2\")\n, p_mq_RFCOMM_Out(\"p_mq_RFCOMM_Out\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out constructor' algorithm generated code\n\n\t//End of 'RFC_Out constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfc_out::~cfm_rfc_out(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out destructor' algorithm generated code\n\n\t//End of 'RFC_Out destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfc_out::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out pre elaboration' algorithm generated code\n\n\t//End of 'RFC_Out pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfc_out::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out post elaboration' algorithm generated code\n\n\t//End of 'RFC_Out post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfc_out::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out post simulation' algorithm generated code\n\n\t//End of 'RFC_Out post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfc_out::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfc_out::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out initializations' algorithm generated code\n\n\t//End of 'RFC_Out initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BB_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bb_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bb_receive_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Receive includes' algorithm generated code\n\n//End of 'BB_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBB_Receive Function BB_Receive\n//@{\n///        \\page dxpBB_Receive\n//@{\n///    \\brief BB_Receive function model start\nclass cfm_bb_receive: public cf_core::cf_function, public cfm_bb_receive_dp_if {\npublic:\n\t/// cfm_bb_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_receive, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_receive, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\t/// cfm_bb_receive type define end\n\n\t/// constructor\n\tcfm_bb_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bb_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive local declarations' algorithm generated code\n\t//receive operation duration in ms\n\tdouble op_rcv_duration;\n\t//End of 'BB_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BB_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BB_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bb_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bb_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_baseband_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bb_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Receive definitions' algorithm generated code\n\n//End of 'BB_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bb_receive::cfm_bb_receive(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_bb_receive_dp_if()\n, p_mq_BaseBand_In(\"p_mq_BaseBand_In\")\n, p_mq_L2CAP_In(\"p_mq_L2CAP_In\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive constructor' algorithm generated code\n\n\t//End of 'BB_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bb_receive::~cfm_bb_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive destructor' algorithm generated code\n\n\t//End of 'BB_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bb_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive pre elaboration' algorithm generated code\n\n\t//End of 'BB_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bb_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive post elaboration' algorithm generated code\n\n\t//End of 'BB_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bb_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive post simulation' algorithm generated code\n\n\t//End of 'BB_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bb_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bb_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive initializations' algorithm generated code\n\t//receive operation duration in ms\n\top_rcv_duration = 0;\n\t//End of 'BB_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BB_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bb_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bb_send_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Send includes' algorithm generated code\n\n//End of 'BB_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBB_Send Function BB_Send\n//@{\n///        \\page dxpBB_Send\n//@{\n///    \\brief BB_Send function model start\nclass cfm_bb_send: public cf_core::cf_function, public cfm_bb_send_dp_if {\npublic:\n\t/// cfm_bb_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_send, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_send, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\t/// cfm_bb_send type define end\n\n\t/// constructor\n\tcfm_bb_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bb_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send local declarations' algorithm generated code\n\t//send operation duration in ms\n\tdouble op_send_duration;\n\t//End of 'BB_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BB_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BB_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bb_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bb_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_baseband_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bb_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Send definitions' algorithm generated code\n\n//End of 'BB_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bb_send::cfm_bb_send(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_bb_send_dp_if()\n, p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\")\n, p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send constructor' algorithm generated code\n\n\t//End of 'BB_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bb_send::~cfm_bb_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send destructor' algorithm generated code\n\n\t//End of 'BB_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bb_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send pre elaboration' algorithm generated code\n\n\t//End of 'BB_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bb_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send post elaboration' algorithm generated code\n\n\t//End of 'BB_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bb_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send post simulation' algorithm generated code\n\n\t//End of 'BB_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bb_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bb_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send initializations' algorithm generated code\n\t//send operation duration in ms\n\top_send_duration = 0;\n\t//End of 'BB_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_receive_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defl2cap_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Receive includes' algorithm generated code\n\n//End of 'L2CAP_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Receive Function L2CAP_Receive\n//@{\n///        \\page dxpL2CAP_Receive\n//@{\n///    \\brief L2CAP_Receive function model start\nclass cfm_l2cap_receive: public cf_core::cf_function, public cfm_l2cap_receive_dp_if {\npublic:\n\t/// cfm_l2cap_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_receive, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_receive, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\t/// cfm_l2cap_receive type define end\n\n\t/// constructor\n\tcfm_l2cap_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_l2cap_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive local declarations' algorithm generated code\n\n\t//End of 'L2CAP_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief L2CAP_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_l2cap_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Receive definitions' algorithm generated code\n\n//End of 'L2CAP_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_receive::cfm_l2cap_receive(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_l2cap_receive_dp_if()\n, p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\")\n, p_mq_L2CAP_In(\"p_mq_L2CAP_In\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive constructor' algorithm generated code\n\n\t//End of 'L2CAP_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_receive::~cfm_l2cap_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive destructor' algorithm generated code\n\n\t//End of 'L2CAP_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_l2cap_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive pre elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_l2cap_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive post elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_l2cap_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive post simulation' algorithm generated code\n\n\t//End of 'L2CAP_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_l2cap_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_l2cap_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive initializations' algorithm generated code\n\n\t//End of 'L2CAP_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_send_dp_if.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Send includes' algorithm generated code\n\n//End of 'L2CAP_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Send Function L2CAP_Send\n//@{\n///        \\page dxpL2CAP_Send\n//@{\n///    \\brief L2CAP_Send function model start\nclass cfm_l2cap_send: public cf_core::cf_function, public cfm_l2cap_send_dp_if {\npublic:\n\t/// cfm_l2cap_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_send, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_send, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\t/// cfm_l2cap_send type define end\n\n\t/// constructor\n\tcfm_l2cap_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_l2cap_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send local declarations' algorithm generated code\n\n\t//End of 'L2CAP_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief L2CAP_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_l2cap_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Send definitions' algorithm generated code\n\n//End of 'L2CAP_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_send::cfm_l2cap_send(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_l2cap_send_dp_if()\n, p_mq_RFCOMM_Out(\"p_mq_RFCOMM_Out\")\n, p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send constructor' algorithm generated code\n\n\t//End of 'L2CAP_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_send::~cfm_l2cap_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send destructor' algorithm generated code\n\n\t//End of 'L2CAP_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_l2cap_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send pre elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_l2cap_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send post elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_l2cap_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send post simulation' algorithm generated code\n\n\t//End of 'L2CAP_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_l2cap_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_l2cap_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send initializations' algorithm generated code\n\n\t//End of 'L2CAP_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OPP_UseCase', 'models': [{'name': 'StartFunc', 'type': 'cofluent:Function'}, {'name': 'UnusedFunc', 'type': 'cofluent:Function'}, {'name': 'Master', 'type': 'cofluent:Function'}, {'name': 'Slave', 'type': 'cofluent:Function'}], 'relations': [{'name': 'StartEv', 'type': 'cofluent:Event', 'connectTo': ['StartFunc']}, {'name': 'UnusedEv', 'type': 'cofluent:Event', 'connectTo': ['UnusedFunc']}, {'name': 'M2S', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'S2M', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_opp_usecase\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE\n#define COFS_MODEL_OPP_USECASE\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_opp_usecase_dp_if.h\"\n#include \"cfm_bt_system.h\"\n#include \"cfm_startfunc.h\"\n#include \"cfm_unusedfunc.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OPP_UseCase includes' algorithm generated code\n\n//End of 'OPP_UseCase includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOPP_UseCase Function OPP_UseCase\n//@{\n///        \\page dxpOPP_UseCase\n//@{\n///    \\brief OPP_UseCase function model start\nclass cfm_opp_usecase: public cf_core::cf_application, public cfm_opp_usecase_dp_if {\npublic:\n\t/// cfm_opp_usecase type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_M2S_t;\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_S2M_t;\n\ttypedef cf_core::cf_event ev_StartEv_t;\n\ttypedef cf_core::cf_event ev_UnusedEv_t;\n\n\t/// cfm_opp_usecase type define end\n\n\t/// constructor\n\tcfm_opp_usecase(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_opp_usecase(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bt_system* Master;\n\tcfm_bt_system* Slave;\n\tcfm_startfunc* StartFunc;\n\tcfm_unusedfunc* UnusedFunc;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_M2S_t mq_M2S;\n\tmq_S2M_t mq_S2M;\n\tev_StartEv_t ev_StartEv;\n\tev_UnusedEv_t ev_UnusedEv;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase local declarations' algorithm generated code\n\n\t//End of 'OPP_UseCase local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OPP_UseCase function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OPP_UseCase', 'models': [{'name': 'StartFunc', 'type': 'cofluent:Function'}, {'name': 'UnusedFunc', 'type': 'cofluent:Function'}, {'name': 'Master', 'type': 'cofluent:Function'}, {'name': 'Slave', 'type': 'cofluent:Function'}], 'relations': [{'name': 'StartEv', 'type': 'cofluent:Event', 'connectTo': ['StartFunc']}, {'name': 'UnusedEv', 'type': 'cofluent:Event', 'connectTo': ['UnusedFunc']}, {'name': 'M2S', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'S2M', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_opp_usecase\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_opp_usecase.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OPP_UseCase definitions' algorithm generated code\n\n//End of 'OPP_UseCase definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_opp_usecase::cfm_opp_usecase(sc_core::sc_module_name name)\ncf_application(name)\n, cfm_opp_usecase_dp_if()\n, mq_M2S(\"M2S\"\n)\n, mq_S2M(\"S2M\"\n)\n, ev_StartEv(\"StartEv\"\n)\n, ev_UnusedEv(\"UnusedEv\"\n)\n\n{\n\tcf_application::init();\n\tMaster = new cfm_bt_system\n\t(\"Master\");\n\tSlave = new cfm_bt_system\n\t(\"Slave\");\n\tStartFunc = new cfm_startfunc\n\t(\"StartFunc\");\n\tUnusedFunc = new cfm_unusedfunc\n\t(\"UnusedFunc\");\n\n\t// connections\n\tMaster->p_mq_BaseBand_Out\n\t(mq_M2S\n\t\t\t.p_target_socket\n\t);\n\tMaster->p_mq_BaseBand_In\n\t(mq_S2M\n\t\t\t.p_target_socket\n\t);\n\tMaster->p_ev_startEv\n\t(ev_StartEv\n\t\t\t.p_target_socket\n\t);\n\n\tSlave->p_mq_BaseBand_Out\n\t(mq_S2M\n\t\t\t.p_target_socket\n\t);\n\tSlave->p_mq_BaseBand_In\n\t(mq_M2S\n\t\t\t.p_target_socket\n\t);\n\tSlave->p_ev_startEv\n\t(ev_UnusedEv\n\t\t\t.p_target_socket\n\t);\n\n\tStartFunc->p_ev_StartEv\n\t(ev_StartEv\n\t\t\t.p_target_socket\n\t);\n\n\tUnusedFunc->p_ev_UnusedEv\n\t(ev_UnusedEv\n\t\t\t.p_target_socket\n\t);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase constructor' algorithm generated code\n\n\t//End of 'OPP_UseCase constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_opp_usecase::~cfm_opp_usecase(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase destructor' algorithm generated code\n\n\t//End of 'OPP_UseCase destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Master;\t///ddd\n\tdelete Slave;\t///ddd\n\tdelete StartFunc;\t///ddd\n\tdelete UnusedFunc;\t///ddd\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_opp_usecase::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase pre elaboration' algorithm generated code\n\n\t//End of 'OPP_UseCase pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_opp_usecase::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OPP_UseCase post elaboration' algorithm generated code\n\tnb_file_parts = 0;\n\tnb_OBEX_df = 0;\n\tnb_RFCOMM_df = 0;\n\ttotal_delay_FILE = 0;\n\ttotal_delay_OBEX = 0;\n\ttotal_delay_RFCOMM = 0;\n\tnb_cdts_req = 0;\n\ttotal_L2CAP_data = 0;\n//End of 'OPP_UseCase post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_opp_usecase::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase post simulation' algorithm generated code\n\t//perf result computation\n\ttotal_time = last_write_time - first_read_time; //in us\n\taverage_throughput = 1000000.0 * (double) File_Size * 8.0 / (double) total_time;\n\tcf_trace_gui_f_param(\"average_throughput\", average_throughput, \"kbits/s\");\n\n\t//print out results\n\tif (Verbose_Level != LEVEL_SILENT) {\n\t\t//file level perfs\n\t\tcf_trace_report(\"FILE LEVEL:\");\n\t\tcf_trace_report(\"\tFile size: %d kBytes\", (int) File_Size);\n\t\tcf_trace_report(\"\tMax file part size: %d Bytes\", (int) OBEX_pl_size);\n\t\tcf_trace_report(\"\tNumber of file parts: %d\", nb_file_parts);\n\t\tcf_trace_report(\"\t--> Total time between first read and last write:%d us\", total_time);\n\t\tcf_trace_report(\"\t--> Average throughput:%f kbits/s\", average_throughput);\n\t\tcf_trace_report(\"\t--> Average delay between read and OBEX final packet (acknowledge) reception:%f us\",\n\t\t\t\t(double) total_delay_FILE / (double) nb_file_parts);\n\t\tcf_trace_report(\"OBEX LEVEL:\");\n\t\tcf_trace_report(\"\tMaximum frame size:%d Bytes\", (int) OBEX_pl_size + OBEX_HDR_S);\n\t\tcf_trace_report(\"\t--> Number of data frames: %d\", nb_OBEX_df);\n\t\tcf_trace_report(\"\t--> Average delay between data frame send and receive:%f us\", (double) total_delay_OBEX / (double) nb_OBEX_df);\n\t\tcf_trace_report(\"RFCOMM LEVEL:\");\n\t\tcf_trace_report(\"\tMaximum frame size:%d Bytes\", (int) RFCOMM_pl_size + RFCOMM_HDR_S);\n\t\tcf_trace_report(\"\t--> Number of data frames:%d\", nb_RFCOMM_df);\n\t\tcf_trace_report(\"\t--> Average delay between data frame send and receive:%f us\", (double) total_delay_RFCOMM / (double) nb_RFCOMM_df);\n\t\tcf_trace_report(\"\tNumber of credits:%d\", (int) RFCOMM_credits);\n\t\tcf_trace_report(\"\tNumber of credit requests:%d\", nb_cdts_req);\n\t\tcf_trace_report(\"L2CAP LEVEL:\");\n\t\tcf_trace_report(\"\tMaximum frame size:%d Bytes\", (int) RFCOMM_pl_size + RFCOMM_HDR_S + L2CAP_HDR_S);\n\t\tcf_trace_report(\"\t--> Number of data frames:%d\", nb_RFCOMM_df);\n\t\tcf_trace_report(\"\t--> Total amount of data exchanged:%d Bytes\", total_L2CAP_data);\n\t\tcf_trace_report(\"\t--> Average load:%f kbits/s\", 8000.0 * (float) total_L2CAP_data / (float) total_time);\n\t\tcf_trace_report(\"BASEBAND LEVEL:\");\n\t\tcf_trace_report(\"\tAverage throughput:%d kbits/s\", (int) Throughput_BaseBand);\n\t}\n\t//End of 'OPP_UseCase post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_opp_usecase::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_M2S.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_M2S.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_M2S.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M2S.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M2S.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_S2M.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_S2M.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_S2M.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_S2M.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_S2M.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_StartEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_StartEv.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_StartEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_UnusedEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_UnusedEv.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_UnusedEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_opp_usecase::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase initializations' algorithm generated code\n\n\t//End of 'OPP_UseCase initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'StartFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'StartEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_startfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE_STARTFUNC\n#define COFS_MODEL_OPP_USECASE_STARTFUNC\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_startfunc_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'StartFunc includes' algorithm generated code\n\n//End of 'StartFunc includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgStartFunc Function StartFunc\n//@{\n///        \\page dxpStartFunc\n//@{\n///    \\brief StartFunc function model start\nclass cfm_startfunc: public cf_core::cf_function, public cfm_startfunc_dp_if {\npublic:\n\t/// cfm_startfunc type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_startfunc> p_ev_StartEv_t;\n\t/// cfm_startfunc type define end\n\n\t/// constructor\n\tcfm_startfunc(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_startfunc(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_StartEv_t p_ev_StartEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc local declarations' algorithm generated code\n\n\t//End of 'StartFunc local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief StartFunc function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE_STARTFUNC\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'StartFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'StartEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_startfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_startfunc.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_opp_usecase\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_startfunc\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'StartFunc definitions' algorithm generated code\n\n//End of 'StartFunc definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_startfunc::cfm_startfunc(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_startfunc_dp_if()\n, p_ev_StartEv(\"p_ev_StartEv\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc constructor' algorithm generated code\n\n\t//End of 'StartFunc constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_startfunc::~cfm_startfunc(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc destructor' algorithm generated code\n\n\t//End of 'StartFunc destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_startfunc::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc pre elaboration' algorithm generated code\n\n\t//End of 'StartFunc pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_startfunc::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc post elaboration' algorithm generated code\n\n\t//End of 'StartFunc post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_startfunc::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc post simulation' algorithm generated code\n\n\t//End of 'StartFunc post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_startfunc::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_startfunc::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc initializations' algorithm generated code\n\n\t//End of 'StartFunc initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UnusedFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'UnusedEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_unusedfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n#define COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_unusedfunc_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UnusedFunc includes' algorithm generated code\n\n//End of 'UnusedFunc includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUnusedFunc Function UnusedFunc\n//@{\n///        \\page dxpUnusedFunc\n//@{\n///    \\brief UnusedFunc function model start\nclass cfm_unusedfunc: public cf_core::cf_function, public cfm_unusedfunc_dp_if {\npublic:\n\t/// cfm_unusedfunc type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_unusedfunc> p_ev_UnusedEv_t;\n\t/// cfm_unusedfunc type define end\n\n\t/// constructor\n\tcfm_unusedfunc(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_unusedfunc(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_UnusedEv_t p_ev_UnusedEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc local declarations' algorithm generated code\n\n\t//End of 'UnusedFunc local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief UnusedFunc function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UnusedFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'UnusedEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_unusedfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_unusedfunc.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_opp_usecase\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_unusedfunc\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UnusedFunc definitions' algorithm generated code\n\n//End of 'UnusedFunc definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_unusedfunc::cfm_unusedfunc(sc_core::sc_module_name name)\ncf_function(name)\n, cfm_unusedfunc_dp_if()\n, p_ev_UnusedEv(\"p_ev_UnusedEv\")\n\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc constructor' algorithm generated code\n\n\t//End of 'UnusedFunc constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_unusedfunc::~cfm_unusedfunc(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc destructor' algorithm generated code\n\n\t//End of 'UnusedFunc destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_unusedfunc::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc pre elaboration' algorithm generated code\n\n\t//End of 'UnusedFunc pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_unusedfunc::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc post elaboration' algorithm generated code\n\n\t//End of 'UnusedFunc post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_unusedfunc::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc post simulation' algorithm generated code\n\n\t//End of 'UnusedFunc post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_unusedfunc::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_unusedfunc::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc initializations' algorithm generated code\n\n\t//End of 'UnusedFunc initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    }
]