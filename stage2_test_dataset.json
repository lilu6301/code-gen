[
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'SoftwareDefinedRadioApp', 'models': [{'name': 'MobilePhone', 'type': 'cofluent:Function'}, {'name': 'Networks', 'type': 'cofluent:Function'}, {'name': 'User', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Request', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'UMTSToNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Response', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'Video', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToDVB', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'Networks']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_softwaredefinedradioapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_softwaredefinedradioapp_dp_if.h\"\n#include \"cfm_mobilephone.h\"\n#include \"cfm_networks.h\"\n#include \"cfm_user.h\"\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'SoftwareDefinedRadioApp includes' algorithm generated code\n\n//End of 'SoftwareDefinedRadioApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSoftwareDefinedRadioApp Function SoftwareDefinedRadioApp\n//@{\n///        \\page dxpSoftwareDefinedRadioApp\n//@{\n///    \\brief SoftwareDefinedRadioApp function model start\nclass cfm_softwaredefinedradioapp: public cf_core::cf_application,\n\t\tpublic cfm_softwaredefinedradioapp_dp_if {\npublic:\n\t/// cfm_softwaredefinedradioapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_NetToDVB_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_NetToUMTS_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_Request_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_Response_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_UMTSToNet_t;\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_Video_t;\n\n\t/// cfm_softwaredefinedradioapp type define end\n\n\t/// constructor\n\tcfm_softwaredefinedradioapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_softwaredefinedradioapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_mobilephone* MobilePhone;\n\tcfm_networks* Networks;\n\tcfm_user* User;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_NetToDVB_t mq_NetToDVB;\n\tmq_NetToUMTS_t mq_NetToUMTS;\n\tmq_Request_t mq_Request;\n\tmq_Response_t mq_Response;\n\tmq_UMTSToNet_t mq_UMTSToNet;\n\tmq_Video_t mq_Video;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SoftwareDefinedRadioApp local declarations' algorithm generated code\n\n\t//End of 'SoftwareDefinedRadioApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief SoftwareDefinedRadioApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'SoftwareDefinedRadioApp', 'models': [{'name': 'MobilePhone', 'type': 'cofluent:Function'}, {'name': 'Networks', 'type': 'cofluent:Function'}, {'name': 'User', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Request', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'UMTSToNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Response', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'Video', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'User']}, {'name': 'NetToDVB', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'Networks']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_softwaredefinedradioapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_softwaredefinedradioapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'SoftwareDefinedRadioApp definitions' algorithm generated code\n\n//End of 'SoftwareDefinedRadioApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_softwaredefinedradioapp::cfm_softwaredefinedradioapp(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), cfm_softwaredefinedradioapp_dp_if(), mq_NetToDVB(\n\t\t\t\t\"NetToDVB\"), mq_NetToUMTS(\"NetToUMTS\"), mq_Request(\"Request\"), mq_Response(\n\t\t\t\t\"Response\"), mq_UMTSToNet(\"UMTSToNet\"), mq_Video(\"Video\") {\n\tcf_application::init();\n\tMobilePhone = new cfm_mobilephone(\"MobilePhone\");\n\tNetworks = new cfm_networks(\"Networks\");\n\tUser = new cfm_user(\"User\");\n\n\t// connections\n\tMobilePhone->p_mq_NetToDVB(mq_NetToDVB.p_target_socket);\n\tMobilePhone->p_mq_Video(mq_Video.p_target_socket);\n\tMobilePhone->p_mq_NetToUMTS(mq_NetToUMTS.p_target_socket);\n\tMobilePhone->p_mq_UMTSToNet(mq_UMTSToNet.p_target_socket);\n\tMobilePhone->p_mq_Response(mq_Response.p_target_socket);\n\tMobilePhone->p_mq_Request(mq_Request.p_target_socket);\n\n\tNetworks->p_mq_NetToDVB(mq_NetToDVB.p_target_socket);\n\tNetworks->p_mq_NetToUMTS(mq_NetToUMTS.p_target_socket);\n\tNetworks->p_mq_UMTSToNet(mq_UMTSToNet.p_target_socket);\n\n\tUser->p_mq_Video(mq_Video.p_target_socket);\n\tUser->p_mq_Response(mq_Response.p_target_socket);\n\tUser->p_mq_Request_0(mq_Request.p_target_socket);\n\tUser->p_mq_Request_1(mq_Request.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SoftwareDefinedRadioApp constructor' algorithm generated code\n\n\t//End of 'SoftwareDefinedRadioApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_softwaredefinedradioapp::~cfm_softwaredefinedradioapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SoftwareDefinedRadioApp destructor' algorithm generated code\n\n\t//End of 'SoftwareDefinedRadioApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete MobilePhone;\n\tdelete Networks;\n\tdelete User;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_softwaredefinedradioapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SoftwareDefinedRadioApp pre elaboration' algorithm generated code\n\n\t//End of 'SoftwareDefinedRadioApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_softwaredefinedradioapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'SoftwareDefinedRadioApp post elaboration' algorithm generated code\n\n//End of 'SoftwareDefinedRadioApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_softwaredefinedradioapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SoftwareDefinedRadioApp post simulation' algorithm generated code\n\tcf_trace_report(\n\t\t\t\"************************************************************\");\n\tcf_trace_report(\"Frames = %i\", TotalFrames);\n\tcf_trace_gui_f_param(\"Frames\", (int) TotalFrames);\n\tif (TotalFrames > 0) {\n\t\tcf_trace_report(\"AverageFrameLatency = %i ms\",\n\t\t\t\t(int) (AverageFrameLatency.to_scalar(CF_MS) / TotalFrames));\n\t\tcf_trace_gui_f_param(\"AverageFrameLatency\",\n\t\t\t\t(int) (AverageFrameLatency.to_scalar(CF_MS) / TotalFrames),\n\t\t\t\t\"ms\");\n\t}\n\tcf_trace_report(\"TotalSizeFrames = %i MB\",\n\t\t\t(int) TotalSizeFrames.to_scalar(CF_MBYTE));\n\tcf_trace_gui_f_param(\"TotalFramesSize\",\n\t\t\t(int) TotalSizeFrames.to_scalar(CF_MBYTE), \"MB\");\n\tcf_trace_report(\"Bursts = %i\", TotalBursts);\n\tcf_trace_gui_f_param(\"Bursts\", (int) TotalBursts);\n\tif (TotalBursts > 0) {\n\t\tcf_trace_report(\"AverageBurstLatency = %i ms\",\n\t\t\t\t(int) (AverageBurstLatency.to_scalar(CF_MS) / TotalBursts));\n\t\tcf_trace_gui_f_param(\"AverageBurstLatency\",\n\t\t\t\t(int) (AverageBurstLatency.to_scalar(CF_MS) / TotalBursts),\n\t\t\t\t\"ms\");\n\t}\n\tcf_trace_report(\n\t\t\t\"************************************************************\");\n\t//End of 'SoftwareDefinedRadioApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_softwaredefinedradioapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_NetToDVB.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToDVB.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToDVB.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_NetToDVB.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_NetToDVB.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_NetToUMTS.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToUMTS.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_NetToUMTS.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_NetToUMTS.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_NetToUMTS.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Request.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Request.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Request.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Request.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Request.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Response.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Response.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_Response.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Response.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Response.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_UMTSToNet.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToNet.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToNet.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_UMTSToNet.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_UMTSToNet.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Video.cfa_send_time.init(cf_expr_duration(1, CF_MS));\n\tmq_Video.cfa_receive_time.init(cf_expr_duration(1, CF_MS));\n\tmq_Video.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Video.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Video.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_softwaredefinedradioapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SoftwareDefinedRadioApp initializations' algorithm generated code\n\n\t//End of 'SoftwareDefinedRadioApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MobilePhone', 'type': 'cofluent:Function', 'models': [{'name': 'ApplicationLayer', 'type': 'cofluent:Function'}, {'name': 'CallProtocolStack', 'type': 'cofluent:Function'}, {'name': 'VideoProtocolStack', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoProtocolStack']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}], 'relations': [{'name': 'AppToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'HTTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'AppToCtrl', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'Controller']}, {'name': 'RTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer', 'VideoProtocolStack']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mobilephone\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_mobilephone_dp_if.h\"\n#include \"cfm_applicationlayer.h\"\n#include \"cfm_callprotocolstack.h\"\n#include \"cfm_controller.h\"\n#include \"cfm_videoprotocolstack.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MobilePhone includes' algorithm generated code\n\n//End of 'MobilePhone includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMobilePhone Function MobilePhone\n//@{\n///        \\page dxpMobilePhone\n//@{\n///    \\brief MobilePhone function model start\nclass cfm_mobilephone: public cf_core::cf_function_container,\n\t\tpublic cfm_mobilephone_dp_if {\npublic:\n\t/// cfm_mobilephone type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_AppToCtrl_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_AppToHTTP_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_HTTPToApp_t;\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_RTPToApp_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_UMTSToNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cft_defcall> p_mq_Request_t;\n\t/// cfm_mobilephone type define end\n\n\t/// constructor\n\tcfm_mobilephone(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_mobilephone(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_t p_mq_Request;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_applicationlayer* ApplicationLayer;\n\tcfm_callprotocolstack* CallProtocolStack;\n\tcfm_controller* Controller;\n\tcfm_videoprotocolstack* VideoProtocolStack;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_AppToCtrl_t mq_AppToCtrl;\n\tmq_AppToHTTP_t mq_AppToHTTP;\n\tmq_HTTPToApp_t mq_HTTPToApp;\n\tmq_RTPToApp_t mq_RTPToApp;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MobilePhone local declarations' algorithm generated code\n\n\t//End of 'MobilePhone local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MobilePhone function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MobilePhone', 'type': 'cofluent:Function', 'models': [{'name': 'ApplicationLayer', 'type': 'cofluent:Function'}, {'name': 'CallProtocolStack', 'type': 'cofluent:Function'}, {'name': 'VideoProtocolStack', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoProtocolStack']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}], 'relations': [{'name': 'AppToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'HTTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'AppToCtrl', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'Controller']}, {'name': 'RTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer', 'VideoProtocolStack']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mobilephone\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mobilephone.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mobilephone\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MobilePhone definitions' algorithm generated code\n\n//End of 'MobilePhone definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mobilephone::cfm_mobilephone(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_mobilephone_dp_if(), p_mq_NetToDVB(\n\t\t\t\t\"p_mq_NetToDVB\"), p_mq_Video(\"p_mq_Video\"), p_mq_NetToUMTS(\n\t\t\t\t\"p_mq_NetToUMTS\"), p_mq_UMTSToNet(\"p_mq_UMTSToNet\"), p_mq_Response(\n\t\t\t\t\"p_mq_Response\"), p_mq_Request(\"p_mq_Request\"), mq_AppToCtrl(\n\t\t\t\t\"AppToCtrl\"), mq_AppToHTTP(\"AppToHTTP\"), mq_HTTPToApp(\n\t\t\t\t\"HTTPToApp\"), mq_RTPToApp(\"RTPToApp\") {\n\tcf_function_container::init();\n\tApplicationLayer = new cfm_applicationlayer(\"ApplicationLayer\");\n\tCallProtocolStack = new cfm_callprotocolstack(\"CallProtocolStack\");\n\tController = new cfm_controller(\"Controller\");\n\tVideoProtocolStack = new cfm_videoprotocolstack(\"VideoProtocolStack\");\n\n\t// connections\n\tApplicationLayer->p_mq_Video(p_mq_Video);\n\tApplicationLayer->p_mq_RTPToApp(mq_RTPToApp.p_target_socket);\n\tApplicationLayer->p_mq_AppToCtrl(mq_AppToCtrl.p_target_socket);\n\tApplicationLayer->p_mq_HTTPToApp(mq_HTTPToApp.p_target_socket);\n\tApplicationLayer->p_mq_AppToHTTP(mq_AppToHTTP.p_target_socket);\n\tApplicationLayer->p_mq_Response(p_mq_Response);\n\tApplicationLayer->p_mq_Request(p_mq_Request);\n\n\tCallProtocolStack->p_mq_NetToUMTS(p_mq_NetToUMTS);\n\tCallProtocolStack->p_mq_UMTSToNet(p_mq_UMTSToNet);\n\tCallProtocolStack->p_mq_HTTPToApp(mq_HTTPToApp.p_target_socket);\n\tCallProtocolStack->p_mq_AppToHTTP(mq_AppToHTTP.p_target_socket);\n\n\tController->p_mq_AppToCtrl(mq_AppToCtrl.p_target_socket);\n\n\tVideoProtocolStack->p_mq_NetToDVB(p_mq_NetToDVB);\n\tVideoProtocolStack->p_mq_RTPToApp(mq_RTPToApp.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MobilePhone constructor' algorithm generated code\n\n\t//End of 'MobilePhone constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mobilephone::~cfm_mobilephone(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MobilePhone destructor' algorithm generated code\n\n\t//End of 'MobilePhone destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ApplicationLayer;\n\tdelete CallProtocolStack;\n\tdelete Controller;\n\tdelete VideoProtocolStack;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_mobilephone::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MobilePhone pre elaboration' algorithm generated code\n\n\t//End of 'MobilePhone pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_mobilephone::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MobilePhone post elaboration' algorithm generated code\n\n\t//End of 'MobilePhone post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_mobilephone::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MobilePhone post simulation' algorithm generated code\n\n\t//End of 'MobilePhone post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_mobilephone::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_AppToCtrl.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToCtrl.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToCtrl.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_AppToCtrl.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_AppToCtrl.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_AppToHTTP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToHTTP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_AppToHTTP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_AppToHTTP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_AppToHTTP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_HTTPToApp.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToApp.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToApp.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_HTTPToApp.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_HTTPToApp.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RTPToApp.cfa_send_time.init(cf_expr_duration(100, CF_US));\n\tmq_RTPToApp.cfa_receive_time.init(cf_expr_duration(1, CF_MS));\n\tmq_RTPToApp.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RTPToApp.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RTPToApp.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_mobilephone::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MobilePhone initializations' algorithm generated code\n\n\t//End of 'MobilePhone initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Networks', 'type': 'cofluent:Function', 'models': [{'name': 'InteractiveNetwork', 'type': 'cofluent:Function'}, {'name': 'BroadcastNetwork', 'type': 'cofluent:Function'}, {'name': 'ClockGenerator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['BroadcastNetwork']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}], 'relations': [{'name': 'VideoNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'VideoFiles', 'type': 'cofluent:SharedVariable', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'BurstClock', 'type': 'cofluent:Event', 'connectTo': ['BroadcastNetwork', 'ClockGenerator']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_networks\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_networks_dp_if.h\"\n#include \"cfm_broadcastnetwork.h\"\n#include \"cfm_clockgenerator.h\"\n#include \"cfm_interactivenetwork.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defnet.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Networks includes' algorithm generated code\n\n//End of 'Networks includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgNetworks Function Networks\n//@{\n///        \\page dxpNetworks\n//@{\n///    \\brief Networks function model start\nclass cfm_networks: public cf_core::cf_function_container,\n\t\tpublic cfm_networks_dp_if {\npublic:\n\t/// cfm_networks type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_event ev_BurstClock_t;\n\ttypedef cf_core::cf_shared_variable<cft_defnet> sv_VideoFiles_t;\n\ttypedef cf_core::cf_message_queue<cft_defnet> mq_VideoNet_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_networks, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_networks, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_networks, cft_defcall> p_mq_UMTSToNet_t;\n\t/// cfm_networks type define end\n\n\t/// constructor\n\tcfm_networks(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_networks(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_broadcastnetwork* BroadcastNetwork;\n\tcfm_clockgenerator* ClockGenerator;\n\tcfm_interactivenetwork* InteractiveNetwork;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tev_BurstClock_t ev_BurstClock;\n\tsv_VideoFiles_t sv_VideoFiles;\n\tmq_VideoNet_t mq_VideoNet;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Networks local declarations' algorithm generated code\n\tDefNet initSem;\n\t//End of 'Networks local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Networks function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Networks', 'type': 'cofluent:Function', 'models': [{'name': 'InteractiveNetwork', 'type': 'cofluent:Function'}, {'name': 'BroadcastNetwork', 'type': 'cofluent:Function'}, {'name': 'ClockGenerator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['BroadcastNetwork']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}], 'relations': [{'name': 'VideoNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'VideoFiles', 'type': 'cofluent:SharedVariable', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'BurstClock', 'type': 'cofluent:Event', 'connectTo': ['BroadcastNetwork', 'ClockGenerator']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_networks\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_networks.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_networks\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Networks definitions' algorithm generated code\n\n//End of 'Networks definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_networks::cfm_networks(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_networks_dp_if(), p_mq_NetToDVB(\n\t\t\t\t\"p_mq_NetToDVB\"), p_mq_NetToUMTS(\"p_mq_NetToUMTS\"), p_mq_UMTSToNet(\n\t\t\t\t\"p_mq_UMTSToNet\"), ev_BurstClock(\"BurstClock\"), sv_VideoFiles(\n\t\t\t\t\"VideoFiles\"), mq_VideoNet(\"VideoNet\") {\n\tcf_function_container::init();\n\tBroadcastNetwork = new cfm_broadcastnetwork(\"BroadcastNetwork\");\n\tClockGenerator = new cfm_clockgenerator(\"ClockGenerator\");\n\tInteractiveNetwork = new cfm_interactivenetwork(\"InteractiveNetwork\");\n\n\t// connections\n\tBroadcastNetwork->p_mq_NetToDVB(p_mq_NetToDVB);\n\tBroadcastNetwork->p_ev_BurstClock(ev_BurstClock.p_target_socket);\n\tBroadcastNetwork->p_sv_VideoFiles(sv_VideoFiles.p_target_socket);\n\tBroadcastNetwork->p_mq_VideoNet(mq_VideoNet.p_target_socket);\n\n\tClockGenerator->p_ev_BurstClock(ev_BurstClock.p_target_socket);\n\n\tInteractiveNetwork->p_sv_VideoFiles(sv_VideoFiles.p_target_socket);\n\tInteractiveNetwork->p_mq_VideoNet(mq_VideoNet.p_target_socket);\n\tInteractiveNetwork->p_mq_NetToUMTS(p_mq_NetToUMTS);\n\tInteractiveNetwork->p_mq_UMTSToNet(p_mq_UMTSToNet);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Networks constructor' algorithm generated code\n\n\t//End of 'Networks constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_networks::~cfm_networks(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Networks destructor' algorithm generated code\n\n\t//End of 'Networks destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BroadcastNetwork;\n\tdelete ClockGenerator;\n\tdelete InteractiveNetwork;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_networks::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Networks pre elaboration' algorithm generated code\n\n\t//End of 'Networks pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_networks::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Networks post elaboration' algorithm generated code\n\n\t//End of 'Networks post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_networks::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Networks post simulation' algorithm generated code\n\n\t//End of 'Networks post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_networks::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tev_BurstClock.cfa_set_time.init(cf_expr_duration(0, CF_MS));\n\tev_BurstClock.cfa_get_time.init(cf_expr_duration(0, CF_MS));\n\tev_BurstClock.cfa_event_policy.init(CF_EV_POLICY_FUGITIVE);\n\tsv_VideoFiles.cfa_write_time.init(cf_expr_duration(10, CF_MS));\n\tsv_VideoFiles.cfa_read_time.init(cf_expr_duration(10, CF_MS));\n\tsv_VideoFiles.cfa_semaphore.init(false);\n\tsv_VideoFiles.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_VideoNet.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_VideoNet.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_VideoNet.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_VideoNet.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_VideoNet.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_networks::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Networks initializations' algorithm generated code\n\tsv_VideoFiles.init_value(initSem);\n\t//End of 'Networks initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'User', 'type': 'cofluent:Function', 'models': [{'name': 'Requesting', 'type': 'cofluent:Function'}, {'name': 'Watching', 'type': 'cofluent:Function'}, {'name': 'Reading', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['Watching']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['Reading']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['Requesting', 'Reading']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_user\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_user_dp_if.h\"\n#include \"cfm_reading.h\"\n#include \"cfm_requesting.h\"\n#include \"cfm_watching.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'User includes' algorithm generated code\n\n//End of 'User includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUser Function User\n//@{\n///        \\page dxpUser\n//@{\n///    \\brief User function model start\nclass cfm_user: public cf_core::cf_function_container, public cfm_user_dp_if {\npublic:\n\t/// cfm_user type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defcall> p_mq_Request_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_user, cft_defcall> p_mq_Request_1_t;\n\t/// cfm_user type define end\n\n\t/// constructor\n\tcfm_user(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_user(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_0_t p_mq_Request_0;\n\tp_mq_Request_1_t p_mq_Request_1;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_reading* Reading;\n\tcfm_requesting* Requesting;\n\tcfm_watching* Watching;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'User local declarations' algorithm generated code\n\n\t//End of 'User local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief User function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'User', 'type': 'cofluent:Function', 'models': [{'name': 'Requesting', 'type': 'cofluent:Function'}, {'name': 'Watching', 'type': 'cofluent:Function'}, {'name': 'Reading', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['Watching']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['Reading']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['Requesting', 'Reading']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_user\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_user.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_user\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'User definitions' algorithm generated code\n\n//End of 'User definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_user::cfm_user(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_user_dp_if(), p_mq_Video(\"p_mq_Video\"), p_mq_Response(\n\t\t\t\t\"p_mq_Response\"), p_mq_Request_0(\"p_mq_Request_0\"), p_mq_Request_1(\n\t\t\t\t\"p_mq_Request_1\") {\n\tcf_function_container::init();\n\tReading = new cfm_reading(\"Reading\");\n\tRequesting = new cfm_requesting(\"Requesting\");\n\tWatching = new cfm_watching(\"Watching\");\n\n\t// connections\n\tReading->p_mq_Request(p_mq_Request_1);\n\tReading->p_mq_Response(p_mq_Response);\n\n\tRequesting->p_mq_Request(p_mq_Request_0);\n\n\tWatching->p_mq_Video(p_mq_Video);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'User constructor' algorithm generated code\n\n\t//End of 'User constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_user::~cfm_user(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'User destructor' algorithm generated code\n\n\t//End of 'User destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Reading;\n\tdelete Requesting;\n\tdelete Watching;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_user::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'User pre elaboration' algorithm generated code\n\n\t//End of 'User pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_user::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'User post elaboration' algorithm generated code\n\n\t//End of 'User post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_user::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'User post simulation' algorithm generated code\n\n\t//End of 'User post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_user::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_user::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'User initializations' algorithm generated code\n\n\t//End of 'User initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationLayer', 'type': 'cofluent:Function', 'models': [{'name': 'CallApplication', 'type': 'cofluent:Function'}, {'name': 'VideoApplication', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}, {'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationlayer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationlayer_dp_if.h\"\n#include \"cfm_callapplication.h\"\n#include \"cfm_videoapplication.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationLayer includes' algorithm generated code\n\n//End of 'ApplicationLayer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationLayer Function ApplicationLayer\n//@{\n///        \\page dxpApplicationLayer\n//@{\n///    \\brief ApplicationLayer function model start\nclass cfm_applicationlayer: public cf_core::cf_function_container,\n\t\tpublic cfm_applicationlayer_dp_if {\npublic:\n\t/// cfm_applicationlayer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defvideo> p_mq_RTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_AppToCtrl_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_AppToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cft_defcall> p_mq_Request_t;\n\t/// cfm_applicationlayer type define end\n\n\t/// constructor\n\tcfm_applicationlayer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_applicationlayer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\tp_mq_AppToCtrl_t p_mq_AppToCtrl;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_t p_mq_Request;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_callapplication* CallApplication;\n\tcfm_videoapplication* VideoApplication;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationLayer local declarations' algorithm generated code\n\n\t//End of 'ApplicationLayer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ApplicationLayer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationLayer', 'type': 'cofluent:Function', 'models': [{'name': 'CallApplication', 'type': 'cofluent:Function'}, {'name': 'VideoApplication', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}, {'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationlayer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationlayer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_applicationlayer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationLayer definitions' algorithm generated code\n\n//End of 'ApplicationLayer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationlayer::cfm_applicationlayer(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_applicationlayer_dp_if(), p_mq_Video(\n\t\t\t\t\"p_mq_Video\"), p_mq_RTPToApp(\"p_mq_RTPToApp\"), p_mq_AppToCtrl(\n\t\t\t\t\"p_mq_AppToCtrl\"), p_mq_HTTPToApp(\"p_mq_HTTPToApp\"), p_mq_AppToHTTP(\n\t\t\t\t\"p_mq_AppToHTTP\"), p_mq_Response(\"p_mq_Response\"), p_mq_Request(\n\t\t\t\t\"p_mq_Request\") {\n\tcf_function_container::init();\n\tCallApplication = new cfm_callapplication(\"CallApplication\");\n\tVideoApplication = new cfm_videoapplication(\"VideoApplication\");\n\n\t// connections\n\tCallApplication->p_mq_AppToCtrl(p_mq_AppToCtrl);\n\tCallApplication->p_mq_HTTPToApp(p_mq_HTTPToApp);\n\tCallApplication->p_mq_AppToHTTP(p_mq_AppToHTTP);\n\tCallApplication->p_mq_Response(p_mq_Response);\n\tCallApplication->p_mq_Request(p_mq_Request);\n\n\tVideoApplication->p_mq_Video(p_mq_Video);\n\tVideoApplication->p_mq_RTPToApp(p_mq_RTPToApp);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationLayer constructor' algorithm generated code\n\n\t//End of 'ApplicationLayer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationlayer::~cfm_applicationlayer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationLayer destructor' algorithm generated code\n\n\t//End of 'ApplicationLayer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete CallApplication;\n\tdelete VideoApplication;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_applicationlayer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationLayer pre elaboration' algorithm generated code\n\n\t//End of 'ApplicationLayer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_applicationlayer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationLayer post elaboration' algorithm generated code\n\n\t//End of 'ApplicationLayer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_applicationlayer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationLayer post simulation' algorithm generated code\n\n\t//End of 'ApplicationLayer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_applicationlayer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_applicationlayer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationLayer initializations' algorithm generated code\n\n\t//End of 'ApplicationLayer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CallProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP', 'type': 'cofluent:Function'}, {'name': 'IPCall', 'type': 'cofluent:Function'}, {'name': 'UMTS', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}], 'relations': [{'name': 'HTTPToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}, {'name': 'UMTSToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_callprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_callprotocolstack_dp_if.h\"\n#include \"cfm_httptcp.h\"\n#include \"cfm_ipcall.h\"\n#include \"cfm_umts.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CallProtocolStack includes' algorithm generated code\n\n//End of 'CallProtocolStack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCallProtocolStack Function CallProtocolStack\n//@{\n///        \\page dxpCallProtocolStack\n//@{\n///    \\brief CallProtocolStack function model start\nclass cfm_callprotocolstack: public cf_core::cf_function_container,\n\t\tpublic cfm_callprotocolstack_dp_if {\npublic:\n\t/// cfm_callprotocolstack type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_HTTPToIP_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_IPToHTTP_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_IPToUMTS_t;\n\ttypedef cf_core::cf_message_queue<cft_defcall> mq_UMTSToIP_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_UMTSToNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cft_defcall> p_mq_AppToHTTP_t;\n\t/// cfm_callprotocolstack type define end\n\n\t/// constructor\n\tcfm_callprotocolstack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_callprotocolstack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_httptcp* HTTPTCP;\n\tcfm_ipcall* IPCall;\n\tcfm_umts* UMTS;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_HTTPToIP_t mq_HTTPToIP;\n\tmq_IPToHTTP_t mq_IPToHTTP;\n\tmq_IPToUMTS_t mq_IPToUMTS;\n\tmq_UMTSToIP_t mq_UMTSToIP;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallProtocolStack local declarations' algorithm generated code\n\n\t//End of 'CallProtocolStack local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CallProtocolStack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CallProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP', 'type': 'cofluent:Function'}, {'name': 'IPCall', 'type': 'cofluent:Function'}, {'name': 'UMTS', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}], 'relations': [{'name': 'HTTPToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}, {'name': 'UMTSToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_callprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_callprotocolstack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_callprotocolstack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CallProtocolStack definitions' algorithm generated code\n\n//End of 'CallProtocolStack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_callprotocolstack::cfm_callprotocolstack(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_callprotocolstack_dp_if(), p_mq_NetToUMTS(\n\t\t\t\t\"p_mq_NetToUMTS\"), p_mq_UMTSToNet(\"p_mq_UMTSToNet\"), p_mq_HTTPToApp(\n\t\t\t\t\"p_mq_HTTPToApp\"), p_mq_AppToHTTP(\"p_mq_AppToHTTP\"), mq_HTTPToIP(\n\t\t\t\t\"HTTPToIP\"), mq_IPToHTTP(\"IPToHTTP\"), mq_IPToUMTS(\"IPToUMTS\"), mq_UMTSToIP(\n\t\t\t\t\"UMTSToIP\") {\n\tcf_function_container::init();\n\tHTTPTCP = new cfm_httptcp(\"HTTPTCP\");\n\tIPCall = new cfm_ipcall(\"IPCall\");\n\tUMTS = new cfm_umts(\"UMTS\");\n\n\t// connections\n\tHTTPTCP->p_mq_IPToHTTP(mq_IPToHTTP.p_target_socket);\n\tHTTPTCP->p_mq_HTTPToIP(mq_HTTPToIP.p_target_socket);\n\tHTTPTCP->p_mq_HTTPToApp(p_mq_HTTPToApp);\n\tHTTPTCP->p_mq_AppToHTTP(p_mq_AppToHTTP);\n\n\tIPCall->p_mq_UMTSToIP(mq_UMTSToIP.p_target_socket);\n\tIPCall->p_mq_IPToUMTS(mq_IPToUMTS.p_target_socket);\n\tIPCall->p_mq_IPToHTTP(mq_IPToHTTP.p_target_socket);\n\tIPCall->p_mq_HTTPToIP(mq_HTTPToIP.p_target_socket);\n\n\tUMTS->p_mq_UMTSToIP(mq_UMTSToIP.p_target_socket);\n\tUMTS->p_mq_NetToUMTS(p_mq_NetToUMTS);\n\tUMTS->p_mq_UMTSToNet(p_mq_UMTSToNet);\n\tUMTS->p_mq_IPToUMTS(mq_IPToUMTS.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallProtocolStack constructor' algorithm generated code\n\n\t//End of 'CallProtocolStack constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_callprotocolstack::~cfm_callprotocolstack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallProtocolStack destructor' algorithm generated code\n\n\t//End of 'CallProtocolStack destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete HTTPTCP;\n\tdelete IPCall;\n\tdelete UMTS;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_callprotocolstack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallProtocolStack pre elaboration' algorithm generated code\n\n\t//End of 'CallProtocolStack pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_callprotocolstack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallProtocolStack post elaboration' algorithm generated code\n\n\t//End of 'CallProtocolStack post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_callprotocolstack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallProtocolStack post simulation' algorithm generated code\n\n\t//End of 'CallProtocolStack post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_callprotocolstack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_HTTPToIP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToIP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_HTTPToIP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_HTTPToIP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_HTTPToIP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_IPToHTTP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToHTTP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToHTTP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_IPToHTTP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_IPToHTTP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_IPToUMTS.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToUMTS.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_IPToUMTS.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_IPToUMTS.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_IPToUMTS.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_UMTSToIP.cfa_send_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToIP.cfa_receive_time.init(cf_expr_duration(10, CF_MS));\n\tmq_UMTSToIP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_UMTSToIP.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_UMTSToIP.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_callprotocolstack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallProtocolStack initializations' algorithm generated code\n\n\t//End of 'CallProtocolStack initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VideoProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'RTPUDP', 'type': 'cofluent:Function'}, {'name': 'IPVideo', 'type': 'cofluent:Function'}, {'name': 'MPETSL', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['MPETSL']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP']}], 'relations': [{'name': 'MPEToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['IPVideo', 'MPETSL']}, {'name': 'IPToRTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP', 'IPVideo']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_videoprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_videoprotocolstack_dp_if.h\"\n#include \"cfm_ipvideo.h\"\n#include \"cfm_mpetsl.h\"\n#include \"cfm_rtpudp.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'VideoProtocolStack includes' algorithm generated code\n\n//End of 'VideoProtocolStack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgVideoProtocolStack Function VideoProtocolStack\n//@{\n///        \\page dxpVideoProtocolStack\n//@{\n///    \\brief VideoProtocolStack function model start\nclass cfm_videoprotocolstack: public cf_core::cf_function_container,\n\t\tpublic cfm_videoprotocolstack_dp_if {\npublic:\n\t/// cfm_videoprotocolstack type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_IPToRTP_t;\n\ttypedef cf_core::cf_message_queue<cft_defvideo> mq_MPEToIP_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoprotocolstack, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoprotocolstack, cft_defvideo> p_mq_RTPToApp_t;\n\t/// cfm_videoprotocolstack type define end\n\n\t/// constructor\n\tcfm_videoprotocolstack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_videoprotocolstack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_ipvideo* IPVideo;\n\tcfm_mpetsl* MPETSL;\n\tcfm_rtpudp* RTPUDP;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_IPToRTP_t mq_IPToRTP;\n\tmq_MPEToIP_t mq_MPEToIP;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoProtocolStack local declarations' algorithm generated code\n\n\t//End of 'VideoProtocolStack local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief VideoProtocolStack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VideoProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'RTPUDP', 'type': 'cofluent:Function'}, {'name': 'IPVideo', 'type': 'cofluent:Function'}, {'name': 'MPETSL', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['MPETSL']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP']}], 'relations': [{'name': 'MPEToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['IPVideo', 'MPETSL']}, {'name': 'IPToRTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP', 'IPVideo']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_videoprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_videoprotocolstack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'VideoProtocolStack definitions' algorithm generated code\n\n//End of 'VideoProtocolStack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_videoprotocolstack::cfm_videoprotocolstack(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_videoprotocolstack_dp_if(), p_mq_NetToDVB(\n\t\t\t\t\"p_mq_NetToDVB\"), p_mq_RTPToApp(\"p_mq_RTPToApp\"), mq_IPToRTP(\n\t\t\t\t\"IPToRTP\"), mq_MPEToIP(\"MPEToIP\") {\n\tcf_function_container::init();\n\tIPVideo = new cfm_ipvideo(\"IPVideo\");\n\tMPETSL = new cfm_mpetsl(\"MPETSL\");\n\tRTPUDP = new cfm_rtpudp(\"RTPUDP\");\n\n\t// connections\n\tIPVideo->p_mq_IPToRTP(mq_IPToRTP.p_target_socket);\n\tIPVideo->p_mq_MPEToIP(mq_MPEToIP.p_target_socket);\n\n\tMPETSL->p_mq_NetToDVB(p_mq_NetToDVB);\n\tMPETSL->p_mq_MPEToIP(mq_MPEToIP.p_target_socket);\n\n\tRTPUDP->p_mq_RTPToApp(p_mq_RTPToApp);\n\tRTPUDP->p_mq_IPToRTP(mq_IPToRTP.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoProtocolStack constructor' algorithm generated code\n\n\t//End of 'VideoProtocolStack constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_videoprotocolstack::~cfm_videoprotocolstack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoProtocolStack destructor' algorithm generated code\n\n\t//End of 'VideoProtocolStack destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete IPVideo;\n\tdelete MPETSL;\n\tdelete RTPUDP;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_videoprotocolstack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoProtocolStack pre elaboration' algorithm generated code\n\n\t//End of 'VideoProtocolStack pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_videoprotocolstack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoProtocolStack post elaboration' algorithm generated code\n\n\t//End of 'VideoProtocolStack post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_videoprotocolstack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoProtocolStack post simulation' algorithm generated code\n\n\t//End of 'VideoProtocolStack post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_videoprotocolstack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_IPToRTP.cfa_send_time.init(cf_expr_duration(100, CF_US));\n\tmq_IPToRTP.cfa_receive_time.init(cf_expr_duration(100, CF_US));\n\tmq_IPToRTP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_IPToRTP.cfa_queue_capacity.init((cf_nonzero_count) FramesBufferSize);\n\tmq_IPToRTP.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MPEToIP.cfa_send_time.init(cf_expr_duration(1, CF_MS));\n\tmq_MPEToIP.cfa_receive_time.init(cf_expr_duration(1, CF_MS));\n\tmq_MPEToIP.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MPEToIP.cfa_queue_capacity.init((cf_nonzero_count) BurstBufferSize);\n\tmq_MPEToIP.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_videoprotocolstack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoProtocolStack initializations' algorithm generated code\n\n\t//End of 'VideoProtocolStack initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_controller_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Controller includes' algorithm generated code\n\n//End of 'Controller includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgController Function Controller\n//@{\n///        \\page dxpController\n//@{\n///    \\brief Controller function model start\nclass cfm_controller: public cf_core::cf_function, public cfm_controller_dp_if {\npublic:\n\t/// cfm_controller type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_controller, cft_defcall> p_mq_AppToCtrl_t;\n\t/// cfm_controller type define end\n\n\t/// constructor\n\tcfm_controller(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_controller(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_AppToCtrl_t p_mq_AppToCtrl;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller local declarations' algorithm generated code\n\tbool SendToCallStack;\n\tbool SendToVideoStack;\n\t//End of 'Controller local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Controller function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_controller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_controller\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Controller definitions' algorithm generated code\n\n//End of 'Controller definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_controller::cfm_controller(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_controller_dp_if(), p_mq_AppToCtrl(\n\t\t\t\t\"p_mq_AppToCtrl\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller constructor' algorithm generated code\n\n\t//End of 'Controller constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_controller::~cfm_controller(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller destructor' algorithm generated code\n\n\t//End of 'Controller destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_controller::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller pre elaboration' algorithm generated code\n\n\t//End of 'Controller pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_controller::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller post elaboration' algorithm generated code\n\n\t//End of 'Controller post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_controller::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller post simulation' algorithm generated code\n\n\t//End of 'Controller post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_controller::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_controller::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller initializations' algorithm generated code\n\n\t//End of 'Controller initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InteractiveNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefNet'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_interactivenetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_interactivenetwork_dp_if.h\"\n#include \"dt/cft_defnet.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InteractiveNetwork includes' algorithm generated code\n\n//End of 'InteractiveNetwork includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInteractiveNetwork Function InteractiveNetwork\n//@{\n///        \\page dxpInteractiveNetwork\n//@{\n///    \\brief InteractiveNetwork function model start\nclass cfm_interactivenetwork: public cf_core::cf_function,\n\t\tpublic cfm_interactivenetwork_dp_if {\npublic:\n\t/// cfm_interactivenetwork type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_interactivenetwork, cft_defnet> p_sv_VideoFiles_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_interactivenetwork, cft_defnet> p_mq_VideoNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_interactivenetwork, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_interactivenetwork, cft_defcall> p_mq_UMTSToNet_t;\n\t/// cfm_interactivenetwork type define end\n\n\t/// constructor\n\tcfm_interactivenetwork(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_interactivenetwork(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_VideoFiles_t p_sv_VideoFiles;\n\tp_mq_VideoNet_t p_mq_VideoNet;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InteractiveNetwork local declarations' algorithm generated code\n\tint StartSize;\n\tint EndSize;\n\tint FileSize;\n\n\tbool FileRequest;\n\tbool ExitLoop;\n\tbool Sending;\n\tbool FullLink;\n\tbool ExitWaiting;\n\n\tint VideoIndex;\n\tint index;\n\tint VideoSendIndex;\n\n\tDefVideoIndex VideoInd[4];\n\tDefFramesInBurst FramesInBurst[4];\n\tDefBurstsInVideo BurstsInVideo[4];\n\t//End of 'InteractiveNetwork local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief InteractiveNetwork function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InteractiveNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefNet'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_interactivenetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_interactivenetwork.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_interactivenetwork\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InteractiveNetwork definitions' algorithm generated code\n\n//End of 'InteractiveNetwork definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_interactivenetwork::cfm_interactivenetwork(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_interactivenetwork_dp_if(), p_sv_VideoFiles(\n\t\t\t\t\"p_sv_VideoFiles\"), p_mq_VideoNet(\"p_mq_VideoNet\"), p_mq_NetToUMTS(\n\t\t\t\t\"p_mq_NetToUMTS\"), p_mq_UMTSToNet(\"p_mq_UMTSToNet\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InteractiveNetwork constructor' algorithm generated code\n\n\t//End of 'InteractiveNetwork constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_interactivenetwork::~cfm_interactivenetwork(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InteractiveNetwork destructor' algorithm generated code\n\n\t//End of 'InteractiveNetwork destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_interactivenetwork::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InteractiveNetwork pre elaboration' algorithm generated code\n\n\t//End of 'InteractiveNetwork pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_interactivenetwork::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InteractiveNetwork post elaboration' algorithm generated code\n\n\t//End of 'InteractiveNetwork post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_interactivenetwork::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InteractiveNetwork post simulation' algorithm generated code\n\n\t//End of 'InteractiveNetwork post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_interactivenetwork::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_interactivenetwork::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InteractiveNetwork initializations' algorithm generated code\n\n\t//End of 'InteractiveNetwork initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BroadcastNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'BurstClock', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefNet'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_broadcastnetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_broadcastnetwork_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n#include \"dt/cft_defnet.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BroadcastNetwork includes' algorithm generated code\n\n//End of 'BroadcastNetwork includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBroadcastNetwork Function BroadcastNetwork\n//@{\n///        \\page dxpBroadcastNetwork\n//@{\n///    \\brief BroadcastNetwork function model start\nclass cfm_broadcastnetwork: public cf_core::cf_function,\n\t\tpublic cfm_broadcastnetwork_dp_if {\npublic:\n\t/// cfm_broadcastnetwork type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_broadcastnetwork, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_broadcastnetwork> p_ev_BurstClock_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_broadcastnetwork, cft_defnet> p_sv_VideoFiles_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_broadcastnetwork, cft_defnet> p_mq_VideoNet_t;\n\t/// cfm_broadcastnetwork type define end\n\n\t/// constructor\n\tcfm_broadcastnetwork(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_broadcastnetwork(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_ev_BurstClock_t p_ev_BurstClock;\n\tp_sv_VideoFiles_t p_sv_VideoFiles;\n\tp_mq_VideoNet_t p_mq_VideoNet;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BroadcastNetwork local declarations' algorithm generated code\n\tbool ExitBurstLoop;\n\tbool FullLink;\n\tbool ExitWaiting;\n\tbool SendWaiting;\n\tint IndexBurst;\n\tint BurstSize;\n\tint IndexWaiting;\n\tint FramesInBurst;\n\tint BurstsInVideo;\n\tbool Init;\n\t//End of 'BroadcastNetwork local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BroadcastNetwork function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BroadcastNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'BurstClock', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefNet'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_broadcastnetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_broadcastnetwork.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_broadcastnetwork\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BroadcastNetwork definitions' algorithm generated code\n\n//End of 'BroadcastNetwork definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_broadcastnetwork::cfm_broadcastnetwork(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_broadcastnetwork_dp_if(), p_mq_NetToDVB(\n\t\t\t\t\"p_mq_NetToDVB\"), p_ev_BurstClock(\"p_ev_BurstClock\"), p_sv_VideoFiles(\n\t\t\t\t\"p_sv_VideoFiles\"), p_mq_VideoNet(\"p_mq_VideoNet\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BroadcastNetwork constructor' algorithm generated code\n\n\t//End of 'BroadcastNetwork constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_broadcastnetwork::~cfm_broadcastnetwork(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BroadcastNetwork destructor' algorithm generated code\n\n\t//End of 'BroadcastNetwork destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_broadcastnetwork::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BroadcastNetwork pre elaboration' algorithm generated code\n\n\t//End of 'BroadcastNetwork pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_broadcastnetwork::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BroadcastNetwork post elaboration' algorithm generated code\n\n\t//End of 'BroadcastNetwork post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_broadcastnetwork::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BroadcastNetwork post simulation' algorithm generated code\n\n\t//End of 'BroadcastNetwork post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_broadcastnetwork::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_broadcastnetwork::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BroadcastNetwork initializations' algorithm generated code\n\tInit = true;\n\t//End of 'BroadcastNetwork initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ClockGenerator', 'type': 'cofluent:Function', 'ports': [{'name': 'BurstClock', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_clockgenerator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_clockgenerator_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ClockGenerator includes' algorithm generated code\n\n//End of 'ClockGenerator includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgClockGenerator Function ClockGenerator\n//@{\n///        \\page dxpClockGenerator\n//@{\n///    \\brief ClockGenerator function model start\nclass cfm_clockgenerator: public cf_core::cf_function,\n\t\tpublic cfm_clockgenerator_dp_if {\npublic:\n\t/// cfm_clockgenerator type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_clockgenerator> p_ev_BurstClock_t;\n\t/// cfm_clockgenerator type define end\n\n\t/// constructor\n\tcfm_clockgenerator(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_clockgenerator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_BurstClock_t p_ev_BurstClock;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClockGenerator local declarations' algorithm generated code\n\n\t//End of 'ClockGenerator local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ClockGenerator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ClockGenerator', 'type': 'cofluent:Function', 'ports': [{'name': 'BurstClock', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_clockgenerator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_clockgenerator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_clockgenerator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ClockGenerator definitions' algorithm generated code\n\n//End of 'ClockGenerator definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_clockgenerator::cfm_clockgenerator(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_clockgenerator_dp_if(), p_ev_BurstClock(\n\t\t\t\t\"p_ev_BurstClock\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClockGenerator constructor' algorithm generated code\n\n\t//End of 'ClockGenerator constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_clockgenerator::~cfm_clockgenerator(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClockGenerator destructor' algorithm generated code\n\n\t//End of 'ClockGenerator destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_clockgenerator::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClockGenerator pre elaboration' algorithm generated code\n\n\t//End of 'ClockGenerator pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_clockgenerator::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClockGenerator post elaboration' algorithm generated code\n\n\t//End of 'ClockGenerator post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_clockgenerator::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClockGenerator post simulation' algorithm generated code\n\n\t//End of 'ClockGenerator post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_clockgenerator::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_clockgenerator::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClockGenerator initializations' algorithm generated code\n\n\t//End of 'ClockGenerator initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Requesting', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_requesting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_requesting_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Requesting includes' algorithm generated code\n\n//End of 'Requesting includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRequesting Function Requesting\n//@{\n///        \\page dxpRequesting\n//@{\n///    \\brief Requesting function model start\nclass cfm_requesting: public cf_core::cf_function, public cfm_requesting_dp_if {\npublic:\n\t/// cfm_requesting type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_requesting, cft_defcall> p_mq_Request_t;\n\t/// cfm_requesting type define end\n\n\t/// constructor\n\tcfm_requesting(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_requesting(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Request_t p_mq_Request;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Requesting local declarations' algorithm generated code\n\tint Index;\n\tdouble UserDelay;\n\n\tdouble Delay[13];\n\tDefUseCase UseCase[13];\n\tDefCommand Command[13];\n\t//End of 'Requesting local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Requesting function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Requesting', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_requesting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_requesting.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_requesting\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Requesting definitions' algorithm generated code\n\n//End of 'Requesting definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_requesting::cfm_requesting(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_requesting_dp_if(), p_mq_Request(\"p_mq_Request\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Requesting constructor' algorithm generated code\n\n\t//End of 'Requesting constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_requesting::~cfm_requesting(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Requesting destructor' algorithm generated code\n\n\t//End of 'Requesting destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_requesting::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Requesting pre elaboration' algorithm generated code\n\n\t//End of 'Requesting pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_requesting::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Requesting post elaboration' algorithm generated code\n\n\t//End of 'Requesting post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_requesting::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Requesting post simulation' algorithm generated code\n\n\t//End of 'Requesting post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_requesting::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_requesting::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Requesting initializations' algorithm generated code\n\n\t//End of 'Requesting initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Watching', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_watching\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_watching_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Watching includes' algorithm generated code\n\n//End of 'Watching includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWatching Function Watching\n//@{\n///        \\page dxpWatching\n//@{\n///    \\brief Watching function model start\nclass cfm_watching: public cf_core::cf_function, public cfm_watching_dp_if {\npublic:\n\t/// cfm_watching type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_watching, cft_defvideo> p_mq_Video_t;\n\t/// cfm_watching type define end\n\n\t/// constructor\n\tcfm_watching(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_watching(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Video_t p_mq_Video;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Watching local declarations' algorithm generated code\n\n\t//End of 'Watching local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Watching function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Watching', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_watching\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_watching.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_watching\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Watching definitions' algorithm generated code\n\n//End of 'Watching definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_watching::cfm_watching(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_watching_dp_if(), p_mq_Video(\"p_mq_Video\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Watching constructor' algorithm generated code\n\n\t//End of 'Watching constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_watching::~cfm_watching(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Watching destructor' algorithm generated code\n\n\t//End of 'Watching destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_watching::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Watching pre elaboration' algorithm generated code\n\n\t//End of 'Watching pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_watching::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Watching post elaboration' algorithm generated code\n\n\t//End of 'Watching post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_watching::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Watching post simulation' algorithm generated code\n\n\t//End of 'Watching post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_watching::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_watching::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Watching initializations' algorithm generated code\n\n\t//End of 'Watching initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reading', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_reading\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_reading_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Reading includes' algorithm generated code\n\n//End of 'Reading includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReading Function Reading\n//@{\n///        \\page dxpReading\n//@{\n///    \\brief Reading function model start\nclass cfm_reading: public cf_core::cf_function, public cfm_reading_dp_if {\npublic:\n\t/// cfm_reading type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reading, cft_defcall> p_mq_Request_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reading, cft_defcall> p_mq_Response_t;\n\t/// cfm_reading type define end\n\n\t/// constructor\n\tcfm_reading(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_reading(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Request_t p_mq_Request;\n\tp_mq_Response_t p_mq_Response;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reading local declarations' algorithm generated code\n\tint VideoIndex;\n\t//End of 'Reading local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Reading function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reading', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_reading\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_reading.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reading\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Reading definitions' algorithm generated code\n\n//End of 'Reading definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_reading::cfm_reading(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_reading_dp_if(), p_mq_Request(\"p_mq_Request\"), p_mq_Response(\n\t\t\t\t\"p_mq_Response\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reading constructor' algorithm generated code\n\n\t//End of 'Reading constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_reading::~cfm_reading(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reading destructor' algorithm generated code\n\n\t//End of 'Reading destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_reading::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reading pre elaboration' algorithm generated code\n\n\t//End of 'Reading pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_reading::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reading post elaboration' algorithm generated code\n\n\t//End of 'Reading post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_reading::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reading post simulation' algorithm generated code\n\n\t//End of 'Reading post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_reading::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_reading::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reading initializations' algorithm generated code\n\n\t//End of 'Reading initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CallApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_callapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_callapplication_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CallApplication includes' algorithm generated code\n\n//End of 'CallApplication includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCallApplication Function CallApplication\n//@{\n///        \\page dxpCallApplication\n//@{\n///    \\brief CallApplication function model start\nclass cfm_callapplication: public cf_core::cf_function,\n\t\tpublic cfm_callapplication_dp_if {\npublic:\n\t/// cfm_callapplication type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_AppToCtrl_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_AppToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_Response_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_callapplication, cft_defcall> p_mq_Request_t;\n\t/// cfm_callapplication type define end\n\n\t/// constructor\n\tcfm_callapplication(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_callapplication(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_AppToCtrl_t p_mq_AppToCtrl;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\tp_mq_Response_t p_mq_Response;\n\tp_mq_Request_t p_mq_Request;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallApplication local declarations' algorithm generated code\n\tbool SendToCtrl;\n\tbool SendToUser;\n\tbool SendToCallStack;\n\tint FileIndex;\n\t//End of 'CallApplication local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CallApplication function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CallApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_callapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_callapplication.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationlayer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_callapplication\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CallApplication definitions' algorithm generated code\n\n//End of 'CallApplication definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_callapplication::cfm_callapplication(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_callapplication_dp_if(), p_mq_AppToCtrl(\n\t\t\t\t\"p_mq_AppToCtrl\"), p_mq_HTTPToApp(\"p_mq_HTTPToApp\"), p_mq_AppToHTTP(\n\t\t\t\t\"p_mq_AppToHTTP\"), p_mq_Response(\"p_mq_Response\"), p_mq_Request(\n\t\t\t\t\"p_mq_Request\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallApplication constructor' algorithm generated code\n\n\t//End of 'CallApplication constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_callapplication::~cfm_callapplication(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallApplication destructor' algorithm generated code\n\n\t//End of 'CallApplication destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_callapplication::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallApplication pre elaboration' algorithm generated code\n\n\t//End of 'CallApplication pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_callapplication::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallApplication post elaboration' algorithm generated code\n\n\t//End of 'CallApplication post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_callapplication::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallApplication post simulation' algorithm generated code\n\n\t//End of 'CallApplication post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_callapplication::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_callapplication::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CallApplication initializations' algorithm generated code\n\n\t//End of 'CallApplication initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VideoApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_videoapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_videoapplication_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'VideoApplication includes' algorithm generated code\n\n//End of 'VideoApplication includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgVideoApplication Function VideoApplication\n//@{\n///        \\page dxpVideoApplication\n//@{\n///    \\brief VideoApplication function model start\nclass cfm_videoapplication: public cf_core::cf_function,\n\t\tpublic cfm_videoapplication_dp_if {\npublic:\n\t/// cfm_videoapplication type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoapplication, cft_defvideo> p_mq_Video_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_videoapplication, cft_defvideo> p_mq_RTPToApp_t;\n\t/// cfm_videoapplication type define end\n\n\t/// constructor\n\tcfm_videoapplication(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_videoapplication(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Video_t p_mq_Video;\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoApplication local declarations' algorithm generated code\n\tcf_dt::cf_data_size SizeFrame;\n\t//End of 'VideoApplication local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief VideoApplication function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VideoApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_videoapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_videoapplication.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationlayer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_videoapplication\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'VideoApplication definitions' algorithm generated code\n\n//End of 'VideoApplication definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_videoapplication::cfm_videoapplication(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_videoapplication_dp_if(), p_mq_Video(\n\t\t\t\t\"p_mq_Video\"), p_mq_RTPToApp(\"p_mq_RTPToApp\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoApplication constructor' algorithm generated code\n\n\t//End of 'VideoApplication constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_videoapplication::~cfm_videoapplication(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoApplication destructor' algorithm generated code\n\n\t//End of 'VideoApplication destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_videoapplication::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoApplication pre elaboration' algorithm generated code\n\n\t//End of 'VideoApplication pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_videoapplication::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoApplication post elaboration' algorithm generated code\n\n\t//End of 'VideoApplication post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_videoapplication::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoApplication post simulation' algorithm generated code\n\n\t//End of 'VideoApplication post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_videoapplication::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_videoapplication::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VideoApplication initializations' algorithm generated code\n\n\t//End of 'VideoApplication initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function'}, {'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_httptcp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_dp_if.h\"\n#include \"cfm_httptcp_receive.h\"\n#include \"cfm_httptcp_send.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HTTPTCP includes' algorithm generated code\n\n//End of 'HTTPTCP includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHTTPTCP Function HTTPTCP\n//@{\n///        \\page dxpHTTPTCP\n//@{\n///    \\brief HTTPTCP function model start\nclass cfm_httptcp: public cf_core::cf_function_container,\n\t\tpublic cfm_httptcp_dp_if {\npublic:\n\t/// cfm_httptcp type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_IPToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_HTTPToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_HTTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cft_defcall> p_mq_AppToHTTP_t;\n\t/// cfm_httptcp type define end\n\n\t/// constructor\n\tcfm_httptcp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_httptcp(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_httptcp_receive* HTTPTCP_Receive;\n\tcfm_httptcp_send* HTTPTCP_Send;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP local declarations' algorithm generated code\n\n\t//End of 'HTTPTCP local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief HTTPTCP function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function'}, {'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_httptcp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_httptcp.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HTTPTCP definitions' algorithm generated code\n\n//End of 'HTTPTCP definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_httptcp::cfm_httptcp(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_httptcp_dp_if(), p_mq_IPToHTTP(\n\t\t\t\t\"p_mq_IPToHTTP\"), p_mq_HTTPToIP(\"p_mq_HTTPToIP\"), p_mq_HTTPToApp(\n\t\t\t\t\"p_mq_HTTPToApp\"), p_mq_AppToHTTP(\"p_mq_AppToHTTP\") {\n\tcf_function_container::init();\n\tHTTPTCP_Receive = new cfm_httptcp_receive(\"HTTPTCP_Receive\");\n\tHTTPTCP_Send = new cfm_httptcp_send(\"HTTPTCP_Send\");\n\n\t// connections\n\tHTTPTCP_Receive->p_mq_IPToHTTP(p_mq_IPToHTTP);\n\tHTTPTCP_Receive->p_mq_HTTPToApp(p_mq_HTTPToApp);\n\n\tHTTPTCP_Send->p_mq_HTTPToIP(p_mq_HTTPToIP);\n\tHTTPTCP_Send->p_mq_AppToHTTP(p_mq_AppToHTTP);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP constructor' algorithm generated code\n\n\t//End of 'HTTPTCP constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_httptcp::~cfm_httptcp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP destructor' algorithm generated code\n\n\t//End of 'HTTPTCP destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete HTTPTCP_Receive;\n\tdelete HTTPTCP_Send;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_httptcp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP pre elaboration' algorithm generated code\n\n\t//End of 'HTTPTCP pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_httptcp::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP post elaboration' algorithm generated code\n\n\t//End of 'HTTPTCP post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_httptcp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP post simulation' algorithm generated code\n\n\t//End of 'HTTPTCP post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_httptcp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_httptcp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP initializations' algorithm generated code\n\n\t//End of 'HTTPTCP initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall', 'type': 'cofluent:Function', 'models': [{'name': 'IPCall_Send', 'type': 'cofluent:Function'}, {'name': 'IPCall_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipcall\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_dp_if.h\"\n#include \"cfm_ipcall_receive.h\"\n#include \"cfm_ipcall_send.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPCall includes' algorithm generated code\n\n//End of 'IPCall includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPCall Function IPCall\n//@{\n///        \\page dxpIPCall\n//@{\n///    \\brief IPCall function model start\nclass cfm_ipcall: public cf_core::cf_function_container, public cfm_ipcall_dp_if {\npublic:\n\t/// cfm_ipcall type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_IPToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_IPToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cft_defcall> p_mq_HTTPToIP_t;\n\t/// cfm_ipcall type define end\n\n\t/// constructor\n\tcfm_ipcall(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ipcall(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_ipcall_receive* IPCall_Receive;\n\tcfm_ipcall_send* IPCall_Send;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall local declarations' algorithm generated code\n\n\t//End of 'IPCall local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief IPCall function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall', 'type': 'cofluent:Function', 'models': [{'name': 'IPCall_Send', 'type': 'cofluent:Function'}, {'name': 'IPCall_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipcall\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipcall.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPCall definitions' algorithm generated code\n\n//End of 'IPCall definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipcall::cfm_ipcall(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_ipcall_dp_if(), p_mq_UMTSToIP(\n\t\t\t\t\"p_mq_UMTSToIP\"), p_mq_IPToUMTS(\"p_mq_IPToUMTS\"), p_mq_IPToHTTP(\n\t\t\t\t\"p_mq_IPToHTTP\"), p_mq_HTTPToIP(\"p_mq_HTTPToIP\") {\n\tcf_function_container::init();\n\tIPCall_Receive = new cfm_ipcall_receive(\"IPCall_Receive\");\n\tIPCall_Send = new cfm_ipcall_send(\"IPCall_Send\");\n\n\t// connections\n\tIPCall_Receive->p_mq_UMTSToIP(p_mq_UMTSToIP);\n\tIPCall_Receive->p_mq_IPToHTTP(p_mq_IPToHTTP);\n\n\tIPCall_Send->p_mq_IPToUMTS(p_mq_IPToUMTS);\n\tIPCall_Send->p_mq_HTTPToIP(p_mq_HTTPToIP);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall constructor' algorithm generated code\n\n\t//End of 'IPCall constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipcall::~cfm_ipcall(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall destructor' algorithm generated code\n\n\t//End of 'IPCall destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete IPCall_Receive;\n\tdelete IPCall_Send;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ipcall::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall pre elaboration' algorithm generated code\n\n\t//End of 'IPCall pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ipcall::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall post elaboration' algorithm generated code\n\n\t//End of 'IPCall post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ipcall::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall post simulation' algorithm generated code\n\n\t//End of 'IPCall post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ipcall::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ipcall::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall initializations' algorithm generated code\n\n\t//End of 'IPCall initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS', 'type': 'cofluent:Function', 'models': [{'name': 'UMTS_Send', 'type': 'cofluent:Function'}, {'name': 'UMTS_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_umts\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_dp_if.h\"\n#include \"cfm_umts_receive.h\"\n#include \"cfm_umts_send.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UMTS includes' algorithm generated code\n\n//End of 'UMTS includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUMTS Function UMTS\n//@{\n///        \\page dxpUMTS\n//@{\n///    \\brief UMTS function model start\nclass cfm_umts: public cf_core::cf_function_container, public cfm_umts_dp_if {\npublic:\n\t/// cfm_umts type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_NetToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_UMTSToNet_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts, cft_defcall> p_mq_IPToUMTS_t;\n\t/// cfm_umts type define end\n\n\t/// constructor\n\tcfm_umts(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_umts(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_umts_receive* UMTS_Receive;\n\tcfm_umts_send* UMTS_Send;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS local declarations' algorithm generated code\n\n\t//End of 'UMTS local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief UMTS function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS', 'type': 'cofluent:Function', 'models': [{'name': 'UMTS_Send', 'type': 'cofluent:Function'}, {'name': 'UMTS_Receive', 'type': 'cofluent:Function'}], 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_umts\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_umts.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UMTS definitions' algorithm generated code\n\n//End of 'UMTS definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_umts::cfm_umts(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_umts_dp_if(), p_mq_UMTSToIP(\n\t\t\t\t\"p_mq_UMTSToIP\"), p_mq_NetToUMTS(\"p_mq_NetToUMTS\"), p_mq_UMTSToNet(\n\t\t\t\t\"p_mq_UMTSToNet\"), p_mq_IPToUMTS(\"p_mq_IPToUMTS\") {\n\tcf_function_container::init();\n\tUMTS_Receive = new cfm_umts_receive(\"UMTS_Receive\");\n\tUMTS_Send = new cfm_umts_send(\"UMTS_Send\");\n\n\t// connections\n\tUMTS_Receive->p_mq_UMTSToIP(p_mq_UMTSToIP);\n\tUMTS_Receive->p_mq_NetToUMTS(p_mq_NetToUMTS);\n\n\tUMTS_Send->p_mq_IPToUMTS(p_mq_IPToUMTS);\n\tUMTS_Send->p_mq_UMTSToNet(p_mq_UMTSToNet);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS constructor' algorithm generated code\n\n\t//End of 'UMTS constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_umts::~cfm_umts(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS destructor' algorithm generated code\n\n\t//End of 'UMTS destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete UMTS_Receive;\n\tdelete UMTS_Send;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_umts::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS pre elaboration' algorithm generated code\n\n\t//End of 'UMTS pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_umts::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS post elaboration' algorithm generated code\n\n\t//End of 'UMTS post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_umts::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS post simulation' algorithm generated code\n\n\t//End of 'UMTS post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_umts::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_umts::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS initializations' algorithm generated code\n\n\t//End of 'UMTS initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RTPUDP', 'type': 'cofluent:Function', 'ports': [{'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rtpudp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rtpudp_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RTPUDP includes' algorithm generated code\n\n//End of 'RTPUDP includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRTPUDP Function RTPUDP\n//@{\n///        \\page dxpRTPUDP\n//@{\n///    \\brief RTPUDP function model start\nclass cfm_rtpudp: public cf_core::cf_function, public cfm_rtpudp_dp_if {\npublic:\n\t/// cfm_rtpudp type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rtpudp, cft_defvideo> p_mq_RTPToApp_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rtpudp, cft_defvideo> p_mq_IPToRTP_t;\n\t/// cfm_rtpudp type define end\n\n\t/// constructor\n\tcfm_rtpudp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rtpudp(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RTPToApp_t p_mq_RTPToApp;\n\tp_mq_IPToRTP_t p_mq_IPToRTP;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RTPUDP local declarations' algorithm generated code\n\tint SyncFramesDuration;\n\tint DelayDuration;\n\tint FramesInBurst;\n\tint TimeDifference;\n\t//End of 'RTPUDP local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RTPUDP function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RTPUDP', 'type': 'cofluent:Function', 'ports': [{'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rtpudp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rtpudp.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rtpudp\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RTPUDP definitions' algorithm generated code\n\n//End of 'RTPUDP definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rtpudp::cfm_rtpudp(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_rtpudp_dp_if(), p_mq_RTPToApp(\"p_mq_RTPToApp\"), p_mq_IPToRTP(\n\t\t\t\t\"p_mq_IPToRTP\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RTPUDP constructor' algorithm generated code\n\n\t//End of 'RTPUDP constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rtpudp::~cfm_rtpudp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RTPUDP destructor' algorithm generated code\n\n\t//End of 'RTPUDP destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rtpudp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RTPUDP pre elaboration' algorithm generated code\n\n\t//End of 'RTPUDP pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rtpudp::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RTPUDP post elaboration' algorithm generated code\n\n\t//End of 'RTPUDP post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rtpudp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RTPUDP post simulation' algorithm generated code\n\n\t//End of 'RTPUDP post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rtpudp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rtpudp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RTPUDP initializations' algorithm generated code\n\n\t//End of 'RTPUDP initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPVideo', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipvideo\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipvideo_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPVideo includes' algorithm generated code\n\n//End of 'IPVideo includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPVideo Function IPVideo\n//@{\n///        \\page dxpIPVideo\n//@{\n///    \\brief IPVideo function model start\nclass cfm_ipvideo: public cf_core::cf_function, public cfm_ipvideo_dp_if {\npublic:\n\t/// cfm_ipvideo type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipvideo, cft_defvideo> p_mq_IPToRTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipvideo, cft_defvideo> p_mq_MPEToIP_t;\n\t/// cfm_ipvideo type define end\n\n\t/// constructor\n\tcfm_ipvideo(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ipvideo(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_IPToRTP_t p_mq_IPToRTP;\n\tp_mq_MPEToIP_t p_mq_MPEToIP;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPVideo local declarations' algorithm generated code\n\tint FramesInBurst;\n\tint IndexFrame;\n\tint TimeDifference;\n\tint Size;\n\t//End of 'IPVideo local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief IPVideo function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPVideo', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipvideo\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipvideo.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipvideo\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPVideo definitions' algorithm generated code\n\n//End of 'IPVideo definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipvideo::cfm_ipvideo(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_ipvideo_dp_if(), p_mq_IPToRTP(\"p_mq_IPToRTP\"), p_mq_MPEToIP(\n\t\t\t\t\"p_mq_MPEToIP\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPVideo constructor' algorithm generated code\n\n\t//End of 'IPVideo constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipvideo::~cfm_ipvideo(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPVideo destructor' algorithm generated code\n\n\t//End of 'IPVideo destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ipvideo::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPVideo pre elaboration' algorithm generated code\n\n\t//End of 'IPVideo pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ipvideo::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPVideo post elaboration' algorithm generated code\n\n\t//End of 'IPVideo post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ipvideo::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPVideo post simulation' algorithm generated code\n\n\t//End of 'IPVideo post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ipvideo::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ipvideo::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPVideo initializations' algorithm generated code\n\n\t//End of 'IPVideo initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MPETSL', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mpetsl\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_mpetsl_dp_if.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MPETSL includes' algorithm generated code\n\n//End of 'MPETSL includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMPETSL Function MPETSL\n//@{\n///        \\page dxpMPETSL\n//@{\n///    \\brief MPETSL function model start\nclass cfm_mpetsl: public cf_core::cf_function, public cfm_mpetsl_dp_if {\npublic:\n\t/// cfm_mpetsl type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mpetsl, cft_defvideo> p_mq_NetToDVB_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mpetsl, cft_defvideo> p_mq_MPEToIP_t;\n\t/// cfm_mpetsl type define end\n\n\t/// constructor\n\tcfm_mpetsl(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_mpetsl(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_NetToDVB_t p_mq_NetToDVB;\n\tp_mq_MPEToIP_t p_mq_MPEToIP;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MPETSL local declarations' algorithm generated code\n\n\t//End of 'MPETSL local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MPETSL function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MPETSL', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mpetsl\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mpetsl.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mpetsl\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MPETSL definitions' algorithm generated code\n\n//End of 'MPETSL definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mpetsl::cfm_mpetsl(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_mpetsl_dp_if(), p_mq_NetToDVB(\"p_mq_NetToDVB\"), p_mq_MPEToIP(\n\t\t\t\t\"p_mq_MPEToIP\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MPETSL constructor' algorithm generated code\n\n\t//End of 'MPETSL constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mpetsl::~cfm_mpetsl(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MPETSL destructor' algorithm generated code\n\n\t//End of 'MPETSL destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_mpetsl::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MPETSL pre elaboration' algorithm generated code\n\n\t//End of 'MPETSL pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_mpetsl::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MPETSL post elaboration' algorithm generated code\n\n\t//End of 'MPETSL post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_mpetsl::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MPETSL post simulation' algorithm generated code\n\n\t//End of 'MPETSL post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_mpetsl::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_mpetsl::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MPETSL initializations' algorithm generated code\n\n\t//End of 'MPETSL initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_httptcp_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_send_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HTTPTCP_Send includes' algorithm generated code\n\n//End of 'HTTPTCP_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHTTPTCP_Send Function HTTPTCP_Send\n//@{\n///        \\page dxpHTTPTCP_Send\n//@{\n///    \\brief HTTPTCP_Send function model start\nclass cfm_httptcp_send: public cf_core::cf_function,\n\t\tpublic cfm_httptcp_send_dp_if {\npublic:\n\t/// cfm_httptcp_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_send, cft_defcall> p_mq_HTTPToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_send, cft_defcall> p_mq_AppToHTTP_t;\n\t/// cfm_httptcp_send type define end\n\n\t/// constructor\n\tcfm_httptcp_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_httptcp_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\tp_mq_AppToHTTP_t p_mq_AppToHTTP;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Send local declarations' algorithm generated code\n\n\t//End of 'HTTPTCP_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief HTTPTCP_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_httptcp_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_httptcp_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_httptcp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HTTPTCP_Send definitions' algorithm generated code\n\n//End of 'HTTPTCP_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_httptcp_send::cfm_httptcp_send(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_httptcp_send_dp_if(), p_mq_HTTPToIP(\n\t\t\t\t\"p_mq_HTTPToIP\"), p_mq_AppToHTTP(\"p_mq_AppToHTTP\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Send constructor' algorithm generated code\n\n\t//End of 'HTTPTCP_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_httptcp_send::~cfm_httptcp_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Send destructor' algorithm generated code\n\n\t//End of 'HTTPTCP_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_httptcp_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Send pre elaboration' algorithm generated code\n\n\t//End of 'HTTPTCP_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_httptcp_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Send post elaboration' algorithm generated code\n\n\t//End of 'HTTPTCP_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_httptcp_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Send post simulation' algorithm generated code\n\n\t//End of 'HTTPTCP_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_httptcp_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_httptcp_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Send initializations' algorithm generated code\n\n\t//End of 'HTTPTCP_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_httptcp_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_receive_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HTTPTCP_Receive includes' algorithm generated code\n\n//End of 'HTTPTCP_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHTTPTCP_Receive Function HTTPTCP_Receive\n//@{\n///        \\page dxpHTTPTCP_Receive\n//@{\n///    \\brief HTTPTCP_Receive function model start\nclass cfm_httptcp_receive: public cf_core::cf_function,\n\t\tpublic cfm_httptcp_receive_dp_if {\npublic:\n\t/// cfm_httptcp_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_receive, cft_defcall> p_mq_IPToHTTP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_httptcp_receive, cft_defcall> p_mq_HTTPToApp_t;\n\t/// cfm_httptcp_receive type define end\n\n\t/// constructor\n\tcfm_httptcp_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_httptcp_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\tp_mq_HTTPToApp_t p_mq_HTTPToApp;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Receive local declarations' algorithm generated code\n\n\t//End of 'HTTPTCP_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief HTTPTCP_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_httptcp_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_httptcp_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_httptcp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HTTPTCP_Receive definitions' algorithm generated code\n\n//End of 'HTTPTCP_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_httptcp_receive::cfm_httptcp_receive(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_httptcp_receive_dp_if(), p_mq_IPToHTTP(\n\t\t\t\t\"p_mq_IPToHTTP\"), p_mq_HTTPToApp(\"p_mq_HTTPToApp\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Receive constructor' algorithm generated code\n\n\t//End of 'HTTPTCP_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_httptcp_receive::~cfm_httptcp_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Receive destructor' algorithm generated code\n\n\t//End of 'HTTPTCP_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_httptcp_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Receive pre elaboration' algorithm generated code\n\n\t//End of 'HTTPTCP_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_httptcp_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Receive post elaboration' algorithm generated code\n\n\t//End of 'HTTPTCP_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_httptcp_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Receive post simulation' algorithm generated code\n\n\t//End of 'HTTPTCP_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_httptcp_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_httptcp_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HTTPTCP_Receive initializations' algorithm generated code\n\n\t//End of 'HTTPTCP_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipcall_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_send_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPCall_Send includes' algorithm generated code\n\n//End of 'IPCall_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPCall_Send Function IPCall_Send\n//@{\n///        \\page dxpIPCall_Send\n//@{\n///    \\brief IPCall_Send function model start\nclass cfm_ipcall_send: public cf_core::cf_function, public cfm_ipcall_send_dp_if {\npublic:\n\t/// cfm_ipcall_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_send, cft_defcall> p_mq_IPToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_send, cft_defcall> p_mq_HTTPToIP_t;\n\t/// cfm_ipcall_send type define end\n\n\t/// constructor\n\tcfm_ipcall_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ipcall_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\tp_mq_HTTPToIP_t p_mq_HTTPToIP;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Send local declarations' algorithm generated code\n\n\t//End of 'IPCall_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief IPCall_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipcall_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipcall_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ipcall\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPCall_Send definitions' algorithm generated code\n\n//End of 'IPCall_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipcall_send::cfm_ipcall_send(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_ipcall_send_dp_if(), p_mq_IPToUMTS(\n\t\t\t\t\"p_mq_IPToUMTS\"), p_mq_HTTPToIP(\"p_mq_HTTPToIP\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Send constructor' algorithm generated code\n\n\t//End of 'IPCall_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipcall_send::~cfm_ipcall_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Send destructor' algorithm generated code\n\n\t//End of 'IPCall_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ipcall_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Send pre elaboration' algorithm generated code\n\n\t//End of 'IPCall_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ipcall_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Send post elaboration' algorithm generated code\n\n\t//End of 'IPCall_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ipcall_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Send post simulation' algorithm generated code\n\n\t//End of 'IPCall_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ipcall_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_ENVIRONMENT);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ipcall_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Send initializations' algorithm generated code\n\n\t//End of 'IPCall_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipcall_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_receive_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPCall_Receive includes' algorithm generated code\n\n//End of 'IPCall_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPCall_Receive Function IPCall_Receive\n//@{\n///        \\page dxpIPCall_Receive\n//@{\n///    \\brief IPCall_Receive function model start\nclass cfm_ipcall_receive: public cf_core::cf_function,\n\t\tpublic cfm_ipcall_receive_dp_if {\npublic:\n\t/// cfm_ipcall_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_receive, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ipcall_receive, cft_defcall> p_mq_IPToHTTP_t;\n\t/// cfm_ipcall_receive type define end\n\n\t/// constructor\n\tcfm_ipcall_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ipcall_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_IPToHTTP_t p_mq_IPToHTTP;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Receive local declarations' algorithm generated code\n\n\t//End of 'IPCall_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief IPCall_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipcall_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipcall_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ipcall\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'IPCall_Receive definitions' algorithm generated code\n\n//End of 'IPCall_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipcall_receive::cfm_ipcall_receive(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_ipcall_receive_dp_if(), p_mq_UMTSToIP(\n\t\t\t\t\"p_mq_UMTSToIP\"), p_mq_IPToHTTP(\"p_mq_IPToHTTP\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Receive constructor' algorithm generated code\n\n\t//End of 'IPCall_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipcall_receive::~cfm_ipcall_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Receive destructor' algorithm generated code\n\n\t//End of 'IPCall_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ipcall_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Receive pre elaboration' algorithm generated code\n\n\t//End of 'IPCall_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ipcall_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Receive post elaboration' algorithm generated code\n\n\t//End of 'IPCall_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ipcall_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Receive post simulation' algorithm generated code\n\n\t//End of 'IPCall_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ipcall_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ipcall_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'IPCall_Receive initializations' algorithm generated code\n\n\t//End of 'IPCall_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_umts_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_send_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UMTS_Send includes' algorithm generated code\n\n//End of 'UMTS_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUMTS_Send Function UMTS_Send\n//@{\n///        \\page dxpUMTS_Send\n//@{\n///    \\brief UMTS_Send function model start\nclass cfm_umts_send: public cf_core::cf_function, public cfm_umts_send_dp_if {\npublic:\n\t/// cfm_umts_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_send, cft_defcall> p_mq_IPToUMTS_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_send, cft_defcall> p_mq_UMTSToNet_t;\n\t/// cfm_umts_send type define end\n\n\t/// constructor\n\tcfm_umts_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_umts_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_IPToUMTS_t p_mq_IPToUMTS;\n\tp_mq_UMTSToNet_t p_mq_UMTSToNet;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Send local declarations' algorithm generated code\n\n\t//End of 'UMTS_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief UMTS_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_umts_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_umts_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_umts\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UMTS_Send definitions' algorithm generated code\n\n//End of 'UMTS_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_umts_send::cfm_umts_send(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_umts_send_dp_if(), p_mq_IPToUMTS(\n\t\t\t\t\"p_mq_IPToUMTS\"), p_mq_UMTSToNet(\"p_mq_UMTSToNet\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Send constructor' algorithm generated code\n\n\t//End of 'UMTS_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_umts_send::~cfm_umts_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Send destructor' algorithm generated code\n\n\t//End of 'UMTS_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_umts_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Send pre elaboration' algorithm generated code\n\n\t//End of 'UMTS_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_umts_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Send post elaboration' algorithm generated code\n\n\t//End of 'UMTS_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_umts_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Send post simulation' algorithm generated code\n\n\t//End of 'UMTS_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_umts_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_umts_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Send initializations' algorithm generated code\n\n\t//End of 'UMTS_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_umts_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_receive_dp_if.h\"\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UMTS_Receive includes' algorithm generated code\n\n//End of 'UMTS_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUMTS_Receive Function UMTS_Receive\n//@{\n///        \\page dxpUMTS_Receive\n//@{\n///    \\brief UMTS_Receive function model start\nclass cfm_umts_receive: public cf_core::cf_function,\n\t\tpublic cfm_umts_receive_dp_if {\npublic:\n\t/// cfm_umts_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_receive, cft_defcall> p_mq_UMTSToIP_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_umts_receive, cft_defcall> p_mq_NetToUMTS_t;\n\t/// cfm_umts_receive type define end\n\n\t/// constructor\n\tcfm_umts_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_umts_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_UMTSToIP_t p_mq_UMTSToIP;\n\tp_mq_NetToUMTS_t p_mq_NetToUMTS;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Receive local declarations' algorithm generated code\n\n\t//End of 'UMTS_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief UMTS_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_umts_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_umts_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_umts\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UMTS_Receive definitions' algorithm generated code\n\n//End of 'UMTS_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_umts_receive::cfm_umts_receive(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_umts_receive_dp_if(), p_mq_UMTSToIP(\n\t\t\t\t\"p_mq_UMTSToIP\"), p_mq_NetToUMTS(\"p_mq_NetToUMTS\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Receive constructor' algorithm generated code\n\n\t//End of 'UMTS_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_umts_receive::~cfm_umts_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Receive destructor' algorithm generated code\n\n\t//End of 'UMTS_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_umts_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Receive pre elaboration' algorithm generated code\n\n\t//End of 'UMTS_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_umts_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Receive post elaboration' algorithm generated code\n\n\t//End of 'UMTS_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_umts_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Receive post simulation' algorithm generated code\n\n\t//End of 'UMTS_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_umts_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_umts_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UMTS_Receive initializations' algorithm generated code\n\n\t//End of 'UMTS_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoSimVCSUVMApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'ProcessingFunction', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'read', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProcessingFunction']}, {'name': 'data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProcessingFunction', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cosimvcsuvmapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP\n#define COFS_MODEL_COSIMVCSUVMAPP\n\n/// Model Header includes start\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"uvm_tlm2_sc_bind.h\"\n#include \"wrappers/cfm_data_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_read_tlm2_lt_target.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoSimVCSUVMApp includes' algorithm generated code\n\n//End of 'CoSimVCSUVMApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoSimVCSUVMApp Function CoSimVCSUVMApp\n//@{\n///        \\page dxpCoSimVCSUVMApp\n//@{\n///    \\brief CoSimVCSUVMApp function model start\nclass cfm_cosimvcsuvmapp: public cf_core::cf_application {\npublic:\n\t/// cfm_cosimvcsuvmapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_data_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_read_t;\n\n\t/// cfm_cosimvcsuvmapp type define end\n\n\t/// constructor\n\tcfm_cosimvcsuvmapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_cosimvcsuvmapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_data_t mq_data;\n\tmq_read_t mq_read;\n\t//@}\n\nprotected:\n\t/// \\name wrappers\n\t//@{\n\tcfm_data_tlm2_lt_initiator data_tlm2_lt_initiator;\n\tcfm_read_tlm2_lt_target read_tlm2_lt_target;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVCSUVMApp local declarations' algorithm generated code\n\n\t//End of 'CoSimVCSUVMApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CoSimVCSUVMApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVCSUVMAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoSimVCSUVMApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'ProcessingFunction', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'read', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProcessingFunction']}, {'name': 'data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProcessingFunction', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cosimvcsuvmapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cosimvcsuvmapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoSimVCSUVMApp definitions' algorithm generated code\n\n//End of 'CoSimVCSUVMApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cosimvcsuvmapp::cfm_cosimvcsuvmapp(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_data(\"data\"), mq_read(\"read\"), data_tlm2_lt_initiator(\n\t\t\t\t\"data_tlm2_lt_initiator\"), read_tlm2_lt_target(\n\t\t\t\t\"read_tlm2_lt_target\") {\n\tcf_application::init();\n\tConsumer = new cfm_consumer(\"Consumer\");\n\tProducer = new cfm_producer(\"Producer\");\n\n\t// connections\n\tConsumer->p_mq_read(mq_read.p_target_socket);\n\n\tuvm_tlm2_bind_sc_target(read_tlm2_lt_target.p_tlm2, UVM_TLM_B, \"port_read\");\n\tuvm_tlm2_bind_sc_initiator(data_tlm2_lt_initiator.p_tlm2, UVM_TLM_B,\n\t\t\t\"port_data\", true);\n\n\tProducer->p_mq_data(mq_data.p_target_socket);\n\n\tdata_tlm2_lt_initiator.p_mq_data(mq_data.p_target_socket);\n\tread_tlm2_lt_target.p_mq_read(mq_read.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVCSUVMApp constructor' algorithm generated code\n\n\t//End of 'CoSimVCSUVMApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cosimvcsuvmapp::~cfm_cosimvcsuvmapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVCSUVMApp destructor' algorithm generated code\n\n\t//End of 'CoSimVCSUVMApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer;\n\tdelete Producer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_cosimvcsuvmapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVCSUVMApp pre elaboration' algorithm generated code\n\n\t//End of 'CoSimVCSUVMApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_cosimvcsuvmapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoSimVCSUVMApp post elaboration' algorithm generated code\n\n//End of 'CoSimVCSUVMApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_cosimvcsuvmapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVCSUVMApp post simulation' algorithm generated code\n\n\t//End of 'CoSimVCSUVMApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_cosimvcsuvmapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_data.cfa_send_time.init(cf_expr_duration(2, CF_NS));\n\tmq_data.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_data.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_data.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_data.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_read.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_read.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_read.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_read.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_read.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_read.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_read.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_cosimvcsuvmapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVCSUVMApp initializations' algorithm generated code\n\n\t//End of 'CoSimVCSUVMApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'read', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n#define COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer,\n\t\t\tcf_core::cf_payload_int> p_mq_read_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_read_t p_mq_read;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'read', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimvcsuvmapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_read(\"p_mq_read\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n#define COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_int> p_mq_data_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_data_t p_mq_data;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\tunsigned int datalen;\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimvcsuvmapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_data(\"p_mq_data\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example1App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inheritance_example1app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP\n\n/// Model Header includes start\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_f1.h\"\n#include \"cfm_f2.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example1App includes' algorithm generated code\n\n//End of 'Inheritance_example1App includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInheritance_example1App Function Inheritance_example1App\n//@{\n///        \\page dxpInheritance_example1App\n//@{\n///    \\brief Inheritance_example1App function model start\nclass cfm_inheritance_example1app: public cf_core::cf_application {\npublic:\n\t/// cfm_inheritance_example1app type define start\n\n\t/// cfm_inheritance_example1app type define end\n\n\t/// constructor\n\tcfm_inheritance_example1app(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inheritance_example1app(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_f1* F1;\n\tcfm_f2* F2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example1App local declarations' algorithm generated code\n\n\t//End of 'Inheritance_example1App local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Inheritance_example1App function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example1App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inheritance_example1app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inheritance_example1app.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example1App definitions' algorithm generated code\n\n//End of 'Inheritance_example1App definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inheritance_example1app::cfm_inheritance_example1app(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name) {\n\tcf_application::init();\n\tF1 = new cfm_f1(\"F1\");\n\tF2 = new cfm_f2(\"F2\");\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example1App constructor' algorithm generated code\n\n\t//End of 'Inheritance_example1App constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inheritance_example1app::~cfm_inheritance_example1app(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example1App destructor' algorithm generated code\n\n\t//End of 'Inheritance_example1App destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete F1;\n\tdelete F2;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inheritance_example1app::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example1App pre elaboration' algorithm generated code\n\n\t//End of 'Inheritance_example1App pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inheritance_example1app::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example1App post elaboration' algorithm generated code\n\n//End of 'Inheritance_example1App post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inheritance_example1app::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example1App post simulation' algorithm generated code\n\n\t//End of 'Inheritance_example1App post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inheritance_example1app::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inheritance_example1app::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example1App initializations' algorithm generated code\n\n\t//End of 'Inheritance_example1App initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n\n/// Model Header includes start\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F1 includes' algorithm generated code\n\n//End of 'F1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF1 Function F1\n//@{\n///        \\page dxpF1\n//@{\n///    \\brief F1 function model start\nclass cfm_f1: public cf_core::cf_function {\npublic:\n\t/// cfm_f1 type define start\n\n\t/// cfm_f1 type define end\n\n\t/// constructor\n\tcfm_f1(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_f1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 local declarations' algorithm generated code\n\n\t//End of 'F1 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief F1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example1app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F1 definitions' algorithm generated code\n\n//End of 'F1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f1::cfm_f1(sc_core::sc_module_name name) :\n\t\tcf_function(name) {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 constructor' algorithm generated code\n\n\t//End of 'F1 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f1::~cfm_f1(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 destructor' algorithm generated code\n\n\t//End of 'F1 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_f1::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 pre elaboration' algorithm generated code\n\n\t//End of 'F1 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_f1::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 post elaboration' algorithm generated code\n\n\t//End of 'F1 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_f1::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 post simulation' algorithm generated code\n\n\t//End of 'F1 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_f1::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_f1::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 initializations' algorithm generated code\n\n\t//End of 'F1 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n\n/// Model Header includes start\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F2 includes' algorithm generated code\n\n//End of 'F2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF2 Function F2\n//@{\n///        \\page dxpF2\n//@{\n///    \\brief F2 function model start\nclass cfm_f2: public cf_core::cf_function {\npublic:\n\t/// cfm_f2 type define start\n\n\t/// cfm_f2 type define end\n\n\t/// constructor\n\tcfm_f2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_f2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 local declarations' algorithm generated code\n\n\t//End of 'F2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief F2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example1app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F2 definitions' algorithm generated code\n\n//End of 'F2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f2::cfm_f2(sc_core::sc_module_name name) :\n\t\tcf_function(name) {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 constructor' algorithm generated code\n\n\t//End of 'F2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f2::~cfm_f2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 destructor' algorithm generated code\n\n\t//End of 'F2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_f2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 pre elaboration' algorithm generated code\n\n\t//End of 'F2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_f2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 post elaboration' algorithm generated code\n\n\t//End of 'F2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_f2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 post simulation' algorithm generated code\n\n\t//End of 'F2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_f2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_f2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 initializations' algorithm generated code\n\n\t//End of 'F2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CopyPayloadNonPod', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_copypayloadnonpod\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD\n#define COFS_MODEL_COPYPAYLOADNONPOD\n\n/// Model Header includes start\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CopyPayloadNonPod includes' algorithm generated code\n\n//End of 'CopyPayloadNonPod includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCopyPayloadNonPod Function CopyPayloadNonPod\n//@{\n///        \\page dxpCopyPayloadNonPod\n//@{\n///    \\brief CopyPayloadNonPod function model start\nclass cfm_copypayloadnonpod: public cf_core::cf_application {\npublic:\n\t/// cfm_copypayloadnonpod type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgQ_t;\n\n\t/// cfm_copypayloadnonpod type define end\n\n\t/// constructor\n\tcfm_copypayloadnonpod(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_copypayloadnonpod(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQ_t mq_MsgQ;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CopyPayloadNonPod local declarations' algorithm generated code\n\n\t//End of 'CopyPayloadNonPod local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CopyPayloadNonPod function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COPYPAYLOADNONPOD\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CopyPayloadNonPod', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_copypayloadnonpod\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_copypayloadnonpod.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CopyPayloadNonPod definitions' algorithm generated code\n\n//End of 'CopyPayloadNonPod definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_copypayloadnonpod::cfm_copypayloadnonpod(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_MsgQ(\"MsgQ\") {\n\tcf_application::init();\n\tConsumer = new cfm_consumer(\"Consumer\");\n\tProducer = new cfm_producer(\"Producer\");\n\n\t// connections\n\tConsumer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n\n\tProducer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CopyPayloadNonPod constructor' algorithm generated code\n\n\t//End of 'CopyPayloadNonPod constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_copypayloadnonpod::~cfm_copypayloadnonpod(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CopyPayloadNonPod destructor' algorithm generated code\n\n\t//End of 'CopyPayloadNonPod destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer;\n\tdelete Producer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_copypayloadnonpod::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CopyPayloadNonPod pre elaboration' algorithm generated code\n\n\t//End of 'CopyPayloadNonPod pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_copypayloadnonpod::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CopyPayloadNonPod post elaboration' algorithm generated code\n\n//End of 'CopyPayloadNonPod post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_copypayloadnonpod::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CopyPayloadNonPod post simulation' algorithm generated code\n\n\t//End of 'CopyPayloadNonPod post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_copypayloadnonpod::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_MsgQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQ.cfa_queue_capacity.init((cf_nonzero_count) 10);\n\tmq_MsgQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_copypayloadnonpod::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CopyPayloadNonPod initializations' algorithm generated code\n\n\t//End of 'CopyPayloadNonPod initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n#define COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cft_defmsgq> p_mq_MsgQ_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_copypayloadnonpod\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n#define COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defmsgq> p_mq_MsgQ_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\tint cpt;\n\tint Value[100];\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_copypayloadnonpod\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoFluentAPIFromExternalIP', 'models': [{'name': 'iUart', 'type': 'cofluent:SystemCIP'}, {'name': 'CoF_Initiator', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgFwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}, {'name': 'MsgBwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cofluentapifromexternalip\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n#define COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n\n/// Model Header includes start\n#include \"cfm_cofluentapifromexternalip_global.h\"\n#include \"cfm_cofluentapifromexternalip_global_types.h\"\n#include \"cofluent.h\"\n#include \"Uart.h\"\n#include \"cfm_cof_initiator.h\"\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoFluentAPIFromExternalIP includes' algorithm generated code\n\n//End of 'CoFluentAPIFromExternalIP includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoFluentAPIFromExternalIP Function CoFluentAPIFromExternalIP\n//@{\n///        \\page dxpCoFluentAPIFromExternalIP\n//@{\n///    \\brief CoFluentAPIFromExternalIP function model start\nclass cfm_cofluentapifromexternalip: public cf_core::cf_application {\npublic:\n\t/// cfm_cofluentapifromexternalip type define start\n\t/// systemC IPs typedef\n\ttypedef Uart iUart_t;\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgBwQ_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgFwQ_t;\n\n\t/// cfm_cofluentapifromexternalip type define end\n\n\t/// constructor\n\tcfm_cofluentapifromexternalip(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_cofluentapifromexternalip(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_cof_initiator* CoF_Initiator;\n\tiUart_t* iUart;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgBwQ_t mq_MsgBwQ;\n\tmq_MsgFwQ_t mq_MsgFwQ;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoFluentAPIFromExternalIP local declarations' algorithm generated code\n\n\t//End of 'CoFluentAPIFromExternalIP local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CoFluentAPIFromExternalIP function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoFluentAPIFromExternalIP', 'models': [{'name': 'iUart', 'type': 'cofluent:SystemCIP'}, {'name': 'CoF_Initiator', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgFwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}, {'name': 'MsgBwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cofluentapifromexternalip\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cofluentapifromexternalip.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoFluentAPIFromExternalIP definitions' algorithm generated code\n\n//End of 'CoFluentAPIFromExternalIP definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cofluentapifromexternalip::cfm_cofluentapifromexternalip(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), mq_MsgBwQ(\"MsgBwQ\"), mq_MsgFwQ(\"MsgFwQ\") {\n\tcf_application::init();\n\tCoF_Initiator = new cfm_cof_initiator(\"CoF_Initiator\");\n\tiUart = new iUart_t(\"iUart\");\n\n\t// connections\n\tCoF_Initiator->p_mq_MsgFwQ(mq_MsgFwQ.p_target_socket);\n\tCoF_Initiator->p_mq_MsgBwQ(mq_MsgBwQ.p_target_socket);\n\n\tiUart->p_mq_request(mq_MsgFwQ.p_target_socket);\n\tiUart->p_mq_response(mq_MsgBwQ.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoFluentAPIFromExternalIP constructor' algorithm generated code\n\n\t//End of 'CoFluentAPIFromExternalIP constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cofluentapifromexternalip::~cfm_cofluentapifromexternalip(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoFluentAPIFromExternalIP destructor' algorithm generated code\n\n\t//End of 'CoFluentAPIFromExternalIP destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete CoF_Initiator;\n\tdelete iUart;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_cofluentapifromexternalip::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoFluentAPIFromExternalIP pre elaboration' algorithm generated code\n\n\t//End of 'CoFluentAPIFromExternalIP pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_cofluentapifromexternalip::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoFluentAPIFromExternalIP post elaboration' algorithm generated code\n\n//End of 'CoFluentAPIFromExternalIP post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_cofluentapifromexternalip::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoFluentAPIFromExternalIP post simulation' algorithm generated code\n\n\t//End of 'CoFluentAPIFromExternalIP post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_cofluentapifromexternalip::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_MsgBwQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgBwQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgBwQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgBwQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgBwQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgBwQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgBwQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgFwQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgFwQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgFwQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgFwQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_cofluentapifromexternalip::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoFluentAPIFromExternalIP initializations' algorithm generated code\n\n\t//End of 'CoFluentAPIFromExternalIP initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoF_Initiator', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgFwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'MsgBwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CoFluentAPIFromExternalIP'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cof_initiator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n#define COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n\n/// Model Header includes start\n#include \"cfm_cofluentapifromexternalip_global.h\"\n#include \"cfm_cofluentapifromexternalip_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoF_Initiator includes' algorithm generated code\n\n//End of 'CoF_Initiator includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoF_Initiator Function CoF_Initiator\n//@{\n///        \\page dxpCoF_Initiator\n//@{\n///    \\brief CoF_Initiator function model start\nclass cfm_cof_initiator: public cf_core::cf_function {\npublic:\n\t/// cfm_cof_initiator type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_cof_initiator, cft_defmsgq> p_mq_MsgFwQ_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_cof_initiator, cft_defmsgq> p_mq_MsgBwQ_t;\n\t/// cfm_cof_initiator type define end\n\n\t/// constructor\n\tcfm_cof_initiator(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_cof_initiator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgFwQ_t p_mq_MsgFwQ;\n\tp_mq_MsgBwQ_t p_mq_MsgBwQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoF_Initiator local declarations' algorithm generated code\n\n\t//End of 'CoF_Initiator local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CoF_Initiator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoF_Initiator', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgFwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'MsgBwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CoFluentAPIFromExternalIP'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cof_initiator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cof_initiator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cofluentapifromexternalip\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_cof_initiator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoF_Initiator definitions' algorithm generated code\n\n//End of 'CoF_Initiator definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cof_initiator::cfm_cof_initiator(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgFwQ(\"p_mq_MsgFwQ\"), p_mq_MsgBwQ(\n\t\t\t\t\"p_mq_MsgBwQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoF_Initiator constructor' algorithm generated code\n\n\t//End of 'CoF_Initiator constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cof_initiator::~cfm_cof_initiator(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoF_Initiator destructor' algorithm generated code\n\n\t//End of 'CoF_Initiator destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_cof_initiator::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoF_Initiator pre elaboration' algorithm generated code\n\n\t//End of 'CoF_Initiator pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_cof_initiator::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoF_Initiator post elaboration' algorithm generated code\n\n\t//End of 'CoF_Initiator post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_cof_initiator::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoF_Initiator post simulation' algorithm generated code\n\n\t//End of 'CoF_Initiator post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_cof_initiator::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_cof_initiator::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoF_Initiator initializations' algorithm generated code\n\tMsgFwQ = 0;\n\tMsgBwQ = 0;\n\t//End of 'CoF_Initiator initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TransactionTrackerMsgQApp', 'models': [{'name': 'Consumer1', 'type': 'cofluent:Function'}, {'name': 'Consumer2', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'MessageRouting', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQOut2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer2', 'MessageRouting']}, {'name': 'MsgQIn', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'MessageRouting']}, {'name': 'MsgQOut1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer1', 'MessageRouting']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_transactiontrackermsgqapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer1.h\"\n#include \"cfm_consumer2.h\"\n#include \"cfm_messagerouting.h\"\n#include \"cfm_producer.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TransactionTrackerMsgQApp includes' algorithm generated code\n\n//End of 'TransactionTrackerMsgQApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTransactionTrackerMsgQApp Function TransactionTrackerMsgQApp\n//@{\n///        \\page dxpTransactionTrackerMsgQApp\n//@{\n///    \\brief TransactionTrackerMsgQApp function model start\nclass cfm_transactiontrackermsgqapp: public cf_core::cf_application {\npublic:\n\t/// cfm_transactiontrackermsgqapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQIn_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQOut1_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQOut2_t;\n\n\t/// cfm_transactiontrackermsgqapp type define end\n\n\t/// constructor\n\tcfm_transactiontrackermsgqapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_transactiontrackermsgqapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer1* Consumer1;\n\tcfm_consumer2* Consumer2;\n\tcfm_messagerouting* MessageRouting;\n\tcfm_producer* Producer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQIn_t mq_MsgQIn;\n\tmq_MsgQOut1_t mq_MsgQOut1;\n\tmq_MsgQOut2_t mq_MsgQOut2;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TransactionTrackerMsgQApp local declarations' algorithm generated code\n\n\t//End of 'TransactionTrackerMsgQApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief TransactionTrackerMsgQApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TransactionTrackerMsgQApp', 'models': [{'name': 'Consumer1', 'type': 'cofluent:Function'}, {'name': 'Consumer2', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'MessageRouting', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQOut2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer2', 'MessageRouting']}, {'name': 'MsgQIn', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'MessageRouting']}, {'name': 'MsgQOut1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer1', 'MessageRouting']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_transactiontrackermsgqapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_transactiontrackermsgqapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TransactionTrackerMsgQApp definitions' algorithm generated code\n\n//End of 'TransactionTrackerMsgQApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_transactiontrackermsgqapp::cfm_transactiontrackermsgqapp(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), mq_MsgQIn(\"MsgQIn\"), mq_MsgQOut1(\"MsgQOut1\"), mq_MsgQOut2(\n\t\t\t\t\"MsgQOut2\") {\n\tcf_application::init();\n\tConsumer1 = new cfm_consumer1(\"Consumer1\");\n\tConsumer2 = new cfm_consumer2(\"Consumer2\");\n\tMessageRouting = new cfm_messagerouting(\"MessageRouting\");\n\tProducer = new cfm_producer(\"Producer\");\n\n\t// connections\n\tConsumer1->p_mq_MsgQOut1(mq_MsgQOut1.p_target_socket);\n\n\tConsumer2->p_mq_MsgQOut2(mq_MsgQOut2.p_target_socket);\n\n\tMessageRouting->p_mq_MsgQIn(mq_MsgQIn.p_target_socket);\n\tMessageRouting->p_mq_MsgQOut2(mq_MsgQOut2.p_target_socket);\n\tMessageRouting->p_mq_MsgQOut1(mq_MsgQOut1.p_target_socket);\n\n\tProducer->p_mq_MsgQIn(mq_MsgQIn.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TransactionTrackerMsgQApp constructor' algorithm generated code\n\n\t//End of 'TransactionTrackerMsgQApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_transactiontrackermsgqapp::~cfm_transactiontrackermsgqapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TransactionTrackerMsgQApp destructor' algorithm generated code\n\n\t//End of 'TransactionTrackerMsgQApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer1;\n\tdelete Consumer2;\n\tdelete MessageRouting;\n\tdelete Producer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_transactiontrackermsgqapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TransactionTrackerMsgQApp pre elaboration' algorithm generated code\n\n\t//End of 'TransactionTrackerMsgQApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_transactiontrackermsgqapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TransactionTrackerMsgQApp post elaboration' algorithm generated code\n\n//End of 'TransactionTrackerMsgQApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_transactiontrackermsgqapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TransactionTrackerMsgQApp post simulation' algorithm generated code\n\n\t//End of 'TransactionTrackerMsgQApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_transactiontrackermsgqapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_MsgQIn.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQIn.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQIn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQIn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQIn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQIn.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQIn.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut1.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut1.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOut1.cfa_queue_capacity.init((cf_nonzero_count) 3);\n\tmq_MsgQOut1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOut1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut2.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut2.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_MsgQOut2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOut2.cfa_queue_capacity.init((cf_nonzero_count) 3);\n\tmq_MsgQOut2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOut2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOut2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_transactiontrackermsgqapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TransactionTrackerMsgQApp initializations' algorithm generated code\n\n\t//End of 'TransactionTrackerMsgQApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer1', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer1 includes' algorithm generated code\n\n//End of 'Consumer1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer1 Function Consumer1\n//@{\n///        \\page dxpConsumer1\n//@{\n///    \\brief Consumer1 function model start\nclass cfm_consumer1: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer1 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer1,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQOut1_t;\n\t/// cfm_consumer1 type define end\n\n\t/// constructor\n\tcfm_consumer1(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQOut1_t p_mq_MsgQOut1;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer1 local declarations' algorithm generated code\n\n\t//End of 'Consumer1 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer1', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer1 definitions' algorithm generated code\n\n//End of 'Consumer1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer1::cfm_consumer1(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQOut1(\"p_mq_MsgQOut1\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer1 constructor' algorithm generated code\n\n\t//End of 'Consumer1 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer1::~cfm_consumer1(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer1 destructor' algorithm generated code\n\n\t//End of 'Consumer1 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer1::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer1 pre elaboration' algorithm generated code\n\n\t//End of 'Consumer1 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer1::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer1 post elaboration' algorithm generated code\n\n\t//End of 'Consumer1 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer1::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer1 post simulation' algorithm generated code\n\n\t//End of 'Consumer1 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer1::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer1::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer1 initializations' algorithm generated code\n\n\t//End of 'Consumer1 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer2', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer2 includes' algorithm generated code\n\n//End of 'Consumer2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer2 Function Consumer2\n//@{\n///        \\page dxpConsumer2\n//@{\n///    \\brief Consumer2 function model start\nclass cfm_consumer2: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer2 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer2,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQOut2_t;\n\t/// cfm_consumer2 type define end\n\n\t/// constructor\n\tcfm_consumer2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQOut2_t p_mq_MsgQOut2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer2 local declarations' algorithm generated code\n\n\t//End of 'Consumer2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer2', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer2 definitions' algorithm generated code\n\n//End of 'Consumer2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer2::cfm_consumer2(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQOut2(\"p_mq_MsgQOut2\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer2 constructor' algorithm generated code\n\n\t//End of 'Consumer2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer2::~cfm_consumer2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer2 destructor' algorithm generated code\n\n\t//End of 'Consumer2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer2 pre elaboration' algorithm generated code\n\n\t//End of 'Consumer2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer2 post elaboration' algorithm generated code\n\n\t//End of 'Consumer2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer2 post simulation' algorithm generated code\n\n\t//End of 'Consumer2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer2 initializations' algorithm generated code\n\n\t//End of 'Consumer2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n#include <sstream>\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQIn_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQIn_t p_mq_MsgQIn;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\tint TempInt;\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQIn(\"p_mq_MsgQIn\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\tTempInt = 0;\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MessageRouting', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_messagerouting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MessageRouting includes' algorithm generated code\n\n//End of 'MessageRouting includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMessageRouting Function MessageRouting\n//@{\n///        \\page dxpMessageRouting\n//@{\n///    \\brief MessageRouting function model start\nclass cfm_messagerouting: public cf_core::cf_function {\npublic:\n\t/// cfm_messagerouting type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_messagerouting,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQIn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_messagerouting,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQOut2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_messagerouting,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQOut1_t;\n\t/// cfm_messagerouting type define end\n\n\t/// constructor\n\tcfm_messagerouting(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_messagerouting(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQIn_t p_mq_MsgQIn;\n\tp_mq_MsgQOut2_t p_mq_MsgQOut2;\n\tp_mq_MsgQOut1_t p_mq_MsgQOut1;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MessageRouting local declarations' algorithm generated code\n\tbool CondOut1 = false;\n\t//End of 'MessageRouting local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MessageRouting function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MessageRouting', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_messagerouting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_messagerouting.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_messagerouting\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MessageRouting definitions' algorithm generated code\n\n//End of 'MessageRouting definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_messagerouting::cfm_messagerouting(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQIn(\"p_mq_MsgQIn\"), p_mq_MsgQOut2(\n\t\t\t\t\"p_mq_MsgQOut2\"), p_mq_MsgQOut1(\"p_mq_MsgQOut1\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MessageRouting constructor' algorithm generated code\n\n\t//End of 'MessageRouting constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_messagerouting::~cfm_messagerouting(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MessageRouting destructor' algorithm generated code\n\n\t//End of 'MessageRouting destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_messagerouting::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MessageRouting pre elaboration' algorithm generated code\n\n\t//End of 'MessageRouting pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_messagerouting::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MessageRouting post elaboration' algorithm generated code\n\n\t//End of 'MessageRouting post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_messagerouting::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MessageRouting post simulation' algorithm generated code\n\n\t//End of 'MessageRouting post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_messagerouting::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_messagerouting::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MessageRouting initializations' algorithm generated code\n\n\t//End of 'MessageRouting initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolMapDataTypeApp', 'models': [{'name': 'ProtocolSend', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'ProtocolReceive', 'type': 'cofluent:Function'}], 'relations': [{'name': 'protocol_data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'ProtocolReceive']}, {'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'Producer']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProtocolReceive']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_protocolmapdatatypeapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_protocolreceive.h\"\n#include \"cfm_protocolsend.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProtocolMapDataTypeApp includes' algorithm generated code\n\n//End of 'ProtocolMapDataTypeApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProtocolMapDataTypeApp Function ProtocolMapDataTypeApp\n//@{\n///        \\page dxpProtocolMapDataTypeApp\n//@{\n///    \\brief ProtocolMapDataTypeApp function model start\nclass cfm_protocolmapdatatypeapp: public cf_core::cf_application {\npublic:\n\t/// cfm_protocolmapdatatypeapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_protocol_data_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_user_data_in_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_user_data_out_t;\n\n\t/// cfm_protocolmapdatatypeapp type define end\n\n\t/// constructor\n\tcfm_protocolmapdatatypeapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_protocolmapdatatypeapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\tcfm_protocolreceive* ProtocolReceive;\n\tcfm_protocolsend* ProtocolSend;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_protocol_data_t mq_protocol_data;\n\tmq_user_data_in_t mq_user_data_in;\n\tmq_user_data_out_t mq_user_data_out;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolMapDataTypeApp local declarations' algorithm generated code\n\n\t//End of 'ProtocolMapDataTypeApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ProtocolMapDataTypeApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolMapDataTypeApp', 'models': [{'name': 'ProtocolSend', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'ProtocolReceive', 'type': 'cofluent:Function'}], 'relations': [{'name': 'protocol_data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'ProtocolReceive']}, {'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'Producer']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProtocolReceive']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_protocolmapdatatypeapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_protocolmapdatatypeapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProtocolMapDataTypeApp definitions' algorithm generated code\n\n//End of 'ProtocolMapDataTypeApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_protocolmapdatatypeapp::cfm_protocolmapdatatypeapp(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), mq_protocol_data(\"protocol_data\"), mq_user_data_in(\n\t\t\t\t\"user_data_in\"), mq_user_data_out(\"user_data_out\") {\n\tcf_application::init();\n\tConsumer = new cfm_consumer(\"Consumer\");\n\tProducer = new cfm_producer(\"Producer\");\n\tProtocolReceive = new cfm_protocolreceive(\"ProtocolReceive\");\n\tProtocolSend = new cfm_protocolsend(\"ProtocolSend\");\n\n\t// connections\n\tConsumer->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n\n\tProducer->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n\n\tProtocolReceive->p_mq_protocol_data(mq_protocol_data.p_target_socket);\n\tProtocolReceive->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n\n\tProtocolSend->p_mq_protocol_data(mq_protocol_data.p_target_socket);\n\tProtocolSend->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolMapDataTypeApp constructor' algorithm generated code\n\n\t//End of 'ProtocolMapDataTypeApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_protocolmapdatatypeapp::~cfm_protocolmapdatatypeapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolMapDataTypeApp destructor' algorithm generated code\n\n\t//End of 'ProtocolMapDataTypeApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer;\n\tdelete Producer;\n\tdelete ProtocolReceive;\n\tdelete ProtocolSend;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_protocolmapdatatypeapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolMapDataTypeApp pre elaboration' algorithm generated code\n\n\t//End of 'ProtocolMapDataTypeApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_protocolmapdatatypeapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProtocolMapDataTypeApp post elaboration' algorithm generated code\n\n//End of 'ProtocolMapDataTypeApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_protocolmapdatatypeapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolMapDataTypeApp post simulation' algorithm generated code\n\n\t//End of 'ProtocolMapDataTypeApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_protocolmapdatatypeapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_protocol_data.cfa_send_time.init(cf_expr_duration(2, CF_NS));\n\tmq_protocol_data.cfa_receive_time.init(cf_expr_duration(3, CF_NS));\n\tmq_protocol_data.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_protocol_data.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_protocol_data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_protocol_data.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_protocol_data.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_in.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_protocolmapdatatypeapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolMapDataTypeApp initializations' algorithm generated code\n\n\t//End of 'ProtocolMapDataTypeApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolSend', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_protocolsend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProtocolSend includes' algorithm generated code\n\n//End of 'ProtocolSend includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProtocolSend Function ProtocolSend\n//@{\n///        \\page dxpProtocolSend\n//@{\n///    \\brief ProtocolSend function model start\nclass cfm_protocolsend: public cf_core::cf_function {\npublic:\n\t/// cfm_protocolsend type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolsend,\n\t\t\tcf_core::cf_payload_map> p_mq_protocol_data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolsend,\n\t\t\tcf_core::cf_payload_map> p_mq_user_data_in_t;\n\t/// cfm_protocolsend type define end\n\n\t/// constructor\n\tcfm_protocolsend(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_protocolsend(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_protocol_data_t p_mq_protocol_data;\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolSend local declarations' algorithm generated code\n\tint number_of_packets;\n\t//End of 'ProtocolSend local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ProtocolSend function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolSend', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_protocolsend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_protocolsend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_protocolsend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProtocolSend definitions' algorithm generated code\n\n//End of 'ProtocolSend definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_protocolsend::cfm_protocolsend(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_protocol_data(\"p_mq_protocol_data\"), p_mq_user_data_in(\n\t\t\t\t\"p_mq_user_data_in\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolSend constructor' algorithm generated code\n\n\t//End of 'ProtocolSend constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_protocolsend::~cfm_protocolsend(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolSend destructor' algorithm generated code\n\n\t//End of 'ProtocolSend destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_protocolsend::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolSend pre elaboration' algorithm generated code\n\n\t//End of 'ProtocolSend pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_protocolsend::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolSend post elaboration' algorithm generated code\n\n\t//End of 'ProtocolSend post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_protocolsend::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolSend post simulation' algorithm generated code\n\n\t//End of 'ProtocolSend post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_protocolsend::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_protocolsend::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolSend initializations' algorithm generated code\n\tnumber_of_packets = 0;\n\t//End of 'ProtocolSend initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer,\n\t\t\tcf_core::cf_payload_map> p_mq_user_data_out_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_user_data_out(\"p_mq_user_data_out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_map> p_mq_user_data_in_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_user_data_in(\"p_mq_user_data_in\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolReceive', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_protocolreceive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProtocolReceive includes' algorithm generated code\n\n//End of 'ProtocolReceive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProtocolReceive Function ProtocolReceive\n//@{\n///        \\page dxpProtocolReceive\n//@{\n///    \\brief ProtocolReceive function model start\nclass cfm_protocolreceive: public cf_core::cf_function {\npublic:\n\t/// cfm_protocolreceive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolreceive,\n\t\t\tcf_core::cf_payload_map> p_mq_protocol_data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_protocolreceive,\n\t\t\tcf_core::cf_payload_map> p_mq_user_data_out_t;\n\t/// cfm_protocolreceive type define end\n\n\t/// constructor\n\tcfm_protocolreceive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_protocolreceive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_protocol_data_t p_mq_protocol_data;\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolReceive local declarations' algorithm generated code\n\tint number_of_packets;\n\t//End of 'ProtocolReceive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ProtocolReceive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolReceive', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_protocolreceive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_protocolreceive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_protocolreceive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProtocolReceive definitions' algorithm generated code\n\n//End of 'ProtocolReceive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_protocolreceive::cfm_protocolreceive(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_protocol_data(\"p_mq_protocol_data\"), p_mq_user_data_out(\n\t\t\t\t\"p_mq_user_data_out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolReceive constructor' algorithm generated code\n\n\t//End of 'ProtocolReceive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_protocolreceive::~cfm_protocolreceive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolReceive destructor' algorithm generated code\n\n\t//End of 'ProtocolReceive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_protocolreceive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolReceive pre elaboration' algorithm generated code\n\n\t//End of 'ProtocolReceive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_protocolreceive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolReceive post elaboration' algorithm generated code\n\n\t//End of 'ProtocolReceive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_protocolreceive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolReceive post simulation' algorithm generated code\n\n\t//End of 'ProtocolReceive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_protocolreceive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_protocolreceive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProtocolReceive initializations' algorithm generated code\n\tnumber_of_packets = 0;\n\t//End of 'ProtocolReceive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MapDataTypeAPIApp', 'models': [{'name': 'ProducerMap', 'type': 'cofluent:Function'}, {'name': 'ConsumerMap', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQMap', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerMap', 'ConsumerMap']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mapdatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP\n#define COFS_MODEL_MAPDATATYPEAPIAPP\n\n/// Model Header includes start\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumermap.h\"\n#include \"cfm_producermap.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MapDataTypeAPIApp includes' algorithm generated code\n\n//End of 'MapDataTypeAPIApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMapDataTypeAPIApp Function MapDataTypeAPIApp\n//@{\n///        \\page dxpMapDataTypeAPIApp\n//@{\n///    \\brief MapDataTypeAPIApp function model start\nclass cfm_mapdatatypeapiapp: public cf_core::cf_application {\npublic:\n\t/// cfm_mapdatatypeapiapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_MsgQMap_t;\n\n\t/// cfm_mapdatatypeapiapp type define end\n\n\t/// constructor\n\tcfm_mapdatatypeapiapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_mapdatatypeapiapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumermap* ConsumerMap;\n\tcfm_producermap* ProducerMap;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQMap_t mq_MsgQMap;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MapDataTypeAPIApp local declarations' algorithm generated code\n\n\t//End of 'MapDataTypeAPIApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MapDataTypeAPIApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MapDataTypeAPIApp', 'models': [{'name': 'ProducerMap', 'type': 'cofluent:Function'}, {'name': 'ConsumerMap', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQMap', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerMap', 'ConsumerMap']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mapdatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mapdatatypeapiapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MapDataTypeAPIApp definitions' algorithm generated code\n\n//End of 'MapDataTypeAPIApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mapdatatypeapiapp::cfm_mapdatatypeapiapp(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_MsgQMap(\"MsgQMap\") {\n\tcf_application::init();\n\tConsumerMap = new cfm_consumermap(\"ConsumerMap\");\n\tProducerMap = new cfm_producermap(\"ProducerMap\");\n\n\t// connections\n\tConsumerMap->p_mq_MsgQMap(mq_MsgQMap.p_target_socket);\n\n\tProducerMap->p_mq_MsgQMap(mq_MsgQMap.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MapDataTypeAPIApp constructor' algorithm generated code\n\n\t//End of 'MapDataTypeAPIApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mapdatatypeapiapp::~cfm_mapdatatypeapiapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MapDataTypeAPIApp destructor' algorithm generated code\n\n\t//End of 'MapDataTypeAPIApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ConsumerMap;\n\tdelete ProducerMap;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_mapdatatypeapiapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MapDataTypeAPIApp pre elaboration' algorithm generated code\n\n\t//End of 'MapDataTypeAPIApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_mapdatatypeapiapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MapDataTypeAPIApp post elaboration' algorithm generated code\n\n//End of 'MapDataTypeAPIApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_mapdatatypeapiapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MapDataTypeAPIApp post simulation' algorithm generated code\n\n\t//End of 'MapDataTypeAPIApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_mapdatatypeapiapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_MsgQMap.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQMap.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQMap.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQMap.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQMap.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQMap.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQMap.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_mapdatatypeapiapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MapDataTypeAPIApp initializations' algorithm generated code\n\n\t//End of 'MapDataTypeAPIApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProducerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n#define COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n\n/// Model Header includes start\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProducerMap includes' algorithm generated code\n\n//End of 'ProducerMap includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducerMap Function ProducerMap\n//@{\n///        \\page dxpProducerMap\n//@{\n///    \\brief ProducerMap function model start\nclass cfm_producermap: public cf_core::cf_function {\npublic:\n\t/// cfm_producermap type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producermap,\n\t\t\tcf_core::cf_payload_map> p_mq_MsgQMap_t;\n\t/// cfm_producermap type define end\n\n\t/// constructor\n\tcfm_producermap(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producermap(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQMap_t p_mq_MsgQMap;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerMap local declarations' algorithm generated code\n\n\t//End of 'ProducerMap local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ProducerMap function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProducerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producermap.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mapdatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producermap\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProducerMap definitions' algorithm generated code\n\n//End of 'ProducerMap definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producermap::cfm_producermap(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQMap(\"p_mq_MsgQMap\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerMap constructor' algorithm generated code\n\n\t//End of 'ProducerMap constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producermap::~cfm_producermap(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerMap destructor' algorithm generated code\n\n\t//End of 'ProducerMap destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producermap::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerMap pre elaboration' algorithm generated code\n\n\t//End of 'ProducerMap pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producermap::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerMap post elaboration' algorithm generated code\n\n\t//End of 'ProducerMap post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producermap::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerMap post simulation' algorithm generated code\n\n\t//End of 'ProducerMap post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producermap::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producermap::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerMap initializations' algorithm generated code\n\n\t//End of 'ProducerMap initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ConsumerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n#define COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n\n/// Model Header includes start\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ConsumerMap includes' algorithm generated code\n\n//End of 'ConsumerMap includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumerMap Function ConsumerMap\n//@{\n///        \\page dxpConsumerMap\n//@{\n///    \\brief ConsumerMap function model start\nclass cfm_consumermap: public cf_core::cf_function {\npublic:\n\t/// cfm_consumermap type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumermap,\n\t\t\tcf_core::cf_payload_map> p_mq_MsgQMap_t;\n\t/// cfm_consumermap type define end\n\n\t/// constructor\n\tcfm_consumermap(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumermap(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQMap_t p_mq_MsgQMap;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerMap local declarations' algorithm generated code\n\n\t//End of 'ConsumerMap local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ConsumerMap function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ConsumerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumermap.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mapdatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumermap\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ConsumerMap definitions' algorithm generated code\n\n//End of 'ConsumerMap definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumermap::cfm_consumermap(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQMap(\"p_mq_MsgQMap\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerMap constructor' algorithm generated code\n\n\t//End of 'ConsumerMap constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumermap::~cfm_consumermap(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerMap destructor' algorithm generated code\n\n\t//End of 'ConsumerMap destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumermap::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerMap pre elaboration' algorithm generated code\n\n\t//End of 'ConsumerMap pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumermap::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerMap post elaboration' algorithm generated code\n\n\t//End of 'ConsumerMap post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumermap::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerMap post simulation' algorithm generated code\n\n\t//End of 'ConsumerMap post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumermap::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumermap::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerMap initializations' algorithm generated code\n\n\t//End of 'ConsumerMap initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VectorDataTypeAPIApp', 'models': [{'name': 'ProducerVector', 'type': 'cofluent:Function'}, {'name': 'ConsumerVector', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQVector', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerVector', 'ConsumerVector']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_vectordatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP\n#define COFS_MODEL_VECTORDATATYPEAPIAPP\n\n/// Model Header includes start\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumervector.h\"\n#include \"cfm_producervector.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'VectorDataTypeAPIApp includes' algorithm generated code\n\n//End of 'VectorDataTypeAPIApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgVectorDataTypeAPIApp Function VectorDataTypeAPIApp\n//@{\n///        \\page dxpVectorDataTypeAPIApp\n//@{\n///    \\brief VectorDataTypeAPIApp function model start\nclass cfm_vectordatatypeapiapp: public cf_core::cf_application {\npublic:\n\t/// cfm_vectordatatypeapiapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_vector> mq_MsgQVector_t;\n\n\t/// cfm_vectordatatypeapiapp type define end\n\n\t/// constructor\n\tcfm_vectordatatypeapiapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_vectordatatypeapiapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumervector* ConsumerVector;\n\tcfm_producervector* ProducerVector;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQVector_t mq_MsgQVector;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VectorDataTypeAPIApp local declarations' algorithm generated code\n\n\t//End of 'VectorDataTypeAPIApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief VectorDataTypeAPIApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VectorDataTypeAPIApp', 'models': [{'name': 'ProducerVector', 'type': 'cofluent:Function'}, {'name': 'ConsumerVector', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQVector', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerVector', 'ConsumerVector']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_vectordatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_vectordatatypeapiapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'VectorDataTypeAPIApp definitions' algorithm generated code\n\n//End of 'VectorDataTypeAPIApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_vectordatatypeapiapp::cfm_vectordatatypeapiapp(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_MsgQVector(\"MsgQVector\") {\n\tcf_application::init();\n\tConsumerVector = new cfm_consumervector(\"ConsumerVector\");\n\tProducerVector = new cfm_producervector(\"ProducerVector\");\n\n\t// connections\n\tConsumerVector->p_mq_MsgQVector(mq_MsgQVector.p_target_socket);\n\n\tProducerVector->p_mq_MsgQVector(mq_MsgQVector.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VectorDataTypeAPIApp constructor' algorithm generated code\n\n\t//End of 'VectorDataTypeAPIApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_vectordatatypeapiapp::~cfm_vectordatatypeapiapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VectorDataTypeAPIApp destructor' algorithm generated code\n\n\t//End of 'VectorDataTypeAPIApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ConsumerVector;\n\tdelete ProducerVector;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_vectordatatypeapiapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VectorDataTypeAPIApp pre elaboration' algorithm generated code\n\n\t//End of 'VectorDataTypeAPIApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_vectordatatypeapiapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'VectorDataTypeAPIApp post elaboration' algorithm generated code\n\n//End of 'VectorDataTypeAPIApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_vectordatatypeapiapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VectorDataTypeAPIApp post simulation' algorithm generated code\n\n\t//End of 'VectorDataTypeAPIApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_vectordatatypeapiapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_MsgQVector.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQVector.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQVector.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQVector.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQVector.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQVector.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQVector.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_vectordatatypeapiapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'VectorDataTypeAPIApp initializations' algorithm generated code\n\n\t//End of 'VectorDataTypeAPIApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProducerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n#define COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n\n/// Model Header includes start\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProducerVector includes' algorithm generated code\n\n//End of 'ProducerVector includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducerVector Function ProducerVector\n//@{\n///        \\page dxpProducerVector\n//@{\n///    \\brief ProducerVector function model start\nclass cfm_producervector: public cf_core::cf_function {\npublic:\n\t/// cfm_producervector type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producervector,\n\t\t\tcf_core::cf_payload_vector> p_mq_MsgQVector_t;\n\t/// cfm_producervector type define end\n\n\t/// constructor\n\tcfm_producervector(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producervector(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQVector_t p_mq_MsgQVector;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerVector local declarations' algorithm generated code\n\n\t//End of 'ProducerVector local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ProducerVector function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProducerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producervector.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_vectordatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producervector\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ProducerVector definitions' algorithm generated code\n\n//End of 'ProducerVector definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producervector::cfm_producervector(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQVector(\"p_mq_MsgQVector\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerVector constructor' algorithm generated code\n\n\t//End of 'ProducerVector constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producervector::~cfm_producervector(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerVector destructor' algorithm generated code\n\n\t//End of 'ProducerVector destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producervector::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerVector pre elaboration' algorithm generated code\n\n\t//End of 'ProducerVector pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producervector::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerVector post elaboration' algorithm generated code\n\n\t//End of 'ProducerVector post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producervector::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerVector post simulation' algorithm generated code\n\n\t//End of 'ProducerVector post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producervector::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producervector::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ProducerVector initializations' algorithm generated code\n\n\t//End of 'ProducerVector initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ConsumerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n#define COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n\n/// Model Header includes start\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ConsumerVector includes' algorithm generated code\n\n//End of 'ConsumerVector includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumerVector Function ConsumerVector\n//@{\n///        \\page dxpConsumerVector\n//@{\n///    \\brief ConsumerVector function model start\nclass cfm_consumervector: public cf_core::cf_function {\npublic:\n\t/// cfm_consumervector type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumervector,\n\t\t\tcf_core::cf_payload_vector> p_mq_MsgQVector_t;\n\t/// cfm_consumervector type define end\n\n\t/// constructor\n\tcfm_consumervector(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumervector(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQVector_t p_mq_MsgQVector;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerVector local declarations' algorithm generated code\n\n\t//End of 'ConsumerVector local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ConsumerVector function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ConsumerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumervector.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_vectordatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumervector\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ConsumerVector definitions' algorithm generated code\n\n//End of 'ConsumerVector definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumervector::cfm_consumervector(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQVector(\"p_mq_MsgQVector\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerVector constructor' algorithm generated code\n\n\t//End of 'ConsumerVector constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumervector::~cfm_consumervector(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerVector destructor' algorithm generated code\n\n\t//End of 'ConsumerVector destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumervector::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerVector pre elaboration' algorithm generated code\n\n\t//End of 'ConsumerVector pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumervector::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerVector post elaboration' algorithm generated code\n\n\t//End of 'ConsumerVector post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumervector::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerVector post simulation' algorithm generated code\n\n\t//End of 'ConsumerVector post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumervector::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumervector::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ConsumerVector initializations' algorithm generated code\n\n\t//End of 'ConsumerVector initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationVectorDataType', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Processing', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Processing']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Processing', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationvectordatatype\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_processing.h\"\n#include \"cfm_producer.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationVectorDataType includes' algorithm generated code\n\n//End of 'ApplicationVectorDataType includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationVectorDataType Function ApplicationVectorDataType\n//@{\n///        \\page dxpApplicationVectorDataType\n//@{\n///    \\brief ApplicationVectorDataType function model start\nclass cfm_applicationvectordatatype: public cf_core::cf_application {\npublic:\n\t/// cfm_applicationvectordatatype type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_vector> mq_user_data_in_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_vector> mq_user_data_out_t;\n\n\t/// cfm_applicationvectordatatype type define end\n\n\t/// constructor\n\tcfm_applicationvectordatatype(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_applicationvectordatatype(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer* Consumer;\n\tcfm_processing* Processing;\n\tcfm_producer* Producer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_user_data_in_t mq_user_data_in;\n\tmq_user_data_out_t mq_user_data_out;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationVectorDataType local declarations' algorithm generated code\n\n\t//End of 'ApplicationVectorDataType local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ApplicationVectorDataType function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationVectorDataType', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Processing', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Processing']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Processing', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationvectordatatype\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationvectordatatype.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationVectorDataType definitions' algorithm generated code\n\n//End of 'ApplicationVectorDataType definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationvectordatatype::cfm_applicationvectordatatype(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), mq_user_data_in(\"user_data_in\"), mq_user_data_out(\n\t\t\t\t\"user_data_out\") {\n\tcf_application::init();\n\tConsumer = new cfm_consumer(\"Consumer\");\n\tProcessing = new cfm_processing(\"Processing\");\n\tProducer = new cfm_producer(\"Producer\");\n\n\t// connections\n\tConsumer->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n\n\tProcessing->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n\tProcessing->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n\n\tProducer->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationVectorDataType constructor' algorithm generated code\n\n\t//End of 'ApplicationVectorDataType constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationvectordatatype::~cfm_applicationvectordatatype(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationVectorDataType destructor' algorithm generated code\n\n\t//End of 'ApplicationVectorDataType destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer;\n\tdelete Processing;\n\tdelete Producer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_applicationvectordatatype::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationVectorDataType pre elaboration' algorithm generated code\n\n\t//End of 'ApplicationVectorDataType pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_applicationvectordatatype::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationVectorDataType post elaboration' algorithm generated code\n\n//End of 'ApplicationVectorDataType post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_applicationvectordatatype::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationVectorDataType post simulation' algorithm generated code\n\n\t//End of 'ApplicationVectorDataType post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_applicationvectordatatype::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_user_data_in.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_in.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_in.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_in.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_user_data_out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_user_data_out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_user_data_out.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_applicationvectordatatype::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationVectorDataType initializations' algorithm generated code\n\n\t//End of 'ApplicationVectorDataType initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_vector> p_mq_user_data_in_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\tint value;\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_user_data_in(\"p_mq_user_data_in\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\tvalue = 0;\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Processing', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_processing\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Processing includes' algorithm generated code\n\n//End of 'Processing includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProcessing Function Processing\n//@{\n///        \\page dxpProcessing\n//@{\n///    \\brief Processing function model start\nclass cfm_processing: public cf_core::cf_function {\npublic:\n\t/// cfm_processing type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_processing,\n\t\t\tcf_core::cf_payload_vector> p_mq_user_data_in_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_processing,\n\t\t\tcf_core::cf_payload_vector> p_mq_user_data_out_t;\n\t/// cfm_processing type define end\n\n\t/// constructor\n\tcfm_processing(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_processing(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_user_data_in_t p_mq_user_data_in;\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Processing local declarations' algorithm generated code\n\tint block_index;\n\t//End of 'Processing local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Processing function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Processing', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_processing\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_processing.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_processing\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Processing definitions' algorithm generated code\n\n//End of 'Processing definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_processing::cfm_processing(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_user_data_in(\"p_mq_user_data_in\"), p_mq_user_data_out(\n\t\t\t\t\"p_mq_user_data_out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Processing constructor' algorithm generated code\n\n\t//End of 'Processing constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_processing::~cfm_processing(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Processing destructor' algorithm generated code\n\n\t//End of 'Processing destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_processing::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Processing pre elaboration' algorithm generated code\n\n\t//End of 'Processing pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_processing::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Processing post elaboration' algorithm generated code\n\n\t//End of 'Processing post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_processing::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Processing post simulation' algorithm generated code\n\n\t//End of 'Processing post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_processing::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_processing::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Processing initializations' algorithm generated code\n\tblock_index = 0;\n\t//End of 'Processing initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer,\n\t\t\tcf_core::cf_payload_vector> p_mq_user_data_out_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_user_data_out_t p_mq_user_data_out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_user_data_out(\"p_mq_user_data_out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoSimVerilatorChiselApp', 'models': [{'name': 'Producer1', 'type': 'cofluent:Function'}, {'name': 'Producer2', 'type': 'cofluent:Function'}, {'name': 'adder', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'sum', 'type': 'cofluent:MessageQueue', 'dataType': 'Defsum', 'connectTo': ['adder', 'Consumer']}, {'name': 'data1', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer1', 'adder']}, {'name': 'data2', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer2', 'adder']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cosimverilatorchiselapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP\n#define COFS_MODEL_COSIMVERILATORCHISELAPP\n\n/// Model Header includes start\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer1.h\"\n#include \"cfm_producer2.h\"\n#include \"wrappers/cfm_data1_initiator.h\"\n#include \"wrappers/cfm_data2_initiator.h\"\n#include \"wrappers/cfm_sum_target.h\"\n#include \"dpi/cofluent_dpi.h\"\n#include \"dt/cft_defsum.h\"\n#include \"dt/cft_defdata1.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoSimVerilatorChiselApp includes' algorithm generated code\n\n//End of 'CoSimVerilatorChiselApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoSimVerilatorChiselApp Function CoSimVerilatorChiselApp\n//@{\n///        \\page dxpCoSimVerilatorChiselApp\n//@{\n///    \\brief CoSimVerilatorChiselApp function model start\nclass cfm_cosimverilatorchiselapp: public cf_core::cf_application {\npublic:\n\t/// cfm_cosimverilatorchiselapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defdata1> mq_data1_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata1> mq_data2_t;\n\ttypedef cf_core::cf_message_queue<cft_defsum> mq_sum_t;\n\n\t/// cfm_cosimverilatorchiselapp type define end\n\n\t/// constructor\n\tcfm_cosimverilatorchiselapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_cosimverilatorchiselapp(void);\n\tvirtual void cb_before_elaboration(void);\n\t//axi lite master\n\tstatic void data1DPI(ContextHandle self, bool resetn,\n\t/* Write address channel.  */\n\tbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA1>* sig_awaddr,\n\t\t\tsc_bv<3>* sig_awprot,\n\t\t\t/* Write data channel.  */\n\t\t\tbool* sig_wvalid, bool sig_wready,\n\t\t\tsc_bv<DATA_WIDTH_DATA1>* sig_wdata,\n\t\t\tsc_bv<DATA_WIDTH_DATA1 / 8>* sig_wstrb,\n\t\t\t/* Write response channel.  */\n\t\t\tbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n\t\t\t/* Read address channel.  */\n\t\t\tbool* sig_arvalid, bool sig_arready,\n\t\t\tsc_bv<ADDR_WIDTH_DATA1>* sig_araddr, sc_bv<3>* sig_arprot,\n\t\t\t/* Read data channel.  */\n\t\t\tbool sig_rvalid, bool* sig_rready,\n\t\t\tsc_bv<DATA_WIDTH_DATA1> sig_rdata, sc_bv<2> sig_rresp);\n\t//axi lite master\n\tstatic void data2DPI(ContextHandle self, bool resetn,\n\t/* Write address channel.  */\n\tbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA2>* sig_awaddr,\n\t\t\tsc_bv<3>* sig_awprot,\n\t\t\t/* Write data channel.  */\n\t\t\tbool* sig_wvalid, bool sig_wready,\n\t\t\tsc_bv<DATA_WIDTH_DATA2>* sig_wdata,\n\t\t\tsc_bv<DATA_WIDTH_DATA2 / 8>* sig_wstrb,\n\t\t\t/* Write response channel.  */\n\t\t\tbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n\t\t\t/* Read address channel.  */\n\t\t\tbool* sig_arvalid, bool sig_arready,\n\t\t\tsc_bv<ADDR_WIDTH_DATA2>* sig_araddr, sc_bv<3>* sig_arprot,\n\t\t\t/* Read data channel.  */\n\t\t\tbool sig_rvalid, bool* sig_rready,\n\t\t\tsc_bv<DATA_WIDTH_DATA2> sig_rdata, sc_bv<2> sig_rresp);\n\t//axi lite client\n\tstatic void sumDPI(ContextHandle self, bool resetn,\n\t/* Write address channel.  */\n\tbool sig_awvalid, bool* sig_awready, sc_bv<ADDR_WIDTH_SUM> sig_awaddr,\n\t\t\tsc_bv<3> sig_awprot,\n\t\t\t/* Write data channel.  */\n\t\t\tbool sig_wvalid, bool* sig_wready, sc_bv<DATA_WIDTH_SUM> sig_wdata,\n\t\t\tsc_bv<DATA_WIDTH_SUM / 8> sig_wstrb,\n\t\t\t/* Write response channel.  */\n\t\t\tbool* sig_bvalid, bool sig_bready, sc_bv<2>* sig_bresp,\n\t\t\t/* Read address channel.  */\n\t\t\tbool sig_arvalid, bool* sig_arready,\n\t\t\tsc_bv<ADDR_WIDTH_SUM> sig_araddr, sc_bv<3> sig_arprot,\n\t\t\t/* Read data channel.  */\n\t\t\tbool* sig_rvalid, bool sig_rready, sc_bv<DATA_WIDTH_SUM>* sig_rdata,\n\t\t\tsc_bv<2>* sig_rresp);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer* Consumer;\n\tcfm_producer1* Producer1;\n\tcfm_producer2* Producer2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_data1_t mq_data1;\n\tmq_data2_t mq_data2;\n\tmq_sum_t mq_sum;\n\t//@}\n\npublic:\n\t/// \\name wrappers\n\t//@{\n\tcfm_data1_initiator data1_initiator;\n\tcfm_data2_initiator data2_initiator;\n\tcfm_sum_target sum_target;\n\t//@}\n\tsc_clock clk { \"clk\", 1, SC_NS, 0.5, 0, SC_NS, true };\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVerilatorChiselApp local declarations' algorithm generated code\n\n\t//End of 'CoSimVerilatorChiselApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CoSimVerilatorChiselApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoSimVerilatorChiselApp', 'models': [{'name': 'Producer1', 'type': 'cofluent:Function'}, {'name': 'Producer2', 'type': 'cofluent:Function'}, {'name': 'adder', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'sum', 'type': 'cofluent:MessageQueue', 'dataType': 'Defsum', 'connectTo': ['adder', 'Consumer']}, {'name': 'data1', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer1', 'adder']}, {'name': 'data2', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer2', 'adder']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cosimverilatorchiselapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cosimverilatorchiselapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoSimVerilatorChiselApp definitions' algorithm generated code\n\n//End of 'CoSimVerilatorChiselApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cosimverilatorchiselapp::cfm_cosimverilatorchiselapp(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), mq_data1(\"data1\"), mq_data2(\"data2\"), mq_sum(\n\t\t\t\t\"sum\"), data1_initiator(\"data1_initiator\"), data2_initiator(\n\t\t\t\t\"data2_initiator\"), sum_target(\"sum_target\") {\n\tcf_application::init();\n\tConsumer = new cfm_consumer(\"Consumer\");\n\tProducer1 = new cfm_producer1(\"Producer1\");\n\tProducer2 = new cfm_producer2(\"Producer2\");\n\n\t// connections\n\tConsumer->p_mq_sum(mq_sum.p_target_socket);\n\n\tProducer1->p_mq_data1(mq_data1.p_target_socket);\n\n\tProducer2->p_mq_data2(mq_data2.p_target_socket);\n\n\tdata1_initiator.p_mq_data1(mq_data1.p_target_socket);\n\tdata2_initiator.p_mq_data2(mq_data2.p_target_socket);\n\tsum_target.p_mq_sum(mq_sum.p_target_socket);\n\tDPIInit(this, data1DPI, data2DPI, sumDPI);\n\tdata1_initiator.axi_bridge.clk(clk);\n\tdata2_initiator.axi_bridge.clk(clk);\n\tsum_target.axi_bridge.clk(clk);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVerilatorChiselApp constructor' algorithm generated code\n\n\t//End of 'CoSimVerilatorChiselApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cosimverilatorchiselapp::~cfm_cosimverilatorchiselapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVerilatorChiselApp destructor' algorithm generated code\n\n\t//End of 'CoSimVerilatorChiselApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer;\n\tdelete Producer1;\n\tdelete Producer2;\n}\n//@}\n\nvoid cfm_cosimverilatorchiselapp::data1DPI(ContextHandle self, bool resetn,\n/* Write address channel.  */\nbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA1>* sig_awaddr,\n\t\tsc_bv<3>* sig_awprot,\n\t\t/* Write data channel.  */\n\t\tbool* sig_wvalid, bool sig_wready, sc_bv<DATA_WIDTH_DATA1>* sig_wdata,\n\t\tsc_bv<DATA_WIDTH_DATA1 / 8>* sig_wstrb,\n\t\t/* Write response channel.  */\n\t\tbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n\t\t/* Read address channel.  */\n\t\tbool* sig_arvalid, bool sig_arready,\n\t\tsc_bv<ADDR_WIDTH_DATA1>* sig_araddr, sc_bv<3>* sig_arprot,\n\t\t/* Read data channel.  */\n\t\tbool sig_rvalid, bool* sig_rready, sc_bv<DATA_WIDTH_DATA1> sig_rdata,\n\t\tsc_bv<2> sig_rresp) {\n\tstatic_cast<cfm_cosimverilatorchiselapp*>(self)->data1_initiator.axiSignals(\n\t\t\tresetn,\n\t\t\t// Write address channel.  \n\t\t\tsig_awvalid, sig_awready, sig_awaddr, sig_awprot,\n\t\t\t// Write data channel.  \n\t\t\tsig_wvalid, sig_wready, sig_wdata, sig_wstrb,\n\t\t\t// Write response channel.  \n\t\t\tsig_bvalid, sig_bready, sig_bresp,\n\t\t\t// Read address channel.  \n\t\t\tsig_arvalid, sig_arready, sig_araddr, sig_arprot,\n\t\t\t// Read data channel.  \n\t\t\tsig_rvalid, sig_rready, sig_rdata, sig_rresp);\n}\nvoid cfm_cosimverilatorchiselapp::data2DPI(ContextHandle self, bool resetn,\n/* Write address channel.  */\nbool* sig_awvalid, bool sig_awready, sc_bv<ADDR_WIDTH_DATA2>* sig_awaddr,\n\t\tsc_bv<3>* sig_awprot,\n\t\t/* Write data channel.  */\n\t\tbool* sig_wvalid, bool sig_wready, sc_bv<DATA_WIDTH_DATA2>* sig_wdata,\n\t\tsc_bv<DATA_WIDTH_DATA2 / 8>* sig_wstrb,\n\t\t/* Write response channel.  */\n\t\tbool sig_bvalid, bool* sig_bready, sc_bv<2> sig_bresp,\n\t\t/* Read address channel.  */\n\t\tbool* sig_arvalid, bool sig_arready,\n\t\tsc_bv<ADDR_WIDTH_DATA2>* sig_araddr, sc_bv<3>* sig_arprot,\n\t\t/* Read data channel.  */\n\t\tbool sig_rvalid, bool* sig_rready, sc_bv<DATA_WIDTH_DATA2> sig_rdata,\n\t\tsc_bv<2> sig_rresp) {\n\tstatic_cast<cfm_cosimverilatorchiselapp*>(self)->data2_initiator.axiSignals(\n\t\t\tresetn,\n\t\t\t// Write address channel.  \n\t\t\tsig_awvalid, sig_awready, sig_awaddr, sig_awprot,\n\t\t\t// Write data channel.  \n\t\t\tsig_wvalid, sig_wready, sig_wdata, sig_wstrb,\n\t\t\t// Write response channel.  \n\t\t\tsig_bvalid, sig_bready, sig_bresp,\n\t\t\t// Read address channel.  \n\t\t\tsig_arvalid, sig_arready, sig_araddr, sig_arprot,\n\t\t\t// Read data channel.  \n\t\t\tsig_rvalid, sig_rready, sig_rdata, sig_rresp);\n}\nvoid cfm_cosimverilatorchiselapp::sumDPI(ContextHandle self, bool resetn,\n/* Write address channel.  */\nbool sig_awvalid, bool* sig_awready, sc_bv<ADDR_WIDTH_SUM> sig_awaddr,\n\t\tsc_bv<3> sig_awprot,\n\t\t/* Write data channel.  */\n\t\tbool sig_wvalid, bool* sig_wready, sc_bv<DATA_WIDTH_SUM> sig_wdata,\n\t\tsc_bv<DATA_WIDTH_SUM / 8> sig_wstrb,\n\t\t/* Write response channel.  */\n\t\tbool* sig_bvalid, bool sig_bready, sc_bv<2>* sig_bresp,\n\t\t/* Read address channel.  */\n\t\tbool sig_arvalid, bool* sig_arready, sc_bv<ADDR_WIDTH_SUM> sig_araddr,\n\t\tsc_bv<3> sig_arprot,\n\t\t/* Read data channel.  */\n\t\tbool* sig_rvalid, bool sig_rready, sc_bv<DATA_WIDTH_SUM>* sig_rdata,\n\t\tsc_bv<2>* sig_rresp) {\n\tstatic_cast<cfm_cosimverilatorchiselapp*>(self)->sum_target.axiSignals(\n\t\t\tresetn,\n\t\t\t// Write address channel.  \n\t\t\tsig_awvalid, sig_awready, sig_awaddr, sig_awprot,\n\t\t\t// Write data channel.  \n\t\t\tsig_wvalid, sig_wready, sig_wdata, sig_wstrb,\n\t\t\t// Write response channel.  \n\t\t\tsig_bvalid, sig_bready, sig_bresp,\n\t\t\t// Read address channel.  \n\t\t\tsig_arvalid, sig_arready, sig_araddr, sig_arprot,\n\t\t\t// Read data channel.  \n\t\t\tsig_rvalid, sig_rready, sig_rdata, sig_rresp);\n}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_cosimverilatorchiselapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVerilatorChiselApp pre elaboration' algorithm generated code\n\n\t//End of 'CoSimVerilatorChiselApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_cosimverilatorchiselapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CoSimVerilatorChiselApp post elaboration' algorithm generated code\n\n//End of 'CoSimVerilatorChiselApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_cosimverilatorchiselapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVerilatorChiselApp post simulation' algorithm generated code\n\n\t//End of 'CoSimVerilatorChiselApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_cosimverilatorchiselapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_data1.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data1.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_data1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_data1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_data1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_data1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data2.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_data2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_data2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_data2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_sum.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_sum.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_sum.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_sum.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_sum.set_one_side_concurrency();\n\tmq_sum.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_sum.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_sum.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_cosimverilatorchiselapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CoSimVerilatorChiselApp initializations' algorithm generated code\n\n\t//End of 'CoSimVerilatorChiselApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer1', 'type': 'cofluent:Function', 'ports': [{'name': 'data1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n\n/// Model Header includes start\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata1.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer1 includes' algorithm generated code\n\n//End of 'Producer1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer1 Function Producer1\n//@{\n///        \\page dxpProducer1\n//@{\n///    \\brief Producer1 function model start\nclass cfm_producer1: public cf_core::cf_function {\npublic:\n\t/// cfm_producer1 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer1, cft_defdata1> p_mq_data1_t;\n\t/// cfm_producer1 type define end\n\n\t/// constructor\n\tcfm_producer1(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_data1_t p_mq_data1;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer1 local declarations' algorithm generated code\n\tint i = 1;\n\t//End of 'Producer1 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer1', 'type': 'cofluent:Function', 'ports': [{'name': 'data1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer1 definitions' algorithm generated code\n\n//End of 'Producer1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer1::cfm_producer1(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_data1(\"p_mq_data1\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer1 constructor' algorithm generated code\n\n\t//End of 'Producer1 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer1::~cfm_producer1(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer1 destructor' algorithm generated code\n\n\t//End of 'Producer1 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer1::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer1 pre elaboration' algorithm generated code\n\n\t//End of 'Producer1 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer1::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer1 post elaboration' algorithm generated code\n\n\t//End of 'Producer1 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer1::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer1 post simulation' algorithm generated code\n\n\t//End of 'Producer1 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer1::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer1::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer1 initializations' algorithm generated code\n\n\t//End of 'Producer1 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer2', 'type': 'cofluent:Function', 'ports': [{'name': 'data2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n\n/// Model Header includes start\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata1.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer2 includes' algorithm generated code\n\n//End of 'Producer2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer2 Function Producer2\n//@{\n///        \\page dxpProducer2\n//@{\n///    \\brief Producer2 function model start\nclass cfm_producer2: public cf_core::cf_function {\npublic:\n\t/// cfm_producer2 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer2, cft_defdata1> p_mq_data2_t;\n\t/// cfm_producer2 type define end\n\n\t/// constructor\n\tcfm_producer2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_data2_t p_mq_data2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer2 local declarations' algorithm generated code\n\tint i = 1;\n\t//End of 'Producer2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer2', 'type': 'cofluent:Function', 'ports': [{'name': 'data2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer2 definitions' algorithm generated code\n\n//End of 'Producer2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer2::cfm_producer2(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_data2(\"p_mq_data2\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer2 constructor' algorithm generated code\n\n\t//End of 'Producer2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer2::~cfm_producer2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer2 destructor' algorithm generated code\n\n\t//End of 'Producer2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer2 pre elaboration' algorithm generated code\n\n\t//End of 'Producer2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer2 post elaboration' algorithm generated code\n\n\t//End of 'Producer2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer2 post simulation' algorithm generated code\n\n\t//End of 'Producer2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer2 initializations' algorithm generated code\n\n\t//End of 'Producer2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'sum', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Defsum'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defsum.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cft_defsum> p_mq_sum_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_sum_t p_mq_sum;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\tint i = 1;\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'sum', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Defsum'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_sum(\"p_mq_sum\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TLM2LT', 'models': [{'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_tlm2lt\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT\n#define COFS_MODEL_TLM2LT\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_reader.h\"\n#include \"cfm_target.h\"\n#include \"cfm_target_2.h\"\n#include \"cfm_writer.h\"\n#include \"lt_top.h\"\n#include \"wrappers/cfm_initiatorreader_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_initiatorwriter_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_targetrequest_tlm2_lt_target.h\"\n#include \"wrappers/cfm_targetwrapper_tlm2_lt_target.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TLM2LT includes' algorithm generated code\n\n//End of 'TLM2LT includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTLM2LT Function TLM2LT\n//@{\n///        \\page dxpTLM2LT\n//@{\n///    \\brief TLM2LT function model start\nclass cfm_tlm2lt: public cf_core::cf_application {\npublic:\n\t/// cfm_tlm2lt type define start\n\t/// systemC IPs typedef\n\ttypedef lt_top TLM2Platfom_t;\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorReader_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_ReaderResponse_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_event ev_Sync_t;\n\ttypedef cf_core::cf_event ev_Sync2_t;\n\ttypedef cf_core::cf_event ev_Sync3_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetRequest_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetResponse_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetWrapper_t;\n\n\t/// cfm_tlm2lt type define end\n\n\t/// constructor\n\tcfm_tlm2lt(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_tlm2lt(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_reader* Reader;\n\tTLM2Platfom_t* TLM2Platfom;\n\tcfm_target* Target;\n\tcfm_target_2* Target_2;\n\tcfm_writer* Writer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_InitiatorReader_t mq_InitiatorReader;\n\tmq_InitiatorWriter_t mq_InitiatorWriter;\n\tmq_ReaderResponse_t mq_ReaderResponse;\n\tmq_ReferenceQueue_t mq_ReferenceQueue;\n\tmq_ReferenceQueue2_t mq_ReferenceQueue2;\n\tmq_ReferenceQueue3_t mq_ReferenceQueue3;\n\tev_Sync_t ev_Sync;\n\tev_Sync2_t ev_Sync2;\n\tev_Sync3_t ev_Sync3;\n\tmq_TargetRequest_t mq_TargetRequest;\n\tmq_TargetResponse_t mq_TargetResponse;\n\tmq_TargetWrapper_t mq_TargetWrapper;\n\t//@}\n\nprotected:\n\t/// \\name wrappers\n\t//@{\n\tcfm_initiatorreader_tlm2_lt_initiator initiatorreader_tlm2_lt_initiator;\n\tcfm_initiatorwriter_tlm2_lt_initiator initiatorwriter_tlm2_lt_initiator;\n\tcfm_targetrequest_tlm2_lt_target targetrequest_tlm2_lt_target;\n\tcfm_targetwrapper_tlm2_lt_target targetwrapper_tlm2_lt_target;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2LT local declarations' algorithm generated code\n\n\t//End of 'TLM2LT local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief TLM2LT function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TLM2LT', 'models': [{'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_tlm2lt\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_tlm2lt.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TLM2LT definitions' algorithm generated code\n\n//End of 'TLM2LT definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_tlm2lt::cfm_tlm2lt(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_InitiatorReader(\"InitiatorReader\"), mq_InitiatorWriter(\n\t\t\t\t\"InitiatorWriter\"), mq_ReaderResponse(\"ReaderResponse\"), mq_ReferenceQueue(\n\t\t\t\t\"ReferenceQueue\"), mq_ReferenceQueue2(\"ReferenceQueue2\"), mq_ReferenceQueue3(\n\t\t\t\t\"ReferenceQueue3\"), ev_Sync(\"Sync\"), ev_Sync2(\"Sync2\"), ev_Sync3(\n\t\t\t\t\"Sync3\"), mq_TargetRequest(\"TargetRequest\"), mq_TargetResponse(\n\t\t\t\t\"TargetResponse\"), mq_TargetWrapper(\"TargetWrapper\"), initiatorreader_tlm2_lt_initiator(\n\t\t\t\t\"initiatorreader_tlm2_lt_initiator\"), initiatorwriter_tlm2_lt_initiator(\n\t\t\t\t\"initiatorwriter_tlm2_lt_initiator\"), targetrequest_tlm2_lt_target(\n\t\t\t\t\"targetrequest_tlm2_lt_target\"), targetwrapper_tlm2_lt_target(\n\t\t\t\t\"targetwrapper_tlm2_lt_target\") {\n\tcf_application::init();\n\tReader = new cfm_reader(\"Reader\");\n\tTLM2Platfom = new TLM2Platfom_t(\"TLM2Platfom\");\n\tTarget = new cfm_target(\"Target\");\n\tTarget_2 = new cfm_target_2(\"Target_2\");\n\tWriter = new cfm_writer(\"Writer\");\n\n\t// connections\n\tReader->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n\tReader->p_mq_InitiatorReader(mq_InitiatorReader.p_target_socket);\n\tReader->p_mq_ReaderResponse(mq_ReaderResponse.p_target_socket);\n\tReader->p_ev_Sync(ev_Sync.p_target_socket);\n\n\tinitiatorwriter_tlm2_lt_initiator.p_tlm2(\n\t\t\tTLM2Platfom->m_bus.target_socket[2]);\n\tTLM2Platfom->m_bus.initiator_socket[2](targetwrapper_tlm2_lt_target.p_tlm2);\n\tinitiatorreader_tlm2_lt_initiator.p_tlm2(\n\t\t\tTLM2Platfom->m_bus.target_socket[3]);\n\tTLM2Platfom->m_bus.initiator_socket[3](targetrequest_tlm2_lt_target.p_tlm2);\n\n\tTarget->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n\tTarget->p_mq_TargetWrapper(mq_TargetWrapper.p_target_socket);\n\tTarget->p_ev_Sync2(ev_Sync2.p_target_socket);\n\n\tTarget_2->p_mq_TargetRequest(mq_TargetRequest.p_target_socket);\n\tTarget_2->p_mq_TargetResponse(mq_TargetResponse.p_target_socket);\n\tTarget_2->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n\tTarget_2->p_ev_Sync3(ev_Sync3.p_target_socket);\n\n\tWriter->p_mq_InitiatorWriter(mq_InitiatorWriter.p_target_socket);\n\tWriter->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n\tWriter->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n\tWriter->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n\tWriter->p_ev_Sync(ev_Sync.p_target_socket);\n\tWriter->p_ev_Sync2(ev_Sync2.p_target_socket);\n\tWriter->p_ev_Sync3(ev_Sync3.p_target_socket);\n\n\tinitiatorreader_tlm2_lt_initiator.p_mq_request(\n\t\t\tmq_InitiatorReader.p_target_socket);\n\tinitiatorreader_tlm2_lt_initiator.p_mq_response(\n\t\t\tmq_ReaderResponse.p_target_socket);\n\tinitiatorwriter_tlm2_lt_initiator.p_mq_request(\n\t\t\tmq_InitiatorWriter.p_target_socket);\n\ttargetrequest_tlm2_lt_target.p_mq_request(mq_TargetRequest.p_target_socket);\n\ttargetrequest_tlm2_lt_target.p_mq_response(\n\t\t\tmq_TargetResponse.p_target_socket);\n\ttargetwrapper_tlm2_lt_target.p_mq_request(mq_TargetWrapper.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2LT constructor' algorithm generated code\n\n\t//End of 'TLM2LT constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_tlm2lt::~cfm_tlm2lt(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2LT destructor' algorithm generated code\n\n\t//End of 'TLM2LT destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Reader;\n\tdelete TLM2Platfom;\n\tdelete Target;\n\tdelete Target_2;\n\tdelete Writer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_tlm2lt::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2LT pre elaboration' algorithm generated code\n\n\t//End of 'TLM2LT pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_tlm2lt::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TLM2LT post elaboration' algorithm generated code\n\n//End of 'TLM2LT post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_tlm2lt::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2LT post simulation' algorithm generated code\n\n\t//End of 'TLM2LT post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_tlm2lt::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_InitiatorReader.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorReader.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_InitiatorReader.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_InitiatorWriter.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_InitiatorWriter.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_InitiatorWriter.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReaderResponse.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_ReaderResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReaderResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue3.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_Sync.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync2.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync3.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tmq_TargetRequest.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetResponse.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetWrapper.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetWrapper.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetWrapper.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_tlm2lt::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2LT initializations' algorithm generated code\n\n\t//End of 'TLM2LT initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_WRITER\n#define COFS_MODEL_TLM2LT_WRITER\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Writer includes' algorithm generated code\n\n//End of 'Writer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWriter Function Writer\n//@{\n///        \\page dxpWriter\n//@{\n///    \\brief Writer function model start\nclass cfm_writer: public cf_core::cf_function {\npublic:\n\t/// cfm_writer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cf_core::cf_payload_tlm2> p_mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync2_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync3_t;\n\t/// cfm_writer type define end\n\n\t/// constructor\n\tcfm_writer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_writer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_InitiatorWriter_t p_mq_InitiatorWriter;\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_ev_Sync_t p_ev_Sync;\n\tp_ev_Sync2_t p_ev_Sync2;\n\tp_ev_Sync3_t p_ev_Sync3;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer local declarations' algorithm generated code\n\tint data;\n\t//End of 'Writer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Writer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_WRITER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_writer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Writer definitions' algorithm generated code\n\n//End of 'Writer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_writer::cfm_writer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_InitiatorWriter(\"p_mq_InitiatorWriter\"), p_mq_ReferenceQueue(\n\t\t\t\t\"p_mq_ReferenceQueue\"), p_mq_ReferenceQueue2(\n\t\t\t\t\"p_mq_ReferenceQueue2\"), p_mq_ReferenceQueue3(\n\t\t\t\t\"p_mq_ReferenceQueue3\"), p_ev_Sync(\"p_ev_Sync\"), p_ev_Sync2(\n\t\t\t\t\"p_ev_Sync2\"), p_ev_Sync3(\"p_ev_Sync3\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer constructor' algorithm generated code\n\n\t//End of 'Writer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_writer::~cfm_writer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer destructor' algorithm generated code\n\n\t//End of 'Writer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_writer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer pre elaboration' algorithm generated code\n\n\t//End of 'Writer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_writer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer post elaboration' algorithm generated code\n\n\t//End of 'Writer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_writer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer post simulation' algorithm generated code\n\n\t//End of 'Writer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_writer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_writer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer initializations' algorithm generated code\n\n\t//End of 'Writer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_TARGET\n#define COFS_MODEL_TLM2LT_TARGET\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target includes' algorithm generated code\n\n//End of 'Target includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget Function Target\n//@{\n///        \\page dxpTarget\n//@{\n///    \\brief Target function model start\nclass cfm_target: public cf_core::cf_function {\npublic:\n\t/// cfm_target type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cf_core::cf_payload_tlm2> p_mq_TargetWrapper_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target> p_ev_Sync2_t;\n\t/// cfm_target type define end\n\n\t/// constructor\n\tcfm_target(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_target(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_mq_TargetWrapper_t p_mq_TargetWrapper;\n\tp_ev_Sync2_t p_ev_Sync2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target local declarations' algorithm generated code\n\n\t//End of 'Target local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Target function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_TARGET\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target definitions' algorithm generated code\n\n//End of 'Target definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target::cfm_target(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_ReferenceQueue2(\"p_mq_ReferenceQueue2\"), p_mq_TargetWrapper(\n\t\t\t\t\"p_mq_TargetWrapper\"), p_ev_Sync2(\"p_ev_Sync2\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target constructor' algorithm generated code\n\n\t//End of 'Target constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target::~cfm_target(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target destructor' algorithm generated code\n\n\t//End of 'Target destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_target::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target pre elaboration' algorithm generated code\n\n\t//End of 'Target pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_target::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post elaboration' algorithm generated code\n\n\t//End of 'Target post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_target::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post simulation' algorithm generated code\n\n\t//End of 'Target post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_target::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_target::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target initializations' algorithm generated code\n\n\t//End of 'Target initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_READER\n#define COFS_MODEL_TLM2LT_READER\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Reader includes' algorithm generated code\n\n//End of 'Reader includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReader Function Reader\n//@{\n///        \\page dxpReader\n//@{\n///    \\brief Reader function model start\nclass cfm_reader: public cf_core::cf_function {\npublic:\n\t/// cfm_reader type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_InitiatorReader_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_ReaderResponse_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_reader> p_ev_Sync_t;\n\t/// cfm_reader type define end\n\n\t/// constructor\n\tcfm_reader(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_reader(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_mq_InitiatorReader_t p_mq_InitiatorReader;\n\tp_mq_ReaderResponse_t p_mq_ReaderResponse;\n\tp_ev_Sync_t p_ev_Sync;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader local declarations' algorithm generated code\n\tint data;\n\t//End of 'Reader local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Reader function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_READER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_reader.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reader\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Reader definitions' algorithm generated code\n\n//End of 'Reader definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_reader::cfm_reader(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_ReferenceQueue3(\"p_mq_ReferenceQueue3\"), p_mq_InitiatorReader(\n\t\t\t\t\"p_mq_InitiatorReader\"), p_mq_ReaderResponse(\n\t\t\t\t\"p_mq_ReaderResponse\"), p_ev_Sync(\"p_ev_Sync\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader constructor' algorithm generated code\n\n\t//End of 'Reader constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_reader::~cfm_reader(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader destructor' algorithm generated code\n\n\t//End of 'Reader destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_reader::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader pre elaboration' algorithm generated code\n\n\t//End of 'Reader pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_reader::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader post elaboration' algorithm generated code\n\n\t//End of 'Reader post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_reader::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader post simulation' algorithm generated code\n\n\t//End of 'Reader post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_reader::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_reader::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader initializations' algorithm generated code\n\n\t//End of 'Reader initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_TARGET_2\n#define COFS_MODEL_TLM2LT_TARGET_2\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target_2 includes' algorithm generated code\n\n//End of 'Target_2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget_2 Function Target_2\n//@{\n///        \\page dxpTarget_2\n//@{\n///    \\brief Target_2 function model start\nclass cfm_target_2: public cf_core::cf_function {\npublic:\n\t/// cfm_target_2 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2,\n\t\t\tcf_core::cf_payload_tlm2> p_mq_TargetRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2,\n\t\t\tcf_core::cf_payload_tlm2> p_mq_TargetResponse_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target_2> p_ev_Sync3_t;\n\t/// cfm_target_2 type define end\n\n\t/// constructor\n\tcfm_target_2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_target_2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_TargetRequest_t p_mq_TargetRequest;\n\tp_mq_TargetResponse_t p_mq_TargetResponse;\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_ev_Sync3_t p_ev_Sync3;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 local declarations' algorithm generated code\n\n\t//End of 'Target_2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Target_2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_TARGET_2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target_2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target_2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target_2 definitions' algorithm generated code\n\n//End of 'Target_2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target_2::cfm_target_2(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_TargetRequest(\"p_mq_TargetRequest\"), p_mq_TargetResponse(\n\t\t\t\t\"p_mq_TargetResponse\"), p_mq_ReferenceQueue(\n\t\t\t\t\"p_mq_ReferenceQueue\"), p_ev_Sync3(\"p_ev_Sync3\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 constructor' algorithm generated code\n\n\t//End of 'Target_2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target_2::~cfm_target_2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 destructor' algorithm generated code\n\n\t//End of 'Target_2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_target_2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 pre elaboration' algorithm generated code\n\n\t//End of 'Target_2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_target_2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 post elaboration' algorithm generated code\n\n\t//End of 'Target_2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_target_2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 post simulation' algorithm generated code\n\n\t//End of 'Target_2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_target_2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_target_2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 initializations' algorithm generated code\n\n\t//End of 'Target_2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'AutomatedPayloadTrackers', 'models': [{'name': 'C2', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}, {'name': 'F12', 'type': 'cofluent:Function'}, {'name': 'P1', 'type': 'cofluent:Function'}, {'name': 'P2', 'type': 'cofluent:Function'}, {'name': 'C1', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M1_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P1']}, {'name': 'M1_3', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'C1']}, {'name': 'M2_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P2']}, {'name': 'M2_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['C2', 'F12']}, {'name': 'M1_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'F12']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_automatedpayloadtrackers\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_c1.h\"\n#include \"cfm_c2.h\"\n#include \"cfm_f12.h\"\n#include \"cfm_f2.h\"\n#include \"cfm_p1.h\"\n#include \"cfm_p2.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'AutomatedPayloadTrackers includes' algorithm generated code\n\n//End of 'AutomatedPayloadTrackers includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgAutomatedPayloadTrackers Function AutomatedPayloadTrackers\n//@{\n///        \\page dxpAutomatedPayloadTrackers\n//@{\n///    \\brief AutomatedPayloadTrackers function model start\nclass cfm_automatedpayloadtrackers: public cf_core::cf_application {\npublic:\n\t/// cfm_automatedpayloadtrackers type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_1_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_2_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_3_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M2_1_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M2_2_t;\n\n\t/// cfm_automatedpayloadtrackers type define end\n\n\t/// constructor\n\tcfm_automatedpayloadtrackers(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_automatedpayloadtrackers(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_c1* C1;\n\tcfm_c2* C2;\n\tcfm_f12* F12;\n\tcfm_f2* F2;\n\tcfm_p1* P1;\n\tcfm_p2* P2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_M1_1_t mq_M1_1;\n\tmq_M1_2_t mq_M1_2;\n\tmq_M1_3_t mq_M1_3;\n\tmq_M2_1_t mq_M2_1;\n\tmq_M2_2_t mq_M2_2;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AutomatedPayloadTrackers local declarations' algorithm generated code\n\n\t//End of 'AutomatedPayloadTrackers local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief AutomatedPayloadTrackers function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'AutomatedPayloadTrackers', 'models': [{'name': 'C2', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}, {'name': 'F12', 'type': 'cofluent:Function'}, {'name': 'P1', 'type': 'cofluent:Function'}, {'name': 'P2', 'type': 'cofluent:Function'}, {'name': 'C1', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M1_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P1']}, {'name': 'M1_3', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'C1']}, {'name': 'M2_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P2']}, {'name': 'M2_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['C2', 'F12']}, {'name': 'M1_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'F12']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_automatedpayloadtrackers\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_automatedpayloadtrackers.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'AutomatedPayloadTrackers definitions' algorithm generated code\n\n//End of 'AutomatedPayloadTrackers definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_automatedpayloadtrackers::cfm_automatedpayloadtrackers(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), mq_M1_1(\"M1_1\"), mq_M1_2(\"M1_2\"), mq_M1_3(\"M1_3\"), mq_M2_1(\n\t\t\t\t\"M2_1\"), mq_M2_2(\"M2_2\") {\n\tcf_application::init();\n\tC1 = new cfm_c1(\"C1\");\n\tC2 = new cfm_c2(\"C2\");\n\tF12 = new cfm_f12(\"F12\");\n\tF2 = new cfm_f2(\"F2\");\n\tP1 = new cfm_p1(\"P1\");\n\tP2 = new cfm_p2(\"P2\");\n\n\t// connections\n\tC1->p_mq_M1_3(mq_M1_3.p_target_socket);\n\n\tC2->p_mq_M2_2(mq_M2_2.p_target_socket);\n\n\tF12->p_mq_M1_1(mq_M1_1.p_target_socket);\n\tF12->p_mq_M2_1(mq_M2_1.p_target_socket);\n\tF12->p_mq_M1_2(mq_M1_2.p_target_socket);\n\tF12->p_mq_M2_2(mq_M2_2.p_target_socket);\n\n\tF2->p_mq_M1_2(mq_M1_2.p_target_socket);\n\tF2->p_mq_M1_3(mq_M1_3.p_target_socket);\n\n\tP1->p_mq_M1_1(mq_M1_1.p_target_socket);\n\n\tP2->p_mq_M2_1(mq_M2_1.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AutomatedPayloadTrackers constructor' algorithm generated code\n\n\t//End of 'AutomatedPayloadTrackers constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_automatedpayloadtrackers::~cfm_automatedpayloadtrackers(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AutomatedPayloadTrackers destructor' algorithm generated code\n\n\t//End of 'AutomatedPayloadTrackers destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete C1;\n\tdelete C2;\n\tdelete F12;\n\tdelete F2;\n\tdelete P1;\n\tdelete P2;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_automatedpayloadtrackers::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AutomatedPayloadTrackers pre elaboration' algorithm generated code\n\n\t//End of 'AutomatedPayloadTrackers pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_automatedpayloadtrackers::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'AutomatedPayloadTrackers post elaboration' algorithm generated code\n\n//End of 'AutomatedPayloadTrackers post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_automatedpayloadtrackers::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AutomatedPayloadTrackers post simulation' algorithm generated code\n\n\t//End of 'AutomatedPayloadTrackers post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_automatedpayloadtrackers::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_M1_1.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_1.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M1_1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M1_1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M1_1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_2.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M1_2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_3.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M1_3.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M1_3.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M1_3.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_1.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M2_1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_1.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_2.cfa_receive_time.init(cf_expr_duration(10, CF_NS));\n\tmq_M2_2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M2_2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_M2_2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_automatedpayloadtrackers::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AutomatedPayloadTrackers initializations' algorithm generated code\n\n\t//End of 'AutomatedPayloadTrackers initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'C2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_c2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'C2 includes' algorithm generated code\n\n//End of 'C2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgC2 Function C2\n//@{\n///        \\page dxpC2\n//@{\n///    \\brief C2 function model start\nclass cfm_c2: public cf_core::cf_function {\npublic:\n\t/// cfm_c2 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_c2, cf_core::cf_payload_int> p_mq_M2_2_t;\n\t/// cfm_c2 type define end\n\n\t/// constructor\n\tcfm_c2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_c2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_M2_2_t p_mq_M2_2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C2 local declarations' algorithm generated code\n\n\t//End of 'C2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief C2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'C2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_c2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_c2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_c2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'C2 definitions' algorithm generated code\n\n//End of 'C2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_c2::cfm_c2(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_M2_2(\"p_mq_M2_2\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C2 constructor' algorithm generated code\n\n\t//End of 'C2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_c2::~cfm_c2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C2 destructor' algorithm generated code\n\n\t//End of 'C2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_c2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C2 pre elaboration' algorithm generated code\n\n\t//End of 'C2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_c2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C2 post elaboration' algorithm generated code\n\n\t//End of 'C2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_c2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C2 post simulation' algorithm generated code\n\n\t//End of 'C2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_c2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_c2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C2 initializations' algorithm generated code\n\n\t//End of 'C2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F2 includes' algorithm generated code\n\n//End of 'F2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF2 Function F2\n//@{\n///        \\page dxpF2\n//@{\n///    \\brief F2 function model start\nclass cfm_f2: public cf_core::cf_function {\npublic:\n\t/// cfm_f2 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f2, cf_core::cf_payload_int> p_mq_M1_2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f2, cf_core::cf_payload_int> p_mq_M1_3_t;\n\t/// cfm_f2 type define end\n\n\t/// constructor\n\tcfm_f2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_f2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_M1_2_t p_mq_M1_2;\n\tp_mq_M1_3_t p_mq_M1_3;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 local declarations' algorithm generated code\n\n\t//End of 'F2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief F2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F2 definitions' algorithm generated code\n\n//End of 'F2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f2::cfm_f2(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_M1_2(\"p_mq_M1_2\"), p_mq_M1_3(\"p_mq_M1_3\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 constructor' algorithm generated code\n\n\t//End of 'F2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f2::~cfm_f2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 destructor' algorithm generated code\n\n\t//End of 'F2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_f2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 pre elaboration' algorithm generated code\n\n\t//End of 'F2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_f2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 post elaboration' algorithm generated code\n\n\t//End of 'F2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_f2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 post simulation' algorithm generated code\n\n\t//End of 'F2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_f2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_f2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 initializations' algorithm generated code\n\n\t//End of 'F2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F12', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f12\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F12 includes' algorithm generated code\n\n//End of 'F12 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF12 Function F12\n//@{\n///        \\page dxpF12\n//@{\n///    \\brief F12 function model start\nclass cfm_f12: public cf_core::cf_function {\npublic:\n\t/// cfm_f12 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M1_1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M2_1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M1_2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_f12, cf_core::cf_payload_int> p_mq_M2_2_t;\n\t/// cfm_f12 type define end\n\n\t/// constructor\n\tcfm_f12(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_f12(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_M1_1_t p_mq_M1_1;\n\tp_mq_M2_1_t p_mq_M2_1;\n\tp_mq_M1_2_t p_mq_M1_2;\n\tp_mq_M2_2_t p_mq_M2_2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F12 local declarations' algorithm generated code\n\n\t//End of 'F12 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief F12 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F12', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f12\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f12.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f12\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F12 definitions' algorithm generated code\n\n//End of 'F12 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f12::cfm_f12(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_M1_1(\"p_mq_M1_1\"), p_mq_M2_1(\"p_mq_M2_1\"), p_mq_M1_2(\n\t\t\t\t\"p_mq_M1_2\"), p_mq_M2_2(\"p_mq_M2_2\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F12 constructor' algorithm generated code\n\n\t//End of 'F12 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f12::~cfm_f12(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F12 destructor' algorithm generated code\n\n\t//End of 'F12 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_f12::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F12 pre elaboration' algorithm generated code\n\n\t//End of 'F12 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_f12::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F12 post elaboration' algorithm generated code\n\n\t//End of 'F12 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_f12::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F12 post simulation' algorithm generated code\n\n\t//End of 'F12 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_f12::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_f12::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F12 initializations' algorithm generated code\n\n\t//End of 'F12 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'P1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_p1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'P1 includes' algorithm generated code\n\n//End of 'P1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgP1 Function P1\n//@{\n///        \\page dxpP1\n//@{\n///    \\brief P1 function model start\nclass cfm_p1: public cf_core::cf_function {\npublic:\n\t/// cfm_p1 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_p1, cf_core::cf_payload_int> p_mq_M1_1_t;\n\t/// cfm_p1 type define end\n\n\t/// constructor\n\tcfm_p1(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_p1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_M1_1_t p_mq_M1_1;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P1 local declarations' algorithm generated code\n\n\t//End of 'P1 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief P1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'P1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_p1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_p1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_p1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'P1 definitions' algorithm generated code\n\n//End of 'P1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_p1::cfm_p1(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_M1_1(\"p_mq_M1_1\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P1 constructor' algorithm generated code\n\n\t//End of 'P1 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_p1::~cfm_p1(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P1 destructor' algorithm generated code\n\n\t//End of 'P1 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_p1::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P1 pre elaboration' algorithm generated code\n\n\t//End of 'P1 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_p1::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P1 post elaboration' algorithm generated code\n\n\t//End of 'P1 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_p1::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P1 post simulation' algorithm generated code\n\n\t//End of 'P1 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_p1::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_p1::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P1 initializations' algorithm generated code\n\n\t//End of 'P1 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'P2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_p2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'P2 includes' algorithm generated code\n\n//End of 'P2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgP2 Function P2\n//@{\n///        \\page dxpP2\n//@{\n///    \\brief P2 function model start\nclass cfm_p2: public cf_core::cf_function {\npublic:\n\t/// cfm_p2 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_p2, cf_core::cf_payload_int> p_mq_M2_1_t;\n\t/// cfm_p2 type define end\n\n\t/// constructor\n\tcfm_p2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_p2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_M2_1_t p_mq_M2_1;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P2 local declarations' algorithm generated code\n\n\t//End of 'P2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief P2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'P2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_p2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_p2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_p2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'P2 definitions' algorithm generated code\n\n//End of 'P2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_p2::cfm_p2(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_M2_1(\"p_mq_M2_1\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P2 constructor' algorithm generated code\n\n\t//End of 'P2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_p2::~cfm_p2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P2 destructor' algorithm generated code\n\n\t//End of 'P2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_p2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P2 pre elaboration' algorithm generated code\n\n\t//End of 'P2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_p2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P2 post elaboration' algorithm generated code\n\n\t//End of 'P2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_p2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P2 post simulation' algorithm generated code\n\n\t//End of 'P2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_p2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_p2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'P2 initializations' algorithm generated code\n\n\t//End of 'P2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'C1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_c1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'C1 includes' algorithm generated code\n\n//End of 'C1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgC1 Function C1\n//@{\n///        \\page dxpC1\n//@{\n///    \\brief C1 function model start\nclass cfm_c1: public cf_core::cf_function {\npublic:\n\t/// cfm_c1 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_c1, cf_core::cf_payload_int> p_mq_M1_3_t;\n\t/// cfm_c1 type define end\n\n\t/// constructor\n\tcfm_c1(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_c1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_M1_3_t p_mq_M1_3;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C1 local declarations' algorithm generated code\n\n\t//End of 'C1 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief C1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'C1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_c1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_c1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_c1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'C1 definitions' algorithm generated code\n\n//End of 'C1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_c1::cfm_c1(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_M1_3(\"p_mq_M1_3\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C1 constructor' algorithm generated code\n\n\t//End of 'C1 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_c1::~cfm_c1(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C1 destructor' algorithm generated code\n\n\t//End of 'C1 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_c1::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C1 pre elaboration' algorithm generated code\n\n\t//End of 'C1 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_c1::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C1 post elaboration' algorithm generated code\n\n\t//End of 'C1 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_c1::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C1 post simulation' algorithm generated code\n\n\t//End of 'C1 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_c1::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_c1::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'C1 initializations' algorithm generated code\n\n\t//End of 'C1 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DDRMemory', 'models': [{'name': 'ClientSide', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}], 'relations': [{'name': 'AWADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAWADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'WDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefWDATAchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'BRESPchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBRESPchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'ARADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefARADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'RDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRDATAchn', 'connectTo': ['ClientSide', 'Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ddrmemory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY\n#define COFS_MODEL_DDRMEMORY\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ddrmemory_dp_if.h\"\n#include \"cfm_clientside.h\"\n#include \"cfm_target.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRMemory includes' algorithm generated code\n\n//End of 'DDRMemory includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDDRMemory Function DDRMemory\n//@{\n///        \\page dxpDDRMemory\n//@{\n///    \\brief DDRMemory function model start\nclass cfm_ddrmemory: public cf_core::cf_application, public cfm_ddrmemory_dp_if {\npublic:\n\t/// cfm_ddrmemory type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defaraddrchn> mq_ARADDRchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defawaddrchn> mq_AWADDRchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defbrespchn> mq_BRESPchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defrdatachn> mq_RDATAchn_t;\n\ttypedef cf_core::cf_message_queue<cft_defwdatachn> mq_WDATAchn_t;\n\n\t/// cfm_ddrmemory type define end\n\n\t/// constructor\n\tcfm_ddrmemory(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ddrmemory(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_clientside* ClientSide;\n\tcfm_target* Target;\n\t//@}\n\npublic:\n\t/// Overload function for mq_WDATAchn message queue send time\n\tcf_dt::cf_duration mq_WDATAchn_cb_send_time(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_ARADDRchn_t mq_ARADDRchn;\n\tmq_AWADDRchn_t mq_AWADDRchn;\n\tmq_BRESPchn_t mq_BRESPchn;\n\tmq_RDATAchn_t mq_RDATAchn;\n\tmq_WDATAchn_t mq_WDATAchn;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory local declarations' algorithm generated code\n\n\t//End of 'DDRMemory local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief DDRMemory function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DDRMemory', 'models': [{'name': 'ClientSide', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}], 'relations': [{'name': 'AWADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAWADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'WDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefWDATAchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'BRESPchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBRESPchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'ARADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefARADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'RDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRDATAchn', 'connectTo': ['ClientSide', 'Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ddrmemory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ddrmemory.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRMemory definitions' algorithm generated code\n\n//End of 'DDRMemory definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ddrmemory::cfm_ddrmemory(sc_core::sc_module_name name) :\n\t\tcf_application(name), cfm_ddrmemory_dp_if(), mq_ARADDRchn(\"ARADDRchn\"), mq_AWADDRchn(\n\t\t\t\t\"AWADDRchn\"), mq_BRESPchn(\"BRESPchn\"), mq_RDATAchn(\"RDATAchn\"), mq_WDATAchn(\n\t\t\t\t\"WDATAchn\") {\n\tcf_application::init();\n\tClientSide = new cfm_clientside(\"ClientSide\");\n\tTarget = new cfm_target(\"Target\");\n\n\t// connections\n\tClientSide->p_mq_RDATAchn(mq_RDATAchn.p_target_socket);\n\tfor (cf_count i = 0; i < (cf_count) ClientSide->p_mq_ARADDRchn_vec.size();\n\t\t\ti++) {\n\t\tcfm_clientside::p_mq_ARADDRchn_t* port =\n\t\t\t\tClientSide->p_mq_ARADDRchn_vec[i];\n\t\tif (port != nullptr) {\n\t\t\tport->bind(mq_ARADDRchn.p_target_socket);\n\t\t}\n\t}\n\tClientSide->p_mq_BRESPchn(mq_BRESPchn.p_target_socket);\n\tfor (cf_count i = 0; i < (cf_count) ClientSide->p_mq_WDATAchn_vec.size();\n\t\t\ti++) {\n\t\tcfm_clientside::p_mq_WDATAchn_t* port = ClientSide->p_mq_WDATAchn_vec[i];\n\t\tif (port != nullptr) {\n\t\t\tport->bind(mq_WDATAchn.p_target_socket);\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count) ClientSide->p_mq_AWADDRchn_vec.size();\n\t\t\ti++) {\n\t\tcfm_clientside::p_mq_AWADDRchn_t* port =\n\t\t\t\tClientSide->p_mq_AWADDRchn_vec[i];\n\t\tif (port != nullptr) {\n\t\t\tport->bind(mq_AWADDRchn.p_target_socket);\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count) Target->p_mq_RDATAchn_vec.size(); i++) {\n\t\tcfm_target::p_mq_RDATAchn_t* port = Target->p_mq_RDATAchn_vec[i];\n\t\tif (port != nullptr) {\n\t\t\tport->bind(mq_RDATAchn.p_target_socket);\n\t\t}\n\t}\n\tTarget->p_mq_ARADDRchn(mq_ARADDRchn.p_target_socket);\n\tfor (cf_count i = 0; i < (cf_count) Target->p_mq_BRESPchn_vec.size(); i++) {\n\t\tcfm_target::p_mq_BRESPchn_t* port = Target->p_mq_BRESPchn_vec[i];\n\t\tif (port != nullptr) {\n\t\t\tport->bind(mq_BRESPchn.p_target_socket);\n\t\t}\n\t}\n\tTarget->p_mq_WDATAchn(mq_WDATAchn.p_target_socket);\n\tTarget->p_mq_AWADDRchn(mq_AWADDRchn.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory constructor' algorithm generated code\n\n\t//End of 'DDRMemory constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tCF_COMM_CB_MQ_SEND(mq_WDATAchn, cfm_ddrmemory::mq_WDATAchn_cb_send_time);\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ddrmemory::~cfm_ddrmemory(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory destructor' algorithm generated code\n\n\t//End of 'DDRMemory destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ClientSide;\n\tdelete Target;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ddrmemory::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory pre elaboration' algorithm generated code\n\n\t//End of 'DDRMemory pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ddrmemory::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRMemory post elaboration' algorithm generated code\n\n//End of 'DDRMemory post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ddrmemory::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory post simulation' algorithm generated code\n\tAverageReadLatency = TotalReadLatency / NbTotalReadRequests;\n\tAverageWriteLatency = TotalWriteLatency / NbTotalWriteRequests;\n\tAverageWriteBandwidth = TotalWriteData * 1000 / TotalWriteLatency;\n\tAverageReadBandwidth = TotalReadData * 1000 / TotalReadLatency;\n\tAverageCombinedBandwidth = (TotalWriteData + TotalReadData) * 1000\n\t\t\t/ (TotalReadLatency + TotalWriteLatency);\n\tcf_trace_gui_f_t(\"AverageReadLatency\", AverageReadLatency);\n\tcf_trace_report(\"AverageReadLatency = %f ns, %f Cycles\", AverageReadLatency,\n\t\t\t(AverageReadLatency / (CyclePeriod)));\n\tcf_trace_gui_f_t(\"AverageWriteLatency\", AverageWriteLatency, \"ns\");\n\tcf_trace_report(\"AverageWriteLatency = %f ns, %f Cycles\",\n\t\t\tAverageWriteLatency, (AverageWriteLatency / (CyclePeriod)));\n\tcf_trace_gui_f_t(\"AverageReadBandwidth\", AverageReadBandwidth, \"Mb/s\");\n\tcf_trace_gui_f_t(\"AverageWriteBandwidth\", AverageWriteBandwidth, \"Mb/s\");\n\tcf_trace_gui_f_t(\"AverageCombinedBandwidth\", AverageCombinedBandwidth,\n\t\t\t\"Mb/s\");\n\tcf_trace_report(\"AverageReadBandwidth = %f Mb/s\", AverageReadBandwidth);\n\tcf_trace_report(\"AverageWriteBandwidth = %f Mb/s\", AverageWriteBandwidth);\n\tcf_trace_report(\"AverageCombinedBandwidth = %f Mb/s\",\n\t\t\tAverageCombinedBandwidth);\n\t//End of 'DDRMemory post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ddrmemory::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(CyclePeriod, CF_NS));\n// initialize relations attributes\n\tmq_ARADDRchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_ARADDRchn.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_ARADDRchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ARADDRchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ARADDRchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_AWADDRchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_AWADDRchn.cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_AWADDRchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_AWADDRchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_AWADDRchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_BRESPchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_BRESPchn.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_BRESPchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_BRESPchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_BRESPchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RDATAchn.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_RDATAchn.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_RDATAchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RDATAchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RDATAchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_WDATAchn.cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_WDATAchn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_WDATAchn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_WDATAchn.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ddrmemory::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRMemory initializations' algorithm generated code\n\n\t//End of 'DDRMemory initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for mq_WDATAchn message queue send time\n//@{\ncf_duration cfm_ddrmemory::mq_WDATAchn_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defwdatachn, WDATAchn_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN\n\treturn cf_expr_duration(BurstLength, CF_CYCLE);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_END\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ClientSide', 'type': 'cofluent:Function', 'models': [{'name': 'Device', 'type': 'cofluent:Function'}, {'name': 'WRDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RDDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['RDDmux']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Device']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['WRDmux']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Device']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Device']}], 'relations': [{'name': 'BRESPin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefBRESPchn', 'connectTo': ['Device', 'WRDmux']}, {'name': 'RDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefRDATAchn', 'connectTo': ['Device', 'RDDmux']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_clientside\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_CLIENTSIDE\n#define COFS_MODEL_DDRMEMORY_CLIENTSIDE\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_clientside_dp_if.h\"\n#include \"cfm_device.h\"\n#include \"cfm_rddmux.h\"\n#include \"cfm_wrdmux.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ClientSide includes' algorithm generated code\n\n//End of 'ClientSide includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgClientSide Function ClientSide\n//@{\n///        \\page dxpClientSide\n//@{\n///    \\brief ClientSide function model start\nclass cfm_clientside: public cf_core::cf_function_container,\n\t\tpublic cfm_clientside_dp_if {\npublic:\n\t/// cfm_clientside type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defbrespchn> mq_BRESPin_t;\n\ttypedef cf_core::cf_message_queue<cft_defrdatachn> mq_RDATAin_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_clientside, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_clientside type define end\n\n\t/// constructor\n\tcfm_clientside(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_clientside(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tstd::vector<p_mq_ARADDRchn_t*> p_mq_ARADDRchn_vec;\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\tstd::vector<p_mq_WDATAchn_t*> p_mq_WDATAchn_vec;\n\tstd::vector<p_mq_AWADDRchn_t*> p_mq_AWADDRchn_vec;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_device*> Device_vec;\n\tcfm_rddmux* RDDmux;\n\tcfm_wrdmux* WRDmux;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_BRESPin_t*> mq_BRESPin_vec;\n\tstd::vector<mq_RDATAin_t*> mq_RDATAin_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide local declarations' algorithm generated code\n\n\t//End of 'ClientSide local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ClientSide function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_CLIENTSIDE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ClientSide', 'type': 'cofluent:Function', 'models': [{'name': 'Device', 'type': 'cofluent:Function'}, {'name': 'WRDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RDDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['RDDmux']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Device']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['WRDmux']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Device']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Device']}], 'relations': [{'name': 'BRESPin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefBRESPchn', 'connectTo': ['Device', 'WRDmux']}, {'name': 'RDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefRDATAchn', 'connectTo': ['Device', 'RDDmux']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_clientside\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_clientside.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ddrmemory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_clientside\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ClientSide definitions' algorithm generated code\n\n//End of 'ClientSide definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_clientside::cfm_clientside(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_clientside_dp_if(), p_mq_RDATAchn(\n\t\t\t\t\"p_mq_RDATAchn\"), p_mq_BRESPchn(\"p_mq_BRESPchn\") {\n\tcf_function_container::init();\n\tRDDmux = new cfm_rddmux(\"RDDmux\");\n\tWRDmux = new cfm_wrdmux(\"WRDmux\");\n\n\t// instantiation of Device_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tcfm_device* module = new cfm_device(cf_string(\"Device[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tDevice_vec.push_back(module);\n\t}\n\t// instantiation of mq_BRESPin_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tmq_BRESPin_t* module = new mq_BRESPin_t(\n\t\t\t\tcf_string(\"BRESPin[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_BRESPin_vec.push_back(module);\n\t}\n\t// instantiation of mq_RDATAin_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tmq_RDATAin_t* module = new mq_RDATAin_t(\n\t\t\t\tcf_string(\"RDATAin[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_RDATAin_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_ARADDRchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tp_mq_ARADDRchn_t* module = new p_mq_ARADDRchn_t(\n\t\t\t\tcf_string(\"p_mq_ARADDRchn[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_ARADDRchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_AWADDRchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tp_mq_AWADDRchn_t* module = new p_mq_AWADDRchn_t(\n\t\t\t\tcf_string(\"p_mq_AWADDRchn[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_AWADDRchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_WDATAchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tp_mq_WDATAchn_t* module = new p_mq_WDATAchn_t(\n\t\t\t\tcf_string(\"p_mq_WDATAchn[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_WDATAchn_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tcfm_device* module = Device_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(C_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_RDATAin(mq_RDATAin_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(C_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_BRESPin(mq_BRESPin_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tmodule->p_mq_ARADDRchn((*p_mq_ARADDRchn_vec[i]));\n\t\t\tmodule->p_mq_WDATAchn((*p_mq_WDATAchn_vec[i]));\n\t\t\tmodule->p_mq_AWADDRchn((*p_mq_AWADDRchn_vec[i]));\n\t\t}\n\t}\n\n\tRDDmux->p_mq_RDATAchn(p_mq_RDATAchn);\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tRDDmux->p_mq_RDATAin(mq_RDATAin_vec[i]->p_target_socket);\n\t}\n\n\tWRDmux->p_mq_BRESPchn(p_mq_BRESPchn);\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\tWRDmux->p_mq_BRESPin(mq_BRESPin_vec[i]->p_target_socket);\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide constructor' algorithm generated code\n\n\t//End of 'ClientSide constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_clientside::~cfm_clientside(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide destructor' algorithm generated code\n\n\t//End of 'ClientSide destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_device*>::const_iterator vi = Device_vec.begin();\n\t\t\tvi != Device_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_BRESPin_t*>::const_iterator vi = mq_BRESPin_vec.begin();\n\t\t\tvi != mq_BRESPin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_RDATAin_t*>::const_iterator vi = mq_RDATAin_vec.begin();\n\t\t\tvi != mq_RDATAin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_ARADDRchn_t*>::const_iterator vi =\n\t\t\tp_mq_ARADDRchn_vec.begin(); vi != p_mq_ARADDRchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_AWADDRchn_t*>::const_iterator vi =\n\t\t\tp_mq_AWADDRchn_vec.begin(); vi != p_mq_AWADDRchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_WDATAchn_t*>::const_iterator vi =\n\t\t\tp_mq_WDATAchn_vec.begin(); vi != p_mq_WDATAchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete RDDmux;\n\tdelete WRDmux;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_clientside::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide pre elaboration' algorithm generated code\n\n\t//End of 'ClientSide pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_clientside::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide post elaboration' algorithm generated code\n\n\t//End of 'ClientSide post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_clientside::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide post simulation' algorithm generated code\n\n\t//End of 'ClientSide post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_clientside::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\t(*mq_BRESPin_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_BRESPin_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_BRESPin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_BRESPin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_BRESPin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n\t\t(*mq_RDATAin_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_RDATAin_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_RDATAin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_RDATAin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_RDATAin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_clientside::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ClientSide initializations' algorithm generated code\n\n\t//End of 'ClientSide initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryController', 'type': 'cofluent:Function'}, {'name': 'Memory', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['MemoryController']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['MemoryController']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['MemoryController']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['MemoryController']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['MemoryController']}], 'relations': [{'name': 'DQs', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDQs', 'connectTo': ['MemoryController', 'Memory']}, {'name': 'DDRCommand', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryController', 'Memory']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_TARGET\n#define COFS_MODEL_DDRMEMORY_TARGET\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_target_dp_if.h\"\n#include \"cfm_memory.h\"\n#include \"cfm_memorycontroller.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target includes' algorithm generated code\n\n//End of 'Target includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget Function Target\n//@{\n///        \\page dxpTarget\n//@{\n///    \\brief Target function model start\nclass cfm_target: public cf_core::cf_function_container, public cfm_target_dp_if {\npublic:\n\t/// cfm_target type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defddrcommand> mq_DDRCommand_t;\n\ttypedef cf_core::cf_message_queue<cft_defdqs> mq_DQs_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_target type define end\n\n\t/// constructor\n\tcfm_target(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_target(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tstd::vector<p_mq_RDATAchn_t*> p_mq_RDATAchn_vec;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tstd::vector<p_mq_BRESPchn_t*> p_mq_BRESPchn_vec;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_memory*> Memory_vec;\n\tcfm_memorycontroller* MemoryController;\n\t//@}\n\npublic:\n\t/// Overload function for mq_DQs message queue receive time\n\tcf_dt::cf_duration mq_DQs_cb_receive_time(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_DDRCommand_t*> mq_DDRCommand_vec;\n\tstd::vector<mq_DQs_t*> mq_DQs_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target local declarations' algorithm generated code\n\n\t//End of 'Target local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Target function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_TARGET\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryController', 'type': 'cofluent:Function'}, {'name': 'Memory', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['MemoryController']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['MemoryController']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['MemoryController']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['MemoryController']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['MemoryController']}], 'relations': [{'name': 'DQs', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDQs', 'connectTo': ['MemoryController', 'Memory']}, {'name': 'DDRCommand', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryController', 'Memory']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ddrmemory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target definitions' algorithm generated code\n\n//End of 'Target definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target::cfm_target(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_target_dp_if(), p_mq_ARADDRchn(\n\t\t\t\t\"p_mq_ARADDRchn\"), p_mq_WDATAchn(\"p_mq_WDATAchn\"), p_mq_AWADDRchn(\n\t\t\t\t\"p_mq_AWADDRchn\") {\n\tcf_function_container::init();\n\tMemoryController = new cfm_memorycontroller(\"MemoryController\");\n\n\t// instantiation of Memory_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tcfm_memory* module = new cfm_memory(cf_string(\"Memory[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tMemory_vec.push_back(module);\n\t}\n\t// instantiation of mq_DDRCommand_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tmq_DDRCommand_t* module = new mq_DDRCommand_t(\n\t\t\t\tcf_string(\"DDRCommand[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_DDRCommand_vec.push_back(module);\n\t}\n\t// instantiation of mq_DQs_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tmq_DQs_t* module = new mq_DQs_t(cf_string(\"DQs[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_DQs_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_BRESPchn_vec\n\tfor (cf_count i = 0;\n\t\t\ti < (cf_count) MemoryController->p_mq_BRESPchn_vec.size(); i++) {\n\t\tp_mq_BRESPchn_t* module = new p_mq_BRESPchn_t(\n\t\t\t\tcf_string(\"p_mq_BRESPchn[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_BRESPchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_RDATAchn_vec\n\tfor (cf_count i = 0;\n\t\t\ti < (cf_count) MemoryController->p_mq_RDATAchn_vec.size(); i++) {\n\t\tp_mq_RDATAchn_t* module = new p_mq_RDATAchn_t(\n\t\t\t\tcf_string(\"p_mq_RDATAchn[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_RDATAchn_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tcfm_memory* module = Memory_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(M_Nbr + 1); j++) {\n\t\t\t\tfor (cf_count k = 0; k < (cf_count) module->p_mq_DQs_vec.size();\n\t\t\t\t\t\tk++) {\n\t\t\t\t\tcfm_memory::p_mq_DQs_t* port = module->p_mq_DQs_vec[k];\n\t\t\t\t\tif (port != nullptr) {\n\t\t\t\t\t\tport->bind(mq_DQs_vec[j]->p_target_socket);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(M_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_DDRCommand(mq_DDRCommand_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tMemoryController->p_mq_DQs(mq_DQs_vec[i]->p_target_socket);\n\t}\n\tfor (cf_count i = 0;\n\t\t\ti < (cf_count) MemoryController->p_mq_RDATAchn_vec.size(); i++) {\n\t\tcfm_memorycontroller::p_mq_RDATAchn_t* port =\n\t\t\t\tMemoryController->p_mq_RDATAchn_vec[i];\n\t\tif (port != nullptr) {\n\t\t\tport->bind((*p_mq_RDATAchn_vec[i]));\n\t\t}\n\t}\n\tMemoryController->p_mq_ARADDRchn(p_mq_ARADDRchn);\n\tfor (cf_count i = 0;\n\t\t\ti < (cf_count) MemoryController->p_mq_BRESPchn_vec.size(); i++) {\n\t\tcfm_memorycontroller::p_mq_BRESPchn_t* port =\n\t\t\t\tMemoryController->p_mq_BRESPchn_vec[i];\n\t\tif (port != nullptr) {\n\t\t\tport->bind((*p_mq_BRESPchn_vec[i]));\n\t\t}\n\t}\n\tMemoryController->p_mq_WDATAchn(p_mq_WDATAchn);\n\tMemoryController->p_mq_AWADDRchn(p_mq_AWADDRchn);\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tMemoryController->p_mq_DDRCommand(\n\t\t\t\tmq_DDRCommand_vec[i]->p_target_socket);\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target constructor' algorithm generated code\n\n\t//End of 'Target constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_DQs_vec[i]),\n\t\t\t\tcfm_target::mq_DQs_cb_receive_time);\n\t}\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target::~cfm_target(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target destructor' algorithm generated code\n\n\t//End of 'Target destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_memory*>::const_iterator vi = Memory_vec.begin();\n\t\t\tvi != Memory_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DDRCommand_t*>::const_iterator vi =\n\t\t\tmq_DDRCommand_vec.begin(); vi != mq_DDRCommand_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DQs_t*>::const_iterator vi = mq_DQs_vec.begin();\n\t\t\tvi != mq_DQs_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_BRESPchn_t*>::const_iterator vi =\n\t\t\tp_mq_BRESPchn_vec.begin(); vi != p_mq_BRESPchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_RDATAchn_t*>::const_iterator vi =\n\t\t\tp_mq_RDATAchn_vec.begin(); vi != p_mq_RDATAchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete MemoryController;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_target::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target pre elaboration' algorithm generated code\n\n\t//End of 'Target pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_target::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post elaboration' algorithm generated code\n\n\t//End of 'Target post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_target::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post simulation' algorithm generated code\n\n\t//End of 'Target post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_target::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\t(*mq_DDRCommand_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DDRCommand_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DDRCommand_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_INFINITE);\n\t\t(*mq_DDRCommand_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\t(*mq_DQs_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_DQs_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_DQs_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_DQs_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_target::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target initializations' algorithm generated code\n\n\t//End of 'Target initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for mq_DQs message queue receive time\n//@{\ncf_duration cfm_target::mq_DQs_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defdqs, DQs_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(DQPutTime, CF_CYCLE);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Device', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'ReceiverRData', 'type': 'cofluent:Function'}, {'name': 'ReceiveWACK', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['ReceiverRData']}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['ReceiveWACK']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Sender']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Sender']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Sender']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_DEVICE\n#define COFS_MODEL_DDRMEMORY_DEVICE\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_device_dp_if.h\"\n#include \"cfm_receiverrdata.h\"\n#include \"cfm_receivewack.h\"\n#include \"cfm_sender.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Device includes' algorithm generated code\n\n//End of 'Device includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDevice Function Device\n//@{\n///        \\page dxpDevice\n//@{\n///    \\brief Device function model start\nclass cfm_device: public cf_core::cf_function_container, public cfm_device_dp_if {\npublic:\n\t/// cfm_device type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defrdatachn> p_mq_RDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defbrespchn> p_mq_BRESPin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_device, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_device type define end\n\n\t/// constructor\n\tcfm_device(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_device(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAin_t p_mq_RDATAin;\n\tp_mq_BRESPin_t p_mq_BRESPin;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_receivewack* ReceiveWACK;\n\tcfm_receiverrdata* ReceiverRData;\n\tcfm_sender* Sender;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device local declarations' algorithm generated code\n\n\t//End of 'Device local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Device function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_DEVICE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Device', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'ReceiverRData', 'type': 'cofluent:Function'}, {'name': 'ReceiveWACK', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['ReceiverRData']}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['ReceiveWACK']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Sender']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Sender']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Sender']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_device.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_clientside\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_device\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Device definitions' algorithm generated code\n\n//End of 'Device definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_device::cfm_device(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_device_dp_if(), p_mq_RDATAin(\n\t\t\t\t\"p_mq_RDATAin\"), p_mq_BRESPin(\"p_mq_BRESPin\"), p_mq_ARADDRchn(\n\t\t\t\t\"p_mq_ARADDRchn\"), p_mq_WDATAchn(\"p_mq_WDATAchn\"), p_mq_AWADDRchn(\n\t\t\t\t\"p_mq_AWADDRchn\") {\n\tcf_function_container::init();\n\tReceiveWACK = new cfm_receivewack(\"ReceiveWACK\");\n\tReceiverRData = new cfm_receiverrdata(\"ReceiverRData\");\n\tSender = new cfm_sender(\"Sender\");\n\n\t// connections\n\tReceiveWACK->p_mq_BRESPin(p_mq_BRESPin);\n\n\tReceiverRData->p_mq_RDATAin(p_mq_RDATAin);\n\n\tSender->p_mq_ARADDRchn(p_mq_ARADDRchn);\n\tSender->p_mq_WDATAchn(p_mq_WDATAchn);\n\tSender->p_mq_AWADDRchn(p_mq_AWADDRchn);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device constructor' algorithm generated code\n\n\t//End of 'Device constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_device::~cfm_device(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device destructor' algorithm generated code\n\n\t//End of 'Device destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ReceiveWACK;\n\tdelete ReceiverRData;\n\tdelete Sender;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_device::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device pre elaboration' algorithm generated code\n\n\t//End of 'Device pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_device::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device post elaboration' algorithm generated code\n\n\t//End of 'Device post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_device::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device post simulation' algorithm generated code\n\n\t//End of 'Device post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_device::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_device::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Device initializations' algorithm generated code\n\n\t//End of 'Device initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WRDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_wrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WRDMUX\n#define COFS_MODEL_DDRMEMORY_WRDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_wrdmux_dp_if.h\"\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WRDmux includes' algorithm generated code\n\n//End of 'WRDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWRDmux Function WRDmux\n//@{\n///        \\page dxpWRDmux\n//@{\n///    \\brief WRDmux function model start\nclass cfm_wrdmux: public cf_core::cf_function_router, public cfm_wrdmux_dp_if {\npublic:\n\t/// cfm_wrdmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wrdmux, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wrdmux, cft_defbrespchn> p_mq_BRESPin_t;\n\t/// cfm_wrdmux type define end\n\n\t/// constructor\n\tcfm_wrdmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_wrdmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\tp_mq_BRESPin_t p_mq_BRESPin;\n\t//@}\n\npublic:\n\t/// Overload function for WRDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux local declarations' algorithm generated code\n\n\t//End of 'WRDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WRDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WRDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_wrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_wrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WRDmux definitions' algorithm generated code\n\n//End of 'WRDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_wrdmux::cfm_wrdmux(sc_core::sc_module_name name) :\n\t\tcf_function_router(name), cfm_wrdmux_dp_if(), p_mq_BRESPchn(\n\t\t\t\t\"p_mq_BRESPchn\"), p_mq_BRESPin(\"p_mq_BRESPin\") {\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_BRESPchn);\n\tadd_output_port (&p_mq_BRESPin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux constructor' algorithm generated code\n\n\t//End of 'WRDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_wrdmux::~cfm_wrdmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux destructor' algorithm generated code\n\n\t//End of 'WRDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_wrdmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux pre elaboration' algorithm generated code\n\n\t//End of 'WRDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_wrdmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux post simulation' algorithm generated code\n\n\t//End of 'WRDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_wrdmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(1, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_wrdmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux initializations' algorithm generated code\n\n\t//End of 'WRDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for WRDmux router destination method\n//@{\nstring cfm_wrdmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WRDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defbrespchn*) _trans)->get_data().ID;\n\tstd::stringstream ss;\n\tss << \"BRESPin[\" << sourceID << \"]\";\n\treturn ss.str();\n\treturn \"\";\n\t//End of 'WRDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RDDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rddmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RDDMUX\n#define COFS_MODEL_DDRMEMORY_RDDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_rddmux_dp_if.h\"\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RDDmux includes' algorithm generated code\n\n//End of 'RDDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRDDmux Function RDDmux\n//@{\n///        \\page dxpRDDmux\n//@{\n///    \\brief RDDmux function model start\nclass cfm_rddmux: public cf_core::cf_function_router, public cfm_rddmux_dp_if {\npublic:\n\t/// cfm_rddmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rddmux, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rddmux, cft_defrdatachn> p_mq_RDATAin_t;\n\t/// cfm_rddmux type define end\n\n\t/// constructor\n\tcfm_rddmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rddmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tp_mq_RDATAin_t p_mq_RDATAin;\n\t//@}\n\npublic:\n\t/// Overload function for RDDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux local declarations' algorithm generated code\n\n\t//End of 'RDDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RDDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RDDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RDDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rddmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rddmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RDDmux definitions' algorithm generated code\n\n//End of 'RDDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rddmux::cfm_rddmux(sc_core::sc_module_name name) :\n\t\tcf_function_router(name), cfm_rddmux_dp_if(), p_mq_RDATAchn(\n\t\t\t\t\"p_mq_RDATAchn\"), p_mq_RDATAin(\"p_mq_RDATAin\") {\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_RDATAchn);\n\tadd_output_port (&p_mq_RDATAin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux constructor' algorithm generated code\n\n\t//End of 'RDDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rddmux::~cfm_rddmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux destructor' algorithm generated code\n\n\t//End of 'RDDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rddmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux pre elaboration' algorithm generated code\n\n\t//End of 'RDDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rddmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux post simulation' algorithm generated code\n\n\t//End of 'RDDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rddmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(1, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rddmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux initializations' algorithm generated code\n\n\t//End of 'RDDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for RDDmux router destination method\n//@{\nstring cfm_rddmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RDDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defrdatachn*) _trans)->get_data().ID;\n\n\tstd::stringstream ss;\n\tss << \"RDATAin[\" << sourceID << \"]\";\n\treturn ss.str();\n\t//End of 'RDDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MemoryController', 'type': 'cofluent:Function', 'models': [{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'FrontEnd', 'type': 'cofluent:Function'}, {'name': 'BackEnd', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['BackEnd']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['FrontEnd']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['FrontEnd']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['BackEnd']}], 'relations': [{'name': 'AWADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux', 'FrontEnd']}, {'name': 'WDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux', 'FrontEnd']}, {'name': 'ARADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux', 'FrontEnd']}, {'name': 'MemWriteRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemWriteRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'WriteAck', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWriteAck', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemReadRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemReadRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'DataRead', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefDataRead', 'connectTo': ['FrontEnd', 'BackEnd']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memorycontroller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n#define COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memorycontroller_dp_if.h\"\n#include \"cfm_backend.h\"\n#include \"cfm_frontend.h\"\n#include \"cfm_raddrdmux.h\"\n#include \"cfm_waddrdmux.h\"\n#include \"cfm_wdatadmux.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defdataread.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryController includes' algorithm generated code\n\n//End of 'MemoryController includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemoryController Function MemoryController\n//@{\n///        \\page dxpMemoryController\n//@{\n///    \\brief MemoryController function model start\nclass cfm_memorycontroller: public cf_core::cf_function_container,\n\t\tpublic cfm_memorycontroller_dp_if {\npublic:\n\t/// cfm_memorycontroller type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defaraddrchn> mq_ARADDRin_t;\n\ttypedef cf_core::cf_message_queue<cft_defawaddrchn> mq_AWADDRin_t;\n\ttypedef cf_core::cf_message_queue<cft_defdataread> mq_DataRead_t;\n\ttypedef cf_core::cf_message_queue<cft_defmemreadrequest> mq_MemReadRequest_t;\n\ttypedef cf_core::cf_message_queue<cft_defmemwriterequest> mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_message_queue<cft_defwdatachn> mq_WDATAin_t;\n\ttypedef cf_core::cf_message_queue<cft_defwriteack> mq_WriteAck_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n\t\t\tcft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n\t\t\tcft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n\t\t\tcft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n\t\t\tcft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n\t\t\tcft_defawaddrchn> p_mq_AWADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n\t\t\tcft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_memorycontroller type define end\n\n\t/// constructor\n\tcfm_memorycontroller(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_memorycontroller(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tstd::vector<p_mq_RDATAchn_t*> p_mq_RDATAchn_vec;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tstd::vector<p_mq_BRESPchn_t*> p_mq_BRESPchn_vec;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_backend* BackEnd;\n\tstd::vector<cfm_frontend*> FrontEnd_vec;\n\tcfm_raddrdmux* RAddrDmux;\n\tcfm_waddrdmux* WAddrDmux;\n\tcfm_wdatadmux* WdataDmux;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_ARADDRin_t*> mq_ARADDRin_vec;\n\tstd::vector<mq_AWADDRin_t*> mq_AWADDRin_vec;\n\tstd::vector<mq_DataRead_t*> mq_DataRead_vec;\n\tmq_MemReadRequest_t mq_MemReadRequest;\n\tmq_MemWriteRequest_t mq_MemWriteRequest;\n\tstd::vector<mq_WDATAin_t*> mq_WDATAin_vec;\n\tstd::vector<mq_WriteAck_t*> mq_WriteAck_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController local declarations' algorithm generated code\n\n\t//End of 'MemoryController local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MemoryController function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MemoryController', 'type': 'cofluent:Function', 'models': [{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'FrontEnd', 'type': 'cofluent:Function'}, {'name': 'BackEnd', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['BackEnd']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['FrontEnd']}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['FrontEnd']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['BackEnd']}], 'relations': [{'name': 'AWADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux', 'FrontEnd']}, {'name': 'WDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux', 'FrontEnd']}, {'name': 'ARADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux', 'FrontEnd']}, {'name': 'MemWriteRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemWriteRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'WriteAck', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWriteAck', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemReadRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemReadRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'DataRead', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefDataRead', 'connectTo': ['FrontEnd', 'BackEnd']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memorycontroller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memorycontroller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_target\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memorycontroller\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryController definitions' algorithm generated code\n\n//End of 'MemoryController definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memorycontroller::cfm_memorycontroller(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_memorycontroller_dp_if(), p_mq_DQs(\n\t\t\t\t\"p_mq_DQs\"), p_mq_ARADDRchn(\"p_mq_ARADDRchn\"), p_mq_WDATAchn(\n\t\t\t\t\"p_mq_WDATAchn\"), p_mq_AWADDRchn(\"p_mq_AWADDRchn\"), p_mq_DDRCommand(\n\t\t\t\t\"p_mq_DDRCommand\"), mq_MemReadRequest(\"MemReadRequest\"), mq_MemWriteRequest(\n\t\t\t\t\"MemWriteRequest\") {\n\tcf_function_container::init();\n\tBackEnd = new cfm_backend(\"BackEnd\");\n\tRAddrDmux = new cfm_raddrdmux(\"RAddrDmux\");\n\tWAddrDmux = new cfm_waddrdmux(\"WAddrDmux\");\n\tWdataDmux = new cfm_wdatadmux(\"WdataDmux\");\n\n\t// instantiation of FrontEnd_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tcfm_frontend* module = new cfm_frontend(\n\t\t\t\tcf_string(\"FrontEnd[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tFrontEnd_vec.push_back(module);\n\t}\n\t// instantiation of mq_ARADDRin_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tmq_ARADDRin_t* module = new mq_ARADDRin_t(\n\t\t\t\tcf_string(\"ARADDRin[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_ARADDRin_vec.push_back(module);\n\t}\n\t// instantiation of mq_AWADDRin_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tmq_AWADDRin_t* module = new mq_AWADDRin_t(\n\t\t\t\tcf_string(\"AWADDRin[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_AWADDRin_vec.push_back(module);\n\t}\n\t// instantiation of mq_DataRead_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tmq_DataRead_t* module = new mq_DataRead_t(\n\t\t\t\tcf_string(\"DataRead[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_DataRead_vec.push_back(module);\n\t}\n\t// instantiation of mq_WDATAin_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tmq_WDATAin_t* module = new mq_WDATAin_t(\n\t\t\t\tcf_string(\"WDATAin[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_WDATAin_vec.push_back(module);\n\t}\n\t// instantiation of mq_WriteAck_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tmq_WriteAck_t* module = new mq_WriteAck_t(\n\t\t\t\tcf_string(\"WriteAck[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_WriteAck_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_BRESPchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tp_mq_BRESPchn_t* module = new p_mq_BRESPchn_t(\n\t\t\t\tcf_string(\"p_mq_BRESPchn[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_BRESPchn_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_RDATAchn_vec\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tp_mq_RDATAchn_t* module = new p_mq_RDATAchn_t(\n\t\t\t\tcf_string(\"p_mq_RDATAchn[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_RDATAchn_vec.push_back(module);\n\t}\n\t// connections\n\tBackEnd->p_mq_DQs(p_mq_DQs);\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tBackEnd->p_mq_DataRead(mq_DataRead_vec[i]->p_target_socket);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tBackEnd->p_mq_WriteAck_0(mq_WriteAck_vec[i]->p_target_socket);\n\t}\n\tBackEnd->p_mq_MemReadRequest(mq_MemReadRequest.p_target_socket);\n\tBackEnd->p_mq_MemWriteRequest(mq_MemWriteRequest.p_target_socket);\n\tBackEnd->p_mq_DDRCommand(p_mq_DDRCommand);\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tBackEnd->p_mq_WriteAck_1(mq_WriteAck_vec[i]->p_target_socket);\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tcfm_frontend* module = FrontEnd_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_DataRead(mq_DataRead_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_WriteAck(mq_WriteAck_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tmodule->p_mq_RDATAchn((*p_mq_RDATAchn_vec[i]));\n\t\t\tmodule->p_mq_BRESPchn((*p_mq_BRESPchn_vec[i]));\n\t\t\tmodule->p_mq_MemReadRequest(mq_MemReadRequest.p_target_socket);\n\t\t\tmodule->p_mq_MemWriteRequest(mq_MemWriteRequest.p_target_socket);\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_ARADDRin(mq_ARADDRin_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_WDATAin(mq_WDATAin_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n\t\t\t\tmodule->p_mq_AWADDRin(mq_AWADDRin_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tRAddrDmux->p_mq_ARADDRin(mq_ARADDRin_vec[i]->p_target_socket);\n\t}\n\tRAddrDmux->p_mq_ARADDRchn(p_mq_ARADDRchn);\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tWAddrDmux->p_mq_AWADDRin(mq_AWADDRin_vec[i]->p_target_socket);\n\t}\n\tWAddrDmux->p_mq_AWADDRchn(p_mq_AWADDRchn);\n\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\tWdataDmux->p_mq_WDATAin(mq_WDATAin_vec[i]->p_target_socket);\n\t}\n\tWdataDmux->p_mq_WDATAchn(p_mq_WDATAchn);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController constructor' algorithm generated code\n\n\t//End of 'MemoryController constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memorycontroller::~cfm_memorycontroller(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController destructor' algorithm generated code\n\n\t//End of 'MemoryController destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_frontend*>::const_iterator vi = FrontEnd_vec.begin();\n\t\t\tvi != FrontEnd_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_ARADDRin_t*>::const_iterator vi = mq_ARADDRin_vec.begin();\n\t\t\tvi != mq_ARADDRin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_AWADDRin_t*>::const_iterator vi = mq_AWADDRin_vec.begin();\n\t\t\tvi != mq_AWADDRin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DataRead_t*>::const_iterator vi = mq_DataRead_vec.begin();\n\t\t\tvi != mq_DataRead_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_WDATAin_t*>::const_iterator vi = mq_WDATAin_vec.begin();\n\t\t\tvi != mq_WDATAin_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_WriteAck_t*>::const_iterator vi = mq_WriteAck_vec.begin();\n\t\t\tvi != mq_WriteAck_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_BRESPchn_t*>::const_iterator vi =\n\t\t\tp_mq_BRESPchn_vec.begin(); vi != p_mq_BRESPchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_RDATAchn_t*>::const_iterator vi =\n\t\t\tp_mq_RDATAchn_vec.begin(); vi != p_mq_RDATAchn_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete BackEnd;\n\tdelete RAddrDmux;\n\tdelete WAddrDmux;\n\tdelete WdataDmux;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_memorycontroller::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController pre elaboration' algorithm generated code\n\n\t//End of 'MemoryController pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_memorycontroller::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController post elaboration' algorithm generated code\n\n\t//End of 'MemoryController post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_memorycontroller::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController post simulation' algorithm generated code\n\n\t//End of 'MemoryController post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_memorycontroller::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_ARADDRin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_ARADDRin_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_ARADDRin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_ARADDRin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_ARADDRin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_AWADDRin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_AWADDRin_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_AWADDRin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_AWADDRin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_AWADDRin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_DataRead_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DataRead_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_DataRead_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_DataRead_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_DataRead_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tmq_MemReadRequest.cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemReadRequest.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemReadRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);\n\tmq_MemReadRequest.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MemWriteRequest.cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemWriteRequest.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_MemWriteRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);\n\tmq_MemWriteRequest.cfa_concurrency.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_WDATAin_vec[i]).cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_WDATAin_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_WDATAin_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_WDATAin_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_WDATAin_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n\t\t(*mq_WriteAck_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_WriteAck_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_CYCLE));\n\t\t(*mq_WriteAck_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_WriteAck_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_WriteAck_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_memorycontroller::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryController initializations' algorithm generated code\n\n\t//End of 'MemoryController initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Memory', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function'}, {'name': 'BankDmuxer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs', 'connectTo': ['MemoryCommandExecution']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand', 'connectTo': ['BankDmuxer']}], 'relations': [{'name': 'DDRAction', 'type': 'cofluent:MessageQueue', 'vector': '0, NbBanksperMemory', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryCommandExecution', 'BankDmuxer']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORY\n#define COFS_MODEL_DDRMEMORY_MEMORY\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memory_dp_if.h\"\n#include \"cfm_bankdmuxer.h\"\n#include \"cfm_memorycommandexecution.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Memory includes' algorithm generated code\n\n//End of 'Memory includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemory Function Memory\n//@{\n///        \\page dxpMemory\n//@{\n///    \\brief Memory function model start\nclass cfm_memory: public cf_core::cf_function_container, public cfm_memory_dp_if {\npublic:\n\t/// cfm_memory type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defddrcommand> mq_DDRAction_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memory, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memory, cft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_memory type define end\n\n\t/// constructor\n\tcfm_memory(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_memory(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tstd::vector<p_mq_DQs_t*> p_mq_DQs_vec;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bankdmuxer* BankDmuxer;\n\tstd::vector<cfm_memorycommandexecution*> MemoryCommandExecution_vec;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_DDRAction_t*> mq_DDRAction_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory local declarations' algorithm generated code\n\n\t//End of 'Memory local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Memory function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORY\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Memory', 'type': 'cofluent:Function', 'models': [{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function'}, {'name': 'BankDmuxer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs', 'connectTo': ['MemoryCommandExecution']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand', 'connectTo': ['BankDmuxer']}], 'relations': [{'name': 'DDRAction', 'type': 'cofluent:MessageQueue', 'vector': '0, NbBanksperMemory', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryCommandExecution', 'BankDmuxer']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memory.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_target\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memory\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Memory definitions' algorithm generated code\n\n//End of 'Memory definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memory::cfm_memory(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_memory_dp_if(), p_mq_DDRCommand(\n\t\t\t\t\"p_mq_DDRCommand\") {\n\tcf_function_container::init();\n\tBankDmuxer = new cfm_bankdmuxer(\"BankDmuxer\");\n\n\t// instantiation of MemoryCommandExecution_vec\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\tcfm_memorycommandexecution* module = new cfm_memorycommandexecution(\n\t\t\t\tcf_string(\"MemoryCommandExecution[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tMemoryCommandExecution_vec.push_back(module);\n\t}\n\t// instantiation of mq_DDRAction_vec\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\tmq_DDRAction_t* module = new mq_DDRAction_t(\n\t\t\t\tcf_string(\"DDRAction[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_DDRAction_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_DQs_vec\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\tp_mq_DQs_t* module = new p_mq_DQs_t(\n\t\t\t\tcf_string(\"p_mq_DQs[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_DQs_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\tBankDmuxer->p_mq_DDRAction(mq_DDRAction_vec[i]->p_target_socket);\n\t}\n\tBankDmuxer->p_mq_DDRCommand(p_mq_DDRCommand);\n\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\tcfm_memorycommandexecution* module = MemoryCommandExecution_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tmodule->p_mq_DQs((*p_mq_DQs_vec[i]));\n\t\t\tfor (cf_count j = 0; j < (cf_count)(NbBanksperMemory + 1); j++) {\n\t\t\t\tmodule->p_mq_DDRAction(mq_DDRAction_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory constructor' algorithm generated code\n\n\t//End of 'Memory constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memory::~cfm_memory(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory destructor' algorithm generated code\n\n\t//End of 'Memory destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_memorycommandexecution*>::const_iterator vi =\n\t\t\tMemoryCommandExecution_vec.begin();\n\t\t\tvi != MemoryCommandExecution_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_DDRAction_t*>::const_iterator vi = mq_DDRAction_vec.begin();\n\t\t\tvi != mq_DDRAction_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_DQs_t*>::const_iterator vi = p_mq_DQs_vec.begin();\n\t\t\tvi != p_mq_DQs_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete BankDmuxer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_memory::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory pre elaboration' algorithm generated code\n\n\t//End of 'Memory pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_memory::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory post elaboration' algorithm generated code\n\n\t//End of 'Memory post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_memory::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory post simulation' algorithm generated code\n\n\t//End of 'Memory post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_memory::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n\t\t(*mq_DDRAction_vec[i]).cfa_send_time.init(cf_expr_duration(10, CF_NS));\n\t\t(*mq_DDRAction_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(0, CF_CYCLE));\n\t\t(*mq_DDRAction_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_DDRAction_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_DDRAction_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_memory::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Memory initializations' algorithm generated code\n\n\t//End of 'Memory initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_SENDER\n#define COFS_MODEL_DDRMEMORY_SENDER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender includes' algorithm generated code\n\n//End of 'Sender includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSender Function Sender\n//@{\n///        \\page dxpSender\n//@{\n///    \\brief Sender function model start\nclass cfm_sender: public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n\t/// cfm_sender type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defwdatachn> p_mq_WDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_sender type define end\n\n\t/// constructor\n\tcfm_sender(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_sender(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender local declarations' algorithm generated code\n\tDefMemCmd Cmd;\n\tint dataValue;\n\tint myIndex;\n\tlong SendInitDuration;\n\tint burstLength;\n\tint size;\n\tfloat startTime;\n\tlong address;\n\tint test;\n\tint SelectCmdDuration;\n\n\tint cptTabTest;\n\tint cptTabSelectCmd;\n\tint cptTabAdressRead;\n\tint cptTabAdressWrite;\n\t//End of 'Sender local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Sender function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_SENDER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender definitions' algorithm generated code\n\n//End of 'Sender definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sender::cfm_sender(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_sender_dp_if(), p_mq_ARADDRchn(\"p_mq_ARADDRchn\"), p_mq_WDATAchn(\n\t\t\t\t\"p_mq_WDATAchn\"), p_mq_AWADDRchn(\"p_mq_AWADDRchn\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender constructor' algorithm generated code\n\n\t//End of 'Sender constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sender::~cfm_sender(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender destructor' algorithm generated code\n\n\t//End of 'Sender destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_sender::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender pre elaboration' algorithm generated code\n\n\t//End of 'Sender pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_sender::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post elaboration' algorithm generated code\n\n\t//End of 'Sender post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_sender::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post simulation' algorithm generated code\n\n\t//End of 'Sender post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_sender::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_sender::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender initializations' algorithm generated code\n\tcptTabTest = 0;\n\tcptTabSelectCmd = 0;\n\tcptTabAdressRead = 0;\n\tcptTabAdressWrite = 0;\n\t//End of 'Sender initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReceiverRData', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receiverrdata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n#define COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiverrdata_dp_if.h\"\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiverRData includes' algorithm generated code\n\n//End of 'ReceiverRData includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiverRData Function ReceiverRData\n//@{\n///        \\page dxpReceiverRData\n//@{\n///    \\brief ReceiverRData function model start\nclass cfm_receiverrdata: public cf_core::cf_function,\n\t\tpublic cfm_receiverrdata_dp_if {\npublic:\n\t/// cfm_receiverrdata type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiverrdata, cft_defrdatachn> p_mq_RDATAin_t;\n\t/// cfm_receiverrdata type define end\n\n\t/// constructor\n\tcfm_receiverrdata(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_receiverrdata(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAin_t p_mq_RDATAin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData local declarations' algorithm generated code\n\tint burstLength;\n\tint myIndex;\n\tlong ReceiveInitDuration;\n\tfloat startTime;\n\tfloat ReadLatency;\n\tint NbDataTransfer;\n\tint RemainingDataTransfer;\n\t//End of 'ReceiverRData local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReceiverRData function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReceiverRData', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receiverrdata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receiverrdata.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiverrdata\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiverRData definitions' algorithm generated code\n\n//End of 'ReceiverRData definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receiverrdata::cfm_receiverrdata(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_receiverrdata_dp_if(), p_mq_RDATAin(\n\t\t\t\t\"p_mq_RDATAin\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData constructor' algorithm generated code\n\n\t//End of 'ReceiverRData constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receiverrdata::~cfm_receiverrdata(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData destructor' algorithm generated code\n\n\t//End of 'ReceiverRData destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_receiverrdata::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData pre elaboration' algorithm generated code\n\n\t//End of 'ReceiverRData pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_receiverrdata::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData post elaboration' algorithm generated code\n\n\t//End of 'ReceiverRData post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_receiverrdata::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData post simulation' algorithm generated code\n\n\t//End of 'ReceiverRData post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_receiverrdata::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_receiverrdata::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiverRData initializations' algorithm generated code\n\n\t//End of 'ReceiverRData initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReceiveWACK', 'type': 'cofluent:Function', 'ports': [{'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receivewack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RECEIVEWACK\n#define COFS_MODEL_DDRMEMORY_RECEIVEWACK\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receivewack_dp_if.h\"\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiveWACK includes' algorithm generated code\n\n//End of 'ReceiveWACK includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiveWACK Function ReceiveWACK\n//@{\n///        \\page dxpReceiveWACK\n//@{\n///    \\brief ReceiveWACK function model start\nclass cfm_receivewack: public cf_core::cf_function, public cfm_receivewack_dp_if {\npublic:\n\t/// cfm_receivewack type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receivewack, cft_defbrespchn> p_mq_BRESPin_t;\n\t/// cfm_receivewack type define end\n\n\t/// constructor\n\tcfm_receivewack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_receivewack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BRESPin_t p_mq_BRESPin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK local declarations' algorithm generated code\n\tint myIndex;\n\tlong ReceiveWACKInitDuration;\n\tfloat WriteLatency;\n\tfloat startTime;\n\tint burstLength;\n\t//End of 'ReceiveWACK local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReceiveWACK function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RECEIVEWACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReceiveWACK', 'type': 'cofluent:Function', 'ports': [{'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receivewack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receivewack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receivewack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReceiveWACK definitions' algorithm generated code\n\n//End of 'ReceiveWACK definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receivewack::cfm_receivewack(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_receivewack_dp_if(), p_mq_BRESPin(\"p_mq_BRESPin\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK constructor' algorithm generated code\n\n\t//End of 'ReceiveWACK constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receivewack::~cfm_receivewack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK destructor' algorithm generated code\n\n\t//End of 'ReceiveWACK destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_receivewack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK pre elaboration' algorithm generated code\n\n\t//End of 'ReceiveWACK pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_receivewack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK post elaboration' algorithm generated code\n\n\t//End of 'ReceiveWACK post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_receivewack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK post simulation' algorithm generated code\n\n\t//End of 'ReceiveWACK post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_receivewack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_receivewack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReceiveWACK initializations' algorithm generated code\n\n\t//End of 'ReceiveWACK initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_waddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WADDRDMUX\n#define COFS_MODEL_DDRMEMORY_WADDRDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_waddrdmux_dp_if.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WAddrDmux includes' algorithm generated code\n\n//End of 'WAddrDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWAddrDmux Function WAddrDmux\n//@{\n///        \\page dxpWAddrDmux\n//@{\n///    \\brief WAddrDmux function model start\nclass cfm_waddrdmux: public cf_core::cf_function_router,\n\t\tpublic cfm_waddrdmux_dp_if {\npublic:\n\t/// cfm_waddrdmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_waddrdmux, cft_defawaddrchn> p_mq_AWADDRin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_waddrdmux, cft_defawaddrchn> p_mq_AWADDRchn_t;\n\t/// cfm_waddrdmux type define end\n\n\t/// constructor\n\tcfm_waddrdmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_waddrdmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_AWADDRin_t p_mq_AWADDRin;\n\tp_mq_AWADDRchn_t p_mq_AWADDRchn;\n\t//@}\n\npublic:\n\t/// Overload function for WAddrDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux local declarations' algorithm generated code\n\tint Port_ID;\n\t//End of 'WAddrDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WAddrDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WADDRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_waddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_waddrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WAddrDmux definitions' algorithm generated code\n\n//End of 'WAddrDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_waddrdmux::cfm_waddrdmux(sc_core::sc_module_name name) :\n\t\tcf_function_router(name), cfm_waddrdmux_dp_if(), p_mq_AWADDRin(\n\t\t\t\t\"p_mq_AWADDRin\"), p_mq_AWADDRchn(\"p_mq_AWADDRchn\") {\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_AWADDRchn);\n\tadd_output_port (&p_mq_AWADDRin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux constructor' algorithm generated code\n\n\t//End of 'WAddrDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_waddrdmux::~cfm_waddrdmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux destructor' algorithm generated code\n\n\t//End of 'WAddrDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_waddrdmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux pre elaboration' algorithm generated code\n\n\t//End of 'WAddrDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_waddrdmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux post simulation' algorithm generated code\n\n\t//End of 'WAddrDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_waddrdmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(0, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_waddrdmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux initializations' algorithm generated code\n\n\t//End of 'WAddrDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for WAddrDmux router destination method\n//@{\nstring cfm_waddrdmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WAddrDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defawaddrchn*) _trans)->get_data().ID;\n\n\tstd::stringstream ss;\n\tss << \"AWADDRin[\" << sourceID << \"]\";\n\tcout << ss.str();\n\treturn ss.str();\n\t//End of 'WAddrDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_wdatadmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WDATADMUX\n#define COFS_MODEL_DDRMEMORY_WDATADMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_wdatadmux_dp_if.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WdataDmux includes' algorithm generated code\n\n//End of 'WdataDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWdataDmux Function WdataDmux\n//@{\n///        \\page dxpWdataDmux\n//@{\n///    \\brief WdataDmux function model start\nclass cfm_wdatadmux: public cf_core::cf_function_router,\n\t\tpublic cfm_wdatadmux_dp_if {\npublic:\n\t/// cfm_wdatadmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wdatadmux, cft_defwdatachn> p_mq_WDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_wdatadmux, cft_defwdatachn> p_mq_WDATAchn_t;\n\t/// cfm_wdatadmux type define end\n\n\t/// constructor\n\tcfm_wdatadmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_wdatadmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_WDATAin_t p_mq_WDATAin;\n\tp_mq_WDATAchn_t p_mq_WDATAchn;\n\t//@}\n\npublic:\n\t/// Overload function for WdataDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux local declarations' algorithm generated code\n\tint Port_ID;\n\t//End of 'WdataDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WdataDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WDATADMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_wdatadmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_wdatadmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WdataDmux definitions' algorithm generated code\n\n//End of 'WdataDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_wdatadmux::cfm_wdatadmux(sc_core::sc_module_name name) :\n\t\tcf_function_router(name), cfm_wdatadmux_dp_if(), p_mq_WDATAin(\n\t\t\t\t\"p_mq_WDATAin\"), p_mq_WDATAchn(\"p_mq_WDATAchn\") {\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_WDATAchn);\n\tadd_output_port (&p_mq_WDATAin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux constructor' algorithm generated code\n\n\t//End of 'WdataDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_wdatadmux::~cfm_wdatadmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux destructor' algorithm generated code\n\n\t//End of 'WdataDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_wdatadmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux pre elaboration' algorithm generated code\n\n\t//End of 'WdataDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_wdatadmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux post simulation' algorithm generated code\n\n\t//End of 'WdataDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_wdatadmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(0, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_wdatadmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux initializations' algorithm generated code\n\n\t//End of 'WdataDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for WdataDmux router destination method\n//@{\nstring cfm_wdatadmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WdataDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defwdatachn*) _trans)->get_data().ID;\n\tstd::stringstream ss;\n\tss << \"WDATAin[\" << sourceID << \"]\";\n\treturn ss.str();\n\t//End of 'WdataDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_raddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RADDRDMUX\n#define COFS_MODEL_DDRMEMORY_RADDRDMUX\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"behavior/cf_function_router.h\"\n#include \"dp/cfm_raddrdmux_dp_if.h\"\n#include \"dt/cft_defaraddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RAddrDmux includes' algorithm generated code\n\n//End of 'RAddrDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRAddrDmux Function RAddrDmux\n//@{\n///        \\page dxpRAddrDmux\n//@{\n///    \\brief RAddrDmux function model start\nclass cfm_raddrdmux: public cf_core::cf_function_router,\n\t\tpublic cfm_raddrdmux_dp_if {\npublic:\n\t/// cfm_raddrdmux type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_raddrdmux, cft_defaraddrchn> p_mq_ARADDRin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_raddrdmux, cft_defaraddrchn> p_mq_ARADDRchn_t;\n\t/// cfm_raddrdmux type define end\n\n\t/// constructor\n\tcfm_raddrdmux(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_raddrdmux(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ARADDRin_t p_mq_ARADDRin;\n\tp_mq_ARADDRchn_t p_mq_ARADDRchn;\n\t//@}\n\npublic:\n\t/// Overload function for RAddrDmux router destination method\n\tstd::string cb_select_destination_name(cf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux local declarations' algorithm generated code\n\tint Port_ID;\n\t//End of 'RAddrDmux local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RAddrDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RADDRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_raddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_raddrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RAddrDmux definitions' algorithm generated code\n\n//End of 'RAddrDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_raddrdmux::cfm_raddrdmux(sc_core::sc_module_name name) :\n\t\tcf_function_router(name), cfm_raddrdmux_dp_if(), p_mq_ARADDRin(\n\t\t\t\t\"p_mq_ARADDRin\"), p_mq_ARADDRchn(\"p_mq_ARADDRchn\") {\n\tcf_function_router::init();\n\n\tadd_input_port (&p_mq_ARADDRchn);\n\tadd_output_port (&p_mq_ARADDRin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux constructor' algorithm generated code\n\n\t//End of 'RAddrDmux constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_raddrdmux::~cfm_raddrdmux(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux destructor' algorithm generated code\n\n\t//End of 'RAddrDmux destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_raddrdmux::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux pre elaboration' algorithm generated code\n\n\t//End of 'RAddrDmux pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_raddrdmux::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux post simulation' algorithm generated code\n\n\t//End of 'RAddrDmux post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_raddrdmux::cb_init_attributes() {\n\n// initialize routing function attributes\n\tcfa_routing_time.init(cf_expr_duration(0, CF_CYCLE));\n\tcfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_raddrdmux::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux initializations' algorithm generated code\n\n\t//End of 'RAddrDmux initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for RAddrDmux router destination method\n//@{\nstring cfm_raddrdmux::cb_select_destination_name(cf_payload_b* _trans) {\n\tstring source_name = get_source_name();\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RAddrDmux destination' algorithm generated code\n\tint sourceID;\n\tsourceID = ((cft_defaraddrchn*) _trans)->get_data().ID;\n\tstd::stringstream ss;\n\tss << \"ARADDRin[\" << sourceID << \"]\";\n\treturn ss.str();\n\t//End of 'RAddrDmux destination' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\treturn \"\";\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'FrontEnd', 'type': 'cofluent:Function', 'models': [{'name': 'WriteDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDriver', 'type': 'cofluent:Function'}, {'name': 'SendWAckDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDataDriver', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead', 'connectTo': ['ReadDataDriver']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck', 'connectTo': ['SendWAckDriver']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['ReadDataDriver']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['SendWAckDriver']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest', 'connectTo': ['ReadDriver']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest', 'connectTo': ['WriteDriver']}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['ReadDriver']}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WriteDriver']}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WriteDriver']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_frontend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_FRONTEND\n#define COFS_MODEL_DDRMEMORY_FRONTEND\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_frontend_dp_if.h\"\n#include \"cfm_readdatadriver.h\"\n#include \"cfm_readdriver.h\"\n#include \"cfm_sendwackdriver.h\"\n#include \"cfm_writedriver.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FrontEnd includes' algorithm generated code\n\n//End of 'FrontEnd includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgFrontEnd Function FrontEnd\n//@{\n///        \\page dxpFrontEnd\n//@{\n///    \\brief FrontEnd function model start\nclass cfm_frontend: public cf_core::cf_function_container,\n\t\tpublic cfm_frontend_dp_if {\npublic:\n\t/// cfm_frontend type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defdataread> p_mq_DataRead_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defwriteack> p_mq_WriteAck_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defbrespchn> p_mq_BRESPchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defaraddrchn> p_mq_ARADDRin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defwdatachn> p_mq_WDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_frontend, cft_defawaddrchn> p_mq_AWADDRin_t;\n\t/// cfm_frontend type define end\n\n\t/// constructor\n\tcfm_frontend(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_frontend(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DataRead_t p_mq_DataRead;\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\tp_mq_ARADDRin_t p_mq_ARADDRin;\n\tp_mq_WDATAin_t p_mq_WDATAin;\n\tp_mq_AWADDRin_t p_mq_AWADDRin;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_readdatadriver* ReadDataDriver;\n\tcfm_readdriver* ReadDriver;\n\tcfm_sendwackdriver* SendWAckDriver;\n\tcfm_writedriver* WriteDriver;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd local declarations' algorithm generated code\n\n\t//End of 'FrontEnd local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief FrontEnd function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_FRONTEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'FrontEnd', 'type': 'cofluent:Function', 'models': [{'name': 'WriteDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDriver', 'type': 'cofluent:Function'}, {'name': 'SendWAckDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDataDriver', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead', 'connectTo': ['ReadDataDriver']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck', 'connectTo': ['SendWAckDriver']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['ReadDataDriver']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['SendWAckDriver']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest', 'connectTo': ['ReadDriver']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest', 'connectTo': ['WriteDriver']}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['ReadDriver']}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WriteDriver']}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WriteDriver']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_frontend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_frontend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memorycontroller\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_frontend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FrontEnd definitions' algorithm generated code\n\n//End of 'FrontEnd definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_frontend::cfm_frontend(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_frontend_dp_if(), p_mq_DataRead(\n\t\t\t\t\"p_mq_DataRead\"), p_mq_WriteAck(\"p_mq_WriteAck\"), p_mq_RDATAchn(\n\t\t\t\t\"p_mq_RDATAchn\"), p_mq_BRESPchn(\"p_mq_BRESPchn\"), p_mq_MemReadRequest(\n\t\t\t\t\"p_mq_MemReadRequest\"), p_mq_MemWriteRequest(\n\t\t\t\t\"p_mq_MemWriteRequest\"), p_mq_ARADDRin(\"p_mq_ARADDRin\"), p_mq_WDATAin(\n\t\t\t\t\"p_mq_WDATAin\"), p_mq_AWADDRin(\"p_mq_AWADDRin\") {\n\tcf_function_container::init();\n\tReadDataDriver = new cfm_readdatadriver(\"ReadDataDriver\");\n\tReadDriver = new cfm_readdriver(\"ReadDriver\");\n\tSendWAckDriver = new cfm_sendwackdriver(\"SendWAckDriver\");\n\tWriteDriver = new cfm_writedriver(\"WriteDriver\");\n\n\t// connections\n\tReadDataDriver->p_mq_RDATAchn(p_mq_RDATAchn);\n\tReadDataDriver->p_mq_DataRead(p_mq_DataRead);\n\n\tReadDriver->p_mq_MemReadRequest(p_mq_MemReadRequest);\n\tReadDriver->p_mq_ARADDRin(p_mq_ARADDRin);\n\n\tSendWAckDriver->p_mq_WriteAck(p_mq_WriteAck);\n\tSendWAckDriver->p_mq_BRESPchn(p_mq_BRESPchn);\n\n\tWriteDriver->p_mq_MemWriteRequest(p_mq_MemWriteRequest);\n\tWriteDriver->p_mq_WDATAin(p_mq_WDATAin);\n\tWriteDriver->p_mq_AWADDRin(p_mq_AWADDRin);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd constructor' algorithm generated code\n\n\t//End of 'FrontEnd constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_frontend::~cfm_frontend(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd destructor' algorithm generated code\n\n\t//End of 'FrontEnd destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete ReadDataDriver;\n\tdelete ReadDriver;\n\tdelete SendWAckDriver;\n\tdelete WriteDriver;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_frontend::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd pre elaboration' algorithm generated code\n\n\t//End of 'FrontEnd pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_frontend::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd post elaboration' algorithm generated code\n\n\t//End of 'FrontEnd post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_frontend::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd post simulation' algorithm generated code\n\n\t//End of 'FrontEnd post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_frontend::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_frontend::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FrontEnd initializations' algorithm generated code\n\n\t//End of 'FrontEnd initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BackEnd', 'type': 'cofluent:Function', 'models': [{'name': 'CollectRequests', 'type': 'cofluent:Function'}, {'name': 'ResponseForward', 'type': 'cofluent:Function'}, {'name': 'Arbitration', 'type': 'cofluent:Function'}, {'name': 'DDRCommandGeneration', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['ResponseForward']}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead', 'connectTo': ['ResponseForward']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest', 'connectTo': ['CollectRequests']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest', 'connectTo': ['CollectRequests']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['DDRCommandGeneration']}], 'relations': [{'name': 'RequestCounter', 'type': 'cofluent:Event', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'ListRequestsPtr', 'type': 'cofluent:SharedVariable', 'dataType': 'DefListRequestsPtr', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'RequestInformation', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequestInformation', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'Requests2Memory', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequests2Memory', 'connectTo': ['Arbitration', 'DDRCommandGeneration']}, {'name': 'MemoryStatus', 'type': 'cofluent:SharedVariable', 'vector': '0, M_Nbr', 'dataType': 'DefMemoryStatus', 'connectTo': ['DDRCommandGeneration']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_backend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_BACKEND\n#define COFS_MODEL_DDRMEMORY_BACKEND\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_backend_dp_if.h\"\n#include \"cfm_arbitration.h\"\n#include \"cfm_collectrequests.h\"\n#include \"cfm_ddrcommandgeneration.h\"\n#include \"cfm_responseforward.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_defrequests2memory.h\"\n#include \"dt/cft_defmemorystatus.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BackEnd includes' algorithm generated code\n\n//End of 'BackEnd includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBackEnd Function BackEnd\n//@{\n///        \\page dxpBackEnd\n//@{\n///    \\brief BackEnd function model start\nclass cfm_backend: public cf_core::cf_function_container,\n\t\tpublic cfm_backend_dp_if {\npublic:\n\t/// cfm_backend type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_deflistrequestsptr> sv_ListRequestsPtr_t;\n\ttypedef cf_core::cf_shared_variable<cft_defmemorystatus> sv_MemoryStatus_t;\n\ttypedef cf_core::cf_event ev_RequestCounter_t;\n\ttypedef cf_core::cf_message_queue<cft_defrequestinformation> mq_RequestInformation_t;\n\ttypedef cf_core::cf_message_queue<cft_defrequests2memory> mq_Requests2Memory_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defdataread> p_mq_DataRead_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defwriteack> p_mq_WriteAck_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defddrcommand> p_mq_DDRCommand_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_backend, cft_defwriteack> p_mq_WriteAck_1_t;\n\t/// cfm_backend type define end\n\n\t/// constructor\n\tcfm_backend(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_backend(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tp_mq_DataRead_t p_mq_DataRead;\n\tp_mq_WriteAck_0_t p_mq_WriteAck_0;\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\tp_mq_WriteAck_1_t p_mq_WriteAck_1;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_arbitration* Arbitration;\n\tcfm_collectrequests* CollectRequests;\n\tcfm_ddrcommandgeneration* DDRCommandGeneration;\n\tcfm_responseforward* ResponseForward;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_ListRequestsPtr_t sv_ListRequestsPtr;\n\tstd::vector<sv_MemoryStatus_t*> sv_MemoryStatus_vec;\n\tev_RequestCounter_t ev_RequestCounter;\n\tmq_RequestInformation_t mq_RequestInformation;\n\tmq_Requests2Memory_t mq_Requests2Memory;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd local declarations' algorithm generated code\n\n\t//End of 'BackEnd local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BackEnd function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_BACKEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BackEnd', 'type': 'cofluent:Function', 'models': [{'name': 'CollectRequests', 'type': 'cofluent:Function'}, {'name': 'ResponseForward', 'type': 'cofluent:Function'}, {'name': 'Arbitration', 'type': 'cofluent:Function'}, {'name': 'DDRCommandGeneration', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['ResponseForward']}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead', 'connectTo': ['ResponseForward']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest', 'connectTo': ['CollectRequests']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest', 'connectTo': ['CollectRequests']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['DDRCommandGeneration']}], 'relations': [{'name': 'RequestCounter', 'type': 'cofluent:Event', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'ListRequestsPtr', 'type': 'cofluent:SharedVariable', 'dataType': 'DefListRequestsPtr', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'RequestInformation', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequestInformation', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'Requests2Memory', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequests2Memory', 'connectTo': ['Arbitration', 'DDRCommandGeneration']}, {'name': 'MemoryStatus', 'type': 'cofluent:SharedVariable', 'vector': '0, M_Nbr', 'dataType': 'DefMemoryStatus', 'connectTo': ['DDRCommandGeneration']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_backend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_backend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memorycontroller\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_backend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BackEnd definitions' algorithm generated code\n\n//End of 'BackEnd definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_backend::cfm_backend(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_backend_dp_if(), p_mq_DQs(\"p_mq_DQs\"), p_mq_DataRead(\n\t\t\t\t\"p_mq_DataRead\"), p_mq_WriteAck_0(\"p_mq_WriteAck_0\"), p_mq_MemReadRequest(\n\t\t\t\t\"p_mq_MemReadRequest\"), p_mq_MemWriteRequest(\n\t\t\t\t\"p_mq_MemWriteRequest\"), p_mq_DDRCommand(\"p_mq_DDRCommand\"), p_mq_WriteAck_1(\n\t\t\t\t\"p_mq_WriteAck_1\"), sv_ListRequestsPtr(\"ListRequestsPtr\"), ev_RequestCounter(\n\t\t\t\t\"RequestCounter\"), mq_RequestInformation(\"RequestInformation\"), mq_Requests2Memory(\n\t\t\t\t\"Requests2Memory\") {\n\tcf_function_container::init();\n\tArbitration = new cfm_arbitration(\"Arbitration\");\n\tCollectRequests = new cfm_collectrequests(\"CollectRequests\");\n\tDDRCommandGeneration = new cfm_ddrcommandgeneration(\"DDRCommandGeneration\");\n\tResponseForward = new cfm_responseforward(\"ResponseForward\");\n\n\t// instantiation of sv_MemoryStatus_vec\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tsv_MemoryStatus_t* module = new sv_MemoryStatus_t(\n\t\t\t\tcf_string(\"MemoryStatus[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tsv_MemoryStatus_vec.push_back(module);\n\t}\n\t// connections\n\tArbitration->p_mq_WriteAck(p_mq_WriteAck_1);\n\tArbitration->p_mq_RequestInformation(mq_RequestInformation.p_target_socket);\n\tArbitration->p_sv_ListRequestsPtr(sv_ListRequestsPtr.p_target_socket);\n\tArbitration->p_mq_Requests2Memory(mq_Requests2Memory.p_target_socket);\n\tArbitration->p_ev_RequestCounter(ev_RequestCounter.p_target_socket);\n\n\tCollectRequests->p_sv_ListRequestsPtr(sv_ListRequestsPtr.p_target_socket);\n\tCollectRequests->p_ev_RequestCounter(ev_RequestCounter.p_target_socket);\n\tCollectRequests->p_mq_MemReadRequest(p_mq_MemReadRequest);\n\tCollectRequests->p_mq_MemWriteRequest(p_mq_MemWriteRequest);\n\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\tDDRCommandGeneration->p_sv_MemoryStatus(\n\t\t\t\tsv_MemoryStatus_vec[i]->p_target_socket);\n\t}\n\tDDRCommandGeneration->p_mq_Requests2Memory(\n\t\t\tmq_Requests2Memory.p_target_socket);\n\tDDRCommandGeneration->p_mq_DDRCommand(p_mq_DDRCommand);\n\n\tResponseForward->p_mq_DQs(p_mq_DQs);\n\tResponseForward->p_mq_RequestInformation(\n\t\t\tmq_RequestInformation.p_target_socket);\n\tResponseForward->p_mq_DataRead(p_mq_DataRead);\n\tResponseForward->p_mq_WriteAck(p_mq_WriteAck_0);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd constructor' algorithm generated code\n\n\t//End of 'BackEnd constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_backend::~cfm_backend(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd destructor' algorithm generated code\n\n\t//End of 'BackEnd destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<sv_MemoryStatus_t*>::const_iterator vi =\n\t\t\tsv_MemoryStatus_vec.begin(); vi != sv_MemoryStatus_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete Arbitration;\n\tdelete CollectRequests;\n\tdelete DDRCommandGeneration;\n\tdelete ResponseForward;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_backend::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd pre elaboration' algorithm generated code\n\n\t//End of 'BackEnd pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_backend::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd post elaboration' algorithm generated code\n\n\t//End of 'BackEnd post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_backend::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd post simulation' algorithm generated code\n\n\t//End of 'BackEnd post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_backend::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tsv_ListRequestsPtr.cfa_write_time.init(cf_expr_duration(0, CF_CYCLE));\n\tsv_ListRequestsPtr.cfa_read_time.init(cf_expr_duration(0, CF_CYCLE));\n\tsv_ListRequestsPtr.cfa_semaphore.init(false);\n\tsv_ListRequestsPtr.cfa_concurrency.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n\t\t(*sv_MemoryStatus_vec[i]).cfa_write_time.init(\n\t\t\t\tcf_expr_duration(0, CF_CYCLE));\n\t\t(*sv_MemoryStatus_vec[i]).cfa_read_time.init(\n\t\t\t\tcf_expr_duration(0, CF_CYCLE));\n\t\t(*sv_MemoryStatus_vec[i]).cfa_semaphore.init(false);\n\t\t(*sv_MemoryStatus_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t}\n\tev_RequestCounter.cfa_set_time.init(cf_expr_duration(0, CF_CYCLE));\n\tev_RequestCounter.cfa_get_time.init(cf_expr_duration(0, CF_CYCLE));\n\tev_RequestCounter.cfa_event_policy.init(CF_EV_POLICY_COUNTER);\n\tmq_RequestInformation.cfa_send_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_RequestInformation.cfa_receive_time.init(cf_expr_duration(0, CF_CYCLE));\n\tmq_RequestInformation.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_INFINITE);\n\tmq_RequestInformation.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Requests2Memory.cfa_send_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_Requests2Memory.cfa_receive_time.init(cf_expr_duration(1, CF_CYCLE));\n\tmq_Requests2Memory.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Requests2Memory.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Requests2Memory.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_backend::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BackEnd initializations' algorithm generated code\n\n\t//End of 'BackEnd initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memorycommandexecution\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n#define COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memorycommandexecution_dp_if.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryCommandExecution includes' algorithm generated code\n\n//End of 'MemoryCommandExecution includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemoryCommandExecution Function MemoryCommandExecution\n//@{\n///        \\page dxpMemoryCommandExecution\n//@{\n///    \\brief MemoryCommandExecution function model start\nclass cfm_memorycommandexecution: public cf_core::cf_function,\n\t\tpublic cfm_memorycommandexecution_dp_if {\npublic:\n\t/// cfm_memorycommandexecution type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycommandexecution,\n\t\t\tcft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_memorycommandexecution,\n\t\t\tcft_defddrcommand> p_mq_DDRAction_t;\n\t/// cfm_memorycommandexecution type define end\n\n\t/// constructor\n\tcfm_memorycommandexecution(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_memorycommandexecution(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tp_mq_DDRAction_t p_mq_DDRAction;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution local declarations' algorithm generated code\n\tint ExecuteCommandDuration;\n\tbool SendDQ;\n\tint AutoPrechargedDuration;\n\tint memID;\n\tint InitBankDuration;\n\tint PowerConsumption;\n\tdouble StaticPowerConsumption;\n\t// 4 because of a maximum of 4 banks per memory\n\tint StartBank[4];\n\tint Instance;\n\t//End of 'MemoryCommandExecution local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MemoryCommandExecution function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memorycommandexecution\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memorycommandexecution.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memorycommandexecution\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MemoryCommandExecution definitions' algorithm generated code\n\n//End of 'MemoryCommandExecution definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memorycommandexecution::cfm_memorycommandexecution(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_memorycommandexecution_dp_if(), p_mq_DQs(\n\t\t\t\t\"p_mq_DQs\"), p_mq_DDRAction(\"p_mq_DDRAction\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution constructor' algorithm generated code\n\n\t//End of 'MemoryCommandExecution constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memorycommandexecution::~cfm_memorycommandexecution(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution destructor' algorithm generated code\n\n\t//End of 'MemoryCommandExecution destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_memorycommandexecution::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution pre elaboration' algorithm generated code\n\n\t//End of 'MemoryCommandExecution pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_memorycommandexecution::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution post elaboration' algorithm generated code\n\n\t//End of 'MemoryCommandExecution post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_memorycommandexecution::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution post simulation' algorithm generated code\n\n\t//End of 'MemoryCommandExecution post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_memorycommandexecution::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_memorycommandexecution::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MemoryCommandExecution initializations' algorithm generated code\n\tStartBank[0] = 0;\n\tStartBank[1] = 0;\n\tStartBank[2] = 0;\n\tStartBank[3] = 0;\n\tmemID = 0;\n\t//End of 'MemoryCommandExecution initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BankDmuxer', 'type': 'cofluent:Function', 'ports': [{'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bankdmuxer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_BANKDMUXER\n#define COFS_MODEL_DDRMEMORY_BANKDMUXER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bankdmuxer_dp_if.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BankDmuxer includes' algorithm generated code\n\n//End of 'BankDmuxer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBankDmuxer Function BankDmuxer\n//@{\n///        \\page dxpBankDmuxer\n//@{\n///    \\brief BankDmuxer function model start\nclass cfm_bankdmuxer: public cf_core::cf_function, public cfm_bankdmuxer_dp_if {\npublic:\n\t/// cfm_bankdmuxer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bankdmuxer, cft_defddrcommand> p_mq_DDRAction_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bankdmuxer, cft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_bankdmuxer type define end\n\n\t/// constructor\n\tcfm_bankdmuxer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bankdmuxer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DDRAction_t p_mq_DDRAction;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer local declarations' algorithm generated code\n\tbool RcvRequest;\n\tint Bank;\n\tfloat LastActivate, CurrentActivate;\n\tint LastBank;\n\tint Send2BankDuration;\n\tint DDRActionSend;\n\t//End of 'BankDmuxer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BankDmuxer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_BANKDMUXER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BankDmuxer', 'type': 'cofluent:Function', 'ports': [{'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bankdmuxer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bankdmuxer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bankdmuxer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BankDmuxer definitions' algorithm generated code\n\n//End of 'BankDmuxer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bankdmuxer::cfm_bankdmuxer(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_bankdmuxer_dp_if(), p_mq_DDRAction(\n\t\t\t\t\"p_mq_DDRAction\"), p_mq_DDRCommand(\"p_mq_DDRCommand\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer constructor' algorithm generated code\n\n\t//End of 'BankDmuxer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bankdmuxer::~cfm_bankdmuxer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer destructor' algorithm generated code\n\n\t//End of 'BankDmuxer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bankdmuxer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer pre elaboration' algorithm generated code\n\n\t//End of 'BankDmuxer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bankdmuxer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer post elaboration' algorithm generated code\n\n\t//End of 'BankDmuxer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bankdmuxer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer post simulation' algorithm generated code\n\n\t//End of 'BankDmuxer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bankdmuxer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bankdmuxer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BankDmuxer initializations' algorithm generated code\n\n\t//End of 'BankDmuxer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WriteDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_writedriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WRITEDRIVER\n#define COFS_MODEL_DDRMEMORY_WRITEDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_writedriver_dp_if.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WriteDriver includes' algorithm generated code\n\n//End of 'WriteDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWriteDriver Function WriteDriver\n//@{\n///        \\page dxpWriteDriver\n//@{\n///    \\brief WriteDriver function model start\nclass cfm_writedriver: public cf_core::cf_function, public cfm_writedriver_dp_if {\npublic:\n\t/// cfm_writedriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writedriver,\n\t\t\tcft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writedriver, cft_defwdatachn> p_mq_WDATAin_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writedriver, cft_defawaddrchn> p_mq_AWADDRin_t;\n\t/// cfm_writedriver type define end\n\n\t/// constructor\n\tcfm_writedriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_writedriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\tp_mq_WDATAin_t p_mq_WDATAin;\n\tp_mq_AWADDRin_t p_mq_AWADDRin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver local declarations' algorithm generated code\n\tint burstLength;\n\tfloat startTime;\n\tint address;\n\tint ID;\n\tint size;\n\tlong WriteInitDuration;\n\tint myIndex;\n\t//End of 'WriteDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief WriteDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WRITEDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WriteDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_writedriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_writedriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writedriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'WriteDriver definitions' algorithm generated code\n\n//End of 'WriteDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_writedriver::cfm_writedriver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_writedriver_dp_if(), p_mq_MemWriteRequest(\n\t\t\t\t\"p_mq_MemWriteRequest\"), p_mq_WDATAin(\"p_mq_WDATAin\"), p_mq_AWADDRin(\n\t\t\t\t\"p_mq_AWADDRin\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver constructor' algorithm generated code\n\n\t//End of 'WriteDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_writedriver::~cfm_writedriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver destructor' algorithm generated code\n\n\t//End of 'WriteDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_writedriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver pre elaboration' algorithm generated code\n\n\t//End of 'WriteDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_writedriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver post elaboration' algorithm generated code\n\n\t//End of 'WriteDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_writedriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver post simulation' algorithm generated code\n\n\t//End of 'WriteDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_writedriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_writedriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'WriteDriver initializations' algorithm generated code\n\n\t//End of 'WriteDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReadDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_readdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_READDRIVER\n#define COFS_MODEL_DDRMEMORY_READDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_readdriver_dp_if.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defaraddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDriver includes' algorithm generated code\n\n//End of 'ReadDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReadDriver Function ReadDriver\n//@{\n///        \\page dxpReadDriver\n//@{\n///    \\brief ReadDriver function model start\nclass cfm_readdriver: public cf_core::cf_function, public cfm_readdriver_dp_if {\npublic:\n\t/// cfm_readdriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdriver,\n\t\t\tcft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdriver, cft_defaraddrchn> p_mq_ARADDRin_t;\n\t/// cfm_readdriver type define end\n\n\t/// constructor\n\tcfm_readdriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_readdriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_ARADDRin_t p_mq_ARADDRin;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver local declarations' algorithm generated code\n\tint burstLength;\n\tfloat startTime;\n\tint address;\n\tint ID;\n\tint size;\n\tbool First;\n\tlong RdInitDuration;\n\tint myIndex;\n\t//End of 'ReadDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReadDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_READDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReadDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_readdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_readdriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_readdriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDriver definitions' algorithm generated code\n\n//End of 'ReadDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_readdriver::cfm_readdriver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_readdriver_dp_if(), p_mq_MemReadRequest(\n\t\t\t\t\"p_mq_MemReadRequest\"), p_mq_ARADDRin(\"p_mq_ARADDRin\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver constructor' algorithm generated code\n\n\t//End of 'ReadDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_readdriver::~cfm_readdriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver destructor' algorithm generated code\n\n\t//End of 'ReadDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_readdriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver pre elaboration' algorithm generated code\n\n\t//End of 'ReadDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_readdriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver post elaboration' algorithm generated code\n\n\t//End of 'ReadDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_readdriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver post simulation' algorithm generated code\n\n\t//End of 'ReadDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_readdriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_readdriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDriver initializations' algorithm generated code\n\n\t//End of 'ReadDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'SendWAckDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sendwackdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n#define COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sendwackdriver_dp_if.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'SendWAckDriver includes' algorithm generated code\n\n//End of 'SendWAckDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSendWAckDriver Function SendWAckDriver\n//@{\n///        \\page dxpSendWAckDriver\n//@{\n///    \\brief SendWAckDriver function model start\nclass cfm_sendwackdriver: public cf_core::cf_function,\n\t\tpublic cfm_sendwackdriver_dp_if {\npublic:\n\t/// cfm_sendwackdriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sendwackdriver, cft_defwriteack> p_mq_WriteAck_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sendwackdriver, cft_defbrespchn> p_mq_BRESPchn_t;\n\t/// cfm_sendwackdriver type define end\n\n\t/// constructor\n\tcfm_sendwackdriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_sendwackdriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\tp_mq_BRESPchn_t p_mq_BRESPchn;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver local declarations' algorithm generated code\n\tlong WACKInitDuration;\n\tint myIndex;\n\t//End of 'SendWAckDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief SendWAckDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'SendWAckDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sendwackdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sendwackdriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sendwackdriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'SendWAckDriver definitions' algorithm generated code\n\n//End of 'SendWAckDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sendwackdriver::cfm_sendwackdriver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_sendwackdriver_dp_if(), p_mq_WriteAck(\n\t\t\t\t\"p_mq_WriteAck\"), p_mq_BRESPchn(\"p_mq_BRESPchn\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver constructor' algorithm generated code\n\n\t//End of 'SendWAckDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sendwackdriver::~cfm_sendwackdriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver destructor' algorithm generated code\n\n\t//End of 'SendWAckDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_sendwackdriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver pre elaboration' algorithm generated code\n\n\t//End of 'SendWAckDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_sendwackdriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver post elaboration' algorithm generated code\n\n\t//End of 'SendWAckDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_sendwackdriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver post simulation' algorithm generated code\n\n\t//End of 'SendWAckDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_sendwackdriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_sendwackdriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'SendWAckDriver initializations' algorithm generated code\n\n\t//End of 'SendWAckDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReadDataDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_readdatadriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_READDATADRIVER\n#define COFS_MODEL_DDRMEMORY_READDATADRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_readdatadriver_dp_if.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defdataread.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDataDriver includes' algorithm generated code\n\n//End of 'ReadDataDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReadDataDriver Function ReadDataDriver\n//@{\n///        \\page dxpReadDataDriver\n//@{\n///    \\brief ReadDataDriver function model start\nclass cfm_readdatadriver: public cf_core::cf_function,\n\t\tpublic cfm_readdatadriver_dp_if {\npublic:\n\t/// cfm_readdatadriver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdatadriver, cft_defrdatachn> p_mq_RDATAchn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_readdatadriver, cft_defdataread> p_mq_DataRead_t;\n\t/// cfm_readdatadriver type define end\n\n\t/// constructor\n\tcfm_readdatadriver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_readdatadriver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RDATAchn_t p_mq_RDATAchn;\n\tp_mq_DataRead_t p_mq_DataRead;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver local declarations' algorithm generated code\n\tfloat startTime;\n\tint ID;\n\tint burstLength;\n\tlong ReadDataInitDuration;\n\tint myIndex;\n\t//End of 'ReadDataDriver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ReadDataDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_READDATADRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReadDataDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_readdatadriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_readdatadriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_readdatadriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ReadDataDriver definitions' algorithm generated code\n\n//End of 'ReadDataDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_readdatadriver::cfm_readdatadriver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_readdatadriver_dp_if(), p_mq_RDATAchn(\n\t\t\t\t\"p_mq_RDATAchn\"), p_mq_DataRead(\"p_mq_DataRead\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver constructor' algorithm generated code\n\n\t//End of 'ReadDataDriver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_readdatadriver::~cfm_readdatadriver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver destructor' algorithm generated code\n\n\t//End of 'ReadDataDriver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_readdatadriver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver pre elaboration' algorithm generated code\n\n\t//End of 'ReadDataDriver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_readdatadriver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver post elaboration' algorithm generated code\n\n\t//End of 'ReadDataDriver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_readdatadriver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver post simulation' algorithm generated code\n\n\t//End of 'ReadDataDriver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_readdatadriver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_readdatadriver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ReadDataDriver initializations' algorithm generated code\n\n\t//End of 'ReadDataDriver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CollectRequests', 'type': 'cofluent:Function', 'ports': [{'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_collectrequests\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n#define COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_collectrequests_dp_if.h\"\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CollectRequests includes' algorithm generated code\n\n//End of 'CollectRequests includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCollectRequests Function CollectRequests\n//@{\n///        \\page dxpCollectRequests\n//@{\n///    \\brief CollectRequests function model start\nclass cfm_collectrequests: public cf_core::cf_function,\n\t\tpublic cfm_collectrequests_dp_if {\npublic:\n\t/// cfm_collectrequests type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_collectrequests,\n\t\t\tcft_deflistrequestsptr> p_sv_ListRequestsPtr_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_collectrequests> p_ev_RequestCounter_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_collectrequests,\n\t\t\tcft_defmemreadrequest> p_mq_MemReadRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_collectrequests,\n\t\t\tcft_defmemwriterequest> p_mq_MemWriteRequest_t;\n\t/// cfm_collectrequests type define end\n\n\t/// constructor\n\tcfm_collectrequests(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_collectrequests(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_ListRequestsPtr_t p_sv_ListRequestsPtr;\n\tp_ev_RequestCounter_t p_ev_RequestCounter;\n\tp_mq_MemReadRequest_t p_mq_MemReadRequest;\n\tp_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests local declarations' algorithm generated code\n\tDefListRequestsPtr currentRequestPtr;\n\tDefListRequestsPtr prevRequestPtr;\n\tint memID;\n\t//End of 'CollectRequests local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CollectRequests function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CollectRequests', 'type': 'cofluent:Function', 'ports': [{'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_collectrequests\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_collectrequests.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_collectrequests\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CollectRequests definitions' algorithm generated code\n\n//End of 'CollectRequests definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_collectrequests::cfm_collectrequests(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_collectrequests_dp_if(), p_sv_ListRequestsPtr(\n\t\t\t\t\"p_sv_ListRequestsPtr\"), p_ev_RequestCounter(\n\t\t\t\t\"p_ev_RequestCounter\"), p_mq_MemReadRequest(\n\t\t\t\t\"p_mq_MemReadRequest\"), p_mq_MemWriteRequest(\n\t\t\t\t\"p_mq_MemWriteRequest\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests constructor' algorithm generated code\n\n\t//End of 'CollectRequests constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_collectrequests::~cfm_collectrequests(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests destructor' algorithm generated code\n\n\t//End of 'CollectRequests destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_collectrequests::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests pre elaboration' algorithm generated code\n\n\t//End of 'CollectRequests pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_collectrequests::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests post elaboration' algorithm generated code\n\n\t//End of 'CollectRequests post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_collectrequests::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests post simulation' algorithm generated code\n\n\t//End of 'CollectRequests post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_collectrequests::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_collectrequests::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CollectRequests initializations' algorithm generated code\n\n\t//End of 'CollectRequests initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ResponseForward', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequestInformation'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_responseforward\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n#define COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_responseforward_dp_if.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ResponseForward includes' algorithm generated code\n\n//End of 'ResponseForward includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgResponseForward Function ResponseForward\n//@{\n///        \\page dxpResponseForward\n//@{\n///    \\brief ResponseForward function model start\nclass cfm_responseforward: public cf_core::cf_function,\n\t\tpublic cfm_responseforward_dp_if {\npublic:\n\t/// cfm_responseforward type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward, cft_defdqs> p_mq_DQs_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward,\n\t\t\tcft_defrequestinformation> p_mq_RequestInformation_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward, cft_defdataread> p_mq_DataRead_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_responseforward, cft_defwriteack> p_mq_WriteAck_t;\n\t/// cfm_responseforward type define end\n\n\t/// constructor\n\tcfm_responseforward(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_responseforward(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_DQs_t p_mq_DQs;\n\tp_mq_RequestInformation_t p_mq_RequestInformation;\n\tp_mq_DataRead_t p_mq_DataRead;\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward local declarations' algorithm generated code\n\tbool IS_WRITE_ACK;\n\tbool IS_DATA_READ;\n\tint NbDataTransfer;\n\t// delay expected before data is available on dq signals\n\tint DqReadyDuration;\n\tbool NORMAL_ACK;\n\tbool SEND_NORMAL_ACK;\n\tlong PrepareResponseDuration;\n\tint BankAccessed;\n\tint RowAccessed;\n\tint ColumnAccessed;\n\tint NbMemRcvTransactions;\n\t// Table used to count the number data transfers already processed within a burst for each master and each command Write/Read\n\tint RemainingData[10][2];\n\tint ID;\n\tint Length;\n\tint Command;\n\t//End of 'ResponseForward local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ResponseForward function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ResponseForward', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequestInformation'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_responseforward\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_responseforward.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_responseforward\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ResponseForward definitions' algorithm generated code\n\n//End of 'ResponseForward definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_responseforward::cfm_responseforward(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_responseforward_dp_if(), p_mq_DQs(\"p_mq_DQs\"), p_mq_RequestInformation(\n\t\t\t\t\"p_mq_RequestInformation\"), p_mq_DataRead(\"p_mq_DataRead\"), p_mq_WriteAck(\n\t\t\t\t\"p_mq_WriteAck\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward constructor' algorithm generated code\n\n\t//End of 'ResponseForward constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_responseforward::~cfm_responseforward(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward destructor' algorithm generated code\n\n\t//End of 'ResponseForward destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_responseforward::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward pre elaboration' algorithm generated code\n\n\t//End of 'ResponseForward pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_responseforward::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward post elaboration' algorithm generated code\n\n\t//End of 'ResponseForward post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_responseforward::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward post simulation' algorithm generated code\n\n\t//End of 'ResponseForward post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_responseforward::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_responseforward::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ResponseForward initializations' algorithm generated code\n\n\t//End of 'ResponseForward initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Arbitration', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequestInformation'}, {'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequests2Memory'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_arbitration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_ARBITRATION\n#define COFS_MODEL_DDRMEMORY_ARBITRATION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_arbitration_dp_if.h\"\n#include \"dt/cft_defwriteack.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defrequests2memory.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Arbitration includes' algorithm generated code\n\n//End of 'Arbitration includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgArbitration Function Arbitration\n//@{\n///        \\page dxpArbitration\n//@{\n///    \\brief Arbitration function model start\nclass cfm_arbitration: public cf_core::cf_function, public cfm_arbitration_dp_if {\npublic:\n\t/// cfm_arbitration type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_arbitration, cft_defwriteack> p_mq_WriteAck_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_arbitration,\n\t\t\tcft_defrequestinformation> p_mq_RequestInformation_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_arbitration,\n\t\t\tcft_deflistrequestsptr> p_sv_ListRequestsPtr_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_arbitration,\n\t\t\tcft_defrequests2memory> p_mq_Requests2Memory_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_arbitration> p_ev_RequestCounter_t;\n\t/// cfm_arbitration type define end\n\n\t/// constructor\n\tcfm_arbitration(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_arbitration(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_WriteAck_t p_mq_WriteAck;\n\tp_mq_RequestInformation_t p_mq_RequestInformation;\n\tp_sv_ListRequestsPtr_t p_sv_ListRequestsPtr;\n\tp_mq_Requests2Memory_t p_mq_Requests2Memory;\n\tp_ev_RequestCounter_t p_ev_RequestCounter;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration local declarations' algorithm generated code\n\tDefListRequestsPtr SelectedRequestPtr;\n\tDefListRequestsPtr CurrentRequestPtr;\n\tDefListRequestsPtr NextRequestPtr;\n\tint memID;\n\tint RemainingRequests;\n\tint BurstID;\n\tint RequestID;\n\tbool RequestIDerror;\n\tint NbRequestsCk;\n\tDefMemCmd CMDRef;\n\tDefMemCmd CMDCurrent;\n\tint NbMemoryTransactions;\n\tbool SendFastAck;\n\t//End of 'Arbitration local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Arbitration function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_ARBITRATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Arbitration', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequestInformation'}, {'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequests2Memory'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_arbitration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_arbitration.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_arbitration\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Arbitration definitions' algorithm generated code\n\n//End of 'Arbitration definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_arbitration::cfm_arbitration(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_arbitration_dp_if(), p_mq_WriteAck(\n\t\t\t\t\"p_mq_WriteAck\"), p_mq_RequestInformation(\n\t\t\t\t\"p_mq_RequestInformation\"), p_sv_ListRequestsPtr(\n\t\t\t\t\"p_sv_ListRequestsPtr\"), p_mq_Requests2Memory(\n\t\t\t\t\"p_mq_Requests2Memory\"), p_ev_RequestCounter(\n\t\t\t\t\"p_ev_RequestCounter\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration constructor' algorithm generated code\n\n\t//End of 'Arbitration constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_arbitration::~cfm_arbitration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration destructor' algorithm generated code\n\n\t//End of 'Arbitration destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_arbitration::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration pre elaboration' algorithm generated code\n\n\t//End of 'Arbitration pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_arbitration::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration post elaboration' algorithm generated code\n\n\t//End of 'Arbitration post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_arbitration::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration post simulation' algorithm generated code\n\n\t//End of 'Arbitration post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_arbitration::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_arbitration::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Arbitration initializations' algorithm generated code\n\n\t//End of 'Arbitration initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DDRCommandGeneration', 'type': 'cofluent:Function', 'ports': [{'name': 'MemoryStatus', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefMemoryStatus'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequests2Memory'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ddrcommandgeneration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n#define COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ddrcommandgeneration_dp_if.h\"\n#include \"dt/cft_defmemorystatus.h\"\n#include \"dt/cft_defrequests2memory.h\"\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRCommandGeneration includes' algorithm generated code\n\n//End of 'DDRCommandGeneration includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDDRCommandGeneration Function DDRCommandGeneration\n//@{\n///        \\page dxpDDRCommandGeneration\n//@{\n///    \\brief DDRCommandGeneration function model start\nclass cfm_ddrcommandgeneration: public cf_core::cf_function,\n\t\tpublic cfm_ddrcommandgeneration_dp_if {\npublic:\n\t/// cfm_ddrcommandgeneration type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_ddrcommandgeneration,\n\t\t\tcft_defmemorystatus> p_sv_MemoryStatus_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ddrcommandgeneration,\n\t\t\tcft_defrequests2memory> p_mq_Requests2Memory_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ddrcommandgeneration,\n\t\t\tcft_defddrcommand> p_mq_DDRCommand_t;\n\t/// cfm_ddrcommandgeneration type define end\n\n\t/// constructor\n\tcfm_ddrcommandgeneration(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ddrcommandgeneration(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_MemoryStatus_t p_sv_MemoryStatus;\n\tp_mq_Requests2Memory_t p_mq_Requests2Memory;\n\tp_mq_DDRCommand_t p_mq_DDRCommand;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration local declarations' algorithm generated code\n\tint BankAccessed, RowAccessed, ColumnAccessed;\n\tbool NeedActive, NeedPrecharge;\n\tDefMemoryMode MemoryState;\n\tunsigned int memID;\n\t//End of 'DDRCommandGeneration local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief DDRCommandGeneration function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DDRCommandGeneration', 'type': 'cofluent:Function', 'ports': [{'name': 'MemoryStatus', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefMemoryStatus'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequests2Memory'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ddrcommandgeneration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ddrcommandgeneration.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ddrcommandgeneration\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DDRCommandGeneration definitions' algorithm generated code\n\n//End of 'DDRCommandGeneration definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ddrcommandgeneration::cfm_ddrcommandgeneration(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_ddrcommandgeneration_dp_if(), p_sv_MemoryStatus(\n\t\t\t\t\"p_sv_MemoryStatus\"), p_mq_Requests2Memory(\n\t\t\t\t\"p_mq_Requests2Memory\"), p_mq_DDRCommand(\"p_mq_DDRCommand\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration constructor' algorithm generated code\n\n\t//End of 'DDRCommandGeneration constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ddrcommandgeneration::~cfm_ddrcommandgeneration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration destructor' algorithm generated code\n\n\t//End of 'DDRCommandGeneration destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ddrcommandgeneration::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration pre elaboration' algorithm generated code\n\n\t//End of 'DDRCommandGeneration pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ddrcommandgeneration::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration post elaboration' algorithm generated code\n\n\t//End of 'DDRCommandGeneration post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ddrcommandgeneration::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration post simulation' algorithm generated code\n\n\t//End of 'DDRCommandGeneration post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ddrcommandgeneration::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ddrcommandgeneration::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DDRCommandGeneration initializations' algorithm generated code\n\n\t//End of 'DDRCommandGeneration initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example3App', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'OS', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inheritance_example3app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_os.h\"\n#include \"cfm_producer.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example3App includes' algorithm generated code\n\n//End of 'Inheritance_example3App includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInheritance_example3App Function Inheritance_example3App\n//@{\n///        \\page dxpInheritance_example3App\n//@{\n///    \\brief Inheritance_example3App function model start\nclass cfm_inheritance_example3app: public cf_core::cf_application {\npublic:\n\t/// cfm_inheritance_example3app type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\t/// cfm_inheritance_example3app type define end\n\n\t/// constructor\n\tcfm_inheritance_example3app(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inheritance_example3app(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_consumer*> Consumer_vec;\n\tcfm_os* OS;\n\tstd::vector<cfm_producer*> Producer_vec;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_MsgQ_t*> mq_MsgQ_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example3App local declarations' algorithm generated code\n\n\t//End of 'Inheritance_example3App local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Inheritance_example3App function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example3App', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'OS', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inheritance_example3app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inheritance_example3app.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example3App definitions' algorithm generated code\n\n//End of 'Inheritance_example3App definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inheritance_example3app::cfm_inheritance_example3app(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name) {\n\tcf_application::init();\n\tOS = new cfm_os(\"OS\");\n\n\t// instantiation of Consumer_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_consumer* module = new cfm_consumer(\n\t\t\t\tcf_string(\"Consumer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tConsumer_vec.push_back(module);\n\t}\n\t// instantiation of Producer_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_producer* module = new cfm_producer(\n\t\t\t\tcf_string(\"Producer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tProducer_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQ_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tmq_MsgQ_t* module = new mq_MsgQ_t(cf_string(\"MsgQ[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQ_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_consumer* module = Consumer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count) 2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_producer* module = Producer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count) 2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example3App constructor' algorithm generated code\n\n\t//End of 'Inheritance_example3App constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inheritance_example3app::~cfm_inheritance_example3app(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example3App destructor' algorithm generated code\n\n\t//End of 'Inheritance_example3App destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_consumer*>::const_iterator vi = Consumer_vec.begin();\n\t\t\tvi != Consumer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_producer*>::const_iterator vi = Producer_vec.begin();\n\t\t\tvi != Producer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQ_t*>::const_iterator vi = mq_MsgQ_vec.begin();\n\t\t\tvi != mq_MsgQ_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete OS;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inheritance_example3app::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example3App pre elaboration' algorithm generated code\n\n\t//End of 'Inheritance_example3App pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inheritance_example3app::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example3App post elaboration' algorithm generated code\n\n//End of 'Inheritance_example3App post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inheritance_example3app::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example3App post simulation' algorithm generated code\n\n\t//End of 'Inheritance_example3App post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inheritance_example3app::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\t(*mq_MsgQ_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inheritance_example3app::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example3App initializations' algorithm generated code\n\n\t//End of 'Inheritance_example3App initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OS', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_os\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n\n/// Model Header includes start\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OS includes' algorithm generated code\n#include \"user_processor_base_class.h\"\n//End of 'OS includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOS Function OS\n//@{\n///        \\page dxpOS\n//@{\n///    \\brief OS function model start\nclass cfm_os: public cf_core::cf_function {\npublic:\n\t/// cfm_os type define start\n\n\t/// cfm_os type define end\n\n\t/// constructor\n\tcfm_os(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_os(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OS local declarations' algorithm generated code\n\tcf_core::cf_cp_selection<cf_core::cf_processor>* sel_processor;\n\t//End of 'OS local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OS function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OS', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_os\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_os.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_os\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OS definitions' algorithm generated code\n\n//End of 'OS definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_os::cfm_os(sc_core::sc_module_name name) :\n\t\tcf_function(name) {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OS constructor' algorithm generated code\n\n\t//End of 'OS constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_os::~cfm_os(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OS destructor' algorithm generated code\n\tdelete sel_processor;\n\t//End of 'OS destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_os::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OS pre elaboration' algorithm generated code\n\n\t//End of 'OS pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_os::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OS post elaboration' algorithm generated code\n\n\t//End of 'OS post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_os::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OS post simulation' algorithm generated code\n\n\t//End of 'OS post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_os::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_os::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OS initializations' algorithm generated code\n\n\t//End of 'OS initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'datacenter', 'models': [{'name': 'ServerRoom', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'DataCenterSwitch', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQToDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_datacenter\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER\n#define COFS_MODEL_DATACENTER\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_datacenter_dp_if.h\"\n#include \"cfm_datacenterswitch.h\"\n#include \"cfm_serverroom.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'datacenter includes' algorithm generated code\n#include <chrono>\n//End of 'datacenter includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgdatacenter Function datacenter\n//@{\n///        \\page dxpdatacenter\n//@{\n///    \\brief datacenter function model start\nclass cfm_datacenter: public cf_core::cf_application,\n\t\tpublic cfm_datacenter_dp_if {\npublic:\n\t/// cfm_datacenter type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToDataCenterSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToServerRoom_t;\n\n\t/// cfm_datacenter type define end\n\n\t/// constructor\n\tcfm_datacenter(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_datacenter(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_datacenterswitch* DataCenterSwitch;\n\tstd::vector<cfm_serverroom*> ServerRoom_vec;\n\t//@}\n\npublic:\n\t/// Overload function for mq_MsgQToDataCenterSwitch message queue send time\n\tcf_dt::cf_duration mq_MsgQToDataCenterSwitch_cb_send_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToDataCenterSwitch message queue receive time\n\tcf_dt::cf_duration mq_MsgQToDataCenterSwitch_cb_receive_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToServerRoom message queue send time\n\tcf_dt::cf_duration mq_MsgQToServerRoom_cb_send_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToServerRoom message queue receive time\n\tcf_dt::cf_duration mq_MsgQToServerRoom_cb_receive_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_MsgQToDataCenterSwitch_t*> mq_MsgQToDataCenterSwitch_vec;\n\tstd::vector<mq_MsgQToServerRoom_t*> mq_MsgQToServerRoom_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'datacenter local declarations' algorithm generated code\n\tstd::chrono::high_resolution_clock::time_point t_start;\n\t//End of 'datacenter local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief datacenter function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'datacenter', 'models': [{'name': 'ServerRoom', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'DataCenterSwitch', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQToDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_datacenter\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_datacenter.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'datacenter definitions' algorithm generated code\nvoid merge_and_sort_vector(std::vector<cf_dt::cf_time>& vect1,\n\t\tstd::vector<cf_dt::cf_time>& vect2) {\n\tvect1.insert(vect1.begin(), vect2.begin(), vect2.end());\n}\n//End of 'datacenter definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_datacenter::cfm_datacenter(sc_core::sc_module_name name) :\n\t\tcf_application(name), cfm_datacenter_dp_if() {\n\tcf_application::init();\n\tDataCenterSwitch = new cfm_datacenterswitch(\"DataCenterSwitch\");\n\n\t// instantiation of ServerRoom_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_serverroom* module = new cfm_serverroom(\n\t\t\t\tcf_string(\"ServerRoom[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tServerRoom_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQToDataCenterSwitch_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tmq_MsgQToDataCenterSwitch_t* module = new mq_MsgQToDataCenterSwitch_t(\n\t\t\t\tcf_string(\"MsgQToDataCenterSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQToDataCenterSwitch_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQToServerRoom_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tmq_MsgQToServerRoom_t* module = new mq_MsgQToServerRoom_t(\n\t\t\t\tcf_string(\"MsgQToServerRoom[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQToServerRoom_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tfor (cf_count j = 0;\n\t\t\t\tj\n\t\t\t\t\t\t< (cf_count) DataCenterSwitch->p_mq_MsgQToDataCenterSwitch_vec.size();\n\t\t\t\tj++) {\n\t\t\tcfm_datacenterswitch::p_mq_MsgQToDataCenterSwitch_t* port =\n\t\t\t\t\tDataCenterSwitch->p_mq_MsgQToDataCenterSwitch_vec[j];\n\t\t\tif (port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToDataCenterSwitch_vec[i]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tfor (cf_count j = 0;\n\t\t\t\tj\n\t\t\t\t\t\t< (cf_count) DataCenterSwitch->p_mq_MsgQToServerRoom_vec.size();\n\t\t\t\tj++) {\n\t\t\tcfm_datacenterswitch::p_mq_MsgQToServerRoom_t* port =\n\t\t\t\t\tDataCenterSwitch->p_mq_MsgQToServerRoom_vec[j];\n\t\t\tif (port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToServerRoom_vec[i]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_serverroom* module = ServerRoom_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToDataCenterSwitch(\n\t\t\t\t\t\tmq_MsgQToDataCenterSwitch_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToServerRoom(\n\t\t\t\t\t\tmq_MsgQToServerRoom_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'datacenter constructor' algorithm generated code\n\n\t//End of 'datacenter constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToDataCenterSwitch_vec[i]),\n\t\t\t\tcfm_datacenter::mq_MsgQToDataCenterSwitch_cb_send_time);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToDataCenterSwitch_vec[i]),\n\t\t\t\tcfm_datacenter::mq_MsgQToDataCenterSwitch_cb_receive_time);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToServerRoom_vec[i]),\n\t\t\t\tcfm_datacenter::mq_MsgQToServerRoom_cb_send_time);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToServerRoom_vec[i]),\n\t\t\t\tcfm_datacenter::mq_MsgQToServerRoom_cb_receive_time);\n\t}\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_datacenter::~cfm_datacenter(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'datacenter destructor' algorithm generated code\n\n\t//End of 'datacenter destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_serverroom*>::const_iterator vi = ServerRoom_vec.begin();\n\t\t\tvi != ServerRoom_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToDataCenterSwitch_t*>::const_iterator vi =\n\t\t\tmq_MsgQToDataCenterSwitch_vec.begin();\n\t\t\tvi != mq_MsgQToDataCenterSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToServerRoom_t*>::const_iterator vi =\n\t\t\tmq_MsgQToServerRoom_vec.begin();\n\t\t\tvi != mq_MsgQToServerRoom_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete DataCenterSwitch;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_datacenter::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'datacenter pre elaboration' algorithm generated code\n\n\t//End of 'datacenter pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_datacenter::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'datacenter post elaboration' algorithm generated code\n// Start chrono\n\tt_start = std::chrono::high_resolution_clock::now();\n//End of 'datacenter post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_datacenter::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'datacenter post simulation' algorithm generated code\n\t// End chrono except for controller (controller already measures execution time)\n#ifndef COF_LSS_CONTROLLER\n\tstd::chrono::high_resolution_clock::time_point t_end =\n\t\t\tstd::chrono::high_resolution_clock::now();\n\tstd::chrono::duration<double> time_span = std::chrono::duration_cast\n\t\t\t< std::chrono::duration<double> > (t_end - t_start);\n\tcf_mon_ostream << \"Wall-clock simulation time: \" << time_span.count()\n\t\t\t<< \" sec\" << cf_mon_endl;\n#endif\n\n\t// Create map for chart\n\tstd::map<int, int> graph;\n\t// Need dp for it\n\tfor (auto it : producer_exec_time) {\n\t\t//cf_trace_report(\"time %s\", it.to_c_str());\n\t\tint t = (int) it.to_scalar(CF_NS) / 100;\n\t\tauto s = graph.find(t);\n\t\tif (s != graph.end())\n\t\t\ts->second = s->second + 1;\n\t\telse\n\t\t\tgraph.insert(std::pair<int, int>(t, 1));\n\t}\n\n\tfor (auto it : graph) {\n\t\t//cf_trace_report(\"key %d value %d\", it.first, it.second);\n\t\t// create graph point\n\t\tcf_trace_gui_f_x(\"latency\", \"nb_func\", it.first, it.second);\n\t}\n\n\t// Display simulation result\n\t// Transaction counts\n\tcf_trace_report(\"Total number of transaction sent is %d\",\n\t\t\ttotal_requests_sent);\n\tcf_trace_report(\"Transaction number routed by ToR switches : %d\",\n\t\t\tnb_trans_routed_by_ToR_Switch);\n\tcf_trace_report(\"Transaction number routed by AGG switches : %d\",\n\t\t\tnb_trans_routed_by_AGG_Switch);\n\tcf_trace_report(\"Transaction number routed by Data Center switch : %d\",\n\t\t\tnb_trans_routed_by_Data_Center_Switch);\n\tcf_trace_report(\"Total number of transaction received is %d\",\n\t\t\ttotal_requests_received);\n\n\t// controller and sequential simulation \n#if defined(COF_LSS_CONTROLLER) || !defined(COF_LSS)\n\n\tcf_trace_report(\n\t\t\t\"Assert number of requests sent and received are the same.\");\n\tcf_assert((total_requests_sent == total_requests_received),\n\t\t\t\"Post-Simulation\", CF_ERROR_USER_ASSERT,\n\t\t\t\"The number of transactions received (%d) is not the same as the number of transactions sent (%d). \\nIncrease simulation time to get full simulation results.\",\n\t\t\ttotal_requests_received, total_requests_sent);\n\n\t// Transaction rate\n\tcf_trace_report(\"Rate of outside server room transaction is %.2f \",\n\t\t\t((float) nb_trans_routed_by_Data_Center_Switch\n\t\t\t\t\t/ total_requests_received) * 100);\n\tcf_trace_report(\"Rate of outside rack transaction is %.2f \",\n\t\t\t((float) (nb_trans_routed_by_AGG_Switch\n\t\t\t\t\t- (nb_trans_routed_by_Data_Center_Switch))\n\t\t\t\t\t/ total_requests_received) * 100);\n\t// Display simulation_duration\n\tcf_trace_report(\"simulation_duration %s\", simulation_duration.to_string());\n\t// Display switches load \n\tdata_center_switch_load = (data_center_switch_running_time.to_scalar(CF_MS)\n\t\t\t* 100) / simulation_duration.to_scalar(CF_MS);\n\tcf_trace_report(\"Data center switch load = %.2f%%\",\n\t\t\tdata_center_switch_load);\n\tagg_switch_load = ((agg_switch_running_time.to_scalar(CF_MS) * 100)\n\t\t\t/ simulation_duration.to_scalar(CF_MS)) / (dpServerRoomNb + 1);\n\tcf_trace_report(\"Agg switch average load = %.2f%%\", agg_switch_load);\n\ttor_switch_load = ((tor_switch_running_time.to_scalar(CF_MS) * 100)\n\t\t\t/ simulation_duration.to_scalar(CF_MS))\n\t\t\t/ ((dpServerRoomNb + 1) * (dpRackNb + 1));\n\tcf_trace_report(\"ToR switch average load = %.2f%%\", tor_switch_load);\n\n\t// Latencies\n\t// Update average latency\t\t\n\taverage_latency = total_latency / ((double) total_requests_received);\n\tcf_trace_report(\"Average latency = %.0f ns\",\n\t\t\taverage_latency.to_scalar(CF_NS));\n\tintra_rack_average_latency = intra_rack_total_latency\n\t\t\t/ ((double) intra_rack_total_requests_received);\n\tcf_trace_report(\"Intra rack requests average latency = %.0f ns\",\n\t\t\tintra_rack_average_latency.to_scalar(CF_NS));\n\tintra_server_room_average_latency = intra_server_room_total_latency\n\t\t\t/ ((double) intra_server_room_total_requests_received);\n\tcf_trace_report(\"Intra server room requests average latency = %.0f ns\",\n\t\t\tintra_server_room_average_latency.to_scalar(CF_NS));\n\toutside_server_room_average_latency = outside_server_room_total_latency\n\t\t\t/ ((double) outside_server_room_total_requests_received);\n\tcf_trace_report(\"Outside server room requests average latency = %.0f ns\",\n\t\t\toutside_server_room_average_latency.to_scalar(CF_NS));\n\n#endif\n\t//End of 'datacenter post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_datacenter::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_concurrency.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToDataCenterSwitch_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_concurrency.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServerRoom_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_datacenter::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'datacenter initializations' algorithm generated code\n\t// Init variables used to generate transaction rate\n\tmin_waiting_time = 1000000000\n\t\t\t/ (dpTransactionRate + dpTransactionRateInterval);\n\tmax_waiting_time = 1000000000\n\t\t\t/ (dpTransactionRate - dpTransactionRateInterval);\n\n\t// Init variables used to count transaction\n\tnb_trans_routed_by_ToR_Switch = 0;\n\tnb_trans_routed_by_AGG_Switch = 0;\n\tnb_trans_routed_by_Data_Center_Switch = 0;\n\n\t// Init variables used to compute latency\n\ttotal_latency = cf_dt::cf_time(0, CF_SEC);\n\taverage_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_rack_total_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_rack_average_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);\n\tintra_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);\n\toutside_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);\n\toutside_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);\n\n\t// Init variables used to compute requests number\n\t/*total_requests_sent = (dpServerRoomNb + 1) * (dpRackNb + 1)\n\t * (dpServerPerRackNb + 1) * dpNbTransPerServer;*/\n\ttotal_requests_received = 0;\n\tintra_rack_total_requests_received = 0;\n\tintra_server_room_total_requests_received = 0;\n\n\t// Variables used to compute switches loads\n\tsimulation_duration = cf_dt::cf_time(0, CF_SEC);\n\tdata_center_switch_running_time = cf_dt::cf_time(0, CF_SEC);\n\tdata_center_switch_load = 0;\n\tagg_switch_running_time = cf_dt::cf_time(0, CF_SEC);\n\tagg_switch_load = 0;\n\ttor_switch_running_time = cf_dt::cf_time(0, CF_SEC);\n\ttor_switch_load = 0;\n\t//End of 'datacenter initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for mq_MsgQToDataCenterSwitch message queue send time\n//@{\ncf_duration cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_send_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToDataCenterSwitch_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN\n\treturn cf_expr_duration(dpServerRoomToDataCenterTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToDataCenterSwitch message queue receive time\n//@{\ncf_duration cfm_datacenter::mq_MsgQToDataCenterSwitch_cb_receive_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToDataCenterSwitch_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(dpServerRoomToDataCenterTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToServerRoom message queue send time\n//@{\ncf_duration cfm_datacenter::mq_MsgQToServerRoom_cb_send_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServerRoom_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN\n\treturn cf_expr_duration(dpDataCenterToServerRoomTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToServerRoom message queue receive time\n//@{\ncf_duration cfm_datacenter::mq_MsgQToServerRoom_cb_receive_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServerRoom_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(dpDataCenterToServerRoomTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ServerRoom', 'type': 'cofluent:Function', 'models': [{'name': 'AGGSwitch', 'type': 'cofluent:Function'}, {'name': 'Rack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}], 'relations': [{'name': 'MsgQToAggSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}, {'name': 'MsgQToRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_serverroom\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_SERVERROOM\n#define COFS_MODEL_DATACENTER_SERVERROOM\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_serverroom_dp_if.h\"\n#include \"cfm_aggswitch.h\"\n#include \"cfm_rack.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ServerRoom includes' algorithm generated code\n\n//End of 'ServerRoom includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgServerRoom Function ServerRoom\n//@{\n///        \\page dxpServerRoom\n//@{\n///    \\brief ServerRoom function model start\nclass cfm_serverroom: public cf_core::cf_function_container,\n\t\tpublic cfm_serverroom_dp_if {\npublic:\n\t/// cfm_serverroom type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToAggSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToRack_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_serverroom, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_serverroom, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\t/// cfm_serverroom type define end\n\n\t/// constructor\n\tcfm_serverroom(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_serverroom(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_aggswitch* AGGSwitch;\n\tstd::vector<cfm_rack*> Rack_vec;\n\t//@}\n\npublic:\n\t/// Overload function for mq_MsgQToAggSwitch message queue send time\n\tcf_dt::cf_duration mq_MsgQToAggSwitch_cb_send_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToAggSwitch message queue receive time\n\tcf_dt::cf_duration mq_MsgQToAggSwitch_cb_receive_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToRack message queue send time\n\tcf_dt::cf_duration mq_MsgQToRack_cb_send_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToRack message queue receive time\n\tcf_dt::cf_duration mq_MsgQToRack_cb_receive_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_MsgQToAggSwitch_t*> mq_MsgQToAggSwitch_vec;\n\tstd::vector<mq_MsgQToRack_t*> mq_MsgQToRack_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ServerRoom local declarations' algorithm generated code\n\n\t//End of 'ServerRoom local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ServerRoom function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_SERVERROOM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ServerRoom', 'type': 'cofluent:Function', 'models': [{'name': 'AGGSwitch', 'type': 'cofluent:Function'}, {'name': 'Rack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}], 'relations': [{'name': 'MsgQToAggSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}, {'name': 'MsgQToRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_serverroom\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_serverroom.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenter\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_serverroom\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ServerRoom definitions' algorithm generated code\n\n//End of 'ServerRoom definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_serverroom::cfm_serverroom(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_serverroom_dp_if(), p_mq_MsgQToDataCenterSwitch(\n\t\t\t\t\"p_mq_MsgQToDataCenterSwitch\"), p_mq_MsgQToServerRoom(\n\t\t\t\t\"p_mq_MsgQToServerRoom\") {\n\tcf_function_container::init();\n\tAGGSwitch = new cfm_aggswitch(\"AGGSwitch\");\n\n\t// instantiation of Rack_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_rack* module = new cfm_rack(cf_string(\"Rack[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tRack_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQToAggSwitch_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tmq_MsgQToAggSwitch_t* module = new mq_MsgQToAggSwitch_t(\n\t\t\t\tcf_string(\"MsgQToAggSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQToAggSwitch_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQToRack_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tmq_MsgQToRack_t* module = new mq_MsgQToRack_t(\n\t\t\t\tcf_string(\"MsgQToRack[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQToRack_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tfor (cf_count j = 0;\n\t\t\t\tj < (cf_count) AGGSwitch->p_mq_MsgQToAggSwitch_vec.size();\n\t\t\t\tj++) {\n\t\t\tcfm_aggswitch::p_mq_MsgQToAggSwitch_t* port =\n\t\t\t\t\tAGGSwitch->p_mq_MsgQToAggSwitch_vec[j];\n\t\t\tif (port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToAggSwitch_vec[i]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tfor (cf_count j = 0;\n\t\t\t\tj < (cf_count) AGGSwitch->p_mq_MsgQToRack_vec.size(); j++) {\n\t\t\tcfm_aggswitch::p_mq_MsgQToRack_t* port =\n\t\t\t\t\tAGGSwitch->p_mq_MsgQToRack_vec[j];\n\t\t\tif (port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToRack_vec[i]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\tAGGSwitch->p_mq_MsgQToServerRoom(p_mq_MsgQToServerRoom);\n\tAGGSwitch->p_mq_MsgQToDataCenterSwitch(p_mq_MsgQToDataCenterSwitch);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_rack* module = Rack_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToRack(mq_MsgQToRack_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToAggSwitch(\n\t\t\t\t\t\tmq_MsgQToAggSwitch_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ServerRoom constructor' algorithm generated code\n\n\t//End of 'ServerRoom constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToAggSwitch_vec[i]),\n\t\t\t\tcfm_serverroom::mq_MsgQToAggSwitch_cb_send_time);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToAggSwitch_vec[i]),\n\t\t\t\tcfm_serverroom::mq_MsgQToAggSwitch_cb_receive_time);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToRack_vec[i]),\n\t\t\t\tcfm_serverroom::mq_MsgQToRack_cb_send_time);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToRack_vec[i]),\n\t\t\t\tcfm_serverroom::mq_MsgQToRack_cb_receive_time);\n\t}\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_serverroom::~cfm_serverroom(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ServerRoom destructor' algorithm generated code\n\n\t//End of 'ServerRoom destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_rack*>::const_iterator vi = Rack_vec.begin();\n\t\t\tvi != Rack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToAggSwitch_t*>::const_iterator vi =\n\t\t\tmq_MsgQToAggSwitch_vec.begin(); vi != mq_MsgQToAggSwitch_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToRack_t*>::const_iterator vi =\n\t\t\tmq_MsgQToRack_vec.begin(); vi != mq_MsgQToRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete AGGSwitch;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_serverroom::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ServerRoom pre elaboration' algorithm generated code\n\n\t//End of 'ServerRoom pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_serverroom::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ServerRoom post elaboration' algorithm generated code\n\n\t//End of 'ServerRoom post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_serverroom::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ServerRoom post simulation' algorithm generated code\n\n\t//End of 'ServerRoom post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_serverroom::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQToAggSwitch_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQToRack_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToRack_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_serverroom::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ServerRoom initializations' algorithm generated code\n\n\t//End of 'ServerRoom initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for mq_MsgQToAggSwitch message queue send time\n//@{\ncf_duration cfm_serverroom::mq_MsgQToAggSwitch_cb_send_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToAggSwitch_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN\n\treturn cf_expr_duration(dpRackToSwitchTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToAggSwitch message queue receive time\n//@{\ncf_duration cfm_serverroom::mq_MsgQToAggSwitch_cb_receive_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToAggSwitch_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(dpRackToSwitchTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToRack message queue send time\n//@{\ncf_duration cfm_serverroom::mq_MsgQToRack_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToRack_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN\n\treturn cf_expr_duration(dpSwitchToRackTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToRack message queue receive time\n//@{\ncf_duration cfm_serverroom::mq_MsgQToRack_cb_receive_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToRack_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(dpSwitchToRackTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DataCenterSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'Inbound', 'type': 'cofluent:Function'}, {'name': 'Outbound', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Inbound']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Outbound']}], 'relations': [{'name': 'MsgQRouting_out', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Outbound', 'RoutingFunction']}, {'name': 'MsgQRouting_in', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Inbound', 'RoutingFunction']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_datacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_DATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_DATACENTERSWITCH\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_datacenterswitch_dp_if.h\"\n#include \"cfm_datacenterswitch_routingfunction.h\"\n#include \"cfm_inbound.h\"\n#include \"cfm_outbound.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DataCenterSwitch includes' algorithm generated code\n\n//End of 'DataCenterSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDataCenterSwitch Function DataCenterSwitch\n//@{\n///        \\page dxpDataCenterSwitch\n//@{\n///    \\brief DataCenterSwitch function model start\nclass cfm_datacenterswitch: public cf_core::cf_function_container,\n\t\tpublic cfm_datacenterswitch_dp_if {\npublic:\n\t/// cfm_datacenterswitch type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQRouting_in_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQRouting_out_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_datacenterswitch, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_datacenterswitch, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\t/// cfm_datacenterswitch type define end\n\n\t/// constructor\n\tcfm_datacenterswitch(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_datacenterswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tstd::vector<p_mq_MsgQToDataCenterSwitch_t*> p_mq_MsgQToDataCenterSwitch_vec;\n\tstd::vector<p_mq_MsgQToServerRoom_t*> p_mq_MsgQToServerRoom_vec;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_inbound*> Inbound_vec;\n\tstd::vector<cfm_outbound*> Outbound_vec;\n\tcfm_datacenterswitch_routingfunction* RoutingFunction;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_MsgQRouting_in_t*> mq_MsgQRouting_in_vec;\n\tstd::vector<mq_MsgQRouting_out_t*> mq_MsgQRouting_out_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DataCenterSwitch local declarations' algorithm generated code\n\n\t//End of 'DataCenterSwitch local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief DataCenterSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_DATACENTERSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DataCenterSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'Inbound', 'type': 'cofluent:Function'}, {'name': 'Outbound', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Inbound']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Outbound']}], 'relations': [{'name': 'MsgQRouting_out', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Outbound', 'RoutingFunction']}, {'name': 'MsgQRouting_in', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Inbound', 'RoutingFunction']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_datacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_datacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenter\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_datacenterswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'DataCenterSwitch definitions' algorithm generated code\n\n//End of 'DataCenterSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_datacenterswitch::cfm_datacenterswitch(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_datacenterswitch_dp_if() {\n\tcf_function_container::init();\n\tRoutingFunction = new cfm_datacenterswitch_routingfunction(\n\t\t\t\"RoutingFunction\");\n\n\t// instantiation of Inbound_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_inbound* module = new cfm_inbound(\n\t\t\t\tcf_string(\"Inbound[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tInbound_vec.push_back(module);\n\t}\n\t// instantiation of Outbound_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_outbound* module = new cfm_outbound(\n\t\t\t\tcf_string(\"Outbound[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tOutbound_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQRouting_in_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tmq_MsgQRouting_in_t* module = new mq_MsgQRouting_in_t(\n\t\t\t\tcf_string(\"MsgQRouting_in[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQRouting_in_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQRouting_out_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tmq_MsgQRouting_out_t* module = new mq_MsgQRouting_out_t(\n\t\t\t\tcf_string(\"MsgQRouting_out[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQRouting_out_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_MsgQToDataCenterSwitch_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tp_mq_MsgQToDataCenterSwitch_t* module =\n\t\t\t\tnew p_mq_MsgQToDataCenterSwitch_t(\n\t\t\t\t\t\tcf_string(\"p_mq_MsgQToDataCenterSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_MsgQToDataCenterSwitch_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_MsgQToServerRoom_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tp_mq_MsgQToServerRoom_t* module = new p_mq_MsgQToServerRoom_t(\n\t\t\t\tcf_string(\"p_mq_MsgQToServerRoom[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_MsgQToServerRoom_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_inbound* module = Inbound_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQRouting_in(\n\t\t\t\t\t\tmq_MsgQRouting_in_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tmodule->p_mq_MsgQToDataCenterSwitch(\n\t\t\t\t\t(*p_mq_MsgQToDataCenterSwitch_vec[i]));\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tcfm_outbound* module = Outbound_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tmodule->p_mq_MsgQToServerRoom((*p_mq_MsgQToServerRoom_vec[i]));\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQRouting_out(\n\t\t\t\t\t\tmq_MsgQRouting_out_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQRouting_in(\n\t\t\t\tmq_MsgQRouting_in_vec[i]->p_target_socket);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQRouting_out(\n\t\t\t\tmq_MsgQRouting_out_vec[i]->p_target_socket);\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DataCenterSwitch constructor' algorithm generated code\n\n\t//End of 'DataCenterSwitch constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_datacenterswitch::~cfm_datacenterswitch(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DataCenterSwitch destructor' algorithm generated code\n\n\t//End of 'DataCenterSwitch destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_inbound*>::const_iterator vi = Inbound_vec.begin();\n\t\t\tvi != Inbound_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_outbound*>::const_iterator vi = Outbound_vec.begin();\n\t\t\tvi != Outbound_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQRouting_in_t*>::const_iterator vi =\n\t\t\tmq_MsgQRouting_in_vec.begin(); vi != mq_MsgQRouting_in_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQRouting_out_t*>::const_iterator vi =\n\t\t\tmq_MsgQRouting_out_vec.begin(); vi != mq_MsgQRouting_out_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToDataCenterSwitch_t*>::const_iterator vi =\n\t\t\tp_mq_MsgQToDataCenterSwitch_vec.begin();\n\t\t\tvi != p_mq_MsgQToDataCenterSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToServerRoom_t*>::const_iterator vi =\n\t\t\tp_mq_MsgQToServerRoom_vec.begin();\n\t\t\tvi != p_mq_MsgQToServerRoom_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete RoutingFunction;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_datacenterswitch::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DataCenterSwitch pre elaboration' algorithm generated code\n\n\t//End of 'DataCenterSwitch pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_datacenterswitch::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DataCenterSwitch post elaboration' algorithm generated code\n\n\t//End of 'DataCenterSwitch post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_datacenterswitch::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DataCenterSwitch post simulation' algorithm generated code\n\n\t//End of 'DataCenterSwitch post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_datacenterswitch::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpDataCenterSwitchPortBufferSize);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_in_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpDataCenterSwitchPortBufferSize);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQRouting_out_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_datacenterswitch::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'DataCenterSwitch initializations' algorithm generated code\n\n\t//End of 'DataCenterSwitch initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'AGGSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundRack', 'type': 'cofluent:Function'}, {'name': 'OutboundRack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundRack']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundRack']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundDataCenterSwitch']}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundDataCenterSwitch']}], 'relations': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundDataCenterSwitch']}, {'name': 'MsgQOutboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundRack']}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundDataCenterSwitch']}, {'name': 'MsgQInboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundRack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_aggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_AGGSWITCH\n#define COFS_MODEL_DATACENTER_AGGSWITCH\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_aggswitch_dp_if.h\"\n#include \"cfm_aggswitch_routingfunction.h\"\n#include \"cfm_inbounddatacenterswitch.h\"\n#include \"cfm_inboundrack.h\"\n#include \"cfm_outbounddatacenterswitch.h\"\n#include \"cfm_outboundrack.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'AGGSwitch includes' algorithm generated code\n\n//End of 'AGGSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgAGGSwitch Function AGGSwitch\n//@{\n///        \\page dxpAGGSwitch\n//@{\n///    \\brief AGGSwitch function model start\nclass cfm_aggswitch: public cf_core::cf_function_container,\n\t\tpublic cfm_aggswitch_dp_if {\npublic:\n\t/// cfm_aggswitch type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundDataCenterSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundRack_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundDataCenterSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundRack_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\t/// cfm_aggswitch type define end\n\n\t/// constructor\n\tcfm_aggswitch(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_aggswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tstd::vector<p_mq_MsgQToAggSwitch_t*> p_mq_MsgQToAggSwitch_vec;\n\tstd::vector<p_mq_MsgQToRack_t*> p_mq_MsgQToRack_vec;\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_inbounddatacenterswitch* InboundDataCenterSwitch;\n\tstd::vector<cfm_inboundrack*> InboundRack_vec;\n\tcfm_outbounddatacenterswitch* OutboundDataCenterSwitch;\n\tstd::vector<cfm_outboundrack*> OutboundRack_vec;\n\tcfm_aggswitch_routingfunction* RoutingFunction;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQInboundDataCenterSwitch_t mq_MsgQInboundDataCenterSwitch;\n\tstd::vector<mq_MsgQInboundRack_t*> mq_MsgQInboundRack_vec;\n\tmq_MsgQOutboundDataCenterSwitch_t mq_MsgQOutboundDataCenterSwitch;\n\tstd::vector<mq_MsgQOutboundRack_t*> mq_MsgQOutboundRack_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AGGSwitch local declarations' algorithm generated code\n\n\t//End of 'AGGSwitch local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief AGGSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_AGGSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'AGGSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundRack', 'type': 'cofluent:Function'}, {'name': 'OutboundRack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundRack']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundRack']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundDataCenterSwitch']}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundDataCenterSwitch']}], 'relations': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundDataCenterSwitch']}, {'name': 'MsgQOutboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundRack']}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundDataCenterSwitch']}, {'name': 'MsgQInboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundRack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_aggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_aggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_serverroom\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_aggswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'AGGSwitch definitions' algorithm generated code\n\n//End of 'AGGSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_aggswitch::cfm_aggswitch(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_aggswitch_dp_if(), p_mq_MsgQToServerRoom(\n\t\t\t\t\"p_mq_MsgQToServerRoom\"), p_mq_MsgQToDataCenterSwitch(\n\t\t\t\t\"p_mq_MsgQToDataCenterSwitch\"), mq_MsgQInboundDataCenterSwitch(\n\t\t\t\t\"MsgQInboundDataCenterSwitch\"), mq_MsgQOutboundDataCenterSwitch(\n\t\t\t\t\"MsgQOutboundDataCenterSwitch\") {\n\tcf_function_container::init();\n\tInboundDataCenterSwitch = new cfm_inbounddatacenterswitch(\n\t\t\t\"InboundDataCenterSwitch\");\n\tOutboundDataCenterSwitch = new cfm_outbounddatacenterswitch(\n\t\t\t\"OutboundDataCenterSwitch\");\n\tRoutingFunction = new cfm_aggswitch_routingfunction(\"RoutingFunction\");\n\n\t// instantiation of InboundRack_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_inboundrack* module = new cfm_inboundrack(\n\t\t\t\tcf_string(\"InboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tInboundRack_vec.push_back(module);\n\t}\n\t// instantiation of OutboundRack_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_outboundrack* module = new cfm_outboundrack(\n\t\t\t\tcf_string(\"OutboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tOutboundRack_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQInboundRack_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tmq_MsgQInboundRack_t* module = new mq_MsgQInboundRack_t(\n\t\t\t\tcf_string(\"MsgQInboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQInboundRack_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQOutboundRack_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tmq_MsgQOutboundRack_t* module = new mq_MsgQOutboundRack_t(\n\t\t\t\tcf_string(\"MsgQOutboundRack[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQOutboundRack_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_MsgQToAggSwitch_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tp_mq_MsgQToAggSwitch_t* module = new p_mq_MsgQToAggSwitch_t(\n\t\t\t\tcf_string(\"p_mq_MsgQToAggSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_MsgQToAggSwitch_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_MsgQToRack_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tp_mq_MsgQToRack_t* module = new p_mq_MsgQToRack_t(\n\t\t\t\tcf_string(\"p_mq_MsgQToRack[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_MsgQToRack_vec.push_back(module);\n\t}\n\t// connections\n\tInboundDataCenterSwitch->p_mq_MsgQToServerRoom(p_mq_MsgQToServerRoom);\n\tInboundDataCenterSwitch->p_mq_MsgQInboundDataCenterSwitch(\n\t\t\tmq_MsgQInboundDataCenterSwitch.p_target_socket);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_inboundrack* module = InboundRack_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQInboundRack(\n\t\t\t\t\t\tmq_MsgQInboundRack_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tmodule->p_mq_MsgQToAggSwitch((*p_mq_MsgQToAggSwitch_vec[i]));\n\t\t}\n\t}\n\n\tOutboundDataCenterSwitch->p_mq_MsgQOutboundDataCenterSwitch(\n\t\t\tmq_MsgQOutboundDataCenterSwitch.p_target_socket);\n\tOutboundDataCenterSwitch->p_mq_MsgQToDataCenterSwitch(\n\t\t\tp_mq_MsgQToDataCenterSwitch);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tcfm_outboundrack* module = OutboundRack_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tmodule->p_mq_MsgQToRack((*p_mq_MsgQToRack_vec[i]));\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQOutboundRack(\n\t\t\t\t\t\tmq_MsgQOutboundRack_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQInboundRack(\n\t\t\t\tmq_MsgQInboundRack_vec[i]->p_target_socket);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQOutboundRack(\n\t\t\t\tmq_MsgQOutboundRack_vec[i]->p_target_socket);\n\t}\n\tRoutingFunction->p_mq_MsgQInboundDataCenterSwitch(\n\t\t\tmq_MsgQInboundDataCenterSwitch.p_target_socket);\n\tRoutingFunction->p_mq_MsgQOutboundDataCenterSwitch(\n\t\t\tmq_MsgQOutboundDataCenterSwitch.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AGGSwitch constructor' algorithm generated code\n\n\t//End of 'AGGSwitch constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_aggswitch::~cfm_aggswitch(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AGGSwitch destructor' algorithm generated code\n\n\t//End of 'AGGSwitch destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_inboundrack*>::const_iterator vi = InboundRack_vec.begin();\n\t\t\tvi != InboundRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_outboundrack*>::const_iterator vi =\n\t\t\tOutboundRack_vec.begin(); vi != OutboundRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQInboundRack_t*>::const_iterator vi =\n\t\t\tmq_MsgQInboundRack_vec.begin(); vi != mq_MsgQInboundRack_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQOutboundRack_t*>::const_iterator vi =\n\t\t\tmq_MsgQOutboundRack_vec.begin();\n\t\t\tvi != mq_MsgQOutboundRack_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToAggSwitch_t*>::const_iterator vi =\n\t\t\tp_mq_MsgQToAggSwitch_vec.begin();\n\t\t\tvi != p_mq_MsgQToAggSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToRack_t*>::const_iterator vi =\n\t\t\tp_mq_MsgQToRack_vec.begin(); vi != p_mq_MsgQToRack_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete InboundDataCenterSwitch;\n\tdelete OutboundDataCenterSwitch;\n\tdelete RoutingFunction;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_aggswitch::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AGGSwitch pre elaboration' algorithm generated code\n\n\t//End of 'AGGSwitch pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_aggswitch::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AGGSwitch post elaboration' algorithm generated code\n\n\t//End of 'AGGSwitch post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_aggswitch::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AGGSwitch post simulation' algorithm generated code\n\n\t//End of 'AGGSwitch post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_aggswitch::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tmq_MsgQInboundDataCenterSwitch.cfa_send_time.init(\n\t\t\tcf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundDataCenterSwitch.cfa_receive_time.init(\n\t\t\tcf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundDataCenterSwitch.cfa_queue_policy.init(\n\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQInboundDataCenterSwitch.cfa_queue_capacity.init(\n\t\t\t(cf_nonzero_count) dpAggSwitchPortBufferSize);\n\tmq_MsgQInboundDataCenterSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQInboundDataCenterSwitch.cfa_send_threshold.init(\n\t\t\t(cf_nonzero_count) 1);\n\tmq_MsgQInboundDataCenterSwitch.cfa_receive_threshold.init(\n\t\t\t(cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpAggSwitchPortBufferSize);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundRack_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\tmq_MsgQOutboundDataCenterSwitch.cfa_send_time.init(\n\t\t\tcf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundDataCenterSwitch.cfa_receive_time.init(\n\t\t\tcf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundDataCenterSwitch.cfa_queue_policy.init(\n\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_queue_capacity.init(\n\t\t\t(cf_nonzero_count) dpAggSwitchPortBufferSize);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_send_threshold.init(\n\t\t\t(cf_nonzero_count) 1);\n\tmq_MsgQOutboundDataCenterSwitch.cfa_receive_threshold.init(\n\t\t\t(cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpAggSwitchPortBufferSize);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_concurrency.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundRack_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_aggswitch::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'AGGSwitch initializations' algorithm generated code\n\n\t//End of 'AGGSwitch initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Rack', 'type': 'cofluent:Function', 'models': [{'name': 'Server', 'type': 'cofluent:Function'}, {'name': 'ToRSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}], 'relations': [{'name': 'MsgQServerToToRSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}, {'name': 'MsgQToServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_RACK\n#define COFS_MODEL_DATACENTER_RACK\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rack_dp_if.h\"\n#include \"cfm_server.h\"\n#include \"cfm_torswitch.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Rack includes' algorithm generated code\n\n//End of 'Rack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRack Function Rack\n//@{\n///        \\page dxpRack\n//@{\n///    \\brief Rack function model start\nclass cfm_rack: public cf_core::cf_function_container, public cfm_rack_dp_if {\npublic:\n\t/// cfm_rack type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQServerToToRSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToServer_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rack, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rack, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\t/// cfm_rack type define end\n\n\t/// constructor\n\tcfm_rack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_server*> Server_vec;\n\tcfm_torswitch* ToRSwitch;\n\t//@}\n\npublic:\n\t/// Overload function for mq_MsgQServerToToRSwitch message queue receive time\n\tcf_dt::cf_duration mq_MsgQServerToToRSwitch_cb_receive_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToServer message queue send time\n\tcf_dt::cf_duration mq_MsgQToServer_cb_send_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\t/// Overload function for mq_MsgQToServer message queue receive time\n\tcf_dt::cf_duration mq_MsgQToServer_cb_receive_time(\n\t\t\tcf_core::cf_payload_b* _trans);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_MsgQServerToToRSwitch_t*> mq_MsgQServerToToRSwitch_vec;\n\tstd::vector<mq_MsgQToServer_t*> mq_MsgQToServer_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Rack local declarations' algorithm generated code\n\n\t//End of 'Rack local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Rack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_RACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Rack', 'type': 'cofluent:Function', 'models': [{'name': 'Server', 'type': 'cofluent:Function'}, {'name': 'ToRSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}], 'relations': [{'name': 'MsgQServerToToRSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}, {'name': 'MsgQToServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_serverroom\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Rack definitions' algorithm generated code\n\n//End of 'Rack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rack::cfm_rack(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_rack_dp_if(), p_mq_MsgQToRack(\n\t\t\t\t\"p_mq_MsgQToRack\"), p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\") {\n\tcf_function_container::init();\n\tToRSwitch = new cfm_torswitch(\"ToRSwitch\");\n\n\t// instantiation of Server_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_server* module = new cfm_server(cf_string(\"Server[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tServer_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQServerToToRSwitch_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tmq_MsgQServerToToRSwitch_t* module = new mq_MsgQServerToToRSwitch_t(\n\t\t\t\tcf_string(\"MsgQServerToToRSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQServerToToRSwitch_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQToServer_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tmq_MsgQToServer_t* module = new mq_MsgQToServer_t(\n\t\t\t\tcf_string(\"MsgQToServer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQToServer_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_server* module = Server_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQServerToToRSwitch(\n\t\t\t\t\t\tmq_MsgQServerToToRSwitch_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQToServer(\n\t\t\t\t\t\tmq_MsgQToServer_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tToRSwitch->p_mq_MsgQToRack(p_mq_MsgQToRack);\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tfor (cf_count j = 0;\n\t\t\t\tj < (cf_count) ToRSwitch->p_mq_MsgQServerToToRSwitch_vec.size();\n\t\t\t\tj++) {\n\t\t\tcfm_torswitch::p_mq_MsgQServerToToRSwitch_t* port =\n\t\t\t\t\tToRSwitch->p_mq_MsgQServerToToRSwitch_vec[j];\n\t\t\tif (port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQServerToToRSwitch_vec[i]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tfor (cf_count j = 0;\n\t\t\t\tj < (cf_count) ToRSwitch->p_mq_MsgQToServer_vec.size(); j++) {\n\t\t\tcfm_torswitch::p_mq_MsgQToServer_t* port =\n\t\t\t\t\tToRSwitch->p_mq_MsgQToServer_vec[j];\n\t\t\tif (port != nullptr) {\n\t\t\t\tport->bind(mq_MsgQToServer_vec[i]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\tToRSwitch->p_mq_MsgQToAggSwitch(p_mq_MsgQToAggSwitch);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Rack constructor' algorithm generated code\n\n\t//End of 'Rack constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQServerToToRSwitch_vec[i]),\n\t\t\t\tcfm_rack::mq_MsgQServerToToRSwitch_cb_receive_time);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tCF_COMM_CB_MQ_SEND((*mq_MsgQToServer_vec[i]),\n\t\t\t\tcfm_rack::mq_MsgQToServer_cb_send_time);\n\t\tCF_COMM_CB_MQ_RECEIVE((*mq_MsgQToServer_vec[i]),\n\t\t\t\tcfm_rack::mq_MsgQToServer_cb_receive_time);\n\t}\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rack::~cfm_rack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Rack destructor' algorithm generated code\n\n\t//End of 'Rack destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_server*>::const_iterator vi = Server_vec.begin();\n\t\t\tvi != Server_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQServerToToRSwitch_t*>::const_iterator vi =\n\t\t\tmq_MsgQServerToToRSwitch_vec.begin();\n\t\t\tvi != mq_MsgQServerToToRSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQToServer_t*>::const_iterator vi =\n\t\t\tmq_MsgQToServer_vec.begin(); vi != mq_MsgQToServer_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete ToRSwitch;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Rack pre elaboration' algorithm generated code\n\n\t//End of 'Rack pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Rack post elaboration' algorithm generated code\n\n\t//End of 'Rack post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Rack post simulation' algorithm generated code\n\n\t//End of 'Rack post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rack::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(0, CF_NS));\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpServerToToRSwitchBufferSize);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_concurrency.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQServerToToRSwitch_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQToServer_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpToRSwitchToServerBufferSize);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQToServer_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Rack initializations' algorithm generated code\n\n\t//End of 'Rack initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name Overload function for mq_MsgQServerToToRSwitch message queue receive time\n//@{\ncf_duration cfm_rack::mq_MsgQServerToToRSwitch_cb_receive_time(\n\t\tcf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQServerToToRSwitch_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(dpServerToToRSwitchTime, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToServer message queue send time\n//@{\ncf_duration cfm_rack::mq_MsgQToServer_cb_send_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServer_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_BEGIN\n\treturn cf_expr_duration(dpToRSwitchToServerTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_SEND_TIME_END\n}\n//@}\n/// \\name Overload function for mq_MsgQToServer message queue receive time\n//@{\ncf_duration cfm_rack::mq_MsgQToServer_cb_receive_time(cf_payload_b* _trans) {\n\tCF_COMM_DEF_TRANS_REF(cft_defpacket, MsgQToServer_trans, _trans);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_BEGIN\n\treturn cf_expr_duration(dpToRSwitchToServerTime / 2, CF_NS);\n\t//#COFS_MESSAGE_QUEUE_RECEIVE_TIME_END\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQRouting_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUND\n#define COFS_MODEL_DATACENTER_INBOUND\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inbound_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inbound includes' algorithm generated code\n\n//End of 'Inbound includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInbound Function Inbound\n//@{\n///        \\page dxpInbound\n//@{\n///    \\brief Inbound function model start\nclass cfm_inbound: public cf_core::cf_function, public cfm_inbound_dp_if {\npublic:\n\t/// cfm_inbound type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbound, cft_defpacket> p_mq_MsgQRouting_in_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbound, cft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\t/// cfm_inbound type define end\n\n\t/// constructor\n\tcfm_inbound(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inbound(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQRouting_in_t p_mq_MsgQRouting_in;\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inbound local declarations' algorithm generated code\n\n\t//End of 'Inbound local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Inbound function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQRouting_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inbound.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenterswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inbound\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inbound definitions' algorithm generated code\n\n//End of 'Inbound definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inbound::cfm_inbound(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_inbound_dp_if(), p_mq_MsgQRouting_in(\n\t\t\t\t\"p_mq_MsgQRouting_in\"), p_mq_MsgQToDataCenterSwitch(\n\t\t\t\t\"p_mq_MsgQToDataCenterSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inbound constructor' algorithm generated code\n\n\t//End of 'Inbound constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inbound::~cfm_inbound(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inbound destructor' algorithm generated code\n\n\t//End of 'Inbound destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inbound::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inbound pre elaboration' algorithm generated code\n\n\t//End of 'Inbound pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inbound::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inbound post elaboration' algorithm generated code\n\n\t//End of 'Inbound post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inbound::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inbound post simulation' algorithm generated code\n\n\t//End of 'Inbound post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inbound::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inbound::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inbound initializations' algorithm generated code\n\n\t//End of 'Inbound initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Outbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQRouting_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUND\n#define COFS_MODEL_DATACENTER_OUTBOUND\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outbound_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Outbound includes' algorithm generated code\n\n//End of 'Outbound includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutbound Function Outbound\n//@{\n///        \\page dxpOutbound\n//@{\n///    \\brief Outbound function model start\nclass cfm_outbound: public cf_core::cf_function, public cfm_outbound_dp_if {\npublic:\n\t/// cfm_outbound type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbound, cft_defpacket> p_mq_MsgQToServerRoom_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbound, cft_defpacket> p_mq_MsgQRouting_out_t;\n\t/// cfm_outbound type define end\n\n\t/// constructor\n\tcfm_outbound(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_outbound(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\tp_mq_MsgQRouting_out_t p_mq_MsgQRouting_out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Outbound local declarations' algorithm generated code\n\t/*int outIndex;*/\n\t//End of 'Outbound local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Outbound function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Outbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQRouting_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outbound.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenterswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outbound\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Outbound definitions' algorithm generated code\n\n//End of 'Outbound definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outbound::cfm_outbound(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_outbound_dp_if(), p_mq_MsgQToServerRoom(\n\t\t\t\t\"p_mq_MsgQToServerRoom\"), p_mq_MsgQRouting_out(\n\t\t\t\t\"p_mq_MsgQRouting_out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Outbound constructor' algorithm generated code\n\n\t//End of 'Outbound constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outbound::~cfm_outbound(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Outbound destructor' algorithm generated code\n\n\t//End of 'Outbound destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_outbound::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Outbound pre elaboration' algorithm generated code\n\n\t//End of 'Outbound pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_outbound::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Outbound post elaboration' algorithm generated code\n\n\t//End of 'Outbound post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_outbound::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Outbound post simulation' algorithm generated code\n\n\t//End of 'Outbound post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_outbound::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_outbound::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Outbound initializations' algorithm generated code\n\n\t//End of 'Outbound initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outbounddatacenterswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundDataCenterSwitch includes' algorithm generated code\n\n//End of 'OutboundDataCenterSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundDataCenterSwitch Function OutboundDataCenterSwitch\n//@{\n///        \\page dxpOutboundDataCenterSwitch\n//@{\n///    \\brief OutboundDataCenterSwitch function model start\nclass cfm_outbounddatacenterswitch: public cf_core::cf_function,\n\t\tpublic cfm_outbounddatacenterswitch_dp_if {\npublic:\n\t/// cfm_outbounddatacenterswitch type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbounddatacenterswitch,\n\t\t\tcft_defpacket> p_mq_MsgQOutboundDataCenterSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outbounddatacenterswitch,\n\t\t\tcft_defpacket> p_mq_MsgQToDataCenterSwitch_t;\n\t/// cfm_outbounddatacenterswitch type define end\n\n\t/// constructor\n\tcfm_outbounddatacenterswitch(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_outbounddatacenterswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQOutboundDataCenterSwitch_t p_mq_MsgQOutboundDataCenterSwitch;\n\tp_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundDataCenterSwitch local declarations' algorithm generated code\n\tint server_room_id;\n\t//End of 'OutboundDataCenterSwitch local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OutboundDataCenterSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outbounddatacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outbounddatacenterswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundDataCenterSwitch definitions' algorithm generated code\n\n//End of 'OutboundDataCenterSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outbounddatacenterswitch::cfm_outbounddatacenterswitch(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_outbounddatacenterswitch_dp_if(), p_mq_MsgQOutboundDataCenterSwitch(\n\t\t\t\t\"p_mq_MsgQOutboundDataCenterSwitch\"), p_mq_MsgQToDataCenterSwitch(\n\t\t\t\t\"p_mq_MsgQToDataCenterSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundDataCenterSwitch constructor' algorithm generated code\n\n\t//End of 'OutboundDataCenterSwitch constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outbounddatacenterswitch::~cfm_outbounddatacenterswitch(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundDataCenterSwitch destructor' algorithm generated code\n\n\t//End of 'OutboundDataCenterSwitch destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_outbounddatacenterswitch::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundDataCenterSwitch pre elaboration' algorithm generated code\n\n\t//End of 'OutboundDataCenterSwitch pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_outbounddatacenterswitch::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundDataCenterSwitch post elaboration' algorithm generated code\n\n\t//End of 'OutboundDataCenterSwitch post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_outbounddatacenterswitch::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundDataCenterSwitch post simulation' algorithm generated code\n\n\t//End of 'OutboundDataCenterSwitch post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_outbounddatacenterswitch::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_outbounddatacenterswitch::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundDataCenterSwitch initializations' algorithm generated code\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n\t//End of 'OutboundDataCenterSwitch initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inbounddatacenterswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundDataCenterSwitch includes' algorithm generated code\n\n//End of 'InboundDataCenterSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundDataCenterSwitch Function InboundDataCenterSwitch\n//@{\n///        \\page dxpInboundDataCenterSwitch\n//@{\n///    \\brief InboundDataCenterSwitch function model start\nclass cfm_inbounddatacenterswitch: public cf_core::cf_function,\n\t\tpublic cfm_inbounddatacenterswitch_dp_if {\npublic:\n\t/// cfm_inbounddatacenterswitch type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbounddatacenterswitch,\n\t\t\tcft_defpacket> p_mq_MsgQToServerRoom_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inbounddatacenterswitch,\n\t\t\tcft_defpacket> p_mq_MsgQInboundDataCenterSwitch_t;\n\t/// cfm_inbounddatacenterswitch type define end\n\n\t/// constructor\n\tcfm_inbounddatacenterswitch(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inbounddatacenterswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n\tp_mq_MsgQInboundDataCenterSwitch_t p_mq_MsgQInboundDataCenterSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundDataCenterSwitch local declarations' algorithm generated code\n\tint server_room_id;\n\t//End of 'InboundDataCenterSwitch local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief InboundDataCenterSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inbounddatacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inbounddatacenterswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundDataCenterSwitch definitions' algorithm generated code\n\n//End of 'InboundDataCenterSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inbounddatacenterswitch::cfm_inbounddatacenterswitch(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_inbounddatacenterswitch_dp_if(), p_mq_MsgQToServerRoom(\n\t\t\t\t\"p_mq_MsgQToServerRoom\"), p_mq_MsgQInboundDataCenterSwitch(\n\t\t\t\t\"p_mq_MsgQInboundDataCenterSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundDataCenterSwitch constructor' algorithm generated code\n\n\t//End of 'InboundDataCenterSwitch constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inbounddatacenterswitch::~cfm_inbounddatacenterswitch(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundDataCenterSwitch destructor' algorithm generated code\n\n\t//End of 'InboundDataCenterSwitch destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inbounddatacenterswitch::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundDataCenterSwitch pre elaboration' algorithm generated code\n\n\t//End of 'InboundDataCenterSwitch pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inbounddatacenterswitch::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundDataCenterSwitch post elaboration' algorithm generated code\n\n\t//End of 'InboundDataCenterSwitch post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inbounddatacenterswitch::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundDataCenterSwitch post simulation' algorithm generated code\n\n\t//End of 'InboundDataCenterSwitch post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inbounddatacenterswitch::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inbounddatacenterswitch::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundDataCenterSwitch initializations' algorithm generated code\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n\t//End of 'InboundDataCenterSwitch initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDRACK\n#define COFS_MODEL_DATACENTER_INBOUNDRACK\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundrack_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundRack includes' algorithm generated code\n\n//End of 'InboundRack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundRack Function InboundRack\n//@{\n///        \\page dxpInboundRack\n//@{\n///    \\brief InboundRack function model start\nclass cfm_inboundrack: public cf_core::cf_function, public cfm_inboundrack_dp_if {\npublic:\n\t/// cfm_inboundrack type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundrack, cft_defpacket> p_mq_MsgQInboundRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundrack, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\t/// cfm_inboundrack type define end\n\n\t/// constructor\n\tcfm_inboundrack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inboundrack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQInboundRack_t p_mq_MsgQInboundRack;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundRack local declarations' algorithm generated code\n\tint server_room_id;\n\tint rack_id;\n\t//End of 'InboundRack local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief InboundRack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDRACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inboundrack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundrack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundRack definitions' algorithm generated code\n\n//End of 'InboundRack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inboundrack::cfm_inboundrack(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_inboundrack_dp_if(), p_mq_MsgQInboundRack(\n\t\t\t\t\"p_mq_MsgQInboundRack\"), p_mq_MsgQToAggSwitch(\n\t\t\t\t\"p_mq_MsgQToAggSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundRack constructor' algorithm generated code\n\n\t//End of 'InboundRack constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inboundrack::~cfm_inboundrack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundRack destructor' algorithm generated code\n\n\t//End of 'InboundRack destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inboundrack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundRack pre elaboration' algorithm generated code\n\n\t//End of 'InboundRack pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inboundrack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundRack post elaboration' algorithm generated code\n\n\t//End of 'InboundRack post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inboundrack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundRack post simulation' algorithm generated code\n\n\t//End of 'InboundRack post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inboundrack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inboundrack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundRack initializations' algorithm generated code\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n\track_id = get_cp_index();\n\t//End of 'InboundRack initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDRACK\n#define COFS_MODEL_DATACENTER_OUTBOUNDRACK\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundrack_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundRack includes' algorithm generated code\n\n//End of 'OutboundRack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundRack Function OutboundRack\n//@{\n///        \\page dxpOutboundRack\n//@{\n///    \\brief OutboundRack function model start\nclass cfm_outboundrack: public cf_core::cf_function,\n\t\tpublic cfm_outboundrack_dp_if {\npublic:\n\t/// cfm_outboundrack type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundrack, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundrack, cft_defpacket> p_mq_MsgQOutboundRack_t;\n\t/// cfm_outboundrack type define end\n\n\t/// constructor\n\tcfm_outboundrack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_outboundrack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tp_mq_MsgQOutboundRack_t p_mq_MsgQOutboundRack;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundRack local declarations' algorithm generated code\n\tint server_room_id;\n\tint rack_id;\n\t//End of 'OutboundRack local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OutboundRack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDRACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outboundrack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundrack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundRack definitions' algorithm generated code\n\n//End of 'OutboundRack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outboundrack::cfm_outboundrack(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_outboundrack_dp_if(), p_mq_MsgQToRack(\n\t\t\t\t\"p_mq_MsgQToRack\"), p_mq_MsgQOutboundRack(\n\t\t\t\t\"p_mq_MsgQOutboundRack\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundRack constructor' algorithm generated code\n\n\t//End of 'OutboundRack constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outboundrack::~cfm_outboundrack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundRack destructor' algorithm generated code\n\n\t//End of 'OutboundRack destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_outboundrack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundRack pre elaboration' algorithm generated code\n\n\t//End of 'OutboundRack pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_outboundrack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundRack post elaboration' algorithm generated code\n\n\t//End of 'OutboundRack post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_outboundrack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundRack post simulation' algorithm generated code\n\n\t//End of 'OutboundRack post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_outboundrack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_outboundrack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundRack initializations' algorithm generated code\n\tserver_room_id = get_container()->get_container()->get_cp_index();\n\track_id = get_cp_index();\n\t//End of 'OutboundRack initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Server', 'type': 'cofluent:Function', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Producer']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Consumer']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_server\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_SERVER\n#define COFS_MODEL_DATACENTER_SERVER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_server_dp_if.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Server includes' algorithm generated code\n\n//End of 'Server includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgServer Function Server\n//@{\n///        \\page dxpServer\n//@{\n///    \\brief Server function model start\nclass cfm_server: public cf_core::cf_function_container, public cfm_server_dp_if {\npublic:\n\t/// cfm_server type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_server, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_server, cft_defpacket> p_mq_MsgQToServer_t;\n\t/// cfm_server type define end\n\n\t/// constructor\n\tcfm_server(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_server(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n\tp_mq_MsgQToServer_t p_mq_MsgQToServer;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer* Consumer;\n\tcfm_producer* Producer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Server local declarations' algorithm generated code\n\n\t//End of 'Server local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Server function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_SERVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Server', 'type': 'cofluent:Function', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Producer']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Consumer']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_server\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_server.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_server\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Server definitions' algorithm generated code\n\n//End of 'Server definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_server::cfm_server(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_server_dp_if(), p_mq_MsgQServerToToRSwitch(\n\t\t\t\t\"p_mq_MsgQServerToToRSwitch\"), p_mq_MsgQToServer(\n\t\t\t\t\"p_mq_MsgQToServer\") {\n\tcf_function_container::init();\n\tConsumer = new cfm_consumer(\"Consumer\");\n\tProducer = new cfm_producer(\"Producer\");\n\n\t// connections\n\tConsumer->p_mq_MsgQToServer(p_mq_MsgQToServer);\n\n\tProducer->p_mq_MsgQServerToToRSwitch(p_mq_MsgQServerToToRSwitch);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Server constructor' algorithm generated code\n\n\t//End of 'Server constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_server::~cfm_server(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Server destructor' algorithm generated code\n\n\t//End of 'Server destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer;\n\tdelete Producer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_server::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Server pre elaboration' algorithm generated code\n\n\t//End of 'Server pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_server::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Server post elaboration' algorithm generated code\n\n\t//End of 'Server post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_server::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Server post simulation' algorithm generated code\n\n\t//End of 'Server post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_server::cb_init_attributes() {\n\n// initialize function attributes\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_server::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Server initializations' algorithm generated code\n\n\t//End of 'Server initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ToRSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundServer', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundServer', 'type': 'cofluent:Function'}, {'name': 'InboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundAGGSwitch']}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundServer']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundServer']}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundAGGSwitch']}], 'relations': [{'name': 'MsgQInboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundAGGSwitch']}, {'name': 'MsgQInboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['InboundServer', 'RoutingFunction']}, {'name': 'MsgQOutboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundServer']}, {'name': 'MsgQOutboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundAGGSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_torswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_TORSWITCH\n#define COFS_MODEL_DATACENTER_TORSWITCH\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_torswitch_dp_if.h\"\n#include \"cfm_inboundaggswitch.h\"\n#include \"cfm_inboundserver.h\"\n#include \"cfm_outboundaggswitch.h\"\n#include \"cfm_outboundserver.h\"\n#include \"cfm_torswitch_routingfunction.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ToRSwitch includes' algorithm generated code\n\n//End of 'ToRSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgToRSwitch Function ToRSwitch\n//@{\n///        \\page dxpToRSwitch\n//@{\n///    \\brief ToRSwitch function model start\nclass cfm_torswitch: public cf_core::cf_function_container,\n\t\tpublic cfm_torswitch_dp_if {\npublic:\n\t/// cfm_torswitch type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundAGGSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundServer_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundAGGSwitch_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundServer_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQToServer_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\t/// cfm_torswitch type define end\n\n\t/// constructor\n\tcfm_torswitch(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_torswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tstd::vector<p_mq_MsgQServerToToRSwitch_t*> p_mq_MsgQServerToToRSwitch_vec;\n\tstd::vector<p_mq_MsgQToServer_t*> p_mq_MsgQToServer_vec;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_inboundaggswitch* InboundAGGSwitch;\n\tstd::vector<cfm_inboundserver*> InboundServer_vec;\n\tcfm_outboundaggswitch* OutboundAGGSwitch;\n\tstd::vector<cfm_outboundserver*> OutboundServer_vec;\n\tcfm_torswitch_routingfunction* RoutingFunction;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQInboundAGGSwitch_t mq_MsgQInboundAGGSwitch;\n\tstd::vector<mq_MsgQInboundServer_t*> mq_MsgQInboundServer_vec;\n\tmq_MsgQOutboundAGGSwitch_t mq_MsgQOutboundAGGSwitch;\n\tstd::vector<mq_MsgQOutboundServer_t*> mq_MsgQOutboundServer_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ToRSwitch local declarations' algorithm generated code\n\n\t//End of 'ToRSwitch local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ToRSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_TORSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ToRSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundServer', 'type': 'cofluent:Function'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}, {'name': 'OutboundServer', 'type': 'cofluent:Function'}, {'name': 'InboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundAGGSwitch']}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundServer']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundServer']}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundAGGSwitch']}], 'relations': [{'name': 'MsgQInboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundAGGSwitch']}, {'name': 'MsgQInboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['InboundServer', 'RoutingFunction']}, {'name': 'MsgQOutboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundServer']}, {'name': 'MsgQOutboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundAGGSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_torswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_torswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_torswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ToRSwitch definitions' algorithm generated code\n\n//End of 'ToRSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_torswitch::cfm_torswitch(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_torswitch_dp_if(), p_mq_MsgQToRack(\n\t\t\t\t\"p_mq_MsgQToRack\"), p_mq_MsgQToAggSwitch(\n\t\t\t\t\"p_mq_MsgQToAggSwitch\"), mq_MsgQInboundAGGSwitch(\n\t\t\t\t\"MsgQInboundAGGSwitch\"), mq_MsgQOutboundAGGSwitch(\n\t\t\t\t\"MsgQOutboundAGGSwitch\") {\n\tcf_function_container::init();\n\tInboundAGGSwitch = new cfm_inboundaggswitch(\"InboundAGGSwitch\");\n\tOutboundAGGSwitch = new cfm_outboundaggswitch(\"OutboundAGGSwitch\");\n\tRoutingFunction = new cfm_torswitch_routingfunction(\"RoutingFunction\");\n\n\t// instantiation of InboundServer_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_inboundserver* module = new cfm_inboundserver(\n\t\t\t\tcf_string(\"InboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tInboundServer_vec.push_back(module);\n\t}\n\t// instantiation of OutboundServer_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_outboundserver* module = new cfm_outboundserver(\n\t\t\t\tcf_string(\"OutboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tOutboundServer_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQInboundServer_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tmq_MsgQInboundServer_t* module = new mq_MsgQInboundServer_t(\n\t\t\t\tcf_string(\"MsgQInboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQInboundServer_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQOutboundServer_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tmq_MsgQOutboundServer_t* module = new mq_MsgQOutboundServer_t(\n\t\t\t\tcf_string(\"MsgQOutboundServer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQOutboundServer_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_MsgQServerToToRSwitch_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tp_mq_MsgQServerToToRSwitch_t* module = new p_mq_MsgQServerToToRSwitch_t(\n\t\t\t\tcf_string(\"p_mq_MsgQServerToToRSwitch[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_MsgQServerToToRSwitch_vec.push_back(module);\n\t}\n\t// instantiation of p_mq_MsgQToServer_vec\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tp_mq_MsgQToServer_t* module = new p_mq_MsgQToServer_t(\n\t\t\t\tcf_string(\"p_mq_MsgQToServer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tp_mq_MsgQToServer_vec.push_back(module);\n\t}\n\t// connections\n\tInboundAGGSwitch->p_mq_MsgQToRack(p_mq_MsgQToRack);\n\tInboundAGGSwitch->p_mq_MsgQInboundAGGSwitch(\n\t\t\tmq_MsgQInboundAGGSwitch.p_target_socket);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_inboundserver* module = InboundServer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQInboundServer(\n\t\t\t\t\t\tmq_MsgQInboundServer_vec[j]->p_target_socket);\n\t\t\t}\n\t\t\tmodule->p_mq_MsgQServerToToRSwitch(\n\t\t\t\t\t(*p_mq_MsgQServerToToRSwitch_vec[i]));\n\t\t}\n\t}\n\n\tOutboundAGGSwitch->p_mq_MsgQOutboundAGGSwitch(\n\t\t\tmq_MsgQOutboundAGGSwitch.p_target_socket);\n\tOutboundAGGSwitch->p_mq_MsgQToAggSwitch(p_mq_MsgQToAggSwitch);\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tcfm_outboundserver* module = OutboundServer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tmodule->p_mq_MsgQToServer((*p_mq_MsgQToServer_vec[i]));\n\t\t\tfor (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n\t\t\t\tmodule->p_mq_MsgQOutboundServer(\n\t\t\t\t\t\tmq_MsgQOutboundServer_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQInboundServer(\n\t\t\t\tmq_MsgQInboundServer_vec[i]->p_target_socket);\n\t}\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\tRoutingFunction->p_mq_MsgQOutboundServer(\n\t\t\t\tmq_MsgQOutboundServer_vec[i]->p_target_socket);\n\t}\n\tRoutingFunction->p_mq_MsgQInboundAGGSwitch(\n\t\t\tmq_MsgQInboundAGGSwitch.p_target_socket);\n\tRoutingFunction->p_mq_MsgQOutboundAGGSwitch(\n\t\t\tmq_MsgQOutboundAGGSwitch.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ToRSwitch constructor' algorithm generated code\n\n\t//End of 'ToRSwitch constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_torswitch::~cfm_torswitch(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ToRSwitch destructor' algorithm generated code\n\n\t//End of 'ToRSwitch destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_inboundserver*>::const_iterator vi =\n\t\t\tInboundServer_vec.begin(); vi != InboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_outboundserver*>::const_iterator vi =\n\t\t\tOutboundServer_vec.begin(); vi != OutboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQInboundServer_t*>::const_iterator vi =\n\t\t\tmq_MsgQInboundServer_vec.begin();\n\t\t\tvi != mq_MsgQInboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQOutboundServer_t*>::const_iterator vi =\n\t\t\tmq_MsgQOutboundServer_vec.begin();\n\t\t\tvi != mq_MsgQOutboundServer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQServerToToRSwitch_t*>::const_iterator vi =\n\t\t\tp_mq_MsgQServerToToRSwitch_vec.begin();\n\t\t\tvi != p_mq_MsgQServerToToRSwitch_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<p_mq_MsgQToServer_t*>::const_iterator vi =\n\t\t\tp_mq_MsgQToServer_vec.begin(); vi != p_mq_MsgQToServer_vec.end();\n\t\t\tvi++) {\n\t\tdelete (*vi);\n\t}\n\tdelete InboundAGGSwitch;\n\tdelete OutboundAGGSwitch;\n\tdelete RoutingFunction;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_torswitch::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ToRSwitch pre elaboration' algorithm generated code\n\n\t//End of 'ToRSwitch pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_torswitch::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ToRSwitch post elaboration' algorithm generated code\n\n\t//End of 'ToRSwitch post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_torswitch::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ToRSwitch post simulation' algorithm generated code\n\n\t//End of 'ToRSwitch post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_torswitch::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tmq_MsgQInboundAGGSwitch.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundAGGSwitch.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQInboundAGGSwitch.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQInboundAGGSwitch.cfa_queue_capacity.init(\n\t\t\t(cf_nonzero_count) dpToRSwitchPortBufferSize);\n\tmq_MsgQInboundAGGSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQInboundAGGSwitch.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQInboundAGGSwitch.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpToRSwitchPortBufferSize);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_concurrency.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQInboundServer_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\tmq_MsgQOutboundAGGSwitch.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundAGGSwitch.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQOutboundAGGSwitch.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQOutboundAGGSwitch.cfa_queue_capacity.init(\n\t\t\t(cf_nonzero_count) dpToRSwitchPortBufferSize);\n\tmq_MsgQOutboundAGGSwitch.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQOutboundAGGSwitch.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQOutboundAGGSwitch.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tfor (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_send_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_receive_time.init(\n\t\t\t\tcf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_queue_policy.init(\n\t\t\t\tCF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_queue_capacity.init(\n\t\t\t\t(cf_nonzero_count) dpToRSwitchPortBufferSize);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_concurrency.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_send_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t\t(*mq_MsgQOutboundServer_vec[i]).cfa_receive_threshold.init(\n\t\t\t\t(cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_torswitch::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ToRSwitch initializations' algorithm generated code\n\n\t//End of 'ToRSwitch initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_PRODUCER\n#define COFS_MODEL_DATACENTER_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function, public cfm_producer_dp_if {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\t// components ID\n\tint server_room_id;\n\tint rack_id;\n\tint server_id;\n\t// Server transaction count\n\tint local_transaction_count;\n\tint local_transaction_outside_rack_count;\n\tint local_transaction_outside_server_room_count;\n\t// Store waiting time for produce operation\n\tint waiting_time;\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_server\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_producer_dp_if(), p_mq_MsgQServerToToRSwitch(\n\t\t\t\t\"p_mq_MsgQServerToToRSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\t// Initialize components ID\n\tserver_room_id =\n\t\t\tget_container()->get_container()->get_container()->get_cp_index();\n\track_id = get_container()->get_container()->get_cp_index();\n\tserver_id = get_container()->get_cp_index();\n\n\t// Get transaction data\n\tlocal_transaction_count = 0;\n\tlocal_transaction_outside_rack_count = 0;\n\tlocal_transaction_outside_server_room_count = 0;\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_CONSUMER\n#define COFS_MODEL_DATACENTER_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_consumer_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function, public cfm_consumer_dp_if {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer, cft_defpacket> p_mq_MsgQToServer_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToServer_t p_mq_MsgQToServer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\t// components ID\n\tint server_room_id;\n\tint rack_id;\n\tint server_id;\n\n\tcf_dt::cf_time latency;\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_server\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_consumer_dp_if(), p_mq_MsgQToServer(\n\t\t\t\t\"p_mq_MsgQToServer\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\t// Initialize components ID\n\tserver_room_id =\n\t\t\tget_container()->get_container()->get_container()->get_cp_index();\n\track_id = get_container()->get_container()->get_cp_index();\n\tserver_id = get_container()->get_cp_index();\n\t// Init latency\n\tlatency = cf_dt::cf_time(0, CF_SEC);\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDSERVER\n#define COFS_MODEL_DATACENTER_INBOUNDSERVER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundserver_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundServer includes' algorithm generated code\n\n//End of 'InboundServer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundServer Function InboundServer\n//@{\n///        \\page dxpInboundServer\n//@{\n///    \\brief InboundServer function model start\nclass cfm_inboundserver: public cf_core::cf_function,\n\t\tpublic cfm_inboundserver_dp_if {\npublic:\n\t/// cfm_inboundserver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundserver, cft_defpacket> p_mq_MsgQInboundServer_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundserver, cft_defpacket> p_mq_MsgQServerToToRSwitch_t;\n\t/// cfm_inboundserver type define end\n\n\t/// constructor\n\tcfm_inboundserver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inboundserver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQInboundServer_t p_mq_MsgQInboundServer;\n\tp_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundServer local declarations' algorithm generated code\n\tint rack_id;\n\t//End of 'InboundServer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief InboundServer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDSERVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inboundserver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundserver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundServer definitions' algorithm generated code\n\n//End of 'InboundServer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inboundserver::cfm_inboundserver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_inboundserver_dp_if(), p_mq_MsgQInboundServer(\n\t\t\t\t\"p_mq_MsgQInboundServer\"), p_mq_MsgQServerToToRSwitch(\n\t\t\t\t\"p_mq_MsgQServerToToRSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundServer constructor' algorithm generated code\n\n\t//End of 'InboundServer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inboundserver::~cfm_inboundserver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundServer destructor' algorithm generated code\n\n\t//End of 'InboundServer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inboundserver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundServer pre elaboration' algorithm generated code\n\n\t//End of 'InboundServer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inboundserver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundServer post elaboration' algorithm generated code\n\n\t//End of 'InboundServer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inboundserver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundServer post simulation' algorithm generated code\n\n\t//End of 'InboundServer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inboundserver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inboundserver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundServer initializations' algorithm generated code\n\track_id = get_container()->get_container()->get_cp_index();\n\t//End of 'InboundServer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n#define COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundserver_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundServer includes' algorithm generated code\n\n//End of 'OutboundServer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundServer Function OutboundServer\n//@{\n///        \\page dxpOutboundServer\n//@{\n///    \\brief OutboundServer function model start\nclass cfm_outboundserver: public cf_core::cf_function,\n\t\tpublic cfm_outboundserver_dp_if {\npublic:\n\t/// cfm_outboundserver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundserver, cft_defpacket> p_mq_MsgQToServer_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundserver, cft_defpacket> p_mq_MsgQOutboundServer_t;\n\t/// cfm_outboundserver type define end\n\n\t/// constructor\n\tcfm_outboundserver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_outboundserver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToServer_t p_mq_MsgQToServer;\n\tp_mq_MsgQOutboundServer_t p_mq_MsgQOutboundServer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundServer local declarations' algorithm generated code\n\tint rack_id;\n\t//End of 'OutboundServer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OutboundServer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outboundserver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundserver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundServer definitions' algorithm generated code\n\n//End of 'OutboundServer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outboundserver::cfm_outboundserver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_outboundserver_dp_if(), p_mq_MsgQToServer(\n\t\t\t\t\"p_mq_MsgQToServer\"), p_mq_MsgQOutboundServer(\n\t\t\t\t\"p_mq_MsgQOutboundServer\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundServer constructor' algorithm generated code\n\n\t//End of 'OutboundServer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outboundserver::~cfm_outboundserver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundServer destructor' algorithm generated code\n\n\t//End of 'OutboundServer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_outboundserver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundServer pre elaboration' algorithm generated code\n\n\t//End of 'OutboundServer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_outboundserver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundServer post elaboration' algorithm generated code\n\n\t//End of 'OutboundServer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_outboundserver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundServer post simulation' algorithm generated code\n\n\t//End of 'OutboundServer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_outboundserver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_outboundserver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundServer initializations' algorithm generated code\n\track_id = get_container()->get_container()->get_cp_index();\n\t//End of 'OutboundServer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n#define COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundaggswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundAGGSwitch includes' algorithm generated code\n\n//End of 'InboundAGGSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundAGGSwitch Function InboundAGGSwitch\n//@{\n///        \\page dxpInboundAGGSwitch\n//@{\n///    \\brief InboundAGGSwitch function model start\nclass cfm_inboundaggswitch: public cf_core::cf_function,\n\t\tpublic cfm_inboundaggswitch_dp_if {\npublic:\n\t/// cfm_inboundaggswitch type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundaggswitch, cft_defpacket> p_mq_MsgQToRack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_inboundaggswitch, cft_defpacket> p_mq_MsgQInboundAGGSwitch_t;\n\t/// cfm_inboundaggswitch type define end\n\n\t/// constructor\n\tcfm_inboundaggswitch(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inboundaggswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQToRack_t p_mq_MsgQToRack;\n\tp_mq_MsgQInboundAGGSwitch_t p_mq_MsgQInboundAGGSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundAGGSwitch local declarations' algorithm generated code\n\tint rack_id;\n\t//End of 'InboundAGGSwitch local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief InboundAGGSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inboundaggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundaggswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'InboundAGGSwitch definitions' algorithm generated code\n\n//End of 'InboundAGGSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inboundaggswitch::cfm_inboundaggswitch(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_inboundaggswitch_dp_if(), p_mq_MsgQToRack(\n\t\t\t\t\"p_mq_MsgQToRack\"), p_mq_MsgQInboundAGGSwitch(\n\t\t\t\t\"p_mq_MsgQInboundAGGSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundAGGSwitch constructor' algorithm generated code\n\n\t//End of 'InboundAGGSwitch constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inboundaggswitch::~cfm_inboundaggswitch(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundAGGSwitch destructor' algorithm generated code\n\n\t//End of 'InboundAGGSwitch destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inboundaggswitch::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundAGGSwitch pre elaboration' algorithm generated code\n\n\t//End of 'InboundAGGSwitch pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inboundaggswitch::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundAGGSwitch post elaboration' algorithm generated code\n\n\t//End of 'InboundAGGSwitch post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inboundaggswitch::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundAGGSwitch post simulation' algorithm generated code\n\n\t//End of 'InboundAGGSwitch post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inboundaggswitch::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inboundaggswitch::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'InboundAGGSwitch initializations' algorithm generated code\n\track_id = get_container()->get_container()->get_cp_index();\n\t//End of 'InboundAGGSwitch initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n#define COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundaggswitch_dp_if.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundAGGSwitch includes' algorithm generated code\n\n//End of 'OutboundAGGSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundAGGSwitch Function OutboundAGGSwitch\n//@{\n///        \\page dxpOutboundAGGSwitch\n//@{\n///    \\brief OutboundAGGSwitch function model start\nclass cfm_outboundaggswitch: public cf_core::cf_function,\n\t\tpublic cfm_outboundaggswitch_dp_if {\npublic:\n\t/// cfm_outboundaggswitch type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundaggswitch, cft_defpacket> p_mq_MsgQOutboundAGGSwitch_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_outboundaggswitch, cft_defpacket> p_mq_MsgQToAggSwitch_t;\n\t/// cfm_outboundaggswitch type define end\n\n\t/// constructor\n\tcfm_outboundaggswitch(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_outboundaggswitch(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQOutboundAGGSwitch_t p_mq_MsgQOutboundAGGSwitch;\n\tp_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundAGGSwitch local declarations' algorithm generated code\n\tint rack_id;\n\t//End of 'OutboundAGGSwitch local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OutboundAGGSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outboundaggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundaggswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OutboundAGGSwitch definitions' algorithm generated code\n\n//End of 'OutboundAGGSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outboundaggswitch::cfm_outboundaggswitch(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_outboundaggswitch_dp_if(), p_mq_MsgQOutboundAGGSwitch(\n\t\t\t\t\"p_mq_MsgQOutboundAGGSwitch\"), p_mq_MsgQToAggSwitch(\n\t\t\t\t\"p_mq_MsgQToAggSwitch\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundAGGSwitch constructor' algorithm generated code\n\n\t//End of 'OutboundAGGSwitch constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outboundaggswitch::~cfm_outboundaggswitch(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundAGGSwitch destructor' algorithm generated code\n\n\t//End of 'OutboundAGGSwitch destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_outboundaggswitch::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundAGGSwitch pre elaboration' algorithm generated code\n\n\t//End of 'OutboundAGGSwitch pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_outboundaggswitch::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundAGGSwitch post elaboration' algorithm generated code\n\n\t//End of 'OutboundAGGSwitch post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_outboundaggswitch::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundAGGSwitch post simulation' algorithm generated code\n\n\t//End of 'OutboundAGGSwitch post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_outboundaggswitch::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_outboundaggswitch::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OutboundAGGSwitch initializations' algorithm generated code\n\track_id = get_container()->get_container()->get_cp_index();\n\t//End of 'OutboundAGGSwitch initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationModel', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL\n#define COFS_MODEL_APPLICATIONMODEL\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationmodel_dp_if.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_receiver.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationModel includes' algorithm generated code\n\n//End of 'ApplicationModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationModel Function ApplicationModel\n//@{\n///        \\page dxpApplicationModel\n//@{\n///    \\brief ApplicationModel function model start\nclass cfm_applicationmodel: public cf_core::cf_application,\n\t\tpublic cfm_applicationmodel_dp_if {\npublic:\n\t/// cfm_applicationmodel type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defack> mq_Ack_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsg> mq_Msg_t;\n\n\t/// cfm_applicationmodel type define end\n\n\t/// constructor\n\tcfm_applicationmodel(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_applicationmodel(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_producer* Producer;\n\tcfm_receiver* Receiver;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_Ack_t mq_Ack;\n\tmq_Msg_t mq_Msg;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModel local declarations' algorithm generated code\n\n\t//End of 'ApplicationModel local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ApplicationModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationModel', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationmodel.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationModel definitions' algorithm generated code\n\n//End of 'ApplicationModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationmodel::cfm_applicationmodel(sc_core::sc_module_name name) :\n\t\tcf_application(name), cfm_applicationmodel_dp_if(), mq_Ack(\"Ack\"), mq_Msg(\n\t\t\t\t\"Msg\") {\n\tcf_application::init();\n\tProducer = new cfm_producer(\"Producer\");\n\tReceiver = new cfm_receiver(\"Receiver\");\n\n\t// connections\n\tProducer->p_mq_Msg(mq_Msg.p_target_socket);\n\tProducer->p_mq_Ack(mq_Ack.p_target_socket);\n\n\tReceiver->p_mq_Ack(mq_Ack.p_target_socket);\n\tReceiver->p_mq_Msg(mq_Msg.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModel constructor' algorithm generated code\n\n\t//End of 'ApplicationModel constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationmodel::~cfm_applicationmodel(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModel destructor' algorithm generated code\n\n\t//End of 'ApplicationModel destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Producer;\n\tdelete Receiver;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_applicationmodel::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModel pre elaboration' algorithm generated code\n\n\t//End of 'ApplicationModel pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_applicationmodel::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationModel post elaboration' algorithm generated code\n\n//End of 'ApplicationModel post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_applicationmodel::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModel post simulation' algorithm generated code\n\n\t//End of 'ApplicationModel post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_applicationmodel::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_Ack.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Ack.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Msg.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_applicationmodel::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModel initializations' algorithm generated code\n\n\t//End of 'ApplicationModel initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}], 'relations': [{'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Generator', 'Sender']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Generator', 'Sender']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_PRODUCER\n#define COFS_MODEL_APPLICATIONMODEL_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n#include \"cfm_generator.h\"\n#include \"cfm_sender.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function_container,\n\t\tpublic cfm_producer_dp_if {\npublic:\n\t/// cfm_producer type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_defdatavar> sv_DataVar_t;\n\ttypedef cf_core::cf_event ev_Req_t;\n\ttypedef cf_core::cf_shared_variable<cft_deftestprod> sv_TestProd_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defack> p_mq_Ack_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_generator* Generator;\n\tcfm_sender* Sender;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_DataVar_t sv_DataVar;\n\tev_Req_t ev_Req;\n\tsv_TestProd_t sv_TestProd;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}], 'relations': [{'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Generator', 'Sender']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Generator', 'Sender']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_producer_dp_if(), p_mq_Msg(\"p_mq_Msg\"), p_mq_Ack(\n\t\t\t\t\"p_mq_Ack\"), sv_DataVar(\"DataVar\"), ev_Req(\"Req\"), sv_TestProd(\n\t\t\t\t\"TestProd\") {\n\tcf_function_container::init();\n\tGenerator = new cfm_generator(\"Generator\");\n\tSender = new cfm_sender(\"Sender\");\n\n\t// connections\n\tGenerator->p_ev_Req(ev_Req.p_target_socket);\n\tGenerator->p_sv_DataVar(sv_DataVar.p_target_socket);\n\tGenerator->p_sv_TestProd(sv_TestProd.p_target_socket);\n\n\tSender->p_ev_Req(ev_Req.p_target_socket);\n\tSender->p_mq_Msg(p_mq_Msg);\n\tSender->p_mq_Ack(p_mq_Ack);\n\tSender->p_sv_DataVar(sv_DataVar.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Generator;\n\tdelete Sender;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tsv_DataVar.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_semaphore.init(false);\n\tsv_DataVar.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_Req.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tsv_TestProd.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_semaphore.init(false);\n\tsv_TestProd.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_RECEIVER\n#define COFS_MODEL_APPLICATIONMODEL_RECEIVER\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiver_dp_if.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Receiver includes' algorithm generated code\n\n//End of 'Receiver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiver Function Receiver\n//@{\n///        \\page dxpReceiver\n//@{\n///    \\brief Receiver function model start\nclass cfm_receiver: public cf_core::cf_function, public cfm_receiver_dp_if {\npublic:\n\t/// cfm_receiver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defmsg> p_mq_Msg_t;\n\t/// cfm_receiver type define end\n\n\t/// constructor\n\tcfm_receiver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_receiver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Ack_t p_mq_Ack;\n\tp_mq_Msg_t p_mq_Msg;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver local declarations' algorithm generated code\n\tDefValue noise;\n\tDefValue TestCons;\n\t//End of 'Receiver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Receiver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_RECEIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receiver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Receiver definitions' algorithm generated code\n\n//End of 'Receiver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receiver::cfm_receiver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_receiver_dp_if(), p_mq_Ack(\"p_mq_Ack\"), p_mq_Msg(\n\t\t\t\t\"p_mq_Msg\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver constructor' algorithm generated code\n\n\t//End of 'Receiver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receiver::~cfm_receiver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver destructor' algorithm generated code\n\n\t//End of 'Receiver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_receiver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver pre elaboration' algorithm generated code\n\n\t//End of 'Receiver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_receiver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver post elaboration' algorithm generated code\n\n\t//End of 'Receiver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_receiver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver post simulation' algorithm generated code\n\n\t//End of 'Receiver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_receiver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_receiver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver initializations' algorithm generated code\n\n\t//End of 'Receiver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_GENERATOR\n#define COFS_MODEL_APPLICATIONMODEL_GENERATOR\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_generator_dp_if.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Generator includes' algorithm generated code\n\n//End of 'Generator includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgGenerator Function Generator\n//@{\n///        \\page dxpGenerator\n//@{\n///    \\brief Generator function model start\nclass cfm_generator: public cf_core::cf_function, public cfm_generator_dp_if {\npublic:\n\t/// cfm_generator type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_generator> p_ev_Req_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_defdatavar> p_sv_DataVar_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_deftestprod> p_sv_TestProd_t;\n\t/// cfm_generator type define end\n\n\t/// constructor\n\tcfm_generator(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_generator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_Req_t p_ev_Req;\n\tp_sv_DataVar_t p_sv_DataVar;\n\tp_sv_TestProd_t p_sv_TestProd;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Generator local declarations' algorithm generated code\n\n\t//End of 'Generator local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Generator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_GENERATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_generator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_generator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Generator definitions' algorithm generated code\n\n//End of 'Generator definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_generator::cfm_generator(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_generator_dp_if(), p_ev_Req(\"p_ev_Req\"), p_sv_DataVar(\n\t\t\t\t\"p_sv_DataVar\"), p_sv_TestProd(\"p_sv_TestProd\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Generator constructor' algorithm generated code\n\n\t//End of 'Generator constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_generator::~cfm_generator(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Generator destructor' algorithm generated code\n\n\t//End of 'Generator destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_generator::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Generator pre elaboration' algorithm generated code\n\n\t//End of 'Generator pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_generator::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Generator post elaboration' algorithm generated code\n\n\t//End of 'Generator post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_generator::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Generator post simulation' algorithm generated code\n\n\t//End of 'Generator post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_generator::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_generator::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Generator initializations' algorithm generated code\n\n\t//End of 'Generator initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_SENDER\n#define COFS_MODEL_APPLICATIONMODEL_SENDER\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender includes' algorithm generated code\n\n//End of 'Sender includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSender Function Sender\n//@{\n///        \\page dxpSender\n//@{\n///    \\brief Sender function model start\nclass cfm_sender: public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n\t/// cfm_sender type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_sender> p_ev_Req_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_sender, cft_defdatavar> p_sv_DataVar_t;\n\t/// cfm_sender type define end\n\n\t/// constructor\n\tcfm_sender(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_sender(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_Req_t p_ev_Req;\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\tp_sv_DataVar_t p_sv_DataVar;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender local declarations' algorithm generated code\n\n\t//End of 'Sender local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Sender function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_SENDER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender definitions' algorithm generated code\n\n//End of 'Sender definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sender::cfm_sender(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_sender_dp_if(), p_ev_Req(\"p_ev_Req\"), p_mq_Msg(\n\t\t\t\t\"p_mq_Msg\"), p_mq_Ack(\"p_mq_Ack\"), p_sv_DataVar(\"p_sv_DataVar\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender constructor' algorithm generated code\n\n\t//End of 'Sender constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sender::~cfm_sender(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender destructor' algorithm generated code\n\n\t//End of 'Sender destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_sender::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender pre elaboration' algorithm generated code\n\n\t//End of 'Sender pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_sender::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post elaboration' algorithm generated code\n\n\t//End of 'Sender post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_sender::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post simulation' algorithm generated code\n\n\t//End of 'Sender post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_sender::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_sender::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender initializations' algorithm generated code\n\n\t//End of 'Sender initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationModelRefinement', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationmodelrefinement\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationmodelrefinement_dp_if.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_receiver.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationModelRefinement includes' algorithm generated code\n\n//End of 'ApplicationModelRefinement includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationModelRefinement Function ApplicationModelRefinement\n//@{\n///        \\page dxpApplicationModelRefinement\n//@{\n///    \\brief ApplicationModelRefinement function model start\nclass cfm_applicationmodelrefinement: public cf_core::cf_application,\n\t\tpublic cfm_applicationmodelrefinement_dp_if {\npublic:\n\t/// cfm_applicationmodelrefinement type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defack> mq_Ack_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsg> mq_Msg_t;\n\n\t/// cfm_applicationmodelrefinement type define end\n\n\t/// constructor\n\tcfm_applicationmodelrefinement(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_applicationmodelrefinement(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_producer* Producer;\n\tcfm_receiver* Receiver;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_Ack_t mq_Ack;\n\tmq_Msg_t mq_Msg;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModelRefinement local declarations' algorithm generated code\n\n\t//End of 'ApplicationModelRefinement local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief ApplicationModelRefinement function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationModelRefinement', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationmodelrefinement\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationmodelrefinement.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationModelRefinement definitions' algorithm generated code\n\n//End of 'ApplicationModelRefinement definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationmodelrefinement::cfm_applicationmodelrefinement(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), cfm_applicationmodelrefinement_dp_if(), mq_Ack(\n\t\t\t\t\"Ack\"), mq_Msg(\"Msg\") {\n\tcf_application::init();\n\tProducer = new cfm_producer(\"Producer\");\n\tReceiver = new cfm_receiver(\"Receiver\");\n\n\t// connections\n\tProducer->p_mq_Msg(mq_Msg.p_target_socket);\n\tProducer->p_mq_Ack(mq_Ack.p_target_socket);\n\n\tReceiver->p_mq_Ack(mq_Ack.p_target_socket);\n\tReceiver->p_mq_Msg(mq_Msg.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModelRefinement constructor' algorithm generated code\n\n\t//End of 'ApplicationModelRefinement constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationmodelrefinement::~cfm_applicationmodelrefinement(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModelRefinement destructor' algorithm generated code\n\n\t//End of 'ApplicationModelRefinement destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Producer;\n\tdelete Receiver;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_applicationmodelrefinement::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModelRefinement pre elaboration' algorithm generated code\n\n\t//End of 'ApplicationModelRefinement pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_applicationmodelrefinement::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'ApplicationModelRefinement post elaboration' algorithm generated code\n\n//End of 'ApplicationModelRefinement post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_applicationmodelrefinement::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModelRefinement post simulation' algorithm generated code\n\tif (TotalNbMsg != 0) {\n\t\tcf_trace_report(\"Total number of messages : %i\", TotalNbMsg);\n\t\tcf_trace_report(\"Average data size : %f bytes\",\n\t\t\t\t(float) TotalDataSize.to_scalar(CF_BYTE) / (float) TotalNbMsg);\n\t\tcf_trace_report(\"AverageLatency = %f ns\",\n\t\t\t\t(float) AverageLatency.to_scalar(CF_NS) / (float) TotalNbMsg);\n\t\tAverageThroughput = cf_dt::cf_throughput(TotalDataSize, AverageLatency);\n\t\tcf_trace_report(\"AverageThroughput = %f MBps\",\n\t\t\t\t(float) AverageThroughput.to_scalar(CF_MBYPS)\n\t\t\t\t\t\t/ (float) TotalNbMsg);\n\t}\n\n\tcf_trace_gui_f_param(\"AverageLatency\",\n\t\t\t(float) AverageLatency.to_scalar(CF_NS) / (float) TotalNbMsg);\n\tcf_trace_gui_f_param(\"AverageThroughput\",\n\t\t\t(float) AverageThroughput.to_scalar(CF_MBYPS) / (float) TotalNbMsg);\n\t//End of 'ApplicationModelRefinement post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_applicationmodelrefinement::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_Ack.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Ack.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Ack.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Ack.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_Msg.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_Msg.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_Msg.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_applicationmodelrefinement::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'ApplicationModelRefinement initializations' algorithm generated code\n\n\t//End of 'ApplicationModelRefinement initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'Generator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}], 'relations': [{'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Sender', 'Generator']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Sender', 'Generator']}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n#include \"cfm_generator.h\"\n#include \"cfm_sender.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_deftestprod.h\"\n#include \"dt/cft_defdatavar.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function_container,\n\t\tpublic cfm_producer_dp_if {\npublic:\n\t/// cfm_producer type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_defdatavar> sv_DataVar_t;\n\ttypedef cf_core::cf_event ev_Req_t;\n\ttypedef cf_core::cf_shared_variable<cft_deftestprod> sv_TestProd_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer, cft_defack> p_mq_Ack_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_generator* Generator;\n\tcfm_sender* Sender;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_DataVar_t sv_DataVar;\n\tev_Req_t ev_Req;\n\tsv_TestProd_t sv_TestProd;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Sender', 'type': 'cofluent:Function'}, {'name': 'Generator', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}], 'relations': [{'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Sender', 'Generator']}, {'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Sender', 'Generator']}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodelrefinement\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_producer_dp_if(), p_mq_Msg(\"p_mq_Msg\"), p_mq_Ack(\n\t\t\t\t\"p_mq_Ack\"), sv_DataVar(\"DataVar\"), ev_Req(\"Req\"), sv_TestProd(\n\t\t\t\t\"TestProd\") {\n\tcf_function_container::init();\n\tGenerator = new cfm_generator(\"Generator\");\n\tSender = new cfm_sender(\"Sender\");\n\n\t// connections\n\tGenerator->p_ev_Req(ev_Req.p_target_socket);\n\tGenerator->p_sv_DataVar(sv_DataVar.p_target_socket);\n\tGenerator->p_sv_TestProd(sv_TestProd.p_target_socket);\n\n\tSender->p_ev_Req(ev_Req.p_target_socket);\n\tSender->p_mq_Msg(p_mq_Msg);\n\tSender->p_mq_Ack(p_mq_Ack);\n\tSender->p_sv_DataVar(sv_DataVar.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Generator;\n\tdelete Sender;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tsv_DataVar.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_DataVar.cfa_semaphore.init(false);\n\tsv_DataVar.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_Req.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Req.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tsv_TestProd.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_TestProd.cfa_semaphore.init(false);\n\tsv_TestProd.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiver_dp_if.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Receiver includes' algorithm generated code\n\n//End of 'Receiver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiver Function Receiver\n//@{\n///        \\page dxpReceiver\n//@{\n///    \\brief Receiver function model start\nclass cfm_receiver: public cf_core::cf_function, public cfm_receiver_dp_if {\npublic:\n\t/// cfm_receiver type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_receiver, cft_defmsg> p_mq_Msg_t;\n\t/// cfm_receiver type define end\n\n\t/// constructor\n\tcfm_receiver(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_receiver(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_Ack_t p_mq_Ack;\n\tp_mq_Msg_t p_mq_Msg;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver local declarations' algorithm generated code\n\tDefValue noise;\n\tDefValue TestCons;\n\tint DecodeTime;\n\tint errorGen;\n\tbool Error; // OR branch condition\n\tcf_dt::cf_time Latency;\n\tcf_dt::cf_throughput Throughput;\n\t//End of 'Receiver local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Receiver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receiver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodelrefinement\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Receiver definitions' algorithm generated code\n\n//End of 'Receiver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receiver::cfm_receiver(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_receiver_dp_if(), p_mq_Ack(\"p_mq_Ack\"), p_mq_Msg(\n\t\t\t\t\"p_mq_Msg\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver constructor' algorithm generated code\n\n\t//End of 'Receiver constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receiver::~cfm_receiver(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver destructor' algorithm generated code\n\n\t//End of 'Receiver destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_receiver::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver pre elaboration' algorithm generated code\n\n\t//End of 'Receiver pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_receiver::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver post elaboration' algorithm generated code\n\n\t//End of 'Receiver post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_receiver::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver post simulation' algorithm generated code\n\n\t//End of 'Receiver post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_receiver::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_receiver::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Receiver initializations' algorithm generated code\n\tDecodeTime = 0;\n\t//End of 'Receiver initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender includes' algorithm generated code\n\n//End of 'Sender includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSender Function Sender\n//@{\n///        \\page dxpSender\n//@{\n///    \\brief Sender function model start\nclass cfm_sender: public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n\t/// cfm_sender type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_sender> p_ev_Req_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defmsg> p_mq_Msg_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_sender, cft_defack> p_mq_Ack_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_sender, cft_defdatavar> p_sv_DataVar_t;\n\t/// cfm_sender type define end\n\n\t/// constructor\n\tcfm_sender(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_sender(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_Req_t p_ev_Req;\n\tp_mq_Msg_t p_mq_Msg;\n\tp_mq_Ack_t p_mq_Ack;\n\tp_sv_DataVar_t p_sv_DataVar;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender local declarations' algorithm generated code\n\tint r;\n\t// Loop condition declaration\n\tbool Resend;\n\t//End of 'Sender local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Sender function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Sender definitions' algorithm generated code\n\n//End of 'Sender definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sender::cfm_sender(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_sender_dp_if(), p_ev_Req(\"p_ev_Req\"), p_mq_Msg(\n\t\t\t\t\"p_mq_Msg\"), p_mq_Ack(\"p_mq_Ack\"), p_sv_DataVar(\"p_sv_DataVar\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender constructor' algorithm generated code\n\n\t//End of 'Sender constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sender::~cfm_sender(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender destructor' algorithm generated code\n\n\t//End of 'Sender destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_sender::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender pre elaboration' algorithm generated code\n\n\t//End of 'Sender pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_sender::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post elaboration' algorithm generated code\n\n\t//End of 'Sender post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_sender::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender post simulation' algorithm generated code\n\n\t//End of 'Sender post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_sender::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_sender::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Sender initializations' algorithm generated code\n\tr = 0;\n\t//End of 'Sender initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_generator_dp_if.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n//Start of 'Generator includes' algorithm generated code\n\n//End of 'Generator includes' algorithm generated code\n/// Model Header includes end\n\n///    \\defgroup dxgGenerator Function Generator\n//@{\n///        \\page dxpGenerator\n//@{\n///    \\brief Generator function model start\nclass cfm_generator: public cf_core::cf_function, public cfm_generator_dp_if {\npublic:\n\t/// cfm_generator type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_generator> p_ev_Req_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_defdatavar> p_sv_DataVar_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_generator, cft_deftestprod> p_sv_TestProd_t;\n\t/// cfm_generator type define end\n\n\t/// constructor\n\tcfm_generator(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_generator(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_Req_t p_ev_Req;\n\tp_sv_DataVar_t p_sv_DataVar;\n\tp_sv_TestProd_t p_sv_TestProd;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//Start of 'Generator local declarations' algorithm generated code\n\n\t//End of 'Generator local declarations' algorithm generated code\n\n};\n///    \\brief Generator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_generator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_generator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//Start of 'Generator definitions' algorithm generated code\n\n//End of 'Generator definitions' algorithm generated code\n\n/// \\name constructor\n//@{\ncfm_generator::cfm_generator(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_generator_dp_if(), p_ev_Req(\"p_ev_Req\"), p_sv_DataVar(\n\t\t\t\t\"p_sv_DataVar\"), p_sv_TestProd(\"p_sv_TestProd\") {\n\tcf_function::init();\n\n\t//Start of 'Generator constructor' algorithm generated code\n\n\t//End of 'Generator constructor' algorithm generated code\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_generator::~cfm_generator(void) {\n\t//Start of 'Generator destructor' algorithm generated code\n\n\t//End of 'Generator destructor' algorithm generated code\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_generator::cb_before_elaboration(void) {\n\t//Start of 'Generator pre elaboration' algorithm generated code\n\n\t//End of 'Generator pre elaboration' algorithm generated code\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_generator::cb_end_of_elaboration(void) {\n\t//Start of 'Generator post elaboration' algorithm generated code\n\n\t//End of 'Generator post elaboration' algorithm generated code\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_generator::cb_end_of_simulation(void) {\n\t//Start of 'Generator post simulation' algorithm generated code\n\n\t//End of 'Generator post simulation' algorithm generated code\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_generator::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_generator::cb_init_local_vars(void) {\n\n\t//Start of 'Generator initializations' algorithm generated code\n\n\t//End of 'Generator initializations' algorithm generated code\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HybridSchedulingApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hybridschedulingapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP\n\n/// Model Header includes start\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_controller.h\"\n#include \"cfm_producer.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HybridSchedulingApp includes' algorithm generated code\n\n//End of 'HybridSchedulingApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHybridSchedulingApp Function HybridSchedulingApp\n//@{\n///        \\page dxpHybridSchedulingApp\n//@{\n///    \\brief HybridSchedulingApp function model start\nclass cfm_hybridschedulingapp: public cf_core::cf_application {\npublic:\n\t/// cfm_hybridschedulingapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\t/// cfm_hybridschedulingapp type define end\n\n\t/// constructor\n\tcfm_hybridschedulingapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_hybridschedulingapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_consumer* Consumer;\n\tcfm_controller* Controller;\n\tcfm_producer* Producer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQ_t mq_MsgQ;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HybridSchedulingApp local declarations' algorithm generated code\n\n\t//End of 'HybridSchedulingApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief HybridSchedulingApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HybridSchedulingApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hybridschedulingapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hybridschedulingapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HybridSchedulingApp definitions' algorithm generated code\n\n//End of 'HybridSchedulingApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hybridschedulingapp::cfm_hybridschedulingapp(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_MsgQ(\"MsgQ\") {\n\tcf_application::init();\n\tConsumer = new cfm_consumer(\"Consumer\");\n\tController = new cfm_controller(\"Controller\");\n\tProducer = new cfm_producer(\"Producer\");\n\n\t// connections\n\tConsumer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n\n\tProducer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HybridSchedulingApp constructor' algorithm generated code\n\n\t//End of 'HybridSchedulingApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hybridschedulingapp::~cfm_hybridschedulingapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HybridSchedulingApp destructor' algorithm generated code\n\n\t//End of 'HybridSchedulingApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Consumer;\n\tdelete Controller;\n\tdelete Producer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_hybridschedulingapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HybridSchedulingApp pre elaboration' algorithm generated code\n\n\t//End of 'HybridSchedulingApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_hybridschedulingapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HybridSchedulingApp post elaboration' algorithm generated code\n\n//End of 'HybridSchedulingApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_hybridschedulingapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HybridSchedulingApp post simulation' algorithm generated code\n\n\t//End of 'HybridSchedulingApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_hybridschedulingapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_MsgQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_hybridschedulingapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HybridSchedulingApp initializations' algorithm generated code\n\n\t//End of 'HybridSchedulingApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n\n/// Model Header includes start\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Controller includes' algorithm generated code\n\n//End of 'Controller includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgController Function Controller\n//@{\n///        \\page dxpController\n//@{\n///    \\brief Controller function model start\nclass cfm_controller: public cf_core::cf_function {\npublic:\n\t/// cfm_controller type define start\n\n\t/// cfm_controller type define end\n\n\t/// constructor\n\tcfm_controller(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_controller(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller local declarations' algorithm generated code\n\n\t//End of 'Controller local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Controller function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_controller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_controller\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Controller definitions' algorithm generated code\n\n//End of 'Controller definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_controller::cfm_controller(sc_core::sc_module_name name) :\n\t\tcf_function(name) {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller constructor' algorithm generated code\n\n\t//End of 'Controller constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_controller::~cfm_controller(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller destructor' algorithm generated code\n\n\t//End of 'Controller destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_controller::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller pre elaboration' algorithm generated code\n\n\t//End of 'Controller pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_controller::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller post elaboration' algorithm generated code\n\n\t//End of 'Controller post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_controller::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller post simulation' algorithm generated code\n\n\t//End of 'Controller post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_controller::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_controller::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Controller initializations' algorithm generated code\n\n\t//End of 'Controller initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example2App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inheritance_example2app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP\n\n/// Model Header includes start\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_f1.h\"\n#include \"cfm_f2.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example2App includes' algorithm generated code\n\n//End of 'Inheritance_example2App includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInheritance_example2App Function Inheritance_example2App\n//@{\n///        \\page dxpInheritance_example2App\n//@{\n///    \\brief Inheritance_example2App function model start\nclass cfm_inheritance_example2app: public cf_core::cf_application {\npublic:\n\t/// cfm_inheritance_example2app type define start\n\n\t/// cfm_inheritance_example2app type define end\n\n\t/// constructor\n\tcfm_inheritance_example2app(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_inheritance_example2app(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_f1* F1;\n\tcfm_f2* F2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example2App local declarations' algorithm generated code\n\n\t//End of 'Inheritance_example2App local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Inheritance_example2App function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example2App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inheritance_example2app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inheritance_example2app.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example2App definitions' algorithm generated code\n\n//End of 'Inheritance_example2App definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inheritance_example2app::cfm_inheritance_example2app(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name) {\n\tcf_application::init();\n\tF1 = new cfm_f1(\"F1\");\n\tF2 = new cfm_f2(\"F2\");\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example2App constructor' algorithm generated code\n\n\t//End of 'Inheritance_example2App constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inheritance_example2app::~cfm_inheritance_example2app(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example2App destructor' algorithm generated code\n\n\t//End of 'Inheritance_example2App destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete F1;\n\tdelete F2;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_inheritance_example2app::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example2App pre elaboration' algorithm generated code\n\n\t//End of 'Inheritance_example2App pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_inheritance_example2app::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Inheritance_example2App post elaboration' algorithm generated code\n\n//End of 'Inheritance_example2App post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_inheritance_example2app::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example2App post simulation' algorithm generated code\n\n\t//End of 'Inheritance_example2App post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_inheritance_example2app::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_inheritance_example2app::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Inheritance_example2App initializations' algorithm generated code\n\n\t//End of 'Inheritance_example2App initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n\n/// Model Header includes start\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n\n/*Start of 'Inherited classes header' from F1's model property generated code*/\n#include \"camera_class.h\"\n/*End of 'Inherited classes header' from F1's model property generated code*/\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F1 includes' algorithm generated code\n//End of 'F1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n///    \\defgroup dxgF1 Function F1\n//@{\n///        \\page dxpF1\n//@{\n///    \\brief F1 function model start\nclass cfm_f1:\n/*Start of 'Inherited classes declaration' from F1's property generated code*/\npublic camera_class, public cf_core::cf_function\n/*End of 'Inherited classes declaration' from F1's property generated code*/\n{\npublic:\n\t/// cfm_f1 type define start\n\n\t/// cfm_f1 type define end\n\n\t/// constructor\n\tcfm_f1(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_f1(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 local declarations' algorithm generated code\n\n\t//End of 'F1 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief F1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example2app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F1 definitions' algorithm generated code\n\n//End of 'F1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f1::cfm_f1(sc_core::sc_module_name name) :\n\t\t/*Start of 'Inherited classes call' from F1's model property generated code*/\n\t\tcamera_class(640, 480), cf_function(name)\n/*End of 'Inherited classes call' from F1's model property generated code*/\n{\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 constructor' algorithm generated code\n\n\t//End of 'F1 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f1::~cfm_f1(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 destructor' algorithm generated code\n\n\t//End of 'F1 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_f1::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 pre elaboration' algorithm generated code\n\n\t//End of 'F1 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_f1::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 post elaboration' algorithm generated code\n\n\t//End of 'F1 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_f1::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 post simulation' algorithm generated code\n\n\t//End of 'F1 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_f1::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_f1::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F1 initializations' algorithm generated code\n\n\t//End of 'F1 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n\n/// Model Header includes start\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F2 includes' algorithm generated code\n\n//End of 'F2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF2 Function F2\n//@{\n///        \\page dxpF2\n//@{\n///    \\brief F2 function model start\nclass cfm_f2: public cf_core::cf_function {\npublic:\n\t/// cfm_f2 type define start\n\n\t/// cfm_f2 type define end\n\n\t/// constructor\n\tcfm_f2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_f2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 local declarations' algorithm generated code\n\n\t//End of 'F2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief F2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example2app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'F2 definitions' algorithm generated code\n\n//End of 'F2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f2::cfm_f2(sc_core::sc_module_name name) :\n\t\tcf_function(name) {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 constructor' algorithm generated code\n\n\t//End of 'F2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f2::~cfm_f2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 destructor' algorithm generated code\n\n\t//End of 'F2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_f2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 pre elaboration' algorithm generated code\n\n\t//End of 'F2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_f2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 post elaboration' algorithm generated code\n\n\t//End of 'F2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_f2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 post simulation' algorithm generated code\n\n\t//End of 'F2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_f2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_f2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'F2 initializations' algorithm generated code\n\n\t//End of 'F2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CustomizedDispatcherApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_customizeddispatcherapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CustomizedDispatcherApp includes' algorithm generated code\n\n//End of 'CustomizedDispatcherApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCustomizedDispatcherApp Function CustomizedDispatcherApp\n//@{\n///        \\page dxpCustomizedDispatcherApp\n//@{\n///    \\brief CustomizedDispatcherApp function model start\nclass cfm_customizeddispatcherapp: public cf_core::cf_application {\npublic:\n\t/// cfm_customizeddispatcherapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\t/// cfm_customizeddispatcherapp type define end\n\n\t/// constructor\n\tcfm_customizeddispatcherapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_customizeddispatcherapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_consumer*> Consumer_vec;\n\tstd::vector<cfm_producer*> Producer_vec;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tstd::vector<mq_MsgQ_t*> mq_MsgQ_vec;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedDispatcherApp local declarations' algorithm generated code\n\n\t//End of 'CustomizedDispatcherApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CustomizedDispatcherApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CustomizedDispatcherApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_customizeddispatcherapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_customizeddispatcherapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CustomizedDispatcherApp definitions' algorithm generated code\n\n//End of 'CustomizedDispatcherApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_customizeddispatcherapp::cfm_customizeddispatcherapp(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name) {\n\tcf_application::init();\n\n\t// instantiation of Consumer_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_consumer* module = new cfm_consumer(\n\t\t\t\tcf_string(\"Consumer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tConsumer_vec.push_back(module);\n\t}\n\t// instantiation of Producer_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_producer* module = new cfm_producer(\n\t\t\t\tcf_string(\"Producer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tProducer_vec.push_back(module);\n\t}\n\t// instantiation of mq_MsgQ_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tmq_MsgQ_t* module = new mq_MsgQ_t(cf_string(\"MsgQ[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tmq_MsgQ_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_consumer* module = Consumer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count) 2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_producer* module = Producer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tfor (cf_count j = 0; j < (cf_count) 2; j++) {\n\t\t\t\tmodule->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n\t\t\t}\n\t\t}\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedDispatcherApp constructor' algorithm generated code\n\n\t//End of 'CustomizedDispatcherApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_customizeddispatcherapp::~cfm_customizeddispatcherapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedDispatcherApp destructor' algorithm generated code\n\n\t//End of 'CustomizedDispatcherApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_consumer*>::const_iterator vi = Consumer_vec.begin();\n\t\t\tvi != Consumer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_producer*>::const_iterator vi = Producer_vec.begin();\n\t\t\tvi != Producer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<mq_MsgQ_t*>::const_iterator vi = mq_MsgQ_vec.begin();\n\t\t\tvi != mq_MsgQ_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_customizeddispatcherapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedDispatcherApp pre elaboration' algorithm generated code\n\n\t//End of 'CustomizedDispatcherApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_customizeddispatcherapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CustomizedDispatcherApp post elaboration' algorithm generated code\n\n//End of 'CustomizedDispatcherApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_customizeddispatcherapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedDispatcherApp post simulation' algorithm generated code\n\n\t//End of 'CustomizedDispatcherApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_customizeddispatcherapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\t(*mq_MsgQ_vec[i]).cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\t\t(*mq_MsgQ_vec[i]).cfa_queue_capacity.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_concurrency.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_send_threshold.init((cf_nonzero_count) 1);\n\t\t(*mq_MsgQ_vec[i]).cfa_receive_threshold.init((cf_nonzero_count) 1);\n\t}\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_customizeddispatcherapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedDispatcherApp initializations' algorithm generated code\n\n\t//End of 'CustomizedDispatcherApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizeddispatcherapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizeddispatcherapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CustomizedSchedulerApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_customizedschedulerapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n\n/// Model Header includes start\n#include <vector>\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CustomizedSchedulerApp includes' algorithm generated code\n\n//End of 'CustomizedSchedulerApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCustomizedSchedulerApp Function CustomizedSchedulerApp\n//@{\n///        \\page dxpCustomizedSchedulerApp\n//@{\n///    \\brief CustomizedSchedulerApp function model start\nclass cfm_customizedschedulerapp: public cf_core::cf_application {\npublic:\n\t/// cfm_customizedschedulerapp type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n\t/// cfm_customizedschedulerapp type define end\n\n\t/// constructor\n\tcfm_customizedschedulerapp(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_customizedschedulerapp(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tstd::vector<cfm_consumer*> Consumer_vec;\n\tstd::vector<cfm_producer*> Producer_vec;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_MsgQ_t mq_MsgQ;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedSchedulerApp local declarations' algorithm generated code\n\n\t//End of 'CustomizedSchedulerApp local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CustomizedSchedulerApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CustomizedSchedulerApp', 'models': [{'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_customizedschedulerapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_customizedschedulerapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CustomizedSchedulerApp definitions' algorithm generated code\n\n//End of 'CustomizedSchedulerApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_customizedschedulerapp::cfm_customizedschedulerapp(\n\t\tsc_core::sc_module_name name) :\n\t\tcf_application(name), mq_MsgQ(\"MsgQ\") {\n\tcf_application::init();\n\n\t// instantiation of Consumer_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_consumer* module = new cfm_consumer(\n\t\t\t\tcf_string(\"Consumer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tConsumer_vec.push_back(module);\n\t}\n\t// instantiation of Producer_vec\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_producer* module = new cfm_producer(\n\t\t\t\tcf_string(\"Producer[%d]\", i).c_str());\n\t\tCF_ASSERT (module)\n\t\tProducer_vec.push_back(module);\n\t}\n\t// connections\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_consumer* module = Consumer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tmodule->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n\t\t}\n\t}\n\n\tfor (cf_count i = 0; i < (cf_count) 2; i++) {\n\t\tcfm_producer* module = Producer_vec[i];\n\t\tif (module != nullptr) {\n\t\t\tmodule->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n\t\t}\n\t}\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedSchedulerApp constructor' algorithm generated code\n\n\t//End of 'CustomizedSchedulerApp constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_customizedschedulerapp::~cfm_customizedschedulerapp(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedSchedulerApp destructor' algorithm generated code\n\n\t//End of 'CustomizedSchedulerApp destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tfor (vector<cfm_consumer*>::const_iterator vi = Consumer_vec.begin();\n\t\t\tvi != Consumer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n\tfor (vector<cfm_producer*>::const_iterator vi = Producer_vec.begin();\n\t\t\tvi != Producer_vec.end(); vi++) {\n\t\tdelete (*vi);\n\t}\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_customizedschedulerapp::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedSchedulerApp pre elaboration' algorithm generated code\n\n\t//End of 'CustomizedSchedulerApp pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_customizedschedulerapp::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CustomizedSchedulerApp post elaboration' algorithm generated code\n\n//End of 'CustomizedSchedulerApp post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_customizedschedulerapp::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedSchedulerApp post simulation' algorithm generated code\n\n\t//End of 'CustomizedSchedulerApp post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_customizedschedulerapp::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_MsgQ.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_MsgQ.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_MsgQ.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_MsgQ.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_customizedschedulerapp::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CustomizedSchedulerApp initializations' algorithm generated code\n\n\t//End of 'CustomizedSchedulerApp initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer includes' algorithm generated code\n\n//End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer: public cf_core::cf_function {\npublic:\n\t/// cfm_producer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_producer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_producer type define end\n\n\t/// constructor\n\tcfm_producer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_producer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer local declarations' algorithm generated code\n\n\t//End of 'Producer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizedschedulerapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Producer definitions' algorithm generated code\n\n//End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer::cfm_producer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer constructor' algorithm generated code\n\n\t//End of 'Producer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer destructor' algorithm generated code\n\n\t//End of 'Producer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_producer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer pre elaboration' algorithm generated code\n\n\t//End of 'Producer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_producer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post elaboration' algorithm generated code\n\n\t//End of 'Producer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_producer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer post simulation' algorithm generated code\n\n\t//End of 'Producer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Producer initializations' algorithm generated code\n\n\t//End of 'Producer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer includes' algorithm generated code\n\n//End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer: public cf_core::cf_function {\npublic:\n\t/// cfm_consumer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_consumer,\n\t\t\tcf_core::cf_payload_int> p_mq_MsgQ_t;\n\t/// cfm_consumer type define end\n\n\t/// constructor\n\tcfm_consumer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_consumer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_MsgQ_t p_mq_MsgQ;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer local declarations' algorithm generated code\n\n\t//End of 'Consumer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizedschedulerapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Consumer definitions' algorithm generated code\n\n//End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer::cfm_consumer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_MsgQ(\"p_mq_MsgQ\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer constructor' algorithm generated code\n\n\t//End of 'Consumer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer destructor' algorithm generated code\n\n\t//End of 'Consumer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_consumer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer pre elaboration' algorithm generated code\n\n\t//End of 'Consumer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_consumer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post elaboration' algorithm generated code\n\n\t//End of 'Consumer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_consumer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer post simulation' algorithm generated code\n\n\t//End of 'Consumer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Consumer initializations' algorithm generated code\n\n\t//End of 'Consumer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MyModel', 'models': [{'name': 'packet_in', 'type': 'cofluent:Function'}, {'name': 'packet_out', 'type': 'cofluent:Function'}, {'name': 'packet_process', 'type': 'cofluent:Function'}], 'relations': [{'name': 'p_in', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_in', 'packet_process']}, {'name': 'p_out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_out', 'packet_process']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mymodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL\n#define COFS_MODEL_MYMODEL\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_packet_in.h\"\n#include \"cfm_packet_out.h\"\n#include \"cfm_packet_process.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MyModel includes' algorithm generated code\n\n//End of 'MyModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMyModel Function MyModel\n//@{\n///        \\page dxpMyModel\n//@{\n///    \\brief MyModel function model start\nclass cfm_mymodel: public cf_core::cf_application {\npublic:\n\t/// cfm_mymodel type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_p_in_t;\n\ttypedef cf_core::cf_message_queue<cft_defpacket> mq_p_out_t;\n\n\t/// cfm_mymodel type define end\n\n\t/// constructor\n\tcfm_mymodel(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_mymodel(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_packet_in* packet_in;\n\tcfm_packet_out* packet_out;\n\tcfm_packet_process* packet_process;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_p_in_t mq_p_in;\n\tmq_p_out_t mq_p_out;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MyModel local declarations' algorithm generated code\n\n\t//End of 'MyModel local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief MyModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MyModel', 'models': [{'name': 'packet_in', 'type': 'cofluent:Function'}, {'name': 'packet_out', 'type': 'cofluent:Function'}, {'name': 'packet_process', 'type': 'cofluent:Function'}], 'relations': [{'name': 'p_in', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_in', 'packet_process']}, {'name': 'p_out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_out', 'packet_process']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mymodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mymodel.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MyModel definitions' algorithm generated code\n\n//End of 'MyModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mymodel::cfm_mymodel(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_p_in(\"p_in\"), mq_p_out(\"p_out\") {\n\tcf_application::init();\n\tpacket_in = new cfm_packet_in(\"packet_in\");\n\tpacket_out = new cfm_packet_out(\"packet_out\");\n\tpacket_process = new cfm_packet_process(\"packet_process\");\n\n\t// connections\n\tpacket_in->p_mq_p_in(mq_p_in.p_target_socket);\n\n\tpacket_out->p_mq_p_out(mq_p_out.p_target_socket);\n\n\tpacket_process->p_mq_p_in(mq_p_in.p_target_socket);\n\tpacket_process->p_mq_p_out(mq_p_out.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MyModel constructor' algorithm generated code\n\n\t//End of 'MyModel constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mymodel::~cfm_mymodel(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MyModel destructor' algorithm generated code\n\n\t//End of 'MyModel destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete packet_in;\n\tdelete packet_out;\n\tdelete packet_process;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_mymodel::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MyModel pre elaboration' algorithm generated code\n\n\t//End of 'MyModel pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_mymodel::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'MyModel post elaboration' algorithm generated code\n// initialize socket server\n\tcf_csl::cf_csl_init_socket_server(\"1250\");\n//End of 'MyModel post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_mymodel::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MyModel post simulation' algorithm generated code\n\n\t//End of 'MyModel post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_mymodel::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_p_in.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_in.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_in.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_p_in.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_p_in.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_p_in.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_p_in.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_out.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_p_out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_p_out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_p_out.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_mymodel::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'MyModel initializations' algorithm generated code\n\n\t//End of 'MyModel initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_in', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_packet_in\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_IN\n#define COFS_MODEL_MYMODEL_PACKET_IN\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'packet_in includes' algorithm generated code\n\n//End of 'packet_in includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgpacket_in Function packet_in\n//@{\n///        \\page dxppacket_in\n//@{\n///    \\brief packet_in function model start\nclass cfm_packet_in: public cf_core::cf_function {\npublic:\n\t/// cfm_packet_in type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_in, cft_defpacket> p_mq_p_in_t;\n\t/// cfm_packet_in type define end\n\n\t/// constructor\n\tcfm_packet_in(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_packet_in(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_p_in_t p_mq_p_in;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_in local declarations' algorithm generated code\n\t// synchronization event callback\n\tvoid my_callback();\n\t// synchronization event declaration\n\tCSL_SYNC_EV_DECL\n\t//End of 'packet_in local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief packet_in function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL_PACKET_IN\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_in', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_packet_in\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_packet_in.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_in\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'packet_in definitions' algorithm generated code\n// synchronization event callback definition\nvoid cfm_packet_in::my_callback() {\n\t// notify internal synchronization event\n\tCF_CSL_NOTIFY_SYNC_EV\n}\n//End of 'packet_in definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_packet_in::cfm_packet_in(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_p_in(\"p_mq_p_in\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_in constructor' algorithm generated code\n\t// set synchronization callback\n\tCF_CSL_SET_SYNC_CB (cfm_packet_in::my_callback)\n\t//End of 'packet_in constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_packet_in::~cfm_packet_in(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_in destructor' algorithm generated code\n\n\t//End of 'packet_in destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_packet_in::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_in pre elaboration' algorithm generated code\n\n\t//End of 'packet_in pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_packet_in::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_in post elaboration' algorithm generated code\n\n\t//End of 'packet_in post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_packet_in::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_in post simulation' algorithm generated code\n\n\t//End of 'packet_in post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_packet_in::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_packet_in::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_in initializations' algorithm generated code\n\n\t//End of 'packet_in initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_out', 'type': 'cofluent:Function', 'ports': [{'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_packet_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_OUT\n#define COFS_MODEL_MYMODEL_PACKET_OUT\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'packet_out includes' algorithm generated code\n\n//End of 'packet_out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgpacket_out Function packet_out\n//@{\n///        \\page dxppacket_out\n//@{\n///    \\brief packet_out function model start\nclass cfm_packet_out: public cf_core::cf_function {\npublic:\n\t/// cfm_packet_out type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_out, cft_defpacket> p_mq_p_out_t;\n\t/// cfm_packet_out type define end\n\n\t/// constructor\n\tcfm_packet_out(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_packet_out(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_p_out_t p_mq_p_out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_out local declarations' algorithm generated code\n\n\t//End of 'packet_out local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief packet_out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL_PACKET_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_out', 'type': 'cofluent:Function', 'ports': [{'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_packet_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_packet_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'packet_out definitions' algorithm generated code\n\n//End of 'packet_out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_packet_out::cfm_packet_out(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_p_out(\"p_mq_p_out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_out constructor' algorithm generated code\n\n\t//End of 'packet_out constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_packet_out::~cfm_packet_out(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_out destructor' algorithm generated code\n\n\t//End of 'packet_out destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_packet_out::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_out pre elaboration' algorithm generated code\n\n\t//End of 'packet_out pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_packet_out::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_out post elaboration' algorithm generated code\n\n\t//End of 'packet_out post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_packet_out::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_out post simulation' algorithm generated code\n\n\t//End of 'packet_out post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_packet_out::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_packet_out::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_out initializations' algorithm generated code\n\n\t//End of 'packet_out initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_process', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_packet_process\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_PROCESS\n#define COFS_MODEL_MYMODEL_PACKET_PROCESS\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'packet_process includes' algorithm generated code\n\n//End of 'packet_process includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgpacket_process Function packet_process\n//@{\n///        \\page dxppacket_process\n//@{\n///    \\brief packet_process function model start\nclass cfm_packet_process: public cf_core::cf_function {\npublic:\n\t/// cfm_packet_process type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_process, cft_defpacket> p_mq_p_in_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_packet_process, cft_defpacket> p_mq_p_out_t;\n\t/// cfm_packet_process type define end\n\n\t/// constructor\n\tcfm_packet_process(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_packet_process(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_p_in_t p_mq_p_in;\n\tp_mq_p_out_t p_mq_p_out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_process local declarations' algorithm generated code\n\n\t//End of 'packet_process local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief packet_process function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL_PACKET_PROCESS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_process', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_packet_process\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_packet_process.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_process\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'packet_process definitions' algorithm generated code\n\n//End of 'packet_process definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_packet_process::cfm_packet_process(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_p_in(\"p_mq_p_in\"), p_mq_p_out(\"p_mq_p_out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_process constructor' algorithm generated code\n\n\t//End of 'packet_process constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_packet_process::~cfm_packet_process(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_process destructor' algorithm generated code\n\n\t//End of 'packet_process destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_packet_process::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_process pre elaboration' algorithm generated code\n\n\t//End of 'packet_process pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_packet_process::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_process post elaboration' algorithm generated code\n\n\t//End of 'packet_process post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_packet_process::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_process post simulation' algorithm generated code\n\n\t//End of 'packet_process post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_packet_process::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_packet_process::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'packet_process initializations' algorithm generated code\n\n\t//End of 'packet_process initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TLM2AT', 'models': [{'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_tlm2at\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT\n#define COFS_MODEL_TLM2AT\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"at_top.h\"\n#include \"cfm_reader.h\"\n#include \"cfm_target.h\"\n#include \"cfm_target_2.h\"\n#include \"cfm_writer.h\"\n#include \"wrappers/cfm_initiatorreader_tlm2_at_initiator.h\"\n#include \"wrappers/cfm_initiatorwriter_tlm2_at_initiator.h\"\n#include \"wrappers/cfm_targetrequest_tlm2_at_target.h\"\n#include \"wrappers/cfm_targetwrapper_tlm2_at_target.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TLM2AT includes' algorithm generated code\n\n//End of 'TLM2AT includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTLM2AT Function TLM2AT\n//@{\n///        \\page dxpTLM2AT\n//@{\n///    \\brief TLM2AT function model start\nclass cfm_tlm2at: public cf_core::cf_application {\npublic:\n\t/// cfm_tlm2at type define start\n\t/// systemC IPs typedef\n\ttypedef at_top TLM2Platfom_t;\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorReader_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_ReaderResponse_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_message_queue<cft_defmsgq> mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_event ev_Sync_t;\n\ttypedef cf_core::cf_event ev_Sync2_t;\n\ttypedef cf_core::cf_event ev_Sync3_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetRequest_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetResponse_t;\n\ttypedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2> mq_TargetWrapper_t;\n\n\t/// cfm_tlm2at type define end\n\n\t/// constructor\n\tcfm_tlm2at(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_tlm2at(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_reader* Reader;\n\tTLM2Platfom_t* TLM2Platfom;\n\tcfm_target* Target;\n\tcfm_target_2* Target_2;\n\tcfm_writer* Writer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_InitiatorReader_t mq_InitiatorReader;\n\tmq_InitiatorWriter_t mq_InitiatorWriter;\n\tmq_ReaderResponse_t mq_ReaderResponse;\n\tmq_ReferenceQueue_t mq_ReferenceQueue;\n\tmq_ReferenceQueue2_t mq_ReferenceQueue2;\n\tmq_ReferenceQueue3_t mq_ReferenceQueue3;\n\tev_Sync_t ev_Sync;\n\tev_Sync2_t ev_Sync2;\n\tev_Sync3_t ev_Sync3;\n\tmq_TargetRequest_t mq_TargetRequest;\n\tmq_TargetResponse_t mq_TargetResponse;\n\tmq_TargetWrapper_t mq_TargetWrapper;\n\t//@}\n\nprotected:\n\t/// \\name wrappers\n\t//@{\n\tcfm_initiatorreader_tlm2_at_initiator initiatorreader_tlm2_at_initiator;\n\tcfm_initiatorwriter_tlm2_at_initiator initiatorwriter_tlm2_at_initiator;\n\tcfm_targetrequest_tlm2_at_target targetrequest_tlm2_at_target;\n\tcfm_targetwrapper_tlm2_at_target targetwrapper_tlm2_at_target;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2AT local declarations' algorithm generated code\n\n\t//End of 'TLM2AT local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief TLM2AT function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TLM2AT', 'models': [{'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Writer', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_tlm2at\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_tlm2at.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TLM2AT definitions' algorithm generated code\n\n//End of 'TLM2AT definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_tlm2at::cfm_tlm2at(sc_core::sc_module_name name) :\n\t\tcf_application(name), mq_InitiatorReader(\"InitiatorReader\"), mq_InitiatorWriter(\n\t\t\t\t\"InitiatorWriter\"), mq_ReaderResponse(\"ReaderResponse\"), mq_ReferenceQueue(\n\t\t\t\t\"ReferenceQueue\"), mq_ReferenceQueue2(\"ReferenceQueue2\"), mq_ReferenceQueue3(\n\t\t\t\t\"ReferenceQueue3\"), ev_Sync(\"Sync\"), ev_Sync2(\"Sync2\"), ev_Sync3(\n\t\t\t\t\"Sync3\"), mq_TargetRequest(\"TargetRequest\"), mq_TargetResponse(\n\t\t\t\t\"TargetResponse\"), mq_TargetWrapper(\"TargetWrapper\"), initiatorreader_tlm2_at_initiator(\n\t\t\t\t\"initiatorreader_tlm2_at_initiator\"), initiatorwriter_tlm2_at_initiator(\n\t\t\t\t\"initiatorwriter_tlm2_at_initiator\"), targetrequest_tlm2_at_target(\n\t\t\t\t\"targetrequest_tlm2_at_target\"), targetwrapper_tlm2_at_target(\n\t\t\t\t\"targetwrapper_tlm2_at_target\") {\n\tcf_application::init();\n\tReader = new cfm_reader(\"Reader\");\n\tTLM2Platfom = new TLM2Platfom_t(\"TLM2Platfom\");\n\tTarget = new cfm_target(\"Target\");\n\tTarget_2 = new cfm_target_2(\"Target_2\");\n\tWriter = new cfm_writer(\"Writer\");\n\n\t// connections\n\tReader->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n\tReader->p_mq_InitiatorReader(mq_InitiatorReader.p_target_socket);\n\tReader->p_mq_ReaderResponse(mq_ReaderResponse.p_target_socket);\n\tReader->p_ev_Sync(ev_Sync.p_target_socket);\n\n\tinitiatorwriter_tlm2_at_initiator.p_tlm2(\n\t\t\tTLM2Platfom->interconnect->targ_socket);\n\tTLM2Platfom->interconnect->init_socket(targetwrapper_tlm2_at_target.p_tlm2);\n\tinitiatorreader_tlm2_at_initiator.p_tlm2(\n\t\t\tTLM2Platfom->interconnect->targ_socket);\n\tTLM2Platfom->interconnect->init_socket(targetrequest_tlm2_at_target.p_tlm2);\n\n\tTarget->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n\tTarget->p_mq_TargetWrapper(mq_TargetWrapper.p_target_socket);\n\tTarget->p_ev_Sync2(ev_Sync2.p_target_socket);\n\n\tTarget_2->p_mq_TargetRequest(mq_TargetRequest.p_target_socket);\n\tTarget_2->p_mq_TargetResponse(mq_TargetResponse.p_target_socket);\n\tTarget_2->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n\tTarget_2->p_ev_Sync3(ev_Sync3.p_target_socket);\n\n\tWriter->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n\tWriter->p_mq_InitiatorWriter(mq_InitiatorWriter.p_target_socket);\n\tWriter->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n\tWriter->p_ev_Sync(ev_Sync.p_target_socket);\n\tWriter->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n\tWriter->p_ev_Sync2(ev_Sync2.p_target_socket);\n\tWriter->p_ev_Sync3(ev_Sync3.p_target_socket);\n\n\tinitiatorreader_tlm2_at_initiator.p_mq_request(\n\t\t\tmq_InitiatorReader.p_target_socket);\n\tinitiatorreader_tlm2_at_initiator.p_mq_response(\n\t\t\tmq_ReaderResponse.p_target_socket);\n\tinitiatorwriter_tlm2_at_initiator.p_mq_request(\n\t\t\tmq_InitiatorWriter.p_target_socket);\n\ttargetrequest_tlm2_at_target.p_mq_request(mq_TargetRequest.p_target_socket);\n\ttargetrequest_tlm2_at_target.p_mq_response(\n\t\t\tmq_TargetResponse.p_target_socket);\n\ttargetwrapper_tlm2_at_target.p_mq_request(mq_TargetWrapper.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2AT constructor' algorithm generated code\n\n\t//End of 'TLM2AT constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_tlm2at::~cfm_tlm2at(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2AT destructor' algorithm generated code\n\n\t//End of 'TLM2AT destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Reader;\n\tdelete TLM2Platfom;\n\tdelete Target;\n\tdelete Target_2;\n\tdelete Writer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_tlm2at::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2AT pre elaboration' algorithm generated code\n\n\t//End of 'TLM2AT pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_tlm2at::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'TLM2AT post elaboration' algorithm generated code\n\n//End of 'TLM2AT post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_tlm2at::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2AT post simulation' algorithm generated code\n\n\t//End of 'TLM2AT post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_tlm2at::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_InitiatorReader.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorReader.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorReader.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_InitiatorWriter.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorWriter.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_InitiatorWriter.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReaderResponse.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReaderResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReaderResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue2.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_ReferenceQueue3.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReferenceQueue3.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_ReferenceQueue3.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tev_Sync.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync2.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync2.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_Sync3.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_Sync3.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tmq_TargetRequest.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetRequest.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetResponse.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_TargetResponse.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetResponse.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_TargetWrapper.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetWrapper.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_TargetWrapper.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_tlm2at::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'TLM2AT initializations' algorithm generated code\n\n\t//End of 'TLM2AT initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_WRITER\n#define COFS_MODEL_TLM2AT_WRITER\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Writer includes' algorithm generated code\n\n//End of 'Writer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWriter Function Writer\n//@{\n///        \\page dxpWriter\n//@{\n///    \\brief Writer function model start\nclass cfm_writer: public cf_core::cf_function {\npublic:\n\t/// cfm_writer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cf_core::cf_payload_tlm2> p_mq_InitiatorWriter_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_writer, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync2_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_writer> p_ev_Sync3_t;\n\t/// cfm_writer type define end\n\n\t/// constructor\n\tcfm_writer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_writer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_mq_InitiatorWriter_t p_mq_InitiatorWriter;\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_ev_Sync_t p_ev_Sync;\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_ev_Sync2_t p_ev_Sync2;\n\tp_ev_Sync3_t p_ev_Sync3;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer local declarations' algorithm generated code\n\tint data;\n\tmy_ext ext;\n\t//End of 'Writer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Writer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_WRITER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_writer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Writer definitions' algorithm generated code\n\n//End of 'Writer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_writer::cfm_writer(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_ReferenceQueue(\"p_mq_ReferenceQueue\"), p_mq_InitiatorWriter(\n\t\t\t\t\"p_mq_InitiatorWriter\"), p_mq_ReferenceQueue2(\n\t\t\t\t\"p_mq_ReferenceQueue2\"), p_ev_Sync(\"p_ev_Sync\"), p_mq_ReferenceQueue3(\n\t\t\t\t\"p_mq_ReferenceQueue3\"), p_ev_Sync2(\"p_ev_Sync2\"), p_ev_Sync3(\n\t\t\t\t\"p_ev_Sync3\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer constructor' algorithm generated code\n\n\t//End of 'Writer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_writer::~cfm_writer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer destructor' algorithm generated code\n\n\t//End of 'Writer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_writer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer pre elaboration' algorithm generated code\n\n\t//End of 'Writer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_writer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer post elaboration' algorithm generated code\n\n\t//End of 'Writer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_writer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer post simulation' algorithm generated code\n\n\t//End of 'Writer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_writer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_writer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Writer initializations' algorithm generated code\n\n\t//End of 'Writer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_TARGET\n#define COFS_MODEL_TLM2AT_TARGET\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target includes' algorithm generated code\n\n//End of 'Target includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget Function Target\n//@{\n///        \\page dxpTarget\n//@{\n///    \\brief Target function model start\nclass cfm_target: public cf_core::cf_function {\npublic:\n\t/// cfm_target type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cft_defdata> p_mq_ReferenceQueue2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target, cf_core::cf_payload_tlm2> p_mq_TargetWrapper_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target> p_ev_Sync2_t;\n\t/// cfm_target type define end\n\n\t/// constructor\n\tcfm_target(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_target(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ReferenceQueue2_t p_mq_ReferenceQueue2;\n\tp_mq_TargetWrapper_t p_mq_TargetWrapper;\n\tp_ev_Sync2_t p_ev_Sync2;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target local declarations' algorithm generated code\n\n\t//End of 'Target local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Target function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_TARGET\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target definitions' algorithm generated code\n\n//End of 'Target definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target::cfm_target(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_ReferenceQueue2(\"p_mq_ReferenceQueue2\"), p_mq_TargetWrapper(\n\t\t\t\t\"p_mq_TargetWrapper\"), p_ev_Sync2(\"p_ev_Sync2\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target constructor' algorithm generated code\n\n\t//End of 'Target constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target::~cfm_target(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target destructor' algorithm generated code\n\n\t//End of 'Target destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_target::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target pre elaboration' algorithm generated code\n\n\t//End of 'Target pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_target::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post elaboration' algorithm generated code\n\n\t//End of 'Target post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_target::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target post simulation' algorithm generated code\n\n\t//End of 'Target post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_target::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_target::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target initializations' algorithm generated code\n\n\t//End of 'Target initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_READER\n#define COFS_MODEL_TLM2AT_READER\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Reader includes' algorithm generated code\n\n//End of 'Reader includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReader Function Reader\n//@{\n///        \\page dxpReader\n//@{\n///    \\brief Reader function model start\nclass cfm_reader: public cf_core::cf_function {\npublic:\n\t/// cfm_reader type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cft_defmsgq> p_mq_ReferenceQueue3_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_InitiatorReader_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_reader, cf_core::cf_payload_tlm2> p_mq_ReaderResponse_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_reader> p_ev_Sync_t;\n\t/// cfm_reader type define end\n\n\t/// constructor\n\tcfm_reader(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_reader(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ReferenceQueue3_t p_mq_ReferenceQueue3;\n\tp_mq_InitiatorReader_t p_mq_InitiatorReader;\n\tp_mq_ReaderResponse_t p_mq_ReaderResponse;\n\tp_ev_Sync_t p_ev_Sync;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader local declarations' algorithm generated code\n\tint data;\n\t//End of 'Reader local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Reader function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_READER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_reader.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reader\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Reader definitions' algorithm generated code\n\n//End of 'Reader definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_reader::cfm_reader(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_ReferenceQueue3(\"p_mq_ReferenceQueue3\"), p_mq_InitiatorReader(\n\t\t\t\t\"p_mq_InitiatorReader\"), p_mq_ReaderResponse(\n\t\t\t\t\"p_mq_ReaderResponse\"), p_ev_Sync(\"p_ev_Sync\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader constructor' algorithm generated code\n\n\t//End of 'Reader constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_reader::~cfm_reader(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader destructor' algorithm generated code\n\n\t//End of 'Reader destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_reader::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader pre elaboration' algorithm generated code\n\n\t//End of 'Reader pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_reader::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader post elaboration' algorithm generated code\n\n\t//End of 'Reader post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_reader::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader post simulation' algorithm generated code\n\n\t//End of 'Reader post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_reader::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_reader::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Reader initializations' algorithm generated code\n\n\t//End of 'Reader initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_TARGET_2\n#define COFS_MODEL_TLM2AT_TARGET_2\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target_2 includes' algorithm generated code\n\n//End of 'Target_2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget_2 Function Target_2\n//@{\n///        \\page dxpTarget_2\n//@{\n///    \\brief Target_2 function model start\nclass cfm_target_2: public cf_core::cf_function {\npublic:\n\t/// cfm_target_2 type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2,\n\t\t\tcf_core::cf_payload_tlm2> p_mq_TargetRequest_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2,\n\t\t\tcf_core::cf_payload_tlm2> p_mq_TargetResponse_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_target_2, cft_defdata> p_mq_ReferenceQueue_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_target_2> p_ev_Sync3_t;\n\t/// cfm_target_2 type define end\n\n\t/// constructor\n\tcfm_target_2(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_target_2(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_TargetRequest_t p_mq_TargetRequest;\n\tp_mq_TargetResponse_t p_mq_TargetResponse;\n\tp_mq_ReferenceQueue_t p_mq_ReferenceQueue;\n\tp_ev_Sync3_t p_ev_Sync3;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 local declarations' algorithm generated code\n\n\t//End of 'Target_2 local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Target_2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_TARGET_2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target_2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target_2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Target_2 definitions' algorithm generated code\n\n//End of 'Target_2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target_2::cfm_target_2(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_TargetRequest(\"p_mq_TargetRequest\"), p_mq_TargetResponse(\n\t\t\t\t\"p_mq_TargetResponse\"), p_mq_ReferenceQueue(\n\t\t\t\t\"p_mq_ReferenceQueue\"), p_ev_Sync3(\"p_ev_Sync3\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 constructor' algorithm generated code\n\n\t//End of 'Target_2 constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target_2::~cfm_target_2(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 destructor' algorithm generated code\n\n\t//End of 'Target_2 destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_target_2::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 pre elaboration' algorithm generated code\n\n\t//End of 'Target_2 pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_target_2::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 post elaboration' algorithm generated code\n\n\t//End of 'Target_2 post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_target_2::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 post simulation' algorithm generated code\n\n\t//End of 'Target_2 post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_target_2::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_target_2::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Target_2 initializations' algorithm generated code\n\n\t//End of 'Target_2 initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HwDeviceModel', 'models': [{'name': 'hwDeviceTest', 'type': 'cofluent:Function'}], 'relations': [{'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwdevicemodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL\n#define COFS_MODEL_HWDEVICEMODEL\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_hwdevicetest.h\"\n#include \"dt/cft_defframe.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HwDeviceModel includes' algorithm generated code\n\n//End of 'HwDeviceModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHwDeviceModel Function HwDeviceModel\n//@{\n///        \\page dxpHwDeviceModel\n//@{\n///    \\brief HwDeviceModel function model start\nclass cfm_hwdevicemodel: public cf_core::cf_application {\npublic:\n\t/// cfm_hwdevicemodel type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_inputStream_t;\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_outputStream_t;\n\n\t/// cfm_hwdevicemodel type define end\n\n\t/// constructor\n\tcfm_hwdevicemodel(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_hwdevicemodel(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_hwdevicetest* hwDeviceTest;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_inputStream_t sv_inputStream;\n\tsv_outputStream_t sv_outputStream;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HwDeviceModel local declarations' algorithm generated code\n\n\t//End of 'HwDeviceModel local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief HwDeviceModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HwDeviceModel', 'models': [{'name': 'hwDeviceTest', 'type': 'cofluent:Function'}], 'relations': [{'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwdevicemodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwdevicemodel.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HwDeviceModel definitions' algorithm generated code\n\n//End of 'HwDeviceModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwdevicemodel::cfm_hwdevicemodel(sc_core::sc_module_name name) :\n\t\tcf_application(name), sv_inputStream(\"inputStream\"), sv_outputStream(\n\t\t\t\t\"outputStream\") {\n\tcf_application::init();\n\thwDeviceTest = new cfm_hwdevicetest(\"hwDeviceTest\");\n\n\t// connections\n\thwDeviceTest->p_sv_inputStream(sv_inputStream.p_target_socket);\n\thwDeviceTest->p_sv_outputStream(sv_outputStream.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HwDeviceModel constructor' algorithm generated code\n\n\t//End of 'HwDeviceModel constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwdevicemodel::~cfm_hwdevicemodel(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HwDeviceModel destructor' algorithm generated code\n\n\t//End of 'HwDeviceModel destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete hwDeviceTest;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_hwdevicemodel::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HwDeviceModel pre elaboration' algorithm generated code\n\n\t//End of 'HwDeviceModel pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_hwdevicemodel::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'HwDeviceModel post elaboration' algorithm generated code\n\n//End of 'HwDeviceModel post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_hwdevicemodel::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HwDeviceModel post simulation' algorithm generated code\n\n\t//End of 'HwDeviceModel post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_hwdevicemodel::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tsv_inputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_semaphore.init(false);\n\tsv_inputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\tsv_outputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_semaphore.init(false);\n\tsv_outputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_hwdevicemodel::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'HwDeviceModel initializations' algorithm generated code\n\n\t//End of 'HwDeviceModel initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwDeviceTest', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'hwTestBench', 'type': 'cofluent:Function'}], 'ports': [{'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'hwTestBench']}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwdevicetest\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n#define COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_hwmodel.h\"\n#include \"cfm_hwtestbench.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwDeviceTest includes' algorithm generated code\n\n//End of 'hwDeviceTest includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxghwDeviceTest Function hwDeviceTest\n//@{\n///        \\page dxphwDeviceTest\n//@{\n///    \\brief hwDeviceTest function model start\nclass cfm_hwdevicetest: public cf_core::cf_function_container {\npublic:\n\t/// cfm_hwdevicetest type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_inputFrame_t;\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_outputFrame_t;\n\ttypedef cf_core::cf_shared_variable<cft_defprocessingmode> sv_processingMode_t;\n\ttypedef cf_core::cf_event ev_startProcess_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwdevicetest, cft_defframe> p_sv_inputStream_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwdevicetest, cft_defframe> p_sv_outputStream_t;\n\t/// cfm_hwdevicetest type define end\n\n\t/// constructor\n\tcfm_hwdevicetest(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_hwdevicetest(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_inputStream_t p_sv_inputStream;\n\tp_sv_outputStream_t p_sv_outputStream;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_hwmodel* hwModel;\n\tcfm_hwtestbench* hwTestBench;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_inputFrame_t mq_inputFrame;\n\tmq_outputFrame_t mq_outputFrame;\n\tsv_processingMode_t sv_processingMode;\n\tev_startProcess_t ev_startProcess;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwDeviceTest local declarations' algorithm generated code\n\n\t//End of 'hwDeviceTest local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief hwDeviceTest function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwDeviceTest', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'hwTestBench', 'type': 'cofluent:Function'}], 'ports': [{'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'hwTestBench']}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwdevicetest\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwdevicetest.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicemodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwdevicetest\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwDeviceTest definitions' algorithm generated code\n\n//End of 'hwDeviceTest definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwdevicetest::cfm_hwdevicetest(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), p_sv_inputStream(\"p_sv_inputStream\"), p_sv_outputStream(\n\t\t\t\t\"p_sv_outputStream\"), mq_inputFrame(\"inputFrame\"), mq_outputFrame(\n\t\t\t\t\"outputFrame\"), sv_processingMode(\"processingMode\"), ev_startProcess(\n\t\t\t\t\"startProcess\") {\n\tcf_function_container::init();\n\thwModel = new cfm_hwmodel(\"hwModel\");\n\thwTestBench = new cfm_hwtestbench(\"hwTestBench\");\n\n\t// connections\n\thwModel->p_ev_startProcess(ev_startProcess.p_target_socket);\n\thwModel->p_mq_inputFrame(mq_inputFrame.p_target_socket);\n\thwModel->p_mq_outputFrame(mq_outputFrame.p_target_socket);\n\thwModel->p_sv_processingMode(sv_processingMode.p_target_socket);\n\n\thwTestBench->p_ev_startProcess(ev_startProcess.p_target_socket);\n\thwTestBench->p_mq_inputFrame(mq_inputFrame.p_target_socket);\n\thwTestBench->p_sv_processingMode(sv_processingMode.p_target_socket);\n\thwTestBench->p_mq_outputFrame(mq_outputFrame.p_target_socket);\n\thwTestBench->p_sv_inputStream(p_sv_inputStream);\n\thwTestBench->p_sv_outputStream(p_sv_outputStream);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwDeviceTest constructor' algorithm generated code\n\n\t//End of 'hwDeviceTest constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwdevicetest::~cfm_hwdevicetest(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwDeviceTest destructor' algorithm generated code\n\n\t//End of 'hwDeviceTest destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete hwModel;\n\tdelete hwTestBench;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_hwdevicetest::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwDeviceTest pre elaboration' algorithm generated code\n\n\t//End of 'hwDeviceTest pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_hwdevicetest::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwDeviceTest post elaboration' algorithm generated code\n\n\t//End of 'hwDeviceTest post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_hwdevicetest::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwDeviceTest post simulation' algorithm generated code\n\n\t//End of 'hwDeviceTest post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_hwdevicetest::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tmq_inputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_inputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_outputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tsv_processingMode.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_semaphore.init(false);\n\tsv_processingMode.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_startProcess.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_hwdevicetest::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwDeviceTest initializations' algorithm generated code\n\n\t//End of 'hwDeviceTest initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWMODEL\n#define COFS_MODEL_HWDEVICEMODEL_HWMODEL\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwModel includes' algorithm generated code\n\n//End of 'hwModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxghwModel Function hwModel\n//@{\n///        \\page dxphwModel\n//@{\n///    \\brief hwModel function model start\nclass cfm_hwmodel: public cf_core::cf_function {\npublic:\n\t/// cfm_hwmodel type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_hwmodel> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwmodel, cft_defprocessingmode> p_sv_processingMode_t;\n\t/// cfm_hwmodel type define end\n\n\t/// constructor\n\tcfm_hwmodel(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_hwmodel(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel local declarations' algorithm generated code\n\tvoid revert_frame();\n\t//End of 'hwModel local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief hwModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL_HWMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwmodel.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicetest\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwmodel\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwModel definitions' algorithm generated code\nvoid cfm_hwmodel::revert_frame() {\n\n\t/* Reverting the image means that Pixel 0 becomes Pixel N-1, where N is the frame size (in Pixels)\n\t * In YUV 422 format, it implies to:\n\t *   - Revert the Y table, located at offset 0\n\t *   - Revert the U table, located at offset N\n\t *   - Revert the V table, located at offset N*1.5\n\t */\n\tunsigned char* outpayload = outputFrame.payload;\n\tunsigned char* inpayload = inputFrame.payload;\n\n\t// 'U' table Offset\n\tint offsetU = (int) (NbPixelsPerLineMax * NbLinesMax);\n\t// 'V' table offset\n\tint offsetV = (int) (NbPixelsPerLineMax * NbLinesMax * 1.5);\n\n\t// 4-Pixel block index in a line\n\tint pixel_block_idx = 0;\n\n\t// Line index\n\tint line_idx;\n\n\t// 4-Pixel block offset, from the beginning of the frame\n\tint current_block_ofs = 0;\n\n\t// For each frame line\n\tfor (line_idx = 0; line_idx < NbLinesMax; line_idx++) {\n\t\t// For each pixel block\n\t\tfor (pixel_block_idx = 0; pixel_block_idx < NbPixelsPerLineMax / 4;\n\t\t\t\tpixel_block_idx++) {\n\n\t\t\t// Revert the Y table\n\t\t\toutpayload[offsetU - 1 - current_block_ofs] =\n\t\t\t\t\tinpayload[current_block_ofs + 0];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 1] =\n\t\t\t\t\tinpayload[current_block_ofs + 1];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 2] =\n\t\t\t\t\tinpayload[current_block_ofs + 2];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 3] =\n\t\t\t\t\tinpayload[current_block_ofs + 3];\n\n\t\t\t// Revert the U table\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 0] =\n\t\t\t\t\tinpayload[offsetU + current_block_ofs / 2 + 0];\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 1] =\n\t\t\t\t\tinpayload[offsetU + current_block_ofs / 2 + 1];\n\n\t\t\t// Revert the V table\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1\n\t\t\t\t\t- current_block_ofs / 2 - 0] = inpayload[offsetV\n\t\t\t\t\t+ current_block_ofs / 2 + 0];\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1\n\t\t\t\t\t- current_block_ofs / 2 - 1] = inpayload[offsetV\n\t\t\t\t\t+ current_block_ofs / 2 + 1];\n\n\t\t\tcurrent_block_ofs += 4;\n\n\t\t}\n\t}\n}\n//End of 'hwModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwmodel::cfm_hwmodel(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_ev_startProcess(\"p_ev_startProcess\"), p_mq_inputFrame(\n\t\t\t\t\"p_mq_inputFrame\"), p_mq_outputFrame(\"p_mq_outputFrame\"), p_sv_processingMode(\n\t\t\t\t\"p_sv_processingMode\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel constructor' algorithm generated code\n\n\t//End of 'hwModel constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwmodel::~cfm_hwmodel(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel destructor' algorithm generated code\n\n\t//End of 'hwModel destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_hwmodel::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel pre elaboration' algorithm generated code\n\n\t//End of 'hwModel pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_hwmodel::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel post elaboration' algorithm generated code\n\n\t//End of 'hwModel post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_hwmodel::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel post simulation' algorithm generated code\n\n\t//End of 'hwModel post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_hwmodel::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_hwmodel::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel initializations' algorithm generated code\n\n\t//End of 'hwModel initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwTestBench', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwtestbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n#define COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwTestBench includes' algorithm generated code\n\n//End of 'hwTestBench includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxghwTestBench Function hwTestBench\n//@{\n///        \\page dxphwTestBench\n//@{\n///    \\brief hwTestBench function model start\nclass cfm_hwtestbench: public cf_core::cf_function {\npublic:\n\t/// cfm_hwtestbench type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_hwtestbench> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwtestbench, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwtestbench,\n\t\t\tcft_defprocessingmode> p_sv_processingMode_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwtestbench, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwtestbench, cft_defframe> p_sv_inputStream_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwtestbench, cft_defframe> p_sv_outputStream_t;\n\t/// cfm_hwtestbench type define end\n\n\t/// constructor\n\tcfm_hwtestbench(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_hwtestbench(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tp_sv_inputStream_t p_sv_inputStream;\n\tp_sv_outputStream_t p_sv_outputStream;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwTestBench local declarations' algorithm generated code\n\tstd::string movieInputFile;\n\tint ProducerNbPicture;\n\tint ConsumerNbPicture;\n\tFILE* movieInputFile_f;\n\tint VideoFrameNumber;\n\tint numread;\n\t//End of 'hwTestBench local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief hwTestBench function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwTestBench', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwtestbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwtestbench.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicetest\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwtestbench\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwTestBench definitions' algorithm generated code\n\n//End of 'hwTestBench definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwtestbench::cfm_hwtestbench(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_ev_startProcess(\"p_ev_startProcess\"), p_mq_inputFrame(\n\t\t\t\t\"p_mq_inputFrame\"), p_sv_processingMode(\"p_sv_processingMode\"), p_mq_outputFrame(\n\t\t\t\t\"p_mq_outputFrame\"), p_sv_inputStream(\"p_sv_inputStream\"), p_sv_outputStream(\n\t\t\t\t\"p_sv_outputStream\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwTestBench constructor' algorithm generated code\n\n\t//End of 'hwTestBench constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwtestbench::~cfm_hwtestbench(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwTestBench destructor' algorithm generated code\n\n\t//End of 'hwTestBench destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_hwtestbench::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwTestBench pre elaboration' algorithm generated code\n\n\t//End of 'hwTestBench pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_hwtestbench::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwTestBench post elaboration' algorithm generated code\n\n\t//End of 'hwTestBench post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_hwtestbench::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwTestBench post simulation' algorithm generated code\n\n\t//End of 'hwTestBench post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_hwtestbench::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_hwtestbench::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwTestBench initializations' algorithm generated code\n\tmovieInputFile = \"../../../video_file/susie422.40.qcif\";\n\tcf_trace_report(\"TEST file name = %s\", movieInputFile.c_str());\n\tProducerNbPicture = 0;\n\tConsumerNbPicture = 0;\n\tnumread = 0;\n\t//End of 'hwTestBench initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CompleteDevice', 'models': [{'name': 'device', 'type': 'cofluent:Function'}, {'name': 'testBench', 'type': 'cofluent:Function'}], 'relations': [{'name': 'dpv', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['device', 'testBench']}, {'name': 'newFrame', 'type': 'cofluent:Event', 'connectTo': ['device', 'testBench']}, {'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_completedevice\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE\n#define COFS_MODEL_COMPLETEDEVICE\n\n/// Model Header includes start\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_device.h\"\n#include \"cfm_testbench.h\"\n#include \"dt/cft_defframe.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CompleteDevice includes' algorithm generated code\n\n//End of 'CompleteDevice includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCompleteDevice Function CompleteDevice\n//@{\n///        \\page dxpCompleteDevice\n//@{\n///    \\brief CompleteDevice function model start\nclass cfm_completedevice: public cf_core::cf_application {\npublic:\n\t/// cfm_completedevice type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_inputStream_t;\n\ttypedef cf_core::cf_event ev_newFrame_t;\n\ttypedef cf_core::cf_shared_variable<cft_defframe> sv_outputStream_t;\n\n\t/// cfm_completedevice type define end\n\n\t/// constructor\n\tcfm_completedevice(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_completedevice(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_device* device;\n\tcfm_testbench* testBench;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_inputStream_t sv_inputStream;\n\tev_newFrame_t ev_newFrame;\n\tsv_outputStream_t sv_outputStream;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CompleteDevice local declarations' algorithm generated code\n\n\t//End of 'CompleteDevice local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CompleteDevice function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COMPLETEDEVICE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CompleteDevice', 'models': [{'name': 'device', 'type': 'cofluent:Function'}, {'name': 'testBench', 'type': 'cofluent:Function'}], 'relations': [{'name': 'dpv', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['device', 'testBench']}, {'name': 'newFrame', 'type': 'cofluent:Event', 'connectTo': ['device', 'testBench']}, {'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['testBench']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_completedevice\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_completedevice.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CompleteDevice definitions' algorithm generated code\n\n//End of 'CompleteDevice definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_completedevice::cfm_completedevice(sc_core::sc_module_name name) :\n\t\tcf_application(name), sv_inputStream(\"inputStream\"), ev_newFrame(\n\t\t\t\t\"newFrame\"), sv_outputStream(\"outputStream\") {\n\tcf_application::init();\n\tdevice = new cfm_device(\"device\");\n\ttestBench = new cfm_testbench(\"testBench\");\n\n\t// connections\n\tdevice->p_ev_newFrame(ev_newFrame.p_target_socket);\n\n\ttestBench->dpv(device->dpv);\n\ttestBench->p_ev_newFrame(ev_newFrame.p_target_socket);\n\ttestBench->p_sv_inputStream(sv_inputStream.p_target_socket);\n\ttestBench->p_sv_outputStream(sv_outputStream.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CompleteDevice constructor' algorithm generated code\n\n\t//End of 'CompleteDevice constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_completedevice::~cfm_completedevice(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CompleteDevice destructor' algorithm generated code\n\n\t//End of 'CompleteDevice destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete device;\n\tdelete testBench;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_completedevice::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CompleteDevice pre elaboration' algorithm generated code\n\n\t//End of 'CompleteDevice pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_completedevice::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CompleteDevice post elaboration' algorithm generated code\n\n//End of 'CompleteDevice post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_completedevice::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CompleteDevice post simulation' algorithm generated code\n\n\t//End of 'CompleteDevice post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_completedevice::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tsv_inputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_inputStream.cfa_semaphore.init(false);\n\tsv_inputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_newFrame.cfa_set_time.init(cf_expr_duration(0, CF_NS));\n\tev_newFrame.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_newFrame.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tsv_outputStream.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_outputStream.cfa_semaphore.init(false);\n\tsv_outputStream.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_completedevice::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CompleteDevice initializations' algorithm generated code\n\n\t//End of 'CompleteDevice initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'device', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView'}, {'name': 'mqToCommand', 'type': 'cofluent:Function'}], 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN', 'connectTo': ['swInterface']}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT', 'connectTo': ['swInterface']}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'mqToCommand']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'storeFrame', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['swInterface', 'mqToCommand']}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_DEVICE\n#define COFS_MODEL_COMPLETEDEVICE_DEVICE\n\n/// Model Header includes start\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"cfm_hwmodel.h\"\n#include \"cfm_mqtocommand.h\"\n#include \"cfm_swinterface.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n#include \"mci/cfm_dpv.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'device includes' algorithm generated code\n\n//End of 'device includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgdevice Function device\n//@{\n///        \\page dxpdevice\n//@{\n///    \\brief device function model start\nclass cfm_device: public cf_core::cf_function_container {\npublic:\n\t/// cfm_device type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_inputFrame_t;\n\ttypedef cf_core::cf_message_queue<cft_defframe> mq_outputFrame_t;\n\ttypedef cf_core::cf_shared_variable<cft_defprocessingmode> sv_processingMode_t;\n\ttypedef cf_core::cf_event ev_startProcess_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mci_port<cfm_dpv> dpv_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_device> p_ev_newFrame_t;\n\t/// cfm_device type define end\n\n\t/// constructor\n\tcfm_device(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_device(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tdpv_t dpv;\n\tp_ev_newFrame_t p_ev_newFrame;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_hwmodel* hwModel;\n\tcfm_mqtocommand* mqToCommand;\n\tcfm_swinterface* swInterface;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_inputFrame_t mq_inputFrame;\n\tmq_outputFrame_t mq_outputFrame;\n\tsv_processingMode_t sv_processingMode;\n\tev_startProcess_t ev_startProcess;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'device local declarations' algorithm generated code\n\n\t//End of 'device local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief device function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COMPLETEDEVICE_DEVICE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'device', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView'}, {'name': 'mqToCommand', 'type': 'cofluent:Function'}], 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN', 'connectTo': ['swInterface']}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT', 'connectTo': ['swInterface']}], 'relations': [{'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'mqToCommand']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'swInterface']}, {'name': 'storeFrame', 'type': 'cofluent:MethodCallInterface', 'connectTo': ['swInterface', 'mqToCommand']}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_device.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_completedevice\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_device\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'device definitions' algorithm generated code\n\n//End of 'device definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_device::cfm_device(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), dpv(\"dpv\"), p_ev_newFrame(\"p_ev_newFrame\"), mq_inputFrame(\n\t\t\t\t\"inputFrame\"), mq_outputFrame(\"outputFrame\"), sv_processingMode(\n\t\t\t\t\"processingMode\"), ev_startProcess(\"startProcess\") {\n\tcf_function_container::init();\n\thwModel = new cfm_hwmodel(\"hwModel\");\n\tmqToCommand = new cfm_mqtocommand(\"mqToCommand\");\n\tswInterface = new cfm_swinterface(\"swInterface\");\n\n\t// connections\n\thwModel->p_ev_startProcess(ev_startProcess.p_target_socket);\n\thwModel->p_mq_inputFrame(mq_inputFrame.p_target_socket);\n\thwModel->p_mq_outputFrame(mq_outputFrame.p_target_socket);\n\thwModel->p_sv_processingMode(sv_processingMode.p_target_socket);\n\n\tmqToCommand->p_mq_outputFrame(mq_outputFrame.p_target_socket);\n\tmqToCommand->storeFrame(*swInterface);\n\n\tswInterface->p_ev_startProcess(ev_startProcess.p_target_socket);\n\tdpv (*swInterface);\n\tswInterface->p_mq_inputFrame(mq_inputFrame.p_target_socket);\n\tswInterface->p_ev_newFrame(p_ev_newFrame);\n\tswInterface->p_sv_processingMode(sv_processingMode.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'device constructor' algorithm generated code\n\n\t//End of 'device constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_device::~cfm_device(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'device destructor' algorithm generated code\n\n\t//End of 'device destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete hwModel;\n\tdelete mqToCommand;\n\tdelete swInterface;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_device::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'device pre elaboration' algorithm generated code\n\n\t//End of 'device pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_device::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'device post elaboration' algorithm generated code\n\n\t//End of 'device post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_device::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'device post simulation' algorithm generated code\n\n\t//End of 'device post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_device::cb_init_attributes() {\n\n// initialize function attributes\n// initialize relations attributes\n\tmq_inputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_inputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_inputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_inputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_receive_time.init(cf_expr_duration(1, CF_NS));\n\tmq_outputFrame.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_outputFrame.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_send_threshold.init((cf_nonzero_count) 1);\n\tmq_outputFrame.cfa_receive_threshold.init((cf_nonzero_count) 1);\n\tsv_processingMode.cfa_write_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_read_time.init(cf_expr_duration(1, CF_NS));\n\tsv_processingMode.cfa_semaphore.init(false);\n\tsv_processingMode.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_startProcess.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_startProcess.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_device::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'device initializations' algorithm generated code\n\n\t//End of 'device initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'testBench', 'type': 'cofluent:Function', 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_testbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_TESTBENCH\n#define COFS_MODEL_COMPLETEDEVICE_TESTBENCH\n\n/// Model Header includes start\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n\n#include \"mci/cfm_dpv.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'testBench includes' algorithm generated code\n\n//End of 'testBench includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgtestBench Function testBench\n//@{\n///        \\page dxptestBench\n//@{\n///    \\brief testBench function model start\nclass cfm_testbench: public cf_core::cf_function {\npublic:\n\t/// cfm_testbench type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mci_port<cfm_dpv> dpv_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_testbench> p_ev_newFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_testbench, cft_defframe> p_sv_inputStream_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_testbench, cft_defframe> p_sv_outputStream_t;\n\t/// cfm_testbench type define end\n\n\t/// constructor\n\tcfm_testbench(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_testbench(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tdpv_t dpv;\n\tp_ev_newFrame_t p_ev_newFrame;\n\tp_sv_inputStream_t p_sv_inputStream;\n\tp_sv_outputStream_t p_sv_outputStream;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'testBench local declarations' algorithm generated code\n\t/* Register address definition */\n#define PROCESSED_FRAME_COUNT_REGISTER_ADDR 0x200\n#define PROCESSING_MODE_REGISTER_ADDR 0x100\n\n\tDefFrame inputFrame, outputFrame;\n\tstd::string movieInputFile;\n\tint ProducerNbPicture;\n\tint ConsumerNbPicture;\n\tFILE* movieInputFile_f;\n\tint VideoFrameNumber;\n\tint new_mode;\n\tint numread;\n\t//End of 'testBench local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief testBench function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COMPLETEDEVICE_TESTBENCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'testBench', 'type': 'cofluent:Function', 'ports': [{'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_testbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_testbench.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_completedevice\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_testbench\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'testBench definitions' algorithm generated code\n\n//End of 'testBench definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_testbench::cfm_testbench(sc_core::sc_module_name name) :\n\t\tcf_function(name), dpv(\"dpv\"), p_ev_newFrame(\"p_ev_newFrame\"), p_sv_inputStream(\n\t\t\t\t\"p_sv_inputStream\"), p_sv_outputStream(\"p_sv_outputStream\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'testBench constructor' algorithm generated code\n\n\t//End of 'testBench constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_testbench::~cfm_testbench(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'testBench destructor' algorithm generated code\n\n\t//End of 'testBench destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_testbench::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'testBench pre elaboration' algorithm generated code\n\n\t//End of 'testBench pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_testbench::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'testBench post elaboration' algorithm generated code\n\n\t//End of 'testBench post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_testbench::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'testBench post simulation' algorithm generated code\n\n\t//End of 'testBench post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_testbench::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_testbench::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'testBench initializations' algorithm generated code\n\tmovieInputFile = \"../../../video_file/susie422.40.qcif\";\n\tcf_trace_report(\"TEST file name = %s\", movieInputFile.c_str());\n\tProducerNbPicture = 0;\n\tConsumerNbPicture = 0;\n\tnew_mode = REVERT_MODE;\n\t//End of 'testBench initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_HWMODEL\n#define COFS_MODEL_COMPLETEDEVICE_HWMODEL\n\n/// Model Header includes start\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwModel includes' algorithm generated code\n\n//End of 'hwModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxghwModel Function hwModel\n//@{\n///        \\page dxphwModel\n//@{\n///    \\brief hwModel function model start\nclass cfm_hwmodel: public cf_core::cf_function {\npublic:\n\t/// cfm_hwmodel type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_hwmodel> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_hwmodel, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_hwmodel, cft_defprocessingmode> p_sv_processingMode_t;\n\t/// cfm_hwmodel type define end\n\n\t/// constructor\n\tcfm_hwmodel(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_hwmodel(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel local declarations' algorithm generated code\n\tvoid revert_frame();\n\t//End of 'hwModel local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief hwModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COMPLETEDEVICE_HWMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwmodel.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwmodel\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'hwModel definitions' algorithm generated code\nvoid cfm_hwmodel::revert_frame() {\n\n\t/* Reverting the image means that Pixel 0 becomes Pixel N-1, where N is the frame size (in Pixels)\n\t * In YUV 422 format, it implies to:\n\t *   - Revert the Y table, located at offset 0\n\t *   - Revert the U table, located at offset N\n\t *   - Revert the V table, located at offset N*1.5\n\t */\n\tunsigned char* outpayload = outputFrame.payload;\n\tunsigned char* inpayload = inputFrame.payload;\n\n\t// 'U' table Offset\n\tint offsetU = (int) (NbPixelsPerLineMax * NbLinesMax);\n\t// 'V' table offset\n\tint offsetV = (int) (NbPixelsPerLineMax * NbLinesMax * 1.5);\n\n\t// 4-Pixel block index in a line\n\tint pixel_block_idx = 0;\n\n\t// Line index\n\tint line_idx;\n\n\t// 4-Pixel block offset, from the beginning of the frame\n\tint current_block_ofs = 0;\n\n\t// For each frame line\n\tfor (line_idx = 0; line_idx < NbLinesMax; line_idx++) {\n\t\t// For each pixel block\n\t\tfor (pixel_block_idx = 0; pixel_block_idx < NbPixelsPerLineMax / 4;\n\t\t\t\tpixel_block_idx++) {\n\n\t\t\t// Revert the Y table\n\t\t\toutpayload[offsetU - 1 - current_block_ofs] =\n\t\t\t\t\tinpayload[current_block_ofs + 0];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 1] =\n\t\t\t\t\tinpayload[current_block_ofs + 1];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 2] =\n\t\t\t\t\tinpayload[current_block_ofs + 2];\n\t\t\toutpayload[offsetU - 1 - current_block_ofs - 3] =\n\t\t\t\t\tinpayload[current_block_ofs + 3];\n\n\t\t\t// Revert the U table\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 0] =\n\t\t\t\t\tinpayload[offsetU + current_block_ofs / 2 + 0];\n\t\t\toutpayload[offsetV - 1 - current_block_ofs / 2 - 1] =\n\t\t\t\t\tinpayload[offsetU + current_block_ofs / 2 + 1];\n\n\t\t\t// Revert the V table\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1\n\t\t\t\t\t- current_block_ofs / 2 - 0] = inpayload[offsetV\n\t\t\t\t\t+ current_block_ofs / 2 + 0];\n\t\t\toutpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1\n\t\t\t\t\t- current_block_ofs / 2 - 1] = inpayload[offsetV\n\t\t\t\t\t+ current_block_ofs / 2 + 1];\n\n\t\t\tcurrent_block_ofs += 4;\n\n\t\t}\n\t}\n}\n//End of 'hwModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwmodel::cfm_hwmodel(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_ev_startProcess(\"p_ev_startProcess\"), p_mq_inputFrame(\n\t\t\t\t\"p_mq_inputFrame\"), p_mq_outputFrame(\"p_mq_outputFrame\"), p_sv_processingMode(\n\t\t\t\t\"p_sv_processingMode\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel constructor' algorithm generated code\n\n\t//End of 'hwModel constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwmodel::~cfm_hwmodel(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel destructor' algorithm generated code\n\n\t//End of 'hwModel destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_hwmodel::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel pre elaboration' algorithm generated code\n\n\t//End of 'hwModel pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_hwmodel::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel post elaboration' algorithm generated code\n\n\t//End of 'hwModel post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_hwmodel::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel post simulation' algorithm generated code\n\n\t//End of 'hwModel post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_hwmodel::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_hwmodel::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'hwModel initializations' algorithm generated code\n\n\t//End of 'hwModel initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_swinterface\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_SWINTERFACE\n#define COFS_MODEL_COMPLETEDEVICE_SWINTERFACE\n\n/// Model Header includes start\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n#include \"mci/cfm_dpv.h\"\n#include \"mci/cfm_storeframe.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'swInterface includes' algorithm generated code\n#include <list>\n//End of 'swInterface includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgswInterface Function swInterface\n//@{\n///        \\page dxpswInterface\n//@{\n///    \\brief swInterface function model start\nclass cfm_swinterface: public cf_core::cf_dpv_container,\n\t\tpublic virtual cfm_dpv,\n\t\tpublic virtual cfm_storeframe {\npublic:\n\t/// cfm_swinterface type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_swinterface> p_ev_startProcess_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_swinterface, cft_defframe> p_mq_inputFrame_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_swinterface> p_ev_newFrame_t;\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_swinterface,\n\t\t\tcft_defprocessingmode> p_sv_processingMode_t;\n\t/// cfm_swinterface type define end\n\n\t/// constructor\n\tcfm_swinterface(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_swinterface(void);\n\tvirtual void cb_before_elaboration(void);\n\n\t// default DPV interface implementation\n\tCF_DPV_REGISTER_IF_IMPL;\n\tCF_DPV_REGISTER_INT_IF_IMPL;\n\tCF_DPV_INTERRUPT_IF_IMPL;\n\tCF_DPV_INTERRUPT_INT_IF_IMPL;\n\tCF_DPV_COMMAND_IF_IMPL;\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_startProcess_t p_ev_startProcess;\n\tp_mq_inputFrame_t p_mq_inputFrame;\n\tp_ev_newFrame_t p_ev_newFrame;\n\tp_sv_processingMode_t p_sv_processingMode;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'swInterface local declarations' algorithm generated code\n\tstd::list<DefFrame> frame_memory;\n\tvoid storeOutputFrame(DefFrame* frame);\n\t//End of 'swInterface local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\nprivate:\nprivate:\n\t// DPV ports\n\tDefFrame inputFrame;\n\tcft_defframe inputFrame_trans;\n\tDefProcessingMode processingMode;\n\tcft_defprocessingmode processingMode_trans;\n\n};\n///    \\brief swInterface function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COMPLETEDEVICE_SWINTERFACE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'swInterface', 'type': 'cofluent:DeviceProgrammersView', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'dpv', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'newFrame', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'IN'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_swinterface\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_swinterface.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'swInterface definitions' algorithm generated code\nvoid cfm_swinterface::storeOutputFrame(DefFrame* frame) {\n\tframe_memory.push_back(*frame);\n\tprocessedFrameCount.write(processedFrameCount.read() + 1);\n\traise_interrupt_int(\"newFrameInt\");\n}\n//End of 'swInterface definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_swinterface::cfm_swinterface(sc_core::sc_module_name name) :\n\t\tcf_dpv_container(name), p_ev_startProcess(\"p_ev_startProcess\"), p_mq_inputFrame(\n\t\t\t\t\"p_mq_inputFrame\"), p_ev_newFrame(\"p_ev_newFrame\"), p_sv_processingMode(\n\t\t\t\t\"p_sv_processingMode\") {\n\tcf_dpv_container::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'swInterface constructor' algorithm generated code\n\n\t//End of 'swInterface constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcfa_endianess.init(cf_dt::CF_DPV_ENDIANESS_BIG);\n\n\t// transaction initialization\n\tinputFrame_trans.set_data_ptr(&inputFrame);\n\tprocessingMode_trans.set_data_ptr(&processingMode);\n\n\tcf_dpv_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_swinterface::~cfm_swinterface(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'swInterface destructor' algorithm generated code\n\n\t//End of 'swInterface destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_swinterface::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'swInterface pre elaboration' algorithm generated code\n\n\t//End of 'swInterface pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_swinterface::cb_init_attributes() {\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_swinterface::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'swInterface initializations' algorithm generated code\n\n\t//End of 'swInterface initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'mqToCommand', 'type': 'cofluent:Function', 'ports': [{'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mqtocommand\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COMPLETEDEVICE_MQTOCOMMAND\n#define COFS_MODEL_COMPLETEDEVICE_MQTOCOMMAND\n\n/// Model Header includes start\n#include \"cfm_completedevice_global.h\"\n#include \"cfm_completedevice_global_types.h\"\n#include \"cofluent.h\"\n#include \"dt/cft_defframe.h\"\n\n#include \"mci/cfm_storeframe.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'mqToCommand includes' algorithm generated code\n\n//End of 'mqToCommand includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgmqToCommand Function mqToCommand\n//@{\n///        \\page dxpmqToCommand\n//@{\n///    \\brief mqToCommand function model start\nclass cfm_mqtocommand: public cf_core::cf_function {\npublic:\n\t/// cfm_mqtocommand type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_mqtocommand, cft_defframe> p_mq_outputFrame_t;\n\ttypedef cf_core::cf_mci_port<cfm_storeframe> storeFrame_t;\n\t/// cfm_mqtocommand type define end\n\n\t/// constructor\n\tcfm_mqtocommand(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_mqtocommand(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_outputFrame_t p_mq_outputFrame;\n\tstoreFrame_t storeFrame;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'mqToCommand local declarations' algorithm generated code\n\n\t//End of 'mqToCommand local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief mqToCommand function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COMPLETEDEVICE_MQTOCOMMAND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'mqToCommand', 'type': 'cofluent:Function', 'ports': [{'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'storeFrame', 'type': 'METHOD_CALL_INTERFACE', 'direction': 'OUT'}], 'globalName': 'CompleteDevice'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mqtocommand\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CompleteDevice generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mqtocommand.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mqtocommand\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'mqToCommand definitions' algorithm generated code\n\n//End of 'mqToCommand definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mqtocommand::cfm_mqtocommand(sc_core::sc_module_name name) :\n\t\tcf_function(name), p_mq_outputFrame(\"p_mq_outputFrame\"), storeFrame(\n\t\t\t\t\"storeFrame\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'mqToCommand constructor' algorithm generated code\n\n\t//End of 'mqToCommand constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mqtocommand::~cfm_mqtocommand(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'mqToCommand destructor' algorithm generated code\n\n\t//End of 'mqToCommand destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_mqtocommand::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'mqToCommand pre elaboration' algorithm generated code\n\n\t//End of 'mqToCommand pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_mqtocommand::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'mqToCommand post elaboration' algorithm generated code\n\n\t//End of 'mqToCommand post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_mqtocommand::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'mqToCommand post simulation' algorithm generated code\n\n\t//End of 'mqToCommand post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_mqtocommand::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_mqtocommand::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'mqToCommand initializations' algorithm generated code\n\n\t//End of 'mqToCommand initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Bluetooth_IPs', 'models': [{'name': 'Slave_Stub', 'type': 'cofluent:Function'}, {'name': 'BT_System', 'type': 'cofluent:Function'}, {'name': 'Start', 'type': 'cofluent:Function'}], 'relations': [{'name': 'BaseBand_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'startEv', 'type': 'cofluent:Event', 'connectTo': ['BT_System', 'Start']}, {'name': 'BaseBand_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bluetooth_ips\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS\n#define COFS_MODEL_BLUETOOTH_IPS\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bluetooth_ips_dp_if.h\"\n#include \"cfm_bt_system.h\"\n#include \"cfm_slave_stub.h\"\n#include \"cfm_start.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Bluetooth_IPs includes' algorithm generated code\n\n//End of 'Bluetooth_IPs includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBluetooth_IPs Function Bluetooth_IPs\n//@{\n///        \\page dxpBluetooth_IPs\n//@{\n///    \\brief Bluetooth_IPs function model start\nclass cfm_bluetooth_ips: public cf_core::cf_application,\n\t\tpublic cfm_bluetooth_ips_dp_if {\npublic:\n\t/// cfm_bluetooth_ips type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_BaseBand_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_event ev_startEv_t;\n\n\t/// cfm_bluetooth_ips type define end\n\n\t/// constructor\n\tcfm_bluetooth_ips(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bluetooth_ips(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bt_system* BT_System;\n\tcfm_slave_stub* Slave_Stub;\n\tcfm_start* Start;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_BaseBand_In_t mq_BaseBand_In;\n\tmq_BaseBand_Out_t mq_BaseBand_Out;\n\tev_startEv_t ev_startEv;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs local declarations' algorithm generated code\n\n\t//End of 'Bluetooth_IPs local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Bluetooth_IPs function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Bluetooth_IPs', 'models': [{'name': 'Slave_Stub', 'type': 'cofluent:Function'}, {'name': 'BT_System', 'type': 'cofluent:Function'}, {'name': 'Start', 'type': 'cofluent:Function'}], 'relations': [{'name': 'BaseBand_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'startEv', 'type': 'cofluent:Event', 'connectTo': ['BT_System', 'Start']}, {'name': 'BaseBand_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bluetooth_ips\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bluetooth_ips.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Bluetooth_IPs definitions' algorithm generated code\n\n//End of 'Bluetooth_IPs definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bluetooth_ips::cfm_bluetooth_ips(sc_core::sc_module_name name) :\n\t\tcf_application(name), cfm_bluetooth_ips_dp_if(), mq_BaseBand_In(\n\t\t\t\t\"BaseBand_In\"), mq_BaseBand_Out(\"BaseBand_Out\"), ev_startEv(\n\t\t\t\t\"startEv\") {\n\tcf_application::init();\n\tBT_System = new cfm_bt_system(\"BT_System\");\n\tSlave_Stub = new cfm_slave_stub(\"Slave_Stub\");\n\tStart = new cfm_start(\"Start\");\n\n\t// connections\n\tBT_System->p_mq_BaseBand_Out(mq_BaseBand_Out.p_target_socket);\n\tBT_System->p_mq_BaseBand_In(mq_BaseBand_In.p_target_socket);\n\tBT_System->p_ev_startEv(ev_startEv.p_target_socket);\n\n\tSlave_Stub->p_mq_BaseBand_In(mq_BaseBand_In.p_target_socket);\n\tSlave_Stub->p_mq_BaseBand_Out(mq_BaseBand_Out.p_target_socket);\n\n\tStart->p_ev_startEv(ev_startEv.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs constructor' algorithm generated code\n\n\t//End of 'Bluetooth_IPs constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bluetooth_ips::~cfm_bluetooth_ips(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs destructor' algorithm generated code\n\n\t//End of 'Bluetooth_IPs destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BT_System;\n\tdelete Slave_Stub;\n\tdelete Start;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bluetooth_ips::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs pre elaboration' algorithm generated code\n\n\t//End of 'Bluetooth_IPs pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bluetooth_ips::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Bluetooth_IPs post elaboration' algorithm generated code\n\tnb_file_parts = 0;\n\tnb_OBEX_df = 0;\n\tnb_RFCOMM_df = 0;\n\ttotal_delay_FILE = 0;\n\ttotal_delay_OBEX = 0;\n\ttotal_delay_RFCOMM = 0;\n\tnb_cdts_req = 0;\n\ttotal_L2CAP_data = 0;\n//End of 'Bluetooth_IPs post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bluetooth_ips::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs post simulation' algorithm generated code\n\n\t//End of 'Bluetooth_IPs post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bluetooth_ips::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_BaseBand_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_BaseBand_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_BaseBand_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_BaseBand_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_BaseBand_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_BaseBand_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_BaseBand_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_startEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_startEv.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_startEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bluetooth_ips::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Bluetooth_IPs initializations' algorithm generated code\n\n\t//End of 'Bluetooth_IPs initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Slave_Stub', 'type': 'cofluent:Function', 'models': [{'name': 'In_Stub', 'type': 'cofluent:Function'}, {'name': 'Out_Stub', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['In_Stub']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['Out_Stub']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_slave_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_slave_stub_dp_if.h\"\n#include \"cfm_in_stub.h\"\n#include \"cfm_out_stub.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Slave_Stub includes' algorithm generated code\n\n//End of 'Slave_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSlave_Stub Function Slave_Stub\n//@{\n///        \\page dxpSlave_Stub\n//@{\n///    \\brief Slave_Stub function model start\nclass cfm_slave_stub: public cf_core::cf_function_container,\n\t\tpublic cfm_slave_stub_dp_if {\npublic:\n\t/// cfm_slave_stub type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_slave_stub, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_slave_stub, cft_defbaseband> p_mq_BaseBand_Out_t;\n\t/// cfm_slave_stub type define end\n\n\t/// constructor\n\tcfm_slave_stub(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_slave_stub(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_in_stub* In_Stub;\n\tcfm_out_stub* Out_Stub;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub local declarations' algorithm generated code\n\n\t//End of 'Slave_Stub local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Slave_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Slave_Stub', 'type': 'cofluent:Function', 'models': [{'name': 'In_Stub', 'type': 'cofluent:Function'}, {'name': 'Out_Stub', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['In_Stub']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['Out_Stub']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_slave_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_slave_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_slave_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Slave_Stub definitions' algorithm generated code\n\n//End of 'Slave_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_slave_stub::cfm_slave_stub(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_slave_stub_dp_if(), p_mq_BaseBand_In(\n\t\t\t\t\"p_mq_BaseBand_In\"), p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\") {\n\tcf_function_container::init();\n\tIn_Stub = new cfm_in_stub(\"In_Stub\");\n\tOut_Stub = new cfm_out_stub(\"Out_Stub\");\n\n\t// connections\n\tIn_Stub->p_mq_BaseBand_In(p_mq_BaseBand_In);\n\n\tOut_Stub->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub constructor' algorithm generated code\n\n\t//End of 'Slave_Stub constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_slave_stub::~cfm_slave_stub(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub destructor' algorithm generated code\n\n\t//End of 'Slave_Stub destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete In_Stub;\n\tdelete Out_Stub;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_slave_stub::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub pre elaboration' algorithm generated code\n\n\t//End of 'Slave_Stub pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_slave_stub::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub post elaboration' algorithm generated code\n\n\t//End of 'Slave_Stub post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_slave_stub::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub post simulation' algorithm generated code\n\n\t//End of 'Slave_Stub post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_slave_stub::cb_init_attributes() {\n\n// initialize function attributes\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_slave_stub::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Slave_Stub initializations' algorithm generated code\n\n\t//End of 'Slave_Stub initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BT_System', 'type': 'cofluent:Function', 'models': [{'name': 'FileSystem', 'type': 'cofluent:Function'}, {'name': 'BT_Stack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['BT_Stack']}], 'relations': [{'name': 'DataOut', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataOut', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'WrOK', 'type': 'cofluent:Event', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'Data', 'type': 'cofluent:SharedVariable', 'dataType': 'DefData', 'connectTo': ['FileSystem']}, {'name': 'DataIn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataIn', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'ReadWrite', 'type': 'cofluent:MessageQueue', 'dataType': 'DefReadWrite', 'connectTo': ['FileSystem', 'BT_Stack']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bt_system\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n#define COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bt_system_dp_if.h\"\n#include \"cfm_bt_stack.h\"\n#include \"cfm_filesystem.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_System includes' algorithm generated code\n\n//End of 'BT_System includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBT_System Function BT_System\n//@{\n///        \\page dxpBT_System\n//@{\n///    \\brief BT_System function model start\nclass cfm_bt_system: public cf_core::cf_function_container,\n\t\tpublic cfm_bt_system_dp_if {\npublic:\n\t/// cfm_bt_system type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_shared_variable<cft_defdata> sv_Data_t;\n\ttypedef cf_core::cf_message_queue<cft_defdatain> mq_DataIn_t;\n\ttypedef cf_core::cf_message_queue<cft_defdataout> mq_DataOut_t;\n\ttypedef cf_core::cf_message_queue<cft_defreadwrite> mq_ReadWrite_t;\n\ttypedef cf_core::cf_event ev_WrOK_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_system, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_system, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_bt_system> p_ev_startEv_t;\n\t/// cfm_bt_system type define end\n\n\t/// constructor\n\tcfm_bt_system(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bt_system(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_ev_startEv_t p_ev_startEv;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bt_stack* BT_Stack;\n\tcfm_filesystem* FileSystem;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tsv_Data_t sv_Data;\n\tmq_DataIn_t mq_DataIn;\n\tmq_DataOut_t mq_DataOut;\n\tmq_ReadWrite_t mq_ReadWrite;\n\tev_WrOK_t ev_WrOK;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System local declarations' algorithm generated code\n\n\t//End of 'BT_System local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BT_System function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BT_System', 'type': 'cofluent:Function', 'models': [{'name': 'FileSystem', 'type': 'cofluent:Function'}, {'name': 'BT_Stack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['BT_Stack']}], 'relations': [{'name': 'DataOut', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataOut', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'WrOK', 'type': 'cofluent:Event', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'Data', 'type': 'cofluent:SharedVariable', 'dataType': 'DefData', 'connectTo': ['FileSystem']}, {'name': 'DataIn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataIn', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'ReadWrite', 'type': 'cofluent:MessageQueue', 'dataType': 'DefReadWrite', 'connectTo': ['FileSystem', 'BT_Stack']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bt_system\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bt_system.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bt_system\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_System definitions' algorithm generated code\n\n//End of 'BT_System definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bt_system::cfm_bt_system(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_bt_system_dp_if(), p_mq_BaseBand_Out(\n\t\t\t\t\"p_mq_BaseBand_Out\"), p_mq_BaseBand_In(\"p_mq_BaseBand_In\"), p_ev_startEv(\n\t\t\t\t\"p_ev_startEv\"), sv_Data(\"Data\"), mq_DataIn(\"DataIn\"), mq_DataOut(\n\t\t\t\t\"DataOut\"), mq_ReadWrite(\"ReadWrite\"), ev_WrOK(\"WrOK\") {\n\tcf_function_container::init();\n\tBT_Stack = new cfm_bt_stack(\"BT_Stack\");\n\tFileSystem = new cfm_filesystem(\"FileSystem\");\n\n\t// connections\n\tBT_Stack->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n\tBT_Stack->p_mq_BaseBand_In(p_mq_BaseBand_In);\n\tBT_Stack->p_mq_ReadWrite_0(mq_ReadWrite.p_target_socket);\n\tBT_Stack->p_mq_DataIn(mq_DataIn.p_target_socket);\n\tBT_Stack->p_ev_WrOK(ev_WrOK.p_target_socket);\n\tBT_Stack->p_mq_DataOut(mq_DataOut.p_target_socket);\n\tBT_Stack->p_ev_startEv(p_ev_startEv);\n\tBT_Stack->p_mq_ReadWrite_1(mq_ReadWrite.p_target_socket);\n\n\tFileSystem->p_sv_Data(sv_Data.p_target_socket);\n\tFileSystem->p_ev_WrOK(ev_WrOK.p_target_socket);\n\tFileSystem->p_mq_DataOut(mq_DataOut.p_target_socket);\n\tFileSystem->p_mq_DataIn(mq_DataIn.p_target_socket);\n\tFileSystem->p_mq_ReadWrite(mq_ReadWrite.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System constructor' algorithm generated code\n\n\t//End of 'BT_System constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bt_system::~cfm_bt_system(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System destructor' algorithm generated code\n\n\t//End of 'BT_System destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BT_Stack;\n\tdelete FileSystem;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bt_system::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System pre elaboration' algorithm generated code\n\n\t//End of 'BT_System pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bt_system::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System post elaboration' algorithm generated code\n\n\t//End of 'BT_System post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bt_system::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System post simulation' algorithm generated code\n\n\t//End of 'BT_System post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bt_system::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tsv_Data.cfa_write_time.init(cf_expr_duration(0, CF_NS));\n\tsv_Data.cfa_read_time.init(cf_expr_duration(0, CF_NS));\n\tsv_Data.cfa_semaphore.init(false);\n\tsv_Data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_DataIn.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataIn.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataIn.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_DataIn.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_DataIn.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_DataOut.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataOut.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_DataOut.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_DataOut.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_DataOut.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_ReadWrite.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_ReadWrite.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_ReadWrite.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_ReadWrite.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_ReadWrite.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_WrOK.cfa_set_time.init(cf_expr_duration(0, CF_NS));\n\tev_WrOK.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_WrOK.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bt_system::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_System initializations' algorithm generated code\n\n\t//End of 'BT_System initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Start', 'type': 'cofluent:Function', 'ports': [{'name': 'startEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_start\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_START\n#define COFS_MODEL_BLUETOOTH_IPS_START\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_start_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Start includes' algorithm generated code\n\n//End of 'Start includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgStart Function Start\n//@{\n///        \\page dxpStart\n//@{\n///    \\brief Start function model start\nclass cfm_start: public cf_core::cf_function, public cfm_start_dp_if {\npublic:\n\t/// cfm_start type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_start> p_ev_startEv_t;\n\t/// cfm_start type define end\n\n\t/// constructor\n\tcfm_start(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_start(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_startEv_t p_ev_startEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start local declarations' algorithm generated code\n\n\t//End of 'Start local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Start function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_START\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Start', 'type': 'cofluent:Function', 'ports': [{'name': 'startEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_start\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_start.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_start\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Start definitions' algorithm generated code\n\n//End of 'Start definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_start::cfm_start(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_start_dp_if(), p_ev_startEv(\"p_ev_startEv\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start constructor' algorithm generated code\n\n\t//End of 'Start constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_start::~cfm_start(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start destructor' algorithm generated code\n\n\t//End of 'Start destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_start::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start pre elaboration' algorithm generated code\n\n\t//End of 'Start pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_start::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start post elaboration' algorithm generated code\n\n\t//End of 'Start post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_start::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start post simulation' algorithm generated code\n\n\t//End of 'Start post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_start::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_start::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Start initializations' algorithm generated code\n\n\t//End of 'Start initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'In_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_in_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_in_stub_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'In_Stub includes' algorithm generated code\n\n//End of 'In_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIn_Stub Function In_Stub\n//@{\n///        \\page dxpIn_Stub\n//@{\n///    \\brief In_Stub function model start\nclass cfm_in_stub: public cf_core::cf_function, public cfm_in_stub_dp_if {\npublic:\n\t/// cfm_in_stub type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_in_stub, cft_defbaseband> p_mq_BaseBand_In_t;\n\t/// cfm_in_stub type define end\n\n\t/// constructor\n\tcfm_in_stub(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_in_stub(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub local declarations' algorithm generated code\n\n\t//End of 'In_Stub local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief In_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'In_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_in_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_in_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_slave_stub\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_in_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'In_Stub definitions' algorithm generated code\n\n//End of 'In_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_in_stub::cfm_in_stub(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_in_stub_dp_if(), p_mq_BaseBand_In(\n\t\t\t\t\"p_mq_BaseBand_In\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub constructor' algorithm generated code\n\n\t//End of 'In_Stub constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_in_stub::~cfm_in_stub(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub destructor' algorithm generated code\n\n\t//End of 'In_Stub destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_in_stub::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub pre elaboration' algorithm generated code\n\n\t//End of 'In_Stub pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_in_stub::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub post elaboration' algorithm generated code\n\n\t//End of 'In_Stub post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_in_stub::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub post simulation' algorithm generated code\n\n\t//End of 'In_Stub post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_in_stub::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_in_stub::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'In_Stub initializations' algorithm generated code\n\n\t//End of 'In_Stub initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Out_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_out_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_out_stub_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Out_Stub includes' algorithm generated code\n\n//End of 'Out_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOut_Stub Function Out_Stub\n//@{\n///        \\page dxpOut_Stub\n//@{\n///    \\brief Out_Stub function model start\nclass cfm_out_stub: public cf_core::cf_function, public cfm_out_stub_dp_if {\npublic:\n\t/// cfm_out_stub type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_out_stub, cft_defbaseband> p_mq_BaseBand_Out_t;\n\t/// cfm_out_stub type define end\n\n\t/// constructor\n\tcfm_out_stub(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_out_stub(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub local declarations' algorithm generated code\n\n\t//End of 'Out_Stub local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief Out_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Out_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_out_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_out_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_slave_stub\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_out_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'Out_Stub definitions' algorithm generated code\n\n//End of 'Out_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_out_stub::cfm_out_stub(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_out_stub_dp_if(), p_mq_BaseBand_Out(\n\t\t\t\t\"p_mq_BaseBand_Out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub constructor' algorithm generated code\n\n\t//End of 'Out_Stub constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_out_stub::~cfm_out_stub(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub destructor' algorithm generated code\n\n\t//End of 'Out_Stub destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_out_stub::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub pre elaboration' algorithm generated code\n\n\t//End of 'Out_Stub pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_out_stub::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub post elaboration' algorithm generated code\n\n\t//End of 'Out_Stub post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_out_stub::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub post simulation' algorithm generated code\n\n\t//End of 'Out_Stub post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_out_stub::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_out_stub::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'Out_Stub initializations' algorithm generated code\n\n\t//End of 'Out_Stub initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'FileSystem', 'type': 'cofluent:Function', 'ports': [{'name': 'Data', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefData'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataOut'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataIn'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefReadWrite'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_filesystem\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n#define COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_filesystem_dp_if.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FileSystem includes' algorithm generated code\n\n//End of 'FileSystem includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgFileSystem Function FileSystem\n//@{\n///        \\page dxpFileSystem\n//@{\n///    \\brief FileSystem function model start\nclass cfm_filesystem: public cf_core::cf_function, public cfm_filesystem_dp_if {\npublic:\n\t/// cfm_filesystem type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_sv_initiator_socket<cfm_filesystem, cft_defdata> p_sv_Data_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_filesystem> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_filesystem, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_filesystem, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_filesystem, cft_defreadwrite> p_mq_ReadWrite_t;\n\t/// cfm_filesystem type define end\n\n\t/// constructor\n\tcfm_filesystem(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_filesystem(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_sv_Data_t p_sv_Data;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_mq_ReadWrite_t p_mq_ReadWrite;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem local declarations' algorithm generated code\n\t//stop flag is activated when file has been read entirely\n\tbool stop;\n\t//read/write flag\n\tint wr;\n\t//file size\n\tint f_size;\n\t//size of a part\n\tint p_size;\n\t//read operation duration in ms\n\tdouble op_read_duration;\n\t//write operation duration in ms\n\tdouble op_write_duration;\n\t//first read flag\n\tbool first_read;\n\t//End of 'FileSystem local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief FileSystem function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'FileSystem', 'type': 'cofluent:Function', 'ports': [{'name': 'Data', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefData'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataOut'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataIn'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefReadWrite'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_filesystem\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_filesystem.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_system\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_filesystem\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'FileSystem definitions' algorithm generated code\n\n//End of 'FileSystem definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_filesystem::cfm_filesystem(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_filesystem_dp_if(), p_sv_Data(\"p_sv_Data\"), p_ev_WrOK(\n\t\t\t\t\"p_ev_WrOK\"), p_mq_DataOut(\"p_mq_DataOut\"), p_mq_DataIn(\n\t\t\t\t\"p_mq_DataIn\"), p_mq_ReadWrite(\"p_mq_ReadWrite\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem constructor' algorithm generated code\n\n\t//End of 'FileSystem constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_filesystem::~cfm_filesystem(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem destructor' algorithm generated code\n\n\t//End of 'FileSystem destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_filesystem::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem pre elaboration' algorithm generated code\n\n\t//End of 'FileSystem pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_filesystem::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem post elaboration' algorithm generated code\n\n\t//End of 'FileSystem post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_filesystem::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem post simulation' algorithm generated code\n\n\t//End of 'FileSystem post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_filesystem::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_filesystem::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'FileSystem initializations' algorithm generated code\n\t//stop flag is activated when file has been read entirely\n\tstop = false;\n\t//read/write flag\n\twr = 0;\n\t//file size\n\tf_size = File_Size * 1000;\n\t//first read flag\n\tfirst_read = true;\n\t//End of 'FileSystem initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BT_Stack', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Layer', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Layer', 'type': 'cofluent:Function'}, {'name': 'BaseBand_Layer', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Layer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Layer']}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Layer']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Layer']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}], 'relations': [{'name': 'OBEX_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'OBEX_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'RFCOMM_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'RFCOMM_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_In', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bt_stack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n#define COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bt_stack_dp_if.h\"\n#include \"cfm_baseband_layer.h\"\n#include \"cfm_l2cap_layer.h\"\n#include \"cfm_obex_layer.h\"\n#include \"cfm_rfcomm_layer.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_Stack includes' algorithm generated code\n\n//End of 'BT_Stack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBT_Stack Function BT_Stack\n//@{\n///        \\page dxpBT_Stack\n//@{\n///    \\brief BT_Stack function model start\nclass cfm_bt_stack: public cf_core::cf_function_container,\n\t\tpublic cfm_bt_stack_dp_if {\npublic:\n\t/// cfm_bt_stack type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defl2cap_in> mq_L2CAP_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defl2cap_out> mq_L2CAP_Out_t;\n\ttypedef cf_core::cf_message_queue<cft_defobex_in> mq_OBEX_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defobex_out> mq_OBEX_Out_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFCOMM_In_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFCOMM_Out_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defreadwrite> p_mq_ReadWrite_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_bt_stack> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_bt_stack> p_ev_startEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cft_defreadwrite> p_mq_ReadWrite_1_t;\n\t/// cfm_bt_stack type define end\n\n\t/// constructor\n\tcfm_bt_stack(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bt_stack(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_ReadWrite_0_t p_mq_ReadWrite_0;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_ev_startEv_t p_ev_startEv;\n\tp_mq_ReadWrite_1_t p_mq_ReadWrite_1;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_baseband_layer* BaseBand_Layer;\n\tcfm_l2cap_layer* L2CAP_Layer;\n\tcfm_obex_layer* OBEX_Layer;\n\tcfm_rfcomm_layer* RFCOMM_Layer;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_L2CAP_In_t mq_L2CAP_In;\n\tmq_L2CAP_Out_t mq_L2CAP_Out;\n\tmq_OBEX_In_t mq_OBEX_In;\n\tmq_OBEX_Out_t mq_OBEX_Out;\n\tmq_RFCOMM_In_t mq_RFCOMM_In;\n\tmq_RFCOMM_Out_t mq_RFCOMM_Out;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack local declarations' algorithm generated code\n\n\t//End of 'BT_Stack local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BT_Stack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BT_Stack', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Layer', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Layer', 'type': 'cofluent:Function'}, {'name': 'BaseBand_Layer', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Layer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Layer']}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Layer']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Layer']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}], 'relations': [{'name': 'OBEX_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'OBEX_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'RFCOMM_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'RFCOMM_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_In', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bt_stack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bt_stack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_system\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bt_stack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BT_Stack definitions' algorithm generated code\n\n//End of 'BT_Stack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bt_stack::cfm_bt_stack(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_bt_stack_dp_if(), p_mq_BaseBand_Out(\n\t\t\t\t\"p_mq_BaseBand_Out\"), p_mq_BaseBand_In(\"p_mq_BaseBand_In\"), p_mq_ReadWrite_0(\n\t\t\t\t\"p_mq_ReadWrite_0\"), p_mq_DataIn(\"p_mq_DataIn\"), p_ev_WrOK(\n\t\t\t\t\"p_ev_WrOK\"), p_mq_DataOut(\"p_mq_DataOut\"), p_ev_startEv(\n\t\t\t\t\"p_ev_startEv\"), p_mq_ReadWrite_1(\"p_mq_ReadWrite_1\"), mq_L2CAP_In(\n\t\t\t\t\"L2CAP_In\"), mq_L2CAP_Out(\"L2CAP_Out\"), mq_OBEX_In(\"OBEX_In\"), mq_OBEX_Out(\n\t\t\t\t\"OBEX_Out\"), mq_RFCOMM_In(\"RFCOMM_In\"), mq_RFCOMM_Out(\n\t\t\t\t\"RFCOMM_Out\") {\n\tcf_function_container::init();\n\tBaseBand_Layer = new cfm_baseband_layer(\"BaseBand_Layer\");\n\tL2CAP_Layer = new cfm_l2cap_layer(\"L2CAP_Layer\");\n\tOBEX_Layer = new cfm_obex_layer(\"OBEX_Layer\");\n\tRFCOMM_Layer = new cfm_rfcomm_layer(\"RFCOMM_Layer\");\n\n\t// connections\n\tBaseBand_Layer->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n\tBaseBand_Layer->p_mq_L2CAP_Out(mq_L2CAP_Out.p_target_socket);\n\tBaseBand_Layer->p_mq_BaseBand_In(p_mq_BaseBand_In);\n\tBaseBand_Layer->p_mq_L2CAP_In(mq_L2CAP_In.p_target_socket);\n\n\tL2CAP_Layer->p_mq_RFCOMM_Out(mq_RFCOMM_Out.p_target_socket);\n\tL2CAP_Layer->p_mq_RFCOMM_In(mq_RFCOMM_In.p_target_socket);\n\tL2CAP_Layer->p_mq_L2CAP_In(mq_L2CAP_In.p_target_socket);\n\tL2CAP_Layer->p_mq_L2CAP_Out(mq_L2CAP_Out.p_target_socket);\n\n\tOBEX_Layer->p_mq_ReadWrite_0(p_mq_ReadWrite_0);\n\tOBEX_Layer->p_mq_DataIn(p_mq_DataIn);\n\tOBEX_Layer->p_ev_WrOK(p_ev_WrOK);\n\tOBEX_Layer->p_mq_DataOut(p_mq_DataOut);\n\tOBEX_Layer->p_mq_OBEX_In(mq_OBEX_In.p_target_socket);\n\tOBEX_Layer->p_ev_startEv(p_ev_startEv);\n\tOBEX_Layer->p_mq_OBEX_Out(mq_OBEX_Out.p_target_socket);\n\tOBEX_Layer->p_mq_ReadWrite_1(p_mq_ReadWrite_1);\n\n\tRFCOMM_Layer->p_mq_OBEX_In(mq_OBEX_In.p_target_socket);\n\tRFCOMM_Layer->p_mq_OBEX_Out(mq_OBEX_Out.p_target_socket);\n\tRFCOMM_Layer->p_mq_RFCOMM_Out(mq_RFCOMM_Out.p_target_socket);\n\tRFCOMM_Layer->p_mq_RFCOMM_In(mq_RFCOMM_In.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack constructor' algorithm generated code\n\n\t//End of 'BT_Stack constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bt_stack::~cfm_bt_stack(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack destructor' algorithm generated code\n\n\t//End of 'BT_Stack destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BaseBand_Layer;\n\tdelete L2CAP_Layer;\n\tdelete OBEX_Layer;\n\tdelete RFCOMM_Layer;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bt_stack::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack pre elaboration' algorithm generated code\n\n\t//End of 'BT_Stack pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bt_stack::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack post elaboration' algorithm generated code\n\n\t//End of 'BT_Stack post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bt_stack::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack post simulation' algorithm generated code\n\n\t//End of 'BT_Stack post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bt_stack::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_L2CAP_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_L2CAP_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_L2CAP_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_L2CAP_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_L2CAP_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_L2CAP_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_L2CAP_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_OBEX_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OBEX_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OBEX_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_OBEX_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OBEX_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OBEX_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OBEX_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_In.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_In.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_In.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFCOMM_In.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_In.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_Out.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_Out.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFCOMM_Out.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFCOMM_Out.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFCOMM_Out.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bt_stack::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BT_Stack initializations' algorithm generated code\n\n\t//End of 'BT_Stack initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Send', 'type': 'cofluent:Function'}, {'name': 'OBEX_Receive', 'type': 'cofluent:Function'}, {'name': 'OB_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Receive']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Receive']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Send']}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Receive']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Send']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out', 'connectTo': ['OB_Out']}], 'relations': [{'name': 'continueEv', 'type': 'cofluent:Event', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'OB_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Receive', 'OB_Out']}, {'name': 'OB_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Send', 'OB_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_layer_dp_if.h\"\n#include \"cfm_ob_out.h\"\n#include \"cfm_obex_receive.h\"\n#include \"cfm_obex_send.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Layer includes' algorithm generated code\n\n//End of 'OBEX_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Layer Function OBEX_Layer\n//@{\n///        \\page dxpOBEX_Layer\n//@{\n///    \\brief OBEX_Layer function model start\nclass cfm_obex_layer: public cf_core::cf_function_container,\n\t\tpublic cfm_obex_layer_dp_if {\npublic:\n\t/// cfm_obex_layer type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defobex_out> mq_OB_Out1_t;\n\ttypedef cf_core::cf_message_queue<cft_defobex_out> mq_OB_Out2_t;\n\ttypedef cf_core::cf_event ev_continueEv_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defreadwrite> p_mq_ReadWrite_0_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_layer> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defobex_in> p_mq_OBEX_In_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_layer> p_ev_startEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defobex_out> p_mq_OBEX_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cft_defreadwrite> p_mq_ReadWrite_1_t;\n\t/// cfm_obex_layer type define end\n\n\t/// constructor\n\tcfm_obex_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_obex_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_ReadWrite_0_t p_mq_ReadWrite_0;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\tp_ev_startEv_t p_ev_startEv;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\tp_mq_ReadWrite_1_t p_mq_ReadWrite_1;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_obex_receive* OBEX_Receive;\n\tcfm_obex_send* OBEX_Send;\n\tcfm_ob_out* OB_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_OB_Out1_t mq_OB_Out1;\n\tmq_OB_Out2_t mq_OB_Out2;\n\tev_continueEv_t ev_continueEv;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer local declarations' algorithm generated code\n\n\t//End of 'OBEX_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OBEX_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Send', 'type': 'cofluent:Function'}, {'name': 'OBEX_Receive', 'type': 'cofluent:Function'}, {'name': 'OB_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Receive']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Receive']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Send']}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Receive']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Send']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out', 'connectTo': ['OB_Out']}], 'relations': [{'name': 'continueEv', 'type': 'cofluent:Event', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'OB_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Receive', 'OB_Out']}, {'name': 'OB_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Send', 'OB_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Layer definitions' algorithm generated code\n\n//End of 'OBEX_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_layer::cfm_obex_layer(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_obex_layer_dp_if(), p_mq_ReadWrite_0(\n\t\t\t\t\"p_mq_ReadWrite_0\"), p_mq_DataIn(\"p_mq_DataIn\"), p_ev_WrOK(\n\t\t\t\t\"p_ev_WrOK\"), p_mq_DataOut(\"p_mq_DataOut\"), p_mq_OBEX_In(\n\t\t\t\t\"p_mq_OBEX_In\"), p_ev_startEv(\"p_ev_startEv\"), p_mq_OBEX_Out(\n\t\t\t\t\"p_mq_OBEX_Out\"), p_mq_ReadWrite_1(\"p_mq_ReadWrite_1\"), mq_OB_Out1(\n\t\t\t\t\"OB_Out1\"), mq_OB_Out2(\"OB_Out2\"), ev_continueEv(\"continueEv\") {\n\tcf_function_container::init();\n\tOBEX_Receive = new cfm_obex_receive(\"OBEX_Receive\");\n\tOBEX_Send = new cfm_obex_send(\"OBEX_Send\");\n\tOB_Out = new cfm_ob_out(\"OB_Out\");\n\n\t// connections\n\tOBEX_Receive->p_ev_continueEv(ev_continueEv.p_target_socket);\n\tOBEX_Receive->p_mq_OB_Out1(mq_OB_Out1.p_target_socket);\n\tOBEX_Receive->p_mq_ReadWrite(p_mq_ReadWrite_0);\n\tOBEX_Receive->p_mq_DataIn(p_mq_DataIn);\n\tOBEX_Receive->p_ev_WrOK(p_ev_WrOK);\n\tOBEX_Receive->p_mq_OBEX_In(p_mq_OBEX_In);\n\n\tOBEX_Send->p_ev_continueEv(ev_continueEv.p_target_socket);\n\tOBEX_Send->p_mq_OB_Out2(mq_OB_Out2.p_target_socket);\n\tOBEX_Send->p_mq_ReadWrite(p_mq_ReadWrite_1);\n\tOBEX_Send->p_mq_DataOut(p_mq_DataOut);\n\tOBEX_Send->p_ev_startEv(p_ev_startEv);\n\n\tOB_Out->p_mq_OB_Out2(mq_OB_Out2.p_target_socket);\n\tOB_Out->p_mq_OB_Out1(mq_OB_Out1.p_target_socket);\n\tOB_Out->p_mq_OBEX_Out(p_mq_OBEX_Out);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer constructor' algorithm generated code\n\n\t//End of 'OBEX_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_layer::~cfm_obex_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer destructor' algorithm generated code\n\n\t//End of 'OBEX_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete OBEX_Receive;\n\tdelete OBEX_Send;\n\tdelete OB_Out;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_obex_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer pre elaboration' algorithm generated code\n\n\t//End of 'OBEX_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_obex_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer post elaboration' algorithm generated code\n\n\t//End of 'OBEX_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_obex_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer post simulation' algorithm generated code\n\n\t//End of 'OBEX_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_obex_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_OB_Out1.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out1.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OB_Out1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OB_Out1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_OB_Out2.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out2.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_OB_Out2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_OB_Out2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_OB_Out2.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_continueEv.cfa_set_time.init(cf_expr_duration(0, CF_NS));\n\tev_continueEv.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_continueEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_obex_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Layer initializations' algorithm generated code\n\n\t//End of 'OBEX_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Send', 'type': 'cofluent:Function'}, {'name': 'CreditsOrData', 'type': 'cofluent:Function'}, {'name': 'RFC_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In', 'connectTo': ['RFCOMM_Receive']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out', 'connectTo': ['RFCOMM_Send']}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFC_Out']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In', 'connectTo': ['CreditsOrData']}], 'relations': [{'name': 'RFC_Data', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Receive', 'CreditsOrData']}, {'name': 'RFC_Cdts', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Send', 'CreditsOrData']}, {'name': 'RFC_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Receive', 'RFC_Out']}, {'name': 'RFC_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Send', 'RFC_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_layer_dp_if.h\"\n#include \"cfm_creditsordata.h\"\n#include \"cfm_rfc_out.h\"\n#include \"cfm_rfcomm_receive.h\"\n#include \"cfm_rfcomm_send.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Layer includes' algorithm generated code\n\n//End of 'RFCOMM_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Layer Function RFCOMM_Layer\n//@{\n///        \\page dxpRFCOMM_Layer\n//@{\n///    \\brief RFCOMM_Layer function model start\nclass cfm_rfcomm_layer: public cf_core::cf_function_container,\n\t\tpublic cfm_rfcomm_layer_dp_if {\npublic:\n\t/// cfm_rfcomm_layer type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFC_Cdts_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFC_Data_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFC_Out1_t;\n\ttypedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFC_Out2_t;\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defobex_in> p_mq_OBEX_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defobex_out> p_mq_OBEX_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\t/// cfm_rfcomm_layer type define end\n\n\t/// constructor\n\tcfm_rfcomm_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfcomm_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_creditsordata* CreditsOrData;\n\tcfm_rfcomm_receive* RFCOMM_Receive;\n\tcfm_rfcomm_send* RFCOMM_Send;\n\tcfm_rfc_out* RFC_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_RFC_Cdts_t mq_RFC_Cdts;\n\tmq_RFC_Data_t mq_RFC_Data;\n\tmq_RFC_Out1_t mq_RFC_Out1;\n\tmq_RFC_Out2_t mq_RFC_Out2;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer local declarations' algorithm generated code\n\n\t//End of 'RFCOMM_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFCOMM_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Send', 'type': 'cofluent:Function'}, {'name': 'CreditsOrData', 'type': 'cofluent:Function'}, {'name': 'RFC_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In', 'connectTo': ['RFCOMM_Receive']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out', 'connectTo': ['RFCOMM_Send']}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFC_Out']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In', 'connectTo': ['CreditsOrData']}], 'relations': [{'name': 'RFC_Data', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Receive', 'CreditsOrData']}, {'name': 'RFC_Cdts', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Send', 'CreditsOrData']}, {'name': 'RFC_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Receive', 'RFC_Out']}, {'name': 'RFC_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Send', 'RFC_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Layer definitions' algorithm generated code\n\n//End of 'RFCOMM_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_layer::cfm_rfcomm_layer(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_rfcomm_layer_dp_if(), p_mq_OBEX_In(\n\t\t\t\t\"p_mq_OBEX_In\"), p_mq_OBEX_Out(\"p_mq_OBEX_Out\"), p_mq_RFCOMM_Out(\n\t\t\t\t\"p_mq_RFCOMM_Out\"), p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\"), mq_RFC_Cdts(\n\t\t\t\t\"RFC_Cdts\"), mq_RFC_Data(\"RFC_Data\"), mq_RFC_Out1(\"RFC_Out1\"), mq_RFC_Out2(\n\t\t\t\t\"RFC_Out2\") {\n\tcf_function_container::init();\n\tCreditsOrData = new cfm_creditsordata(\"CreditsOrData\");\n\tRFCOMM_Receive = new cfm_rfcomm_receive(\"RFCOMM_Receive\");\n\tRFCOMM_Send = new cfm_rfcomm_send(\"RFCOMM_Send\");\n\tRFC_Out = new cfm_rfc_out(\"RFC_Out\");\n\n\t// connections\n\tCreditsOrData->p_mq_RFC_Data(mq_RFC_Data.p_target_socket);\n\tCreditsOrData->p_mq_RFC_Cdts(mq_RFC_Cdts.p_target_socket);\n\tCreditsOrData->p_mq_RFCOMM_In(p_mq_RFCOMM_In);\n\n\tRFCOMM_Receive->p_mq_RFC_Data(mq_RFC_Data.p_target_socket);\n\tRFCOMM_Receive->p_mq_RFC_Out1(mq_RFC_Out1.p_target_socket);\n\tRFCOMM_Receive->p_mq_OBEX_In(p_mq_OBEX_In);\n\n\tRFCOMM_Send->p_mq_RFC_Cdts(mq_RFC_Cdts.p_target_socket);\n\tRFCOMM_Send->p_mq_RFC_Out2(mq_RFC_Out2.p_target_socket);\n\tRFCOMM_Send->p_mq_OBEX_Out(p_mq_OBEX_Out);\n\n\tRFC_Out->p_mq_RFC_Out1(mq_RFC_Out1.p_target_socket);\n\tRFC_Out->p_mq_RFC_Out2(mq_RFC_Out2.p_target_socket);\n\tRFC_Out->p_mq_RFCOMM_Out(p_mq_RFCOMM_Out);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer constructor' algorithm generated code\n\n\t//End of 'RFCOMM_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_layer::~cfm_rfcomm_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer destructor' algorithm generated code\n\n\t//End of 'RFCOMM_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete CreditsOrData;\n\tdelete RFCOMM_Receive;\n\tdelete RFCOMM_Send;\n\tdelete RFC_Out;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfcomm_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer pre elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfcomm_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer post elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfcomm_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer post simulation' algorithm generated code\n\n\t//End of 'RFCOMM_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfcomm_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_RFC_Cdts.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Cdts.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Cdts.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Cdts.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Cdts.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFC_Data.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Data.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Data.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Data.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Data.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFC_Out1.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out1.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out1.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Out1.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Out1.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_RFC_Out2.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out2.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_RFC_Out2.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_RFC_Out2.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_RFC_Out2.cfa_concurrency.init((cf_nonzero_count) 1);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfcomm_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Layer initializations' algorithm generated code\n\n\t//End of 'RFCOMM_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BaseBand_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'BB_Receive', 'type': 'cofluent:Function'}, {'name': 'BB_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Send']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BB_Send']}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Receive']}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In', 'connectTo': ['BB_Receive']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_baseband_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_baseband_layer_dp_if.h\"\n#include \"cfm_bb_receive.h\"\n#include \"cfm_bb_send.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_out.h\"\n#include \"dt/cft_defl2cap_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BaseBand_Layer includes' algorithm generated code\n\n//End of 'BaseBand_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBaseBand_Layer Function BaseBand_Layer\n//@{\n///        \\page dxpBaseBand_Layer\n//@{\n///    \\brief BaseBand_Layer function model start\nclass cfm_baseband_layer: public cf_core::cf_function_container,\n\t\tpublic cfm_baseband_layer_dp_if {\npublic:\n\t/// cfm_baseband_layer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\t/// cfm_baseband_layer type define end\n\n\t/// constructor\n\tcfm_baseband_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_baseband_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bb_receive* BB_Receive;\n\tcfm_bb_send* BB_Send;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer local declarations' algorithm generated code\n\n\t//End of 'BaseBand_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BaseBand_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BaseBand_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'BB_Receive', 'type': 'cofluent:Function'}, {'name': 'BB_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Send']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BB_Send']}, {'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Receive']}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In', 'connectTo': ['BB_Receive']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_baseband_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_baseband_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_baseband_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BaseBand_Layer definitions' algorithm generated code\n\n//End of 'BaseBand_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_baseband_layer::cfm_baseband_layer(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_baseband_layer_dp_if(), p_mq_BaseBand_Out(\n\t\t\t\t\"p_mq_BaseBand_Out\"), p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\"), p_mq_BaseBand_In(\n\t\t\t\t\"p_mq_BaseBand_In\"), p_mq_L2CAP_In(\"p_mq_L2CAP_In\") {\n\tcf_function_container::init();\n\tBB_Receive = new cfm_bb_receive(\"BB_Receive\");\n\tBB_Send = new cfm_bb_send(\"BB_Send\");\n\n\t// connections\n\tBB_Receive->p_mq_BaseBand_In(p_mq_BaseBand_In);\n\tBB_Receive->p_mq_L2CAP_In(p_mq_L2CAP_In);\n\n\tBB_Send->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n\tBB_Send->p_mq_L2CAP_Out(p_mq_L2CAP_Out);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer constructor' algorithm generated code\n\n\t//End of 'BaseBand_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_baseband_layer::~cfm_baseband_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer destructor' algorithm generated code\n\n\t//End of 'BaseBand_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete BB_Receive;\n\tdelete BB_Send;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_baseband_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer pre elaboration' algorithm generated code\n\n\t//End of 'BaseBand_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_baseband_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer post elaboration' algorithm generated code\n\n\t//End of 'BaseBand_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_baseband_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer post simulation' algorithm generated code\n\n\t//End of 'BaseBand_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_baseband_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_baseband_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BaseBand_Layer initializations' algorithm generated code\n\n\t//End of 'BaseBand_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'L2CAP_Receive', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['L2CAP_Send']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out', 'connectTo': ['L2CAP_Send']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_layer_dp_if.h\"\n#include \"cfm_l2cap_receive.h\"\n#include \"cfm_l2cap_send.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Layer includes' algorithm generated code\n\n//End of 'L2CAP_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Layer Function L2CAP_Layer\n//@{\n///        \\page dxpL2CAP_Layer\n//@{\n///    \\brief L2CAP_Layer function model start\nclass cfm_l2cap_layer: public cf_core::cf_function_container,\n\t\tpublic cfm_l2cap_layer_dp_if {\npublic:\n\t/// cfm_l2cap_layer type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\t/// cfm_l2cap_layer type define end\n\n\t/// constructor\n\tcfm_l2cap_layer(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_l2cap_layer(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\t//@}\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_l2cap_receive* L2CAP_Receive;\n\tcfm_l2cap_send* L2CAP_Send;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer local declarations' algorithm generated code\n\n\t//End of 'L2CAP_Layer local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief L2CAP_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'L2CAP_Receive', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['L2CAP_Send']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out', 'connectTo': ['L2CAP_Send']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Layer definitions' algorithm generated code\n\n//End of 'L2CAP_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_layer::cfm_l2cap_layer(sc_core::sc_module_name name) :\n\t\tcf_function_container(name), cfm_l2cap_layer_dp_if(), p_mq_RFCOMM_Out(\n\t\t\t\t\"p_mq_RFCOMM_Out\"), p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\"), p_mq_L2CAP_In(\n\t\t\t\t\"p_mq_L2CAP_In\"), p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\") {\n\tcf_function_container::init();\n\tL2CAP_Receive = new cfm_l2cap_receive(\"L2CAP_Receive\");\n\tL2CAP_Send = new cfm_l2cap_send(\"L2CAP_Send\");\n\n\t// connections\n\tL2CAP_Receive->p_mq_RFCOMM_In(p_mq_RFCOMM_In);\n\tL2CAP_Receive->p_mq_L2CAP_In(p_mq_L2CAP_In);\n\n\tL2CAP_Send->p_mq_RFCOMM_Out(p_mq_RFCOMM_Out);\n\tL2CAP_Send->p_mq_L2CAP_Out(p_mq_L2CAP_Out);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer constructor' algorithm generated code\n\n\t//End of 'L2CAP_Layer constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_layer::~cfm_l2cap_layer(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer destructor' algorithm generated code\n\n\t//End of 'L2CAP_Layer destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete L2CAP_Receive;\n\tdelete L2CAP_Send;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_l2cap_layer::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer pre elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Layer pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_l2cap_layer::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer post elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Layer post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_l2cap_layer::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer post simulation' algorithm generated code\n\n\t//End of 'L2CAP_Layer post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_l2cap_layer::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_l2cap_layer::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Layer initializations' algorithm generated code\n\n\t//End of 'L2CAP_Layer initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_send_dp_if.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdataout.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Send includes' algorithm generated code\n\n//End of 'OBEX_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Send Function OBEX_Send\n//@{\n///        \\page dxpOBEX_Send\n//@{\n///    \\brief OBEX_Send function model start\nclass cfm_obex_send: public cf_core::cf_function, public cfm_obex_send_dp_if {\npublic:\n\t/// cfm_obex_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_send> p_ev_continueEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_send, cft_defobex_out> p_mq_OB_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_send, cft_defreadwrite> p_mq_ReadWrite_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_send, cft_defdataout> p_mq_DataOut_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_send> p_ev_startEv_t;\n\t/// cfm_obex_send type define end\n\n\t/// constructor\n\tcfm_obex_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_obex_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_continueEv_t p_ev_continueEv;\n\tp_mq_OB_Out2_t p_mq_OB_Out2;\n\tp_mq_ReadWrite_t p_mq_ReadWrite;\n\tp_mq_DataOut_t p_mq_DataOut;\n\tp_ev_startEv_t p_ev_startEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send local declarations' algorithm generated code\n\n\t//End of 'OBEX_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OBEX_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Send definitions' algorithm generated code\n\n//End of 'OBEX_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_send::cfm_obex_send(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_obex_send_dp_if(), p_ev_continueEv(\n\t\t\t\t\"p_ev_continueEv\"), p_mq_OB_Out2(\"p_mq_OB_Out2\"), p_mq_ReadWrite(\n\t\t\t\t\"p_mq_ReadWrite\"), p_mq_DataOut(\"p_mq_DataOut\"), p_ev_startEv(\n\t\t\t\t\"p_ev_startEv\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send constructor' algorithm generated code\n\n\t//End of 'OBEX_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_send::~cfm_obex_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send destructor' algorithm generated code\n\n\t//End of 'OBEX_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_obex_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send pre elaboration' algorithm generated code\n\n\t//End of 'OBEX_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_obex_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send post elaboration' algorithm generated code\n\n\t//End of 'OBEX_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_obex_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send post simulation' algorithm generated code\n\n\t//End of 'OBEX_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_obex_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_obex_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Send initializations' algorithm generated code\n\n\t//End of 'OBEX_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_receive_dp_if.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defobex_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Receive includes' algorithm generated code\n\n//End of 'OBEX_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Receive Function OBEX_Receive\n//@{\n///        \\page dxpOBEX_Receive\n//@{\n///    \\brief OBEX_Receive function model start\nclass cfm_obex_receive: public cf_core::cf_function,\n\t\tpublic cfm_obex_receive_dp_if {\npublic:\n\t/// cfm_obex_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_receive> p_ev_continueEv_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defobex_out> p_mq_OB_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defreadwrite> p_mq_ReadWrite_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defdatain> p_mq_DataIn_t;\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_obex_receive> p_ev_WrOK_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_obex_receive, cft_defobex_in> p_mq_OBEX_In_t;\n\t/// cfm_obex_receive type define end\n\n\t/// constructor\n\tcfm_obex_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_obex_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_continueEv_t p_ev_continueEv;\n\tp_mq_OB_Out1_t p_mq_OB_Out1;\n\tp_mq_ReadWrite_t p_mq_ReadWrite;\n\tp_mq_DataIn_t p_mq_DataIn;\n\tp_ev_WrOK_t p_ev_WrOK;\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive local declarations' algorithm generated code\n\tint ack;\n\t//End of 'OBEX_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OBEX_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OBEX_Receive definitions' algorithm generated code\n\n//End of 'OBEX_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_receive::cfm_obex_receive(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_obex_receive_dp_if(), p_ev_continueEv(\n\t\t\t\t\"p_ev_continueEv\"), p_mq_OB_Out1(\"p_mq_OB_Out1\"), p_mq_ReadWrite(\n\t\t\t\t\"p_mq_ReadWrite\"), p_mq_DataIn(\"p_mq_DataIn\"), p_ev_WrOK(\n\t\t\t\t\"p_ev_WrOK\"), p_mq_OBEX_In(\"p_mq_OBEX_In\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive constructor' algorithm generated code\n\n\t//End of 'OBEX_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_receive::~cfm_obex_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive destructor' algorithm generated code\n\n\t//End of 'OBEX_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_obex_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive pre elaboration' algorithm generated code\n\n\t//End of 'OBEX_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_obex_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive post elaboration' algorithm generated code\n\n\t//End of 'OBEX_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_obex_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive post simulation' algorithm generated code\n\n\t//End of 'OBEX_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_obex_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_obex_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OBEX_Receive initializations' algorithm generated code\n\tack = 0;\n\t//End of 'OBEX_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OB_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ob_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n#define COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ob_out_dp_if.h\"\n#include \"dt/cft_defobex_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OB_Out includes' algorithm generated code\n\n//End of 'OB_Out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOB_Out Function OB_Out\n//@{\n///        \\page dxpOB_Out\n//@{\n///    \\brief OB_Out function model start\nclass cfm_ob_out: public cf_core::cf_function, public cfm_ob_out_dp_if {\npublic:\n\t/// cfm_ob_out type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ob_out, cft_defobex_out> p_mq_OB_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ob_out, cft_defobex_out> p_mq_OB_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_ob_out, cft_defobex_out> p_mq_OBEX_Out_t;\n\t/// cfm_ob_out type define end\n\n\t/// constructor\n\tcfm_ob_out(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_ob_out(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_OB_Out2_t p_mq_OB_Out2;\n\tp_mq_OB_Out1_t p_mq_OB_Out1;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out local declarations' algorithm generated code\n\n\t//End of 'OB_Out local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OB_Out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OB_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ob_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ob_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ob_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OB_Out definitions' algorithm generated code\n\n//End of 'OB_Out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ob_out::cfm_ob_out(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_ob_out_dp_if(), p_mq_OB_Out2(\"p_mq_OB_Out2\"), p_mq_OB_Out1(\n\t\t\t\t\"p_mq_OB_Out1\"), p_mq_OBEX_Out(\"p_mq_OBEX_Out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out constructor' algorithm generated code\n\n\t//End of 'OB_Out constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ob_out::~cfm_ob_out(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out destructor' algorithm generated code\n\n\t//End of 'OB_Out destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_ob_out::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out pre elaboration' algorithm generated code\n\n\t//End of 'OB_Out pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_ob_out::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out post elaboration' algorithm generated code\n\n\t//End of 'OB_Out post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_ob_out::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out post simulation' algorithm generated code\n\n\t//End of 'OB_Out post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_ob_out::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_ob_out::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OB_Out initializations' algorithm generated code\n\n\t//End of 'OB_Out initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_receive_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defobex_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Receive includes' algorithm generated code\n\n//End of 'RFCOMM_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Receive Function RFCOMM_Receive\n//@{\n///        \\page dxpRFCOMM_Receive\n//@{\n///    \\brief RFCOMM_Receive function model start\nclass cfm_rfcomm_receive: public cf_core::cf_function,\n\t\tpublic cfm_rfcomm_receive_dp_if {\npublic:\n\t/// cfm_rfcomm_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_receive, cft_defrfcomm_in> p_mq_RFC_Data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_receive,\n\t\t\tcft_defrfcomm_out> p_mq_RFC_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_receive, cft_defobex_in> p_mq_OBEX_In_t;\n\t/// cfm_rfcomm_receive type define end\n\n\t/// constructor\n\tcfm_rfcomm_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfcomm_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Data_t p_mq_RFC_Data;\n\tp_mq_RFC_Out1_t p_mq_RFC_Out1;\n\tp_mq_OBEX_In_t p_mq_OBEX_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive local declarations' algorithm generated code\n\t//number of credits available for the peer device\n\tint peer_credits;\n\t//flag indicating if peer need credits\n\tbool peer_need_credits;\n\t//flag indicating if OBEX frame reconstruction is finished\n\tbool receive_complete;\n\t//size of the already received RFCOMM payloads\n\tint received_payload_size;\n\t//type of the OBEX packet under reconstruction\n\tunsigned char OBEX_packet_type;\n\t//receive operation time in us\n\tdouble receive_op_time;\n\t//End of 'RFCOMM_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFCOMM_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Receive definitions' algorithm generated code\n\n//End of 'RFCOMM_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_receive::cfm_rfcomm_receive(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_rfcomm_receive_dp_if(), p_mq_RFC_Data(\n\t\t\t\t\"p_mq_RFC_Data\"), p_mq_RFC_Out1(\"p_mq_RFC_Out1\"), p_mq_OBEX_In(\n\t\t\t\t\"p_mq_OBEX_In\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive constructor' algorithm generated code\n\n\t//End of 'RFCOMM_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_receive::~cfm_rfcomm_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive destructor' algorithm generated code\n\n\t//End of 'RFCOMM_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfcomm_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive pre elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfcomm_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive post elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfcomm_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive post simulation' algorithm generated code\n\n\t//End of 'RFCOMM_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfcomm_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfcomm_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Receive initializations' algorithm generated code\n\t//number of credits available for the peer device\n\tpeer_credits = RFCOMM_credits;\n\t//flag indicating if peer need credits\n\tpeer_need_credits = false;\n\t//flag indicating if OBEX frame reconstruction is finished\n\treceive_complete = false;\n\t//size of the already received RFCOMM payloads\n\treceived_payload_size = 0;\n\t//receive operation time in us\n\treceive_op_time = 0.0;\n\t//End of 'RFCOMM_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_send_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defobex_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Send includes' algorithm generated code\n\n//End of 'RFCOMM_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Send Function RFCOMM_Send\n//@{\n///        \\page dxpRFCOMM_Send\n//@{\n///    \\brief RFCOMM_Send function model start\nclass cfm_rfcomm_send: public cf_core::cf_function, public cfm_rfcomm_send_dp_if {\npublic:\n\t/// cfm_rfcomm_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_send, cft_defrfcomm_in> p_mq_RFC_Cdts_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_send, cft_defrfcomm_out> p_mq_RFC_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_send, cft_defobex_out> p_mq_OBEX_Out_t;\n\t/// cfm_rfcomm_send type define end\n\n\t/// constructor\n\tcfm_rfcomm_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfcomm_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Cdts_t p_mq_RFC_Cdts;\n\tp_mq_RFC_Out2_t p_mq_RFC_Out2;\n\tp_mq_OBEX_Out_t p_mq_OBEX_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send local declarations' algorithm generated code\n\t//number of RFCOMM data packets to send\n\tint nb_packets_to_send;\n\t//size of the last RFCOMM packet payload\n\tint last_payload_size;\n\t//credits\n\tint credits;\n\tbool needCredits;\n\t//type of the OBEX packet under fragmentation\n\tunsigned char OBEX_packet_type;\n\t//End of 'RFCOMM_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFCOMM_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFCOMM_Send definitions' algorithm generated code\n\n//End of 'RFCOMM_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_send::cfm_rfcomm_send(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_rfcomm_send_dp_if(), p_mq_RFC_Cdts(\n\t\t\t\t\"p_mq_RFC_Cdts\"), p_mq_RFC_Out2(\"p_mq_RFC_Out2\"), p_mq_OBEX_Out(\n\t\t\t\t\"p_mq_OBEX_Out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send constructor' algorithm generated code\n\n\t//End of 'RFCOMM_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_send::~cfm_rfcomm_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send destructor' algorithm generated code\n\n\t//End of 'RFCOMM_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfcomm_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send pre elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfcomm_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send post elaboration' algorithm generated code\n\n\t//End of 'RFCOMM_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfcomm_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send post simulation' algorithm generated code\n\n\t//End of 'RFCOMM_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfcomm_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfcomm_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFCOMM_Send initializations' algorithm generated code\n\t//credits\n\tcredits = RFCOMM_credits;\n\tneedCredits = false;\n\t//End of 'RFCOMM_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CreditsOrData', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_creditsordata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n#define COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_creditsordata_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CreditsOrData includes' algorithm generated code\n\n//End of 'CreditsOrData includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCreditsOrData Function CreditsOrData\n//@{\n///        \\page dxpCreditsOrData\n//@{\n///    \\brief CreditsOrData function model start\nclass cfm_creditsordata: public cf_core::cf_function,\n\t\tpublic cfm_creditsordata_dp_if {\npublic:\n\t/// cfm_creditsordata type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_creditsordata, cft_defrfcomm_in> p_mq_RFC_Data_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_creditsordata, cft_defrfcomm_in> p_mq_RFC_Cdts_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_creditsordata, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\t/// cfm_creditsordata type define end\n\n\t/// constructor\n\tcfm_creditsordata(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_creditsordata(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Data_t p_mq_RFC_Data;\n\tp_mq_RFC_Cdts_t p_mq_RFC_Cdts;\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData local declarations' algorithm generated code\n\t//data flag\n\tbool data_flag;\n\t//credit flag\n\tbool cdt_flag;\n\t//End of 'CreditsOrData local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief CreditsOrData function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CreditsOrData', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_creditsordata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_creditsordata.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_creditsordata\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'CreditsOrData definitions' algorithm generated code\n\n//End of 'CreditsOrData definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_creditsordata::cfm_creditsordata(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_creditsordata_dp_if(), p_mq_RFC_Data(\n\t\t\t\t\"p_mq_RFC_Data\"), p_mq_RFC_Cdts(\"p_mq_RFC_Cdts\"), p_mq_RFCOMM_In(\n\t\t\t\t\"p_mq_RFCOMM_In\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData constructor' algorithm generated code\n\n\t//End of 'CreditsOrData constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_creditsordata::~cfm_creditsordata(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData destructor' algorithm generated code\n\n\t//End of 'CreditsOrData destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_creditsordata::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData pre elaboration' algorithm generated code\n\n\t//End of 'CreditsOrData pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_creditsordata::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData post elaboration' algorithm generated code\n\n\t//End of 'CreditsOrData post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_creditsordata::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData post simulation' algorithm generated code\n\n\t//End of 'CreditsOrData post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_creditsordata::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_creditsordata::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'CreditsOrData initializations' algorithm generated code\n\t//data flag\n\tdata_flag = false;\n\t//credit flag\n\tcdt_flag = false;\n\t//End of 'CreditsOrData initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFC_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfc_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n#define COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfc_out_dp_if.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFC_Out includes' algorithm generated code\n\n//End of 'RFC_Out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFC_Out Function RFC_Out\n//@{\n///        \\page dxpRFC_Out\n//@{\n///    \\brief RFC_Out function model start\nclass cfm_rfc_out: public cf_core::cf_function, public cfm_rfc_out_dp_if {\npublic:\n\t/// cfm_rfc_out type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfc_out, cft_defrfcomm_out> p_mq_RFC_Out1_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfc_out, cft_defrfcomm_out> p_mq_RFC_Out2_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_rfc_out, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\t/// cfm_rfc_out type define end\n\n\t/// constructor\n\tcfm_rfc_out(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_rfc_out(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFC_Out1_t p_mq_RFC_Out1;\n\tp_mq_RFC_Out2_t p_mq_RFC_Out2;\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out local declarations' algorithm generated code\n\n\t//End of 'RFC_Out local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief RFC_Out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFC_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfc_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfc_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfc_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'RFC_Out definitions' algorithm generated code\n\n//End of 'RFC_Out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfc_out::cfm_rfc_out(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_rfc_out_dp_if(), p_mq_RFC_Out1(\"p_mq_RFC_Out1\"), p_mq_RFC_Out2(\n\t\t\t\t\"p_mq_RFC_Out2\"), p_mq_RFCOMM_Out(\"p_mq_RFCOMM_Out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out constructor' algorithm generated code\n\n\t//End of 'RFC_Out constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfc_out::~cfm_rfc_out(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out destructor' algorithm generated code\n\n\t//End of 'RFC_Out destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_rfc_out::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out pre elaboration' algorithm generated code\n\n\t//End of 'RFC_Out pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_rfc_out::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out post elaboration' algorithm generated code\n\n\t//End of 'RFC_Out post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_rfc_out::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out post simulation' algorithm generated code\n\n\t//End of 'RFC_Out post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_rfc_out::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_rfc_out::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'RFC_Out initializations' algorithm generated code\n\n\t//End of 'RFC_Out initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BB_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bb_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bb_receive_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Receive includes' algorithm generated code\n\n//End of 'BB_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBB_Receive Function BB_Receive\n//@{\n///        \\page dxpBB_Receive\n//@{\n///    \\brief BB_Receive function model start\nclass cfm_bb_receive: public cf_core::cf_function, public cfm_bb_receive_dp_if {\npublic:\n\t/// cfm_bb_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_receive, cft_defbaseband> p_mq_BaseBand_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_receive, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\t/// cfm_bb_receive type define end\n\n\t/// constructor\n\tcfm_bb_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bb_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_In_t p_mq_BaseBand_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive local declarations' algorithm generated code\n\t//receive operation duration in ms\n\tdouble op_rcv_duration;\n\t//End of 'BB_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BB_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BB_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bb_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bb_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_baseband_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bb_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Receive definitions' algorithm generated code\n\n//End of 'BB_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bb_receive::cfm_bb_receive(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_bb_receive_dp_if(), p_mq_BaseBand_In(\n\t\t\t\t\"p_mq_BaseBand_In\"), p_mq_L2CAP_In(\"p_mq_L2CAP_In\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive constructor' algorithm generated code\n\n\t//End of 'BB_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bb_receive::~cfm_bb_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive destructor' algorithm generated code\n\n\t//End of 'BB_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bb_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive pre elaboration' algorithm generated code\n\n\t//End of 'BB_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bb_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive post elaboration' algorithm generated code\n\n\t//End of 'BB_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bb_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive post simulation' algorithm generated code\n\n\t//End of 'BB_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bb_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bb_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Receive initializations' algorithm generated code\n\t//receive operation duration in ms\n\top_rcv_duration = 0;\n\t//End of 'BB_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BB_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bb_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bb_send_dp_if.h\"\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Send includes' algorithm generated code\n\n//End of 'BB_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBB_Send Function BB_Send\n//@{\n///        \\page dxpBB_Send\n//@{\n///    \\brief BB_Send function model start\nclass cfm_bb_send: public cf_core::cf_function, public cfm_bb_send_dp_if {\npublic:\n\t/// cfm_bb_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_send, cft_defbaseband> p_mq_BaseBand_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_bb_send, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\t/// cfm_bb_send type define end\n\n\t/// constructor\n\tcfm_bb_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_bb_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send local declarations' algorithm generated code\n\t//send operation duration in ms\n\tdouble op_send_duration;\n\t//End of 'BB_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief BB_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BB_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bb_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bb_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_baseband_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bb_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'BB_Send definitions' algorithm generated code\n\n//End of 'BB_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bb_send::cfm_bb_send(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_bb_send_dp_if(), p_mq_BaseBand_Out(\n\t\t\t\t\"p_mq_BaseBand_Out\"), p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send constructor' algorithm generated code\n\n\t//End of 'BB_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bb_send::~cfm_bb_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send destructor' algorithm generated code\n\n\t//End of 'BB_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_bb_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send pre elaboration' algorithm generated code\n\n\t//End of 'BB_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_bb_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send post elaboration' algorithm generated code\n\n\t//End of 'BB_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_bb_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send post simulation' algorithm generated code\n\n\t//End of 'BB_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_bb_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_bb_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'BB_Send initializations' algorithm generated code\n\t//send operation duration in ms\n\top_send_duration = 0;\n\t//End of 'BB_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_receive_dp_if.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defl2cap_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Receive includes' algorithm generated code\n\n//End of 'L2CAP_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Receive Function L2CAP_Receive\n//@{\n///        \\page dxpL2CAP_Receive\n//@{\n///    \\brief L2CAP_Receive function model start\nclass cfm_l2cap_receive: public cf_core::cf_function,\n\t\tpublic cfm_l2cap_receive_dp_if {\npublic:\n\t/// cfm_l2cap_receive type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_receive, cft_defrfcomm_in> p_mq_RFCOMM_In_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_receive, cft_defl2cap_in> p_mq_L2CAP_In_t;\n\t/// cfm_l2cap_receive type define end\n\n\t/// constructor\n\tcfm_l2cap_receive(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_l2cap_receive(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n\tp_mq_L2CAP_In_t p_mq_L2CAP_In;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive local declarations' algorithm generated code\n\n\t//End of 'L2CAP_Receive local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief L2CAP_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_l2cap_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Receive definitions' algorithm generated code\n\n//End of 'L2CAP_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_receive::cfm_l2cap_receive(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_l2cap_receive_dp_if(), p_mq_RFCOMM_In(\n\t\t\t\t\"p_mq_RFCOMM_In\"), p_mq_L2CAP_In(\"p_mq_L2CAP_In\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive constructor' algorithm generated code\n\n\t//End of 'L2CAP_Receive constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_receive::~cfm_l2cap_receive(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive destructor' algorithm generated code\n\n\t//End of 'L2CAP_Receive destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_l2cap_receive::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive pre elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Receive pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_l2cap_receive::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive post elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Receive post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_l2cap_receive::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive post simulation' algorithm generated code\n\n\t//End of 'L2CAP_Receive post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_l2cap_receive::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_l2cap_receive::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Receive initializations' algorithm generated code\n\n\t//End of 'L2CAP_Receive initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_send_dp_if.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Send includes' algorithm generated code\n\n//End of 'L2CAP_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Send Function L2CAP_Send\n//@{\n///        \\page dxpL2CAP_Send\n//@{\n///    \\brief L2CAP_Send function model start\nclass cfm_l2cap_send: public cf_core::cf_function, public cfm_l2cap_send_dp_if {\npublic:\n\t/// cfm_l2cap_send type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_send, cft_defrfcomm_out> p_mq_RFCOMM_Out_t;\n\ttypedef cf_core::cf_mq_initiator_socket<cfm_l2cap_send, cft_defl2cap_out> p_mq_L2CAP_Out_t;\n\t/// cfm_l2cap_send type define end\n\n\t/// constructor\n\tcfm_l2cap_send(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_l2cap_send(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n\tp_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send local declarations' algorithm generated code\n\n\t//End of 'L2CAP_Send local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief L2CAP_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_l2cap_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'L2CAP_Send definitions' algorithm generated code\n\n//End of 'L2CAP_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_send::cfm_l2cap_send(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_l2cap_send_dp_if(), p_mq_RFCOMM_Out(\n\t\t\t\t\"p_mq_RFCOMM_Out\"), p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send constructor' algorithm generated code\n\n\t//End of 'L2CAP_Send constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_send::~cfm_l2cap_send(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send destructor' algorithm generated code\n\n\t//End of 'L2CAP_Send destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_l2cap_send::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send pre elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Send pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_l2cap_send::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send post elaboration' algorithm generated code\n\n\t//End of 'L2CAP_Send post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_l2cap_send::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send post simulation' algorithm generated code\n\n\t//End of 'L2CAP_Send post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_l2cap_send::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_l2cap_send::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'L2CAP_Send initializations' algorithm generated code\n\n\t//End of 'L2CAP_Send initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OPP_UseCase', 'models': [{'name': 'StartFunc', 'type': 'cofluent:Function'}, {'name': 'UnusedFunc', 'type': 'cofluent:Function'}, {'name': 'Master', 'type': 'cofluent:Function'}, {'name': 'Slave', 'type': 'cofluent:Function'}], 'relations': [{'name': 'StartEv', 'type': 'cofluent:Event', 'connectTo': ['StartFunc']}, {'name': 'UnusedEv', 'type': 'cofluent:Event', 'connectTo': ['UnusedFunc']}, {'name': 'M2S', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'S2M', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_opp_usecase\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE\n#define COFS_MODEL_OPP_USECASE\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_opp_usecase_dp_if.h\"\n#include \"cfm_bt_system.h\"\n#include \"cfm_startfunc.h\"\n#include \"cfm_unusedfunc.h\"\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OPP_UseCase includes' algorithm generated code\n\n//End of 'OPP_UseCase includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOPP_UseCase Function OPP_UseCase\n//@{\n///        \\page dxpOPP_UseCase\n//@{\n///    \\brief OPP_UseCase function model start\nclass cfm_opp_usecase: public cf_core::cf_application,\n\t\tpublic cfm_opp_usecase_dp_if {\npublic:\n\t/// cfm_opp_usecase type define start\n\t/// relations typedef\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_M2S_t;\n\ttypedef cf_core::cf_message_queue<cft_defbaseband> mq_S2M_t;\n\ttypedef cf_core::cf_event ev_StartEv_t;\n\ttypedef cf_core::cf_event ev_UnusedEv_t;\n\n\t/// cfm_opp_usecase type define end\n\n\t/// constructor\n\tcfm_opp_usecase(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_opp_usecase(void);\n\tvirtual void cb_before_elaboration(void);\n\n\tvoid cb_end_of_elaboration(void);\n\tvoid cb_end_of_simulation(void);\n\npublic:\n\t/// \\name functions\n\t//@{\n\tcfm_bt_system* Master;\n\tcfm_bt_system* Slave;\n\tcfm_startfunc* StartFunc;\n\tcfm_unusedfunc* UnusedFunc;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\npublic:\n\t/// \\name relations\n\t//@{\n\tmq_M2S_t mq_M2S;\n\tmq_S2M_t mq_S2M;\n\tev_StartEv_t ev_StartEv;\n\tev_UnusedEv_t ev_UnusedEv;\n\t//@}\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase local declarations' algorithm generated code\n\n\t//End of 'OPP_UseCase local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief OPP_UseCase function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OPP_UseCase', 'models': [{'name': 'StartFunc', 'type': 'cofluent:Function'}, {'name': 'UnusedFunc', 'type': 'cofluent:Function'}, {'name': 'Master', 'type': 'cofluent:Function'}, {'name': 'Slave', 'type': 'cofluent:Function'}], 'relations': [{'name': 'StartEv', 'type': 'cofluent:Event', 'connectTo': ['StartFunc']}, {'name': 'UnusedEv', 'type': 'cofluent:Event', 'connectTo': ['UnusedFunc']}, {'name': 'M2S', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'S2M', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_opp_usecase\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_opp_usecase.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OPP_UseCase definitions' algorithm generated code\n\n//End of 'OPP_UseCase definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_opp_usecase::cfm_opp_usecase(sc_core::sc_module_name name) :\n\t\tcf_application(name), cfm_opp_usecase_dp_if(), mq_M2S(\"M2S\"), mq_S2M(\n\t\t\t\t\"S2M\"), ev_StartEv(\"StartEv\"), ev_UnusedEv(\"UnusedEv\") {\n\tcf_application::init();\n\tMaster = new cfm_bt_system(\"Master\");\n\tSlave = new cfm_bt_system(\"Slave\");\n\tStartFunc = new cfm_startfunc(\"StartFunc\");\n\tUnusedFunc = new cfm_unusedfunc(\"UnusedFunc\");\n\n\t// connections\n\tMaster->p_mq_BaseBand_Out(mq_M2S.p_target_socket);\n\tMaster->p_mq_BaseBand_In(mq_S2M.p_target_socket);\n\tMaster->p_ev_startEv(ev_StartEv.p_target_socket);\n\n\tSlave->p_mq_BaseBand_Out(mq_S2M.p_target_socket);\n\tSlave->p_mq_BaseBand_In(mq_M2S.p_target_socket);\n\tSlave->p_ev_startEv(ev_UnusedEv.p_target_socket);\n\n\tStartFunc->p_ev_StartEv(ev_StartEv.p_target_socket);\n\n\tUnusedFunc->p_ev_UnusedEv(ev_UnusedEv.p_target_socket);\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase constructor' algorithm generated code\n\n\t//End of 'OPP_UseCase constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_opp_usecase::~cfm_opp_usecase(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase destructor' algorithm generated code\n\n\t//End of 'OPP_UseCase destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\tdelete Master;\n\tdelete Slave;\n\tdelete StartFunc;\n\tdelete UnusedFunc;\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_opp_usecase::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase pre elaboration' algorithm generated code\n\n\t//End of 'OPP_UseCase pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_opp_usecase::cb_end_of_elaboration(void) {\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'OPP_UseCase post elaboration' algorithm generated code\n\tnb_file_parts = 0;\n\tnb_OBEX_df = 0;\n\tnb_RFCOMM_df = 0;\n\ttotal_delay_FILE = 0;\n\ttotal_delay_OBEX = 0;\n\ttotal_delay_RFCOMM = 0;\n\tnb_cdts_req = 0;\n\ttotal_L2CAP_data = 0;\n//End of 'OPP_UseCase post elaboration' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_opp_usecase::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase post simulation' algorithm generated code\n\t//perf result computation\n\ttotal_time = last_write_time - first_read_time; //in us\n\taverage_throughput = 1000000.0 * (double) File_Size * 8.0\n\t\t\t/ (double) total_time;\n\tcf_trace_gui_f_param(\"average_throughput\", average_throughput, \"kbits/s\");\n\n\t//print out results\n\tif (Verbose_Level != LEVEL_SILENT) {\n\t\t//file level perfs\n\t\tcf_trace_report(\"FILE LEVEL:\");\n\t\tcf_trace_report(\"\tFile size: %d kBytes\", (int) File_Size);\n\t\tcf_trace_report(\"\tMax file part size: %d Bytes\", (int) OBEX_pl_size);\n\t\tcf_trace_report(\"\tNumber of file parts: %d\", nb_file_parts);\n\t\tcf_trace_report(\n\t\t\t\t\"\t--> Total time between first read and last write:%d us\",\n\t\t\t\ttotal_time);\n\t\tcf_trace_report(\"\t--> Average throughput:%f kbits/s\",\n\t\t\t\taverage_throughput);\n\t\tcf_trace_report(\n\t\t\t\t\"\t--> Average delay between read and OBEX final packet (acknowledge) reception:%f us\",\n\t\t\t\t(double) total_delay_FILE / (double) nb_file_parts);\n\t\tcf_trace_report(\"OBEX LEVEL:\");\n\t\tcf_trace_report(\"\tMaximum frame size:%d Bytes\",\n\t\t\t\t(int) OBEX_pl_size + OBEX_HDR_S);\n\t\tcf_trace_report(\"\t--> Number of data frames: %d\", nb_OBEX_df);\n\t\tcf_trace_report(\n\t\t\t\t\"\t--> Average delay between data frame send and receive:%f us\",\n\t\t\t\t(double) total_delay_OBEX / (double) nb_OBEX_df);\n\t\tcf_trace_report(\"RFCOMM LEVEL:\");\n\t\tcf_trace_report(\"\tMaximum frame size:%d Bytes\",\n\t\t\t\t(int) RFCOMM_pl_size + RFCOMM_HDR_S);\n\t\tcf_trace_report(\"\t--> Number of data frames:%d\", nb_RFCOMM_df);\n\t\tcf_trace_report(\n\t\t\t\t\"\t--> Average delay between data frame send and receive:%f us\",\n\t\t\t\t(double) total_delay_RFCOMM / (double) nb_RFCOMM_df);\n\t\tcf_trace_report(\"\tNumber of credits:%d\", (int) RFCOMM_credits);\n\t\tcf_trace_report(\"\tNumber of credit requests:%d\", nb_cdts_req);\n\t\tcf_trace_report(\"L2CAP LEVEL:\");\n\t\tcf_trace_report(\"\tMaximum frame size:%d Bytes\",\n\t\t\t\t(int) RFCOMM_pl_size + RFCOMM_HDR_S + L2CAP_HDR_S);\n\t\tcf_trace_report(\"\t--> Number of data frames:%d\", nb_RFCOMM_df);\n\t\tcf_trace_report(\"\t--> Total amount of data exchanged:%d Bytes\",\n\t\t\t\ttotal_L2CAP_data);\n\t\tcf_trace_report(\"\t--> Average load:%f kbits/s\",\n\t\t\t\t8000.0 * (float) total_L2CAP_data / (float) total_time);\n\t\tcf_trace_report(\"BASEBAND LEVEL:\");\n\t\tcf_trace_report(\"\tAverage throughput:%d kbits/s\",\n\t\t\t\t(int) Throughput_BaseBand);\n\t}\n\t//End of 'OPP_UseCase post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_opp_usecase::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n// initialize relations attributes\n\tmq_M2S.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_M2S.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_M2S.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_M2S.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_M2S.cfa_concurrency.init((cf_nonzero_count) 1);\n\tmq_S2M.cfa_send_time.init(cf_expr_duration(0, CF_NS));\n\tmq_S2M.cfa_receive_time.init(cf_expr_duration(0, CF_NS));\n\tmq_S2M.cfa_queue_policy.init(CF_MQ_POLICY_FIFO_FINITE);\n\tmq_S2M.cfa_queue_capacity.init((cf_nonzero_count) 1);\n\tmq_S2M.cfa_concurrency.init((cf_nonzero_count) 1);\n\tev_StartEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_StartEv.cfa_get_time.init(cf_expr_duration(0, CF_NS));\n\tev_StartEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\tev_UnusedEv.cfa_set_time.init(cf_expr_duration(1, CF_NS));\n\tev_UnusedEv.cfa_get_time.init(cf_expr_duration(1, CF_NS));\n\tev_UnusedEv.cfa_event_policy.init(CF_EV_POLICY_BOOLEAN);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_opp_usecase::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'OPP_UseCase initializations' algorithm generated code\n\n\t//End of 'OPP_UseCase initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'StartFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'StartEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_startfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE_STARTFUNC\n#define COFS_MODEL_OPP_USECASE_STARTFUNC\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_startfunc_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'StartFunc includes' algorithm generated code\n\n//End of 'StartFunc includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgStartFunc Function StartFunc\n//@{\n///        \\page dxpStartFunc\n//@{\n///    \\brief StartFunc function model start\nclass cfm_startfunc: public cf_core::cf_function, public cfm_startfunc_dp_if {\npublic:\n\t/// cfm_startfunc type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_startfunc> p_ev_StartEv_t;\n\t/// cfm_startfunc type define end\n\n\t/// constructor\n\tcfm_startfunc(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_startfunc(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_StartEv_t p_ev_StartEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc local declarations' algorithm generated code\n\n\t//End of 'StartFunc local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief StartFunc function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE_STARTFUNC\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'StartFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'StartEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_startfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_startfunc.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_opp_usecase\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_startfunc\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'StartFunc definitions' algorithm generated code\n\n//End of 'StartFunc definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_startfunc::cfm_startfunc(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_startfunc_dp_if(), p_ev_StartEv(\"p_ev_StartEv\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc constructor' algorithm generated code\n\n\t//End of 'StartFunc constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_startfunc::~cfm_startfunc(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc destructor' algorithm generated code\n\n\t//End of 'StartFunc destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_startfunc::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc pre elaboration' algorithm generated code\n\n\t//End of 'StartFunc pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_startfunc::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc post elaboration' algorithm generated code\n\n\t//End of 'StartFunc post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_startfunc::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc post simulation' algorithm generated code\n\n\t//End of 'StartFunc post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_startfunc::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_startfunc::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'StartFunc initializations' algorithm generated code\n\n\t//End of 'StartFunc initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UnusedFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'UnusedEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_unusedfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n#define COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_unusedfunc_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UnusedFunc includes' algorithm generated code\n\n//End of 'UnusedFunc includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUnusedFunc Function UnusedFunc\n//@{\n///        \\page dxpUnusedFunc\n//@{\n///    \\brief UnusedFunc function model start\nclass cfm_unusedfunc: public cf_core::cf_function, public cfm_unusedfunc_dp_if {\npublic:\n\t/// cfm_unusedfunc type define start\n\n\t/// ports typedef\n\ttypedef cf_core::cf_ev_initiator_socket<cfm_unusedfunc> p_ev_UnusedEv_t;\n\t/// cfm_unusedfunc type define end\n\n\t/// constructor\n\tcfm_unusedfunc(sc_core::sc_module_name name);\n\n\t/// destructor\n\tvirtual ~cfm_unusedfunc(void);\n\tvirtual void cb_before_elaboration(void);\n\tvirtual void cb_end_of_elaboration(void);\n\tvirtual void cb_end_of_simulation(void);\n\npublic:\n\t/// \\name input/output ports\n\t//@{\n\tp_ev_UnusedEv_t p_ev_UnusedEv;\n\t//@}\n\nprotected:\n\t/// initialize attributes\n\tvoid cb_init_attributes(void);\n\t/// initialize definitions\n\tvoid cb_init_local_vars(void);\n\n\t/// Model private fields start\n\t/// Model private fields end\n\n\t/// \\name user-defined local declarations\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc local declarations' algorithm generated code\n\n\t//End of 'UnusedFunc local declarations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n};\n///    \\brief UnusedFunc function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UnusedFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'UnusedEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_unusedfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_unusedfunc.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_opp_usecase\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_unusedfunc\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n//Start of 'UnusedFunc definitions' algorithm generated code\n\n//End of 'UnusedFunc definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_unusedfunc::cfm_unusedfunc(sc_core::sc_module_name name) :\n\t\tcf_function(name), cfm_unusedfunc_dp_if(), p_ev_UnusedEv(\n\t\t\t\t\"p_ev_UnusedEv\") {\n\tcf_function::init();\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc constructor' algorithm generated code\n\n\t//End of 'UnusedFunc constructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n\n\tcf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_unusedfunc::~cfm_unusedfunc(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc destructor' algorithm generated code\n\n\t//End of 'UnusedFunc destructor' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name pre-elaboration section\n//@{\nvoid cfm_unusedfunc::cb_before_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc pre elaboration' algorithm generated code\n\n\t//End of 'UnusedFunc pre elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-elaboration section\n//@{\nvoid cfm_unusedfunc::cb_end_of_elaboration(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc post elaboration' algorithm generated code\n\n\t//End of 'UnusedFunc post elaboration' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name post-simulation section\n//@{\nvoid cfm_unusedfunc::cb_end_of_simulation(void) {\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc post simulation' algorithm generated code\n\n\t//End of 'UnusedFunc post simulation' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n/// \\name initialize attributes\n//@{\nvoid cfm_unusedfunc::cb_init_attributes() {\n\n// initialize function attributes\n\tcfa_cycle_period.init(cf_expr_time(10, CF_NS));\n\tcfa_scope.init(CF_FCT_SYSTEM);\n\n\treturn;\n}\n//@}\n\n/// \\name initialize definitions\n//@{\nvoid cfm_unusedfunc::cb_init_local_vars(void) {\n\n\t//<#!@READ-ONLY-SECTION-END@!#>\n\t//Start of 'UnusedFunc initializations' algorithm generated code\n\n\t//End of 'UnusedFunc initializations' algorithm generated code\n\t//<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    }
]