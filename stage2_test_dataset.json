[
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'SoftwareDefinedRadioApp', 'models': [{'name': 'MobilePhone', 'type': 'cofluent:Function'}, {'name': 'Networks', 'type': 'cofluent:Function'}, {'name': 'User', 'type': 'cofluent:Function'}], 'relations': [{'name': 'NetToDVB', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'NetToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Request', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'Response', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'UMTSToNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Video', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'User']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_softwaredefinedradioapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n\n/// Model Header includes start\n#include \"cfm_mobilephone.h\"\n#include \"cfm_networks.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cfm_user.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_softwaredefinedradioapp_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'SoftwareDefinedRadioApp includes' algorithm generated code\n\n// End of 'SoftwareDefinedRadioApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSoftwareDefinedRadioApp Function SoftwareDefinedRadioApp\n//@{\n///        \\page dxpSoftwareDefinedRadioApp\n//@{\n///    \\brief SoftwareDefinedRadioApp function model start\nclass cfm_softwaredefinedradioapp : public cf_core::cf_application,\n                                    public cfm_softwaredefinedradioapp_dp_if {\npublic:\n  /// cfm_softwaredefinedradioapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defvideo> mq_NetToDVB_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_NetToUMTS_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_Request_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_Response_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_UMTSToNet_t;\n  typedef cf_core::cf_message_queue<cft_defvideo> mq_Video_t;\n\n  /// cfm_softwaredefinedradioapp type define end\n\n  /// constructor\n  cfm_softwaredefinedradioapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_softwaredefinedradioapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_mobilephone *MobilePhone;\n  cfm_networks *Networks;\n  cfm_user *User;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_NetToDVB_t mq_NetToDVB;\n  mq_NetToUMTS_t mq_NetToUMTS;\n  mq_Request_t mq_Request;\n  mq_Response_t mq_Response;\n  mq_UMTSToNet_t mq_UMTSToNet;\n  mq_Video_t mq_Video;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'SoftwareDefinedRadioApp local declarations' algorithm generated\n  // code\n\n  // End of 'SoftwareDefinedRadioApp local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief SoftwareDefinedRadioApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'SoftwareDefinedRadioApp', 'models': [{'name': 'MobilePhone', 'type': 'cofluent:Function'}, {'name': 'Networks', 'type': 'cofluent:Function'}, {'name': 'User', 'type': 'cofluent:Function'}], 'relations': [{'name': 'NetToDVB', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'NetToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Request', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'Response', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'User']}, {'name': 'UMTSToNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['MobilePhone', 'Networks']}, {'name': 'Video', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['MobilePhone', 'User']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_softwaredefinedradioapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_softwaredefinedradioapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'SoftwareDefinedRadioApp definitions' algorithm generated code\n\n// End of 'SoftwareDefinedRadioApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_softwaredefinedradioapp ::cfm_softwaredefinedradioapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), cfm_softwaredefinedradioapp_dp_if(),\n      mq_NetToDVB(\"NetToDVB\"), mq_NetToUMTS(\"NetToUMTS\"), mq_Request(\"Request\"),\n      mq_Response(\"Response\"), mq_UMTSToNet(\"UMTSToNet\"), mq_Video(\"Video\") {\n  cf_application::init();\n  // instantiation of models\n  MobilePhone = new cfm_mobilephone(\"MobilePhone\");\n  Networks = new cfm_networks(\"Networks\");\n  User = new cfm_user(\"User\");\n  // connections\n  // model connect to relation\n  MobilePhone->p_mq_NetToDVB(mq_NetToDVB.p_target_socket);\n  MobilePhone->p_mq_NetToUMTS(mq_NetToUMTS.p_target_socket);\n  MobilePhone->p_mq_Request(mq_Request.p_target_socket);\n  MobilePhone->p_mq_Response(mq_Response.p_target_socket);\n  MobilePhone->p_mq_UMTSToNet(mq_UMTSToNet.p_target_socket);\n  MobilePhone->p_mq_Video(mq_Video.p_target_socket);\n  // model connect to relation\n  Networks->p_mq_NetToDVB(mq_NetToDVB.p_target_socket);\n  Networks->p_mq_NetToUMTS(mq_NetToUMTS.p_target_socket);\n  Networks->p_mq_UMTSToNet(mq_UMTSToNet.p_target_socket);\n  // model connect to relation\n  User->p_mq_Request(mq_Request.p_target_socket);\n  User->p_mq_Response(mq_Response.p_target_socket);\n  User->p_mq_Video(mq_Video.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_softwaredefinedradioapp::~cfm_softwaredefinedradioapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'SoftwareDefinedRadioApp destructor' algorithm generated code\n\n  // End of 'SoftwareDefinedRadioApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete MobilePhone;\n  delete Networks;\n  delete User;\n}\n\n//@{\nvoid cfm_softwaredefinedradioapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_softwaredefinedradioapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MobilePhone', 'type': 'cofluent:Function', 'models': [{'name': 'ApplicationLayer', 'type': 'cofluent:Function'}, {'name': 'CallProtocolStack', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}, {'name': 'VideoProtocolStack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoProtocolStack']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer']}], 'relations': [{'name': 'AppToCtrl', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'Controller']}, {'name': 'AppToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'HTTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'RTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer', 'VideoProtocolStack']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mobilephone\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n\n/// Model Header includes start\n#include \"cfm_applicationlayer.h\"\n#include \"cfm_callprotocolstack.h\"\n#include \"cfm_controller.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cfm_videoprotocolstack.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_mobilephone_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MobilePhone includes' algorithm generated code\n\n// End of 'MobilePhone includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMobilePhone Function MobilePhone\n//@{\n///        \\page dxpMobilePhone\n//@{\n///    \\brief MobilePhone function model start\nclass cfm_mobilephone : public cf_core::cf_function_container,\n                        public cfm_mobilephone_dp_if {\npublic:\n  /// cfm_mobilephone type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defcall> mq_AppToCtrl_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_AppToHTTP_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_HTTPToApp_t;\n  typedef cf_core::cf_message_queue<cft_defvideo> mq_RTPToApp_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cfm_defvideo>\n      p_mq_NetToDVB_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cfm_defcall>\n      p_mq_NetToUMTS_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cfm_defcall>\n      p_mq_Request_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cfm_defcall>\n      p_mq_Response_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cfm_defcall>\n      p_mq_UMTSToNet_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_mobilephone, cfm_defvideo>\n      p_mq_Video_t;\n  /// cfm_mobilephone type define end\n\n  /// constructor\n  cfm_mobilephone(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_mobilephone(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_NetToDVB_t p_mq_NetToDVB;\n  p_mq_NetToUMTS_t p_mq_NetToUMTS;\n  p_mq_Request_t p_mq_Request;\n  p_mq_Response_t p_mq_Response;\n  p_mq_UMTSToNet_t p_mq_UMTSToNet;\n  p_mq_Video_t p_mq_Video;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_applicationlayer *ApplicationLayer;\n  cfm_callprotocolstack *CallProtocolStack;\n  cfm_controller *Controller;\n  cfm_videoprotocolstack *VideoProtocolStack;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_AppToCtrl_t mq_AppToCtrl;\n  mq_AppToHTTP_t mq_AppToHTTP;\n  mq_HTTPToApp_t mq_HTTPToApp;\n  mq_RTPToApp_t mq_RTPToApp;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MobilePhone local declarations' algorithm generated code\n\n  // End of 'MobilePhone local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief MobilePhone function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MOBILEPHONE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MobilePhone', 'type': 'cofluent:Function', 'models': [{'name': 'ApplicationLayer', 'type': 'cofluent:Function'}, {'name': 'CallProtocolStack', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}, {'name': 'VideoProtocolStack', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoProtocolStack']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallProtocolStack']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer']}], 'relations': [{'name': 'AppToCtrl', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'Controller']}, {'name': 'AppToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'HTTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['ApplicationLayer', 'CallProtocolStack']}, {'name': 'RTPToApp', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['ApplicationLayer', 'VideoProtocolStack']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mobilephone\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mobilephone.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mobilephone\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MobilePhone definitions' algorithm generated code\n\n// End of 'MobilePhone definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mobilephone ::cfm_mobilephone()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_mobilephone_dp_if(),\n      mq_AppToCtrl(\"AppToCtrl\"), mq_AppToHTTP(\"AppToHTTP\"),\n      mq_HTTPToApp(\"HTTPToApp\"), mq_RTPToApp(\"RTPToApp\"),\n      p_mq_NetToDVB(\"p_mq_NetToDVB\"), p_mq_NetToUMTS(\"p_mq_NetToUMTS\"),\n      p_mq_Request(\"p_mq_Request\"), p_mq_Response(\"p_mq_Response\"),\n      p_mq_UMTSToNet(\"p_mq_UMTSToNet\"), p_mq_Video(\"p_mq_Video\") {\n  cf_function_container::init();\n  // instantiation of models\n  ApplicationLayer = new cfm_applicationlayer(\"ApplicationLayer\");\n  CallProtocolStack = new cfm_callprotocolstack(\"CallProtocolStack\");\n  Controller = new cfm_controller(\"Controller\");\n  VideoProtocolStack = new cfm_videoprotocolstack(\"VideoProtocolStack\");\n  // connections\n  // model connect to relation\n  ApplicationLayer->p_mq_AppToCtrl(mq_AppToCtrl.p_target_socket);\n  ApplicationLayer->p_mq_AppToHTTP(mq_AppToHTTP.p_target_socket);\n  ApplicationLayer->p_mq_HTTPToApp(mq_HTTPToApp.p_target_socket);\n  ApplicationLayer->p_mq_RTPToApp(mq_RTPToApp.p_target_socket);\n  // model connect to port\n  ApplicationLayer->p_mq_Request(p_mq_Request);\n  ApplicationLayer->p_mq_Response(p_mq_Response);\n  ApplicationLayer->p_mq_Video(p_mq_Video);\n  // model connect to relation\n  CallProtocolStack->p_mq_AppToHTTP(mq_AppToHTTP.p_target_socket);\n  CallProtocolStack->p_mq_HTTPToApp(mq_HTTPToApp.p_target_socket);\n  // model connect to port\n  CallProtocolStack->p_mq_NetToUMTS(p_mq_NetToUMTS);\n  CallProtocolStack->p_mq_UMTSToNet(p_mq_UMTSToNet);\n  // model connect to relation\n  Controller->p_mq_AppToCtrl(mq_AppToCtrl.p_target_socket);\n  // model connect to relation\n  VideoProtocolStack->p_mq_RTPToApp(mq_RTPToApp.p_target_socket);\n  // model connect to port\n  VideoProtocolStack->p_mq_NetToDVB(p_mq_NetToDVB);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mobilephone::~cfm_mobilephone(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MobilePhone destructor' algorithm generated code\n\n  // End of 'MobilePhone destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete ApplicationLayer;\n  delete CallProtocolStack;\n  delete Controller;\n  delete VideoProtocolStack;\n}\n\n//@{\nvoid cfm_mobilephone::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_mobilephone::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Networks', 'type': 'cofluent:Function', 'models': [{'name': 'BroadcastNetwork', 'type': 'cofluent:Function'}, {'name': 'ClockGenerator', 'type': 'cofluent:Function'}, {'name': 'InteractiveNetwork', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['BroadcastNetwork']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}], 'relations': [{'name': 'BurstClock', 'type': 'cofluent:Event', 'connectTo': ['BroadcastNetwork', 'ClockGenerator']}, {'name': 'VideoFiles', 'type': 'cofluent:SharedVariable', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'VideoNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_networks\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n\n/// Model Header includes start\n#include \"cfm_broadcastnetwork.h\"\n#include \"cfm_clockgenerator.h\"\n#include \"cfm_interactivenetwork.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_networks_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defnet.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Networks includes' algorithm generated code\n\n// End of 'Networks includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgNetworks Function Networks\n//@{\n///        \\page dxpNetworks\n//@{\n///    \\brief Networks function model start\nclass cfm_networks : public cf_core::cf_function_container,\n                     public cfm_networks_dp_if {\npublic:\n  /// cfm_networks type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_BurstClock_t;\n  typedef cf_core::cf_message_queue<cft_defnet> mq_VideoNet_t;\n  typedef cf_core::cf_shared_variable<cft_defnet> sv_VideoFiles_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_networks, cfm_defvideo>\n      p_mq_NetToDVB_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_networks, cfm_defcall>\n      p_mq_NetToUMTS_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_networks, cfm_defcall>\n      p_mq_UMTSToNet_t;\n  /// cfm_networks type define end\n\n  /// constructor\n  cfm_networks(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_networks(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_NetToDVB_t p_mq_NetToDVB;\n  p_mq_NetToUMTS_t p_mq_NetToUMTS;\n  p_mq_UMTSToNet_t p_mq_UMTSToNet;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_broadcastnetwork *BroadcastNetwork;\n  cfm_clockgenerator *ClockGenerator;\n  cfm_interactivenetwork *InteractiveNetwork;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_BurstClock_t ev_BurstClock;\n  mq_VideoNet_t mq_VideoNet;\n  sv_VideoFiles_t sv_VideoFiles;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Networks local declarations' algorithm generated code\n\n  // End of 'Networks local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Networks function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_NETWORKS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Networks', 'type': 'cofluent:Function', 'models': [{'name': 'BroadcastNetwork', 'type': 'cofluent:Function'}, {'name': 'ClockGenerator', 'type': 'cofluent:Function'}, {'name': 'InteractiveNetwork', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['BroadcastNetwork']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['InteractiveNetwork']}], 'relations': [{'name': 'BurstClock', 'type': 'cofluent:Event', 'connectTo': ['BroadcastNetwork', 'ClockGenerator']}, {'name': 'VideoFiles', 'type': 'cofluent:SharedVariable', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}, {'name': 'VideoNet', 'type': 'cofluent:MessageQueue', 'dataType': 'DefNet', 'connectTo': ['InteractiveNetwork', 'BroadcastNetwork']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_networks\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_networks.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_networks\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Networks definitions' algorithm generated code\n\n// End of 'Networks definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_networks ::cfm_networks()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_networks_dp_if(),\n      ev_BurstClock(\"BurstClock\"), mq_VideoNet(\"VideoNet\"),\n      p_mq_NetToDVB(\"p_mq_NetToDVB\"), p_mq_NetToUMTS(\"p_mq_NetToUMTS\"),\n      p_mq_UMTSToNet(\"p_mq_UMTSToNet\"), sv_VideoFiles(\"VideoFiles\") {\n  cf_function_container::init();\n  // instantiation of models\n  BroadcastNetwork = new cfm_broadcastnetwork(\"BroadcastNetwork\");\n  ClockGenerator = new cfm_clockgenerator(\"ClockGenerator\");\n  InteractiveNetwork = new cfm_interactivenetwork(\"InteractiveNetwork\");\n  // connections\n  // model connect to relation\n  BroadcastNetwork->p_ev_BurstClock(ev_BurstClock.p_target_socket);\n  BroadcastNetwork->p_sv_VideoFiles(sv_VideoFiles.p_target_socket);\n  BroadcastNetwork->p_mq_VideoNet(mq_VideoNet.p_target_socket);\n  // model connect to port\n  BroadcastNetwork->p_mq_NetToDVB(p_mq_NetToDVB);\n  // model connect to relation\n  ClockGenerator->p_ev_BurstClock(ev_BurstClock.p_target_socket);\n  // model connect to relation\n  InteractiveNetwork->p_sv_VideoFiles(sv_VideoFiles.p_target_socket);\n  InteractiveNetwork->p_mq_VideoNet(mq_VideoNet.p_target_socket);\n  // model connect to port\n  InteractiveNetwork->p_mq_NetToUMTS(p_mq_NetToUMTS);\n  InteractiveNetwork->p_mq_UMTSToNet(p_mq_UMTSToNet);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_networks::~cfm_networks(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Networks destructor' algorithm generated code\n\n  // End of 'Networks destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete BroadcastNetwork;\n  delete ClockGenerator;\n  delete InteractiveNetwork;\n}\n\n//@{\nvoid cfm_networks::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_networks::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'User', 'type': 'cofluent:Function', 'models': [{'name': 'Reading', 'type': 'cofluent:Function'}, {'name': 'Requesting', 'type': 'cofluent:Function'}, {'name': 'Watching', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['Requesting', 'Reading']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['Reading']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['Watching']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_user\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n\n/// Model Header includes start\n#include \"cfm_reading.h\"\n#include \"cfm_requesting.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cfm_watching.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_user_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'User includes' algorithm generated code\n\n// End of 'User includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUser Function User\n//@{\n///        \\page dxpUser\n//@{\n///    \\brief User function model start\nclass cfm_user : public cf_core::cf_function_container, public cfm_user_dp_if {\npublic:\n  /// cfm_user type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_user, cfm_defcall> p_mq_Request_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_user, cfm_defcall>\n      p_mq_Response_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_user, cfm_defvideo> p_mq_Video_t;\n  /// cfm_user type define end\n\n  /// constructor\n  cfm_user(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_user(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_Request_t p_mq_Request;\n  p_mq_Response_t p_mq_Response;\n  p_mq_Video_t p_mq_Video;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_reading *Reading;\n  cfm_requesting *Requesting;\n  cfm_watching *Watching;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'User local declarations' algorithm generated code\n\n  // End of 'User local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief User function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_USER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'User', 'type': 'cofluent:Function', 'models': [{'name': 'Reading', 'type': 'cofluent:Function'}, {'name': 'Requesting', 'type': 'cofluent:Function'}, {'name': 'Watching', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['Requesting', 'Reading']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['Reading']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['Watching']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_user\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_user.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_softwaredefinedradioapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_user\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'User definitions' algorithm generated code\n\n// End of 'User definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_user ::cfm_user()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_user_dp_if(),\n      p_mq_Request(\"p_mq_Request\"), p_mq_Response(\"p_mq_Response\"),\n      p_mq_Video(\"p_mq_Video\") {\n  cf_function_container::init();\n  // instantiation of models\n  Reading = new cfm_reading(\"Reading\");\n  Requesting = new cfm_requesting(\"Requesting\");\n  Watching = new cfm_watching(\"Watching\");\n  // connections\n  // model connect to port\n  Reading->p_mq_Request(p_mq_Request);\n  Reading->p_mq_Response(p_mq_Response);\n  // model connect to port\n  Requesting->p_mq_Request(p_mq_Request);\n  // model connect to port\n  Watching->p_mq_Video(p_mq_Video);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_user::~cfm_user(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'User destructor' algorithm generated code\n\n  // End of 'User destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Reading;\n  delete Requesting;\n  delete Watching;\n}\n\n//@{\nvoid cfm_user::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_user::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationLayer', 'type': 'cofluent:Function', 'models': [{'name': 'CallApplication', 'type': 'cofluent:Function'}, {'name': 'VideoApplication', 'type': 'cofluent:Function'}], 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationlayer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n\n/// Model Header includes start\n#include \"cfm_callapplication.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cfm_videoapplication.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationlayer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationLayer includes' algorithm generated code\n\n// End of 'ApplicationLayer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationLayer Function ApplicationLayer\n//@{\n///        \\page dxpApplicationLayer\n//@{\n///    \\brief ApplicationLayer function model start\nclass cfm_applicationlayer : public cf_core::cf_function_container,\n                             public cfm_applicationlayer_dp_if {\npublic:\n  /// cfm_applicationlayer type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cfm_defcall>\n      p_mq_AppToCtrl_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cfm_defcall>\n      p_mq_AppToHTTP_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cfm_defcall>\n      p_mq_HTTPToApp_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cfm_defvideo>\n      p_mq_RTPToApp_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cfm_defcall>\n      p_mq_Request_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cfm_defcall>\n      p_mq_Response_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_applicationlayer, cfm_defvideo>\n      p_mq_Video_t;\n  /// cfm_applicationlayer type define end\n\n  /// constructor\n  cfm_applicationlayer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_applicationlayer(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_AppToCtrl_t p_mq_AppToCtrl;\n  p_mq_AppToHTTP_t p_mq_AppToHTTP;\n  p_mq_HTTPToApp_t p_mq_HTTPToApp;\n  p_mq_RTPToApp_t p_mq_RTPToApp;\n  p_mq_Request_t p_mq_Request;\n  p_mq_Response_t p_mq_Response;\n  p_mq_Video_t p_mq_Video;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_callapplication *CallApplication;\n  cfm_videoapplication *VideoApplication;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationLayer local declarations' algorithm generated code\n\n  // End of 'ApplicationLayer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ApplicationLayer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_APPLICATIONLAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationLayer', 'type': 'cofluent:Function', 'models': [{'name': 'CallApplication', 'type': 'cofluent:Function'}, {'name': 'VideoApplication', 'type': 'cofluent:Function'}], 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['CallApplication']}, {'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['VideoApplication']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationlayer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationlayer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_applicationlayer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationLayer definitions' algorithm generated code\n\n// End of 'ApplicationLayer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationlayer ::cfm_applicationlayer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_applicationlayer_dp_if(),\n      p_mq_AppToCtrl(\"p_mq_AppToCtrl\"), p_mq_AppToHTTP(\"p_mq_AppToHTTP\"),\n      p_mq_HTTPToApp(\"p_mq_HTTPToApp\"), p_mq_RTPToApp(\"p_mq_RTPToApp\"),\n      p_mq_Request(\"p_mq_Request\"), p_mq_Response(\"p_mq_Response\"),\n      p_mq_Video(\"p_mq_Video\") {\n  cf_function_container::init();\n  // instantiation of models\n  CallApplication = new cfm_callapplication(\"CallApplication\");\n  VideoApplication = new cfm_videoapplication(\"VideoApplication\");\n  // connections\n  // model connect to port\n  CallApplication->p_mq_AppToCtrl(p_mq_AppToCtrl);\n  CallApplication->p_mq_AppToHTTP(p_mq_AppToHTTP);\n  CallApplication->p_mq_HTTPToApp(p_mq_HTTPToApp);\n  CallApplication->p_mq_Request(p_mq_Request);\n  CallApplication->p_mq_Response(p_mq_Response);\n  // model connect to port\n  VideoApplication->p_mq_RTPToApp(p_mq_RTPToApp);\n  VideoApplication->p_mq_Video(p_mq_Video);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationlayer::~cfm_applicationlayer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationLayer destructor' algorithm generated code\n\n  // End of 'ApplicationLayer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete CallApplication;\n  delete VideoApplication;\n}\n\n//@{\nvoid cfm_applicationlayer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_applicationlayer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CallProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP', 'type': 'cofluent:Function'}, {'name': 'IPCall', 'type': 'cofluent:Function'}, {'name': 'UMTS', 'type': 'cofluent:Function'}], 'ports': [{'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS']}], 'relations': [{'name': 'HTTPToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}, {'name': 'UMTSToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_callprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n\n/// Model Header includes start\n#include \"cfm_httptcp.h\"\n#include \"cfm_ipcall.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cfm_umts.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_callprotocolstack_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CallProtocolStack includes' algorithm generated code\n\n// End of 'CallProtocolStack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCallProtocolStack Function CallProtocolStack\n//@{\n///        \\page dxpCallProtocolStack\n//@{\n///    \\brief CallProtocolStack function model start\nclass cfm_callprotocolstack : public cf_core::cf_function_container,\n                              public cfm_callprotocolstack_dp_if {\npublic:\n  /// cfm_callprotocolstack type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defcall> mq_HTTPToIP_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_IPToHTTP_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_IPToUMTS_t;\n  typedef cf_core::cf_message_queue<cft_defcall> mq_UMTSToIP_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cfm_defcall>\n      p_mq_AppToHTTP_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cfm_defcall>\n      p_mq_HTTPToApp_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cfm_defcall>\n      p_mq_NetToUMTS_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_callprotocolstack, cfm_defcall>\n      p_mq_UMTSToNet_t;\n  /// cfm_callprotocolstack type define end\n\n  /// constructor\n  cfm_callprotocolstack(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_callprotocolstack(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_AppToHTTP_t p_mq_AppToHTTP;\n  p_mq_HTTPToApp_t p_mq_HTTPToApp;\n  p_mq_NetToUMTS_t p_mq_NetToUMTS;\n  p_mq_UMTSToNet_t p_mq_UMTSToNet;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_httptcp *HTTPTCP;\n  cfm_ipcall *IPCall;\n  cfm_umts *UMTS;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_HTTPToIP_t mq_HTTPToIP;\n  mq_IPToHTTP_t mq_IPToHTTP;\n  mq_IPToUMTS_t mq_IPToUMTS;\n  mq_UMTSToIP_t mq_UMTSToIP;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CallProtocolStack local declarations' algorithm generated code\n\n  // End of 'CallProtocolStack local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CallProtocolStack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLPROTOCOLSTACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CallProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP', 'type': 'cofluent:Function'}, {'name': 'IPCall', 'type': 'cofluent:Function'}, {'name': 'UMTS', 'type': 'cofluent:Function'}], 'ports': [{'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS']}], 'relations': [{'name': 'HTTPToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToHTTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP', 'IPCall']}, {'name': 'IPToUMTS', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}, {'name': 'UMTSToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefCall', 'connectTo': ['IPCall', 'UMTS']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_callprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_callprotocolstack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_callprotocolstack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CallProtocolStack definitions' algorithm generated code\n\n// End of 'CallProtocolStack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_callprotocolstack ::cfm_callprotocolstack()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_callprotocolstack_dp_if(),\n      mq_HTTPToIP(\"HTTPToIP\"), mq_IPToHTTP(\"IPToHTTP\"), mq_IPToUMTS(\"IPToUMTS\"),\n      mq_UMTSToIP(\"UMTSToIP\"), p_mq_AppToHTTP(\"p_mq_AppToHTTP\"),\n      p_mq_HTTPToApp(\"p_mq_HTTPToApp\"), p_mq_NetToUMTS(\"p_mq_NetToUMTS\"),\n      p_mq_UMTSToNet(\"p_mq_UMTSToNet\") {\n  cf_function_container::init();\n  // instantiation of models\n  HTTPTCP = new cfm_httptcp(\"HTTPTCP\");\n  IPCall = new cfm_ipcall(\"IPCall\");\n  UMTS = new cfm_umts(\"UMTS\");\n  // connections\n  // model connect to relation\n  HTTPTCP->p_mq_HTTPToIP(mq_HTTPToIP.p_target_socket);\n  HTTPTCP->p_mq_IPToHTTP(mq_IPToHTTP.p_target_socket);\n  // model connect to port\n  HTTPTCP->p_mq_AppToHTTP(p_mq_AppToHTTP);\n  HTTPTCP->p_mq_HTTPToApp(p_mq_HTTPToApp);\n  // model connect to relation\n  IPCall->p_mq_HTTPToIP(mq_HTTPToIP.p_target_socket);\n  IPCall->p_mq_IPToHTTP(mq_IPToHTTP.p_target_socket);\n  IPCall->p_mq_IPToUMTS(mq_IPToUMTS.p_target_socket);\n  IPCall->p_mq_UMTSToIP(mq_UMTSToIP.p_target_socket);\n  // model connect to relation\n  UMTS->p_mq_IPToUMTS(mq_IPToUMTS.p_target_socket);\n  UMTS->p_mq_UMTSToIP(mq_UMTSToIP.p_target_socket);\n  // model connect to port\n  UMTS->p_mq_NetToUMTS(p_mq_NetToUMTS);\n  UMTS->p_mq_UMTSToNet(p_mq_UMTSToNet);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_callprotocolstack::~cfm_callprotocolstack(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CallProtocolStack destructor' algorithm generated code\n\n  // End of 'CallProtocolStack destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete HTTPTCP;\n  delete IPCall;\n  delete UMTS;\n}\n\n//@{\nvoid cfm_callprotocolstack::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_callprotocolstack::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VideoProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'IPVideo', 'type': 'cofluent:Function'}, {'name': 'MPETSL', 'type': 'cofluent:Function'}, {'name': 'RTPUDP', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['MPETSL']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP']}], 'relations': [{'name': 'IPToRTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP', 'IPVideo']}, {'name': 'MPEToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['IPVideo', 'MPETSL']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_videoprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n\n/// Model Header includes start\n#include \"cfm_ipvideo.h\"\n#include \"cfm_mpetsl.h\"\n#include \"cfm_rtpudp.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_videoprotocolstack_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'VideoProtocolStack includes' algorithm generated code\n\n// End of 'VideoProtocolStack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgVideoProtocolStack Function VideoProtocolStack\n//@{\n///        \\page dxpVideoProtocolStack\n//@{\n///    \\brief VideoProtocolStack function model start\nclass cfm_videoprotocolstack : public cf_core::cf_function_container,\n                               public cfm_videoprotocolstack_dp_if {\npublic:\n  /// cfm_videoprotocolstack type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defvideo> mq_IPToRTP_t;\n  typedef cf_core::cf_message_queue<cft_defvideo> mq_MPEToIP_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_videoprotocolstack, cfm_defvideo>\n      p_mq_NetToDVB_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_videoprotocolstack, cfm_defvideo>\n      p_mq_RTPToApp_t;\n  /// cfm_videoprotocolstack type define end\n\n  /// constructor\n  cfm_videoprotocolstack(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_videoprotocolstack(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_NetToDVB_t p_mq_NetToDVB;\n  p_mq_RTPToApp_t p_mq_RTPToApp;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_ipvideo *IPVideo;\n  cfm_mpetsl *MPETSL;\n  cfm_rtpudp *RTPUDP;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_IPToRTP_t mq_IPToRTP;\n  mq_MPEToIP_t mq_MPEToIP;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'VideoProtocolStack local declarations' algorithm generated code\n\n  // End of 'VideoProtocolStack local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief VideoProtocolStack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOPROTOCOLSTACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VideoProtocolStack', 'type': 'cofluent:Function', 'models': [{'name': 'IPVideo', 'type': 'cofluent:Function'}, {'name': 'MPETSL', 'type': 'cofluent:Function'}, {'name': 'RTPUDP', 'type': 'cofluent:Function'}], 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo', 'connectTo': ['MPETSL']}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP']}], 'relations': [{'name': 'IPToRTP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['RTPUDP', 'IPVideo']}, {'name': 'MPEToIP', 'type': 'cofluent:MessageQueue', 'dataType': 'DefVideo', 'connectTo': ['IPVideo', 'MPETSL']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_videoprotocolstack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_videoprotocolstack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'VideoProtocolStack definitions' algorithm generated code\n\n// End of 'VideoProtocolStack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_videoprotocolstack ::cfm_videoprotocolstack()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_videoprotocolstack_dp_if(),\n      mq_IPToRTP(\"IPToRTP\"), mq_MPEToIP(\"MPEToIP\"),\n      p_mq_NetToDVB(\"p_mq_NetToDVB\"), p_mq_RTPToApp(\"p_mq_RTPToApp\") {\n  cf_function_container::init();\n  // instantiation of models\n  IPVideo = new cfm_ipvideo(\"IPVideo\");\n  MPETSL = new cfm_mpetsl(\"MPETSL\");\n  RTPUDP = new cfm_rtpudp(\"RTPUDP\");\n  // connections\n  // model connect to relation\n  IPVideo->p_mq_IPToRTP(mq_IPToRTP.p_target_socket);\n  IPVideo->p_mq_MPEToIP(mq_MPEToIP.p_target_socket);\n  // model connect to relation\n  MPETSL->p_mq_MPEToIP(mq_MPEToIP.p_target_socket);\n  // model connect to port\n  MPETSL->p_mq_NetToDVB(p_mq_NetToDVB);\n  // model connect to relation\n  RTPUDP->p_mq_IPToRTP(mq_IPToRTP.p_target_socket);\n  // model connect to port\n  RTPUDP->p_mq_RTPToApp(p_mq_RTPToApp);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_videoprotocolstack::~cfm_videoprotocolstack(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'VideoProtocolStack destructor' algorithm generated code\n\n  // End of 'VideoProtocolStack destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete IPVideo;\n  delete MPETSL;\n  delete RTPUDP;\n}\n\n//@{\nvoid cfm_videoprotocolstack::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_videoprotocolstack::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_controller_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Controller includes' algorithm generated code\n\n// End of 'Controller includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgController Function Controller\n//@{\n///        \\page dxpController\n//@{\n///    \\brief Controller function model start\nclass cfm_controller : public cf_core::cf_function,\n                       public cfm_controller_dp_if {\npublic:\n  /// cfm_controller type define start\n\n  /// constructor\n  cfm_controller(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_controller(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Controller local declarations' algorithm generated code\n\n  // End of 'Controller local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Controller function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CONTROLLER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_controller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mobilephone\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_controller\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Controller definitions' algorithm generated code\n\n// End of 'Controller definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_controller ::cfm_controller()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_controller_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_controller::~cfm_controller(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Controller destructor' algorithm generated code\n\n  // End of 'Controller destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_controller::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_controller::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InteractiveNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefNet'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_interactivenetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_interactivenetwork_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n#include \"dt/cft_defnet.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InteractiveNetwork includes' algorithm generated code\n\n// End of 'InteractiveNetwork includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInteractiveNetwork Function InteractiveNetwork\n//@{\n///        \\page dxpInteractiveNetwork\n//@{\n///    \\brief InteractiveNetwork function model start\nclass cfm_interactivenetwork : public cf_core::cf_function,\n                               public cfm_interactivenetwork_dp_if {\npublic:\n  /// cfm_interactivenetwork type define start\n\n  /// constructor\n  cfm_interactivenetwork(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_interactivenetwork(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InteractiveNetwork local declarations' algorithm generated code\n\n  // End of 'InteractiveNetwork local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief InteractiveNetwork function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_INTERACTIVENETWORK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InteractiveNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefNet'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_interactivenetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_interactivenetwork.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_interactivenetwork\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InteractiveNetwork definitions' algorithm generated code\n\n// End of 'InteractiveNetwork definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_interactivenetwork ::cfm_interactivenetwork()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_interactivenetwork_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_interactivenetwork::~cfm_interactivenetwork(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InteractiveNetwork destructor' algorithm generated code\n\n  // End of 'InteractiveNetwork destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_interactivenetwork::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_interactivenetwork::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BroadcastNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'BurstClock', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefNet'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_broadcastnetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_broadcastnetwork_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defnet.h\"\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BroadcastNetwork includes' algorithm generated code\n\n// End of 'BroadcastNetwork includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBroadcastNetwork Function BroadcastNetwork\n//@{\n///        \\page dxpBroadcastNetwork\n//@{\n///    \\brief BroadcastNetwork function model start\nclass cfm_broadcastnetwork : public cf_core::cf_function,\n                             public cfm_broadcastnetwork_dp_if {\npublic:\n  /// cfm_broadcastnetwork type define start\n\n  /// constructor\n  cfm_broadcastnetwork(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_broadcastnetwork(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BroadcastNetwork local declarations' algorithm generated code\n\n  // End of 'BroadcastNetwork local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BroadcastNetwork function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_BROADCASTNETWORK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BroadcastNetwork', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'BurstClock', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'VideoFiles', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefNet'}, {'name': 'VideoNet', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefNet'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_broadcastnetwork\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_broadcastnetwork.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_broadcastnetwork\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BroadcastNetwork definitions' algorithm generated code\n\n// End of 'BroadcastNetwork definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_broadcastnetwork ::cfm_broadcastnetwork()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_broadcastnetwork_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_broadcastnetwork::~cfm_broadcastnetwork(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BroadcastNetwork destructor' algorithm generated code\n\n  // End of 'BroadcastNetwork destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_broadcastnetwork::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_broadcastnetwork::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ClockGenerator', 'type': 'cofluent:Function', 'ports': [{'name': 'BurstClock', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_clockgenerator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_clockgenerator_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ClockGenerator includes' algorithm generated code\n\n// End of 'ClockGenerator includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgClockGenerator Function ClockGenerator\n//@{\n///        \\page dxpClockGenerator\n//@{\n///    \\brief ClockGenerator function model start\nclass cfm_clockgenerator : public cf_core::cf_function,\n                           public cfm_clockgenerator_dp_if {\npublic:\n  /// cfm_clockgenerator type define start\n\n  /// constructor\n  cfm_clockgenerator(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_clockgenerator(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ClockGenerator local declarations' algorithm generated code\n\n  // End of 'ClockGenerator local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ClockGenerator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CLOCKGENERATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ClockGenerator', 'type': 'cofluent:Function', 'ports': [{'name': 'BurstClock', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_clockgenerator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_clockgenerator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_networks\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_clockgenerator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ClockGenerator definitions' algorithm generated code\n\n// End of 'ClockGenerator definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_clockgenerator ::cfm_clockgenerator()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_clockgenerator_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_clockgenerator::~cfm_clockgenerator(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ClockGenerator destructor' algorithm generated code\n\n  // End of 'ClockGenerator destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_clockgenerator::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_clockgenerator::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Requesting', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_requesting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_requesting_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Requesting includes' algorithm generated code\n\n// End of 'Requesting includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRequesting Function Requesting\n//@{\n///        \\page dxpRequesting\n//@{\n///    \\brief Requesting function model start\nclass cfm_requesting : public cf_core::cf_function,\n                       public cfm_requesting_dp_if {\npublic:\n  /// cfm_requesting type define start\n\n  /// constructor\n  cfm_requesting(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_requesting(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Requesting local declarations' algorithm generated code\n\n  // End of 'Requesting local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Requesting function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_REQUESTING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Requesting', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_requesting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_requesting.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_requesting\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Requesting definitions' algorithm generated code\n\n// End of 'Requesting definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_requesting ::cfm_requesting()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_requesting_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_requesting::~cfm_requesting(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Requesting destructor' algorithm generated code\n\n  // End of 'Requesting destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_requesting::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_requesting::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Watching', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_watching\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_watching_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Watching includes' algorithm generated code\n\n// End of 'Watching includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWatching Function Watching\n//@{\n///        \\page dxpWatching\n//@{\n///    \\brief Watching function model start\nclass cfm_watching : public cf_core::cf_function, public cfm_watching_dp_if {\npublic:\n  /// cfm_watching type define start\n\n  /// constructor\n  cfm_watching(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_watching(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Watching local declarations' algorithm generated code\n\n  // End of 'Watching local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Watching function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_WATCHING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Watching', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_watching\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_watching.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_watching\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Watching definitions' algorithm generated code\n\n// End of 'Watching definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_watching ::cfm_watching()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_watching_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_watching::~cfm_watching(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Watching destructor' algorithm generated code\n\n  // End of 'Watching destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_watching::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_watching::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reading', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_reading\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_reading_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Reading includes' algorithm generated code\n\n// End of 'Reading includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReading Function Reading\n//@{\n///        \\page dxpReading\n//@{\n///    \\brief Reading function model start\nclass cfm_reading : public cf_core::cf_function, public cfm_reading_dp_if {\npublic:\n  /// cfm_reading type define start\n\n  /// constructor\n  cfm_reading(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_reading(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Reading local declarations' algorithm generated code\n\n  // End of 'Reading local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Reading function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_READING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reading', 'type': 'cofluent:Function', 'ports': [{'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_reading\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_reading.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_user\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reading\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Reading definitions' algorithm generated code\n\n// End of 'Reading definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_reading ::cfm_reading()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_reading_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_reading::~cfm_reading(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Reading destructor' algorithm generated code\n\n  // End of 'Reading destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_reading::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_reading::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CallApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_callapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_callapplication_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CallApplication includes' algorithm generated code\n\n// End of 'CallApplication includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCallApplication Function CallApplication\n//@{\n///        \\page dxpCallApplication\n//@{\n///    \\brief CallApplication function model start\nclass cfm_callapplication : public cf_core::cf_function,\n                            public cfm_callapplication_dp_if {\npublic:\n  /// cfm_callapplication type define start\n\n  /// constructor\n  cfm_callapplication(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_callapplication(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CallApplication local declarations' algorithm generated code\n\n  // End of 'CallApplication local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CallApplication function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_CALLAPPLICATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CallApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'AppToCtrl', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Response', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'Request', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_callapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_callapplication.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationlayer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_callapplication\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CallApplication definitions' algorithm generated code\n\n// End of 'CallApplication definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_callapplication ::cfm_callapplication()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_callapplication_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_callapplication::~cfm_callapplication(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CallApplication destructor' algorithm generated code\n\n  // End of 'CallApplication destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_callapplication::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_callapplication::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VideoApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_videoapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_videoapplication_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'VideoApplication includes' algorithm generated code\n\n// End of 'VideoApplication includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgVideoApplication Function VideoApplication\n//@{\n///        \\page dxpVideoApplication\n//@{\n///    \\brief VideoApplication function model start\nclass cfm_videoapplication : public cf_core::cf_function,\n                             public cfm_videoapplication_dp_if {\npublic:\n  /// cfm_videoapplication type define start\n\n  /// constructor\n  cfm_videoapplication(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_videoapplication(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'VideoApplication local declarations' algorithm generated code\n\n  // End of 'VideoApplication local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief VideoApplication function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_VIDEOAPPLICATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VideoApplication', 'type': 'cofluent:Function', 'ports': [{'name': 'Video', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_videoapplication\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_videoapplication.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationlayer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_videoapplication\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'VideoApplication definitions' algorithm generated code\n\n// End of 'VideoApplication definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_videoapplication ::cfm_videoapplication()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_videoapplication_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_videoapplication::~cfm_videoapplication(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'VideoApplication destructor' algorithm generated code\n\n  // End of 'VideoApplication destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_videoapplication::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_videoapplication::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function'}, {'name': 'HTTPTCP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_httptcp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n\n/// Model Header includes start\n#include \"cfm_httptcp_receive.h\"\n#include \"cfm_httptcp_send.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HTTPTCP includes' algorithm generated code\n\n// End of 'HTTPTCP includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHTTPTCP Function HTTPTCP\n//@{\n///        \\page dxpHTTPTCP\n//@{\n///    \\brief HTTPTCP function model start\nclass cfm_httptcp : public cf_core::cf_function_container,\n                    public cfm_httptcp_dp_if {\npublic:\n  /// cfm_httptcp type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cfm_defcall>\n      p_mq_AppToHTTP_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cfm_defcall>\n      p_mq_HTTPToApp_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cfm_defcall>\n      p_mq_HTTPToIP_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_httptcp, cfm_defcall>\n      p_mq_IPToHTTP_t;\n  /// cfm_httptcp type define end\n\n  /// constructor\n  cfm_httptcp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_httptcp(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_AppToHTTP_t p_mq_AppToHTTP;\n  p_mq_HTTPToApp_t p_mq_HTTPToApp;\n  p_mq_HTTPToIP_t p_mq_HTTPToIP;\n  p_mq_IPToHTTP_t p_mq_IPToHTTP;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_httptcp_receive *HTTPTCP_Receive;\n  cfm_httptcp_send *HTTPTCP_Send;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HTTPTCP local declarations' algorithm generated code\n\n  // End of 'HTTPTCP local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief HTTPTCP function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP', 'type': 'cofluent:Function', 'models': [{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function'}, {'name': 'HTTPTCP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Send']}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['HTTPTCP_Receive']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_httptcp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_httptcp.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HTTPTCP definitions' algorithm generated code\n\n// End of 'HTTPTCP definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_httptcp ::cfm_httptcp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_httptcp_dp_if(),\n      p_mq_AppToHTTP(\"p_mq_AppToHTTP\"), p_mq_HTTPToApp(\"p_mq_HTTPToApp\"),\n      p_mq_HTTPToIP(\"p_mq_HTTPToIP\"), p_mq_IPToHTTP(\"p_mq_IPToHTTP\") {\n  cf_function_container::init();\n  // instantiation of models\n  HTTPTCP_Receive = new cfm_httptcp_receive(\"HTTPTCP_Receive\");\n  HTTPTCP_Send = new cfm_httptcp_send(\"HTTPTCP_Send\");\n  // connections\n  // model connect to port\n  HTTPTCP_Receive->p_mq_HTTPToApp(p_mq_HTTPToApp);\n  HTTPTCP_Receive->p_mq_IPToHTTP(p_mq_IPToHTTP);\n  // model connect to port\n  HTTPTCP_Send->p_mq_AppToHTTP(p_mq_AppToHTTP);\n  HTTPTCP_Send->p_mq_HTTPToIP(p_mq_HTTPToIP);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_httptcp::~cfm_httptcp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HTTPTCP destructor' algorithm generated code\n\n  // End of 'HTTPTCP destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete HTTPTCP_Receive;\n  delete HTTPTCP_Send;\n}\n\n//@{\nvoid cfm_httptcp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_httptcp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall', 'type': 'cofluent:Function', 'models': [{'name': 'IPCall_Receive', 'type': 'cofluent:Function'}, {'name': 'IPCall_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}, {'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipcall\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n\n/// Model Header includes start\n#include \"cfm_ipcall_receive.h\"\n#include \"cfm_ipcall_send.h\"\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPCall includes' algorithm generated code\n\n// End of 'IPCall includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPCall Function IPCall\n//@{\n///        \\page dxpIPCall\n//@{\n///    \\brief IPCall function model start\nclass cfm_ipcall : public cf_core::cf_function_container,\n                   public cfm_ipcall_dp_if {\npublic:\n  /// cfm_ipcall type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cfm_defcall>\n      p_mq_HTTPToIP_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cfm_defcall>\n      p_mq_IPToHTTP_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cfm_defcall>\n      p_mq_IPToUMTS_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_ipcall, cfm_defcall>\n      p_mq_UMTSToIP_t;\n  /// cfm_ipcall type define end\n\n  /// constructor\n  cfm_ipcall(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_ipcall(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_HTTPToIP_t p_mq_HTTPToIP;\n  p_mq_IPToHTTP_t p_mq_IPToHTTP;\n  p_mq_IPToUMTS_t p_mq_IPToUMTS;\n  p_mq_UMTSToIP_t p_mq_UMTSToIP;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_ipcall_receive *IPCall_Receive;\n  cfm_ipcall_send *IPCall_Send;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPCall local declarations' algorithm generated code\n\n  // End of 'IPCall local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief IPCall function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall', 'type': 'cofluent:Function', 'models': [{'name': 'IPCall_Receive', 'type': 'cofluent:Function'}, {'name': 'IPCall_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}, {'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['IPCall_Send']}, {'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['IPCall_Receive']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipcall\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipcall.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPCall definitions' algorithm generated code\n\n// End of 'IPCall definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipcall ::cfm_ipcall()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_ipcall_dp_if(),\n      p_mq_HTTPToIP(\"p_mq_HTTPToIP\"), p_mq_IPToHTTP(\"p_mq_IPToHTTP\"),\n      p_mq_IPToUMTS(\"p_mq_IPToUMTS\"), p_mq_UMTSToIP(\"p_mq_UMTSToIP\") {\n  cf_function_container::init();\n  // instantiation of models\n  IPCall_Receive = new cfm_ipcall_receive(\"IPCall_Receive\");\n  IPCall_Send = new cfm_ipcall_send(\"IPCall_Send\");\n  // connections\n  // model connect to port\n  IPCall_Receive->p_mq_IPToHTTP(p_mq_IPToHTTP);\n  IPCall_Receive->p_mq_UMTSToIP(p_mq_UMTSToIP);\n  // model connect to port\n  IPCall_Send->p_mq_HTTPToIP(p_mq_HTTPToIP);\n  IPCall_Send->p_mq_IPToUMTS(p_mq_IPToUMTS);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipcall::~cfm_ipcall(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPCall destructor' algorithm generated code\n\n  // End of 'IPCall destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete IPCall_Receive;\n  delete IPCall_Send;\n}\n\n//@{\nvoid cfm_ipcall::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_ipcall::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS', 'type': 'cofluent:Function', 'models': [{'name': 'UMTS_Receive', 'type': 'cofluent:Function'}, {'name': 'UMTS_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_umts\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cfm_umts_receive.h\"\n#include \"cfm_umts_send.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UMTS includes' algorithm generated code\n\n// End of 'UMTS includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUMTS Function UMTS\n//@{\n///        \\page dxpUMTS\n//@{\n///    \\brief UMTS function model start\nclass cfm_umts : public cf_core::cf_function_container, public cfm_umts_dp_if {\npublic:\n  /// cfm_umts type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_umts, cfm_defcall>\n      p_mq_IPToUMTS_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_umts, cfm_defcall>\n      p_mq_NetToUMTS_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_umts, cfm_defcall>\n      p_mq_UMTSToIP_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_umts, cfm_defcall>\n      p_mq_UMTSToNet_t;\n  /// cfm_umts type define end\n\n  /// constructor\n  cfm_umts(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_umts(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_IPToUMTS_t p_mq_IPToUMTS;\n  p_mq_NetToUMTS_t p_mq_NetToUMTS;\n  p_mq_UMTSToIP_t p_mq_UMTSToIP;\n  p_mq_UMTSToNet_t p_mq_UMTSToNet;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_umts_receive *UMTS_Receive;\n  cfm_umts_send *UMTS_Send;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UMTS local declarations' algorithm generated code\n\n  // End of 'UMTS local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief UMTS function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS', 'type': 'cofluent:Function', 'models': [{'name': 'UMTS_Receive', 'type': 'cofluent:Function'}, {'name': 'UMTS_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Receive']}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall', 'connectTo': ['UMTS_Send']}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_umts\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_umts.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_callprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UMTS definitions' algorithm generated code\n\n// End of 'UMTS definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_umts ::cfm_umts()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_umts_dp_if(),\n      p_mq_IPToUMTS(\"p_mq_IPToUMTS\"), p_mq_NetToUMTS(\"p_mq_NetToUMTS\"),\n      p_mq_UMTSToIP(\"p_mq_UMTSToIP\"), p_mq_UMTSToNet(\"p_mq_UMTSToNet\") {\n  cf_function_container::init();\n  // instantiation of models\n  UMTS_Receive = new cfm_umts_receive(\"UMTS_Receive\");\n  UMTS_Send = new cfm_umts_send(\"UMTS_Send\");\n  // connections\n  // model connect to port\n  UMTS_Receive->p_mq_NetToUMTS(p_mq_NetToUMTS);\n  UMTS_Receive->p_mq_UMTSToIP(p_mq_UMTSToIP);\n  // model connect to port\n  UMTS_Send->p_mq_IPToUMTS(p_mq_IPToUMTS);\n  UMTS_Send->p_mq_UMTSToNet(p_mq_UMTSToNet);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_umts::~cfm_umts(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UMTS destructor' algorithm generated code\n\n  // End of 'UMTS destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete UMTS_Receive;\n  delete UMTS_Send;\n}\n\n//@{\nvoid cfm_umts::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_umts::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RTPUDP', 'type': 'cofluent:Function', 'ports': [{'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rtpudp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rtpudp_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RTPUDP includes' algorithm generated code\n\n// End of 'RTPUDP includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRTPUDP Function RTPUDP\n//@{\n///        \\page dxpRTPUDP\n//@{\n///    \\brief RTPUDP function model start\nclass cfm_rtpudp : public cf_core::cf_function, public cfm_rtpudp_dp_if {\npublic:\n  /// cfm_rtpudp type define start\n\n  /// constructor\n  cfm_rtpudp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_rtpudp(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RTPUDP local declarations' algorithm generated code\n\n  // End of 'RTPUDP local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief RTPUDP function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_RTPUDP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RTPUDP', 'type': 'cofluent:Function', 'ports': [{'name': 'RTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rtpudp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rtpudp.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rtpudp\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RTPUDP definitions' algorithm generated code\n\n// End of 'RTPUDP definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rtpudp ::cfm_rtpudp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_rtpudp_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rtpudp::~cfm_rtpudp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RTPUDP destructor' algorithm generated code\n\n  // End of 'RTPUDP destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_rtpudp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_rtpudp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPVideo', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipvideo\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipvideo_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPVideo includes' algorithm generated code\n\n// End of 'IPVideo includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPVideo Function IPVideo\n//@{\n///        \\page dxpIPVideo\n//@{\n///    \\brief IPVideo function model start\nclass cfm_ipvideo : public cf_core::cf_function, public cfm_ipvideo_dp_if {\npublic:\n  /// cfm_ipvideo type define start\n\n  /// constructor\n  cfm_ipvideo(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_ipvideo(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPVideo local declarations' algorithm generated code\n\n  // End of 'IPVideo local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief IPVideo function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPVIDEO\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPVideo', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToRTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipvideo\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipvideo.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipvideo\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPVideo definitions' algorithm generated code\n\n// End of 'IPVideo definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipvideo ::cfm_ipvideo()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_ipvideo_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipvideo::~cfm_ipvideo(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPVideo destructor' algorithm generated code\n\n  // End of 'IPVideo destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_ipvideo::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_ipvideo::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MPETSL', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mpetsl\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_mpetsl_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defvideo.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MPETSL includes' algorithm generated code\n\n// End of 'MPETSL includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMPETSL Function MPETSL\n//@{\n///        \\page dxpMPETSL\n//@{\n///    \\brief MPETSL function model start\nclass cfm_mpetsl : public cf_core::cf_function, public cfm_mpetsl_dp_if {\npublic:\n  /// cfm_mpetsl type define start\n\n  /// constructor\n  cfm_mpetsl(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_mpetsl(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MPETSL local declarations' algorithm generated code\n\n  // End of 'MPETSL local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief MPETSL function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_MPETSL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MPETSL', 'type': 'cofluent:Function', 'ports': [{'name': 'NetToDVB', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefVideo'}, {'name': 'MPEToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefVideo'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mpetsl\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mpetsl.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_videoprotocolstack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_mpetsl\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MPETSL definitions' algorithm generated code\n\n// End of 'MPETSL definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mpetsl ::cfm_mpetsl()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_mpetsl_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mpetsl::~cfm_mpetsl(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MPETSL destructor' algorithm generated code\n\n  // End of 'MPETSL destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_mpetsl::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_mpetsl::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_httptcp_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_send_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HTTPTCP_Send includes' algorithm generated code\n\n// End of 'HTTPTCP_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHTTPTCP_Send Function HTTPTCP_Send\n//@{\n///        \\page dxpHTTPTCP_Send\n//@{\n///    \\brief HTTPTCP_Send function model start\nclass cfm_httptcp_send : public cf_core::cf_function,\n                         public cfm_httptcp_send_dp_if {\npublic:\n  /// cfm_httptcp_send type define start\n\n  /// constructor\n  cfm_httptcp_send(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_httptcp_send(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HTTPTCP_Send local declarations' algorithm generated code\n\n  // End of 'HTTPTCP_Send local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief HTTPTCP_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'AppToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_httptcp_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_httptcp_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_httptcp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HTTPTCP_Send definitions' algorithm generated code\n\n// End of 'HTTPTCP_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_httptcp_send ::cfm_httptcp_send()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_httptcp_send_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_httptcp_send::~cfm_httptcp_send(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HTTPTCP_Send destructor' algorithm generated code\n\n  // End of 'HTTPTCP_Send destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_httptcp_send::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_httptcp_send::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_httptcp_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_httptcp_receive_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HTTPTCP_Receive includes' algorithm generated code\n\n// End of 'HTTPTCP_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHTTPTCP_Receive Function HTTPTCP_Receive\n//@{\n///        \\page dxpHTTPTCP_Receive\n//@{\n///    \\brief HTTPTCP_Receive function model start\nclass cfm_httptcp_receive : public cf_core::cf_function,\n                            public cfm_httptcp_receive_dp_if {\npublic:\n  /// cfm_httptcp_receive type define start\n\n  /// constructor\n  cfm_httptcp_receive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_httptcp_receive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HTTPTCP_Receive local declarations' algorithm generated code\n\n  // End of 'HTTPTCP_Receive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief HTTPTCP_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_HTTPTCP_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HTTPTCP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'HTTPToApp', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_httptcp_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_httptcp_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_httptcp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_httptcp_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HTTPTCP_Receive definitions' algorithm generated code\n\n// End of 'HTTPTCP_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_httptcp_receive ::cfm_httptcp_receive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_httptcp_receive_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_httptcp_receive::~cfm_httptcp_receive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HTTPTCP_Receive destructor' algorithm generated code\n\n  // End of 'HTTPTCP_Receive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_httptcp_receive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_httptcp_receive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipcall_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_send_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPCall_Send includes' algorithm generated code\n\n// End of 'IPCall_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPCall_Send Function IPCall_Send\n//@{\n///        \\page dxpIPCall_Send\n//@{\n///    \\brief IPCall_Send function model start\nclass cfm_ipcall_send : public cf_core::cf_function,\n                        public cfm_ipcall_send_dp_if {\npublic:\n  /// cfm_ipcall_send type define start\n\n  /// constructor\n  cfm_ipcall_send(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_ipcall_send(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPCall_Send local declarations' algorithm generated code\n\n  // End of 'IPCall_Send local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief IPCall_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'HTTPToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipcall_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipcall_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ipcall\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPCall_Send definitions' algorithm generated code\n\n// End of 'IPCall_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipcall_send ::cfm_ipcall_send()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_ipcall_send_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipcall_send::~cfm_ipcall_send(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPCall_Send destructor' algorithm generated code\n\n  // End of 'IPCall_Send destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_ipcall_send::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_ipcall_send::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'IPCall_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ipcall_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ipcall_receive_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPCall_Receive includes' algorithm generated code\n\n// End of 'IPCall_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIPCall_Receive Function IPCall_Receive\n//@{\n///        \\page dxpIPCall_Receive\n//@{\n///    \\brief IPCall_Receive function model start\nclass cfm_ipcall_receive : public cf_core::cf_function,\n                           public cfm_ipcall_receive_dp_if {\npublic:\n  /// cfm_ipcall_receive type define start\n\n  /// constructor\n  cfm_ipcall_receive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_ipcall_receive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPCall_Receive local declarations' algorithm generated code\n\n  // End of 'IPCall_Receive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief IPCall_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_IPCALL_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'IPCall_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'IPToHTTP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ipcall_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ipcall_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ipcall\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ipcall_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'IPCall_Receive definitions' algorithm generated code\n\n// End of 'IPCall_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ipcall_receive ::cfm_ipcall_receive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_ipcall_receive_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ipcall_receive::~cfm_ipcall_receive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'IPCall_Receive destructor' algorithm generated code\n\n  // End of 'IPCall_Receive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_ipcall_receive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_ipcall_receive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_umts_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_send_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UMTS_Send includes' algorithm generated code\n\n// End of 'UMTS_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUMTS_Send Function UMTS_Send\n//@{\n///        \\page dxpUMTS_Send\n//@{\n///    \\brief UMTS_Send function model start\nclass cfm_umts_send : public cf_core::cf_function, public cfm_umts_send_dp_if {\npublic:\n  /// cfm_umts_send type define start\n\n  /// constructor\n  cfm_umts_send(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_umts_send(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UMTS_Send local declarations' algorithm generated code\n\n  // End of 'UMTS_Send local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief UMTS_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'IPToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}, {'name': 'UMTSToNet', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_umts_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_umts_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_umts\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UMTS_Send definitions' algorithm generated code\n\n// End of 'UMTS_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_umts_send ::cfm_umts_send()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_umts_send_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_umts_send::~cfm_umts_send(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UMTS_Send destructor' algorithm generated code\n\n  // End of 'UMTS_Send destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_umts_send::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_umts_send::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UMTS_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_umts_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n#define COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_softwaredefinedradioapp_global.h\"\n#include \"cfm_softwaredefinedradioapp_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_umts_receive_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defcall.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UMTS_Receive includes' algorithm generated code\n\n// End of 'UMTS_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUMTS_Receive Function UMTS_Receive\n//@{\n///        \\page dxpUMTS_Receive\n//@{\n///    \\brief UMTS_Receive function model start\nclass cfm_umts_receive : public cf_core::cf_function,\n                         public cfm_umts_receive_dp_if {\npublic:\n  /// cfm_umts_receive type define start\n\n  /// constructor\n  cfm_umts_receive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_umts_receive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UMTS_Receive local declarations' algorithm generated code\n\n  // End of 'UMTS_Receive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief UMTS_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_SOFTWAREDEFINEDRADIOAPP_UMTS_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UMTS_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'UMTSToIP', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefCall'}, {'name': 'NetToUMTS', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefCall'}], 'globalName': 'SoftwareDefinedRadioApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_umts_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of SoftwareDefinedRadioApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_umts_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_umts\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_umts_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UMTS_Receive definitions' algorithm generated code\n\n// End of 'UMTS_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_umts_receive ::cfm_umts_receive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_umts_receive_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_umts_receive::~cfm_umts_receive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UMTS_Receive destructor' algorithm generated code\n\n  // End of 'UMTS_Receive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_umts_receive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_umts_receive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoSimVCSUVMApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'ProcessingFunction', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProcessingFunction', 'Producer']}, {'name': 'read', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProcessingFunction']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cosimvcsuvmapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP\n#define COFS_MODEL_COSIMVCSUVMAPP\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n#include \"uvm_tlm2_sc_bind.h\"\n#include \"wrappers/cfm_data_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_read_tlm2_lt_target.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoSimVCSUVMApp includes' algorithm generated code\n\n// End of 'CoSimVCSUVMApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoSimVCSUVMApp Function CoSimVCSUVMApp\n//@{\n///        \\page dxpCoSimVCSUVMApp\n//@{\n///    \\brief CoSimVCSUVMApp function model start\nclass cfm_cosimvcsuvmapp : public cf_core::cf_application {\npublic:\n  /// cfm_cosimvcsuvmapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_data_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_read_t;\n\n  /// cfm_cosimvcsuvmapp type define end\n\n  /// constructor\n  cfm_cosimvcsuvmapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_cosimvcsuvmapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer *Consumer;\n  cfm_producer *Producer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_data_t mq_data;\n  mq_read_t mq_read;\n  //@}\n\nprotected:\n  /// \\name wrappers\n  //@{\n  cfm_data_tlm2_lt_initiator data_tlm2_lt_initiator;\n  cfm_read_tlm2_lt_target read_tlm2_lt_target;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoSimVCSUVMApp local declarations' algorithm generated code\n\n  // End of 'CoSimVCSUVMApp local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CoSimVCSUVMApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVCSUVMAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoSimVCSUVMApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'ProcessingFunction', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProcessingFunction', 'Producer']}, {'name': 'read', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProcessingFunction']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cosimvcsuvmapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cosimvcsuvmapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoSimVCSUVMApp definitions' algorithm generated code\n\n// End of 'CoSimVCSUVMApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cosimvcsuvmapp ::cfm_cosimvcsuvmapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_data(\"data\"), mq_read(\"read\") {\n  cf_application::init();\n  // instantiation of models\n  Consumer = new cfm_consumer(\"Consumer\");\n  ProcessingFunction = new cfm_processingfunction(\"ProcessingFunction\");\n  Producer = new cfm_producer(\"Producer\");\n  // connections\n  // model connect to relation\n  Consumer->p_mq_read(mq_read.p_target_socket);\n  // model connect to relation\n  ProcessingFunction->p_mq_data(mq_data.p_target_socket);\n  ProcessingFunction->p_mq_read(mq_read.p_target_socket);\n  // model connect to relation\n  Producer->p_mq_data(mq_data.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cosimvcsuvmapp::~cfm_cosimvcsuvmapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoSimVCSUVMApp destructor' algorithm generated code\n\n  // End of 'CoSimVCSUVMApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer;\n  delete ProcessingFunction;\n  delete Producer;\n}\n\n//@{\nvoid cfm_cosimvcsuvmapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_cosimvcsuvmapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'read', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n#define COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVCSUVMAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'read', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimvcsuvmapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n#define COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_cosimvcsuvmapp_global.h\"\n#include \"cfm_cosimvcsuvmapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVCSUVMAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CoSimVCSUVMApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVCSUVMApp generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimvcsuvmapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example1App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inheritance_example1app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP\n\n/// Model Header includes start\n#include \"cfm_f1.h\"\n#include \"cfm_f2.h\"\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inheritance_example1App includes' algorithm generated code\n\n// End of 'Inheritance_example1App includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInheritance_example1App Function Inheritance_example1App\n//@{\n///        \\page dxpInheritance_example1App\n//@{\n///    \\brief Inheritance_example1App function model start\nclass cfm_inheritance_example1app : public cf_core::cf_application {\npublic:\n  /// cfm_inheritance_example1app type define start\n\n  /// cfm_inheritance_example1app type define end\n\n  /// constructor\n  cfm_inheritance_example1app(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inheritance_example1app(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_f1 *F1;\n  cfm_f2 *F2;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inheritance_example1App local declarations' algorithm generated\n  // code\n\n  // End of 'Inheritance_example1App local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Inheritance_example1App function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example1App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inheritance_example1app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inheritance_example1app.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inheritance_example1App definitions' algorithm generated code\n\n// End of 'Inheritance_example1App definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inheritance_example1app ::cfm_inheritance_example1app()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name) {\n  cf_application::init();\n  // instantiation of models\n  F1 = new cfm_f1(\"F1\");\n  F2 = new cfm_f2(\"F2\");\n  // connections\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inheritance_example1app::~cfm_inheritance_example1app(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inheritance_example1App destructor' algorithm generated code\n\n  // End of 'Inheritance_example1App destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete F1;\n  delete F2;\n}\n\n//@{\nvoid cfm_inheritance_example1app::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inheritance_example1app::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n\n/// Model Header includes start\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F1 includes' algorithm generated code\n\n// End of 'F1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF1 Function F1\n//@{\n///        \\page dxpF1\n//@{\n///    \\brief F1 function model start\nclass cfm_f1 : public cf_core::cf_function {\npublic:\n  /// cfm_f1 type define start\n\n  /// cfm_f1 type define end\n\n  /// constructor\n  cfm_f1(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_f1(void);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F1 local declarations' algorithm generated code\n\n  // End of 'F1 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief F1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP_F1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example1app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F1 definitions' algorithm generated code\n\n// End of 'F1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f1 ::cfm_f1()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f1::~cfm_f1(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F1 destructor' algorithm generated code\n\n  // End of 'F1 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_f1::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_f1::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n#define COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n\n/// Model Header includes start\n#include \"cfm_inheritance_example1app_global.h\"\n#include \"cfm_inheritance_example1app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F2 includes' algorithm generated code\n\n// End of 'F2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF2 Function F2\n//@{\n///        \\page dxpF2\n//@{\n///    \\brief F2 function model start\nclass cfm_f2 : public cf_core::cf_function {\npublic:\n  /// cfm_f2 type define start\n\n  /// cfm_f2 type define end\n\n  /// constructor\n  cfm_f2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_f2(void);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F2 local declarations' algorithm generated code\n\n  // End of 'F2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief F2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE1APP_F2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example1App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example1App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example1app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F2 definitions' algorithm generated code\n\n// End of 'F2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f2 ::cfm_f2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f2::~cfm_f2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F2 destructor' algorithm generated code\n\n  // End of 'F2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_f2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_f2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CopyPayloadNonPod', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_copypayloadnonpod\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD\n#define COFS_MODEL_COPYPAYLOADNONPOD\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CopyPayloadNonPod includes' algorithm generated code\n\n// End of 'CopyPayloadNonPod includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCopyPayloadNonPod Function CopyPayloadNonPod\n//@{\n///        \\page dxpCopyPayloadNonPod\n//@{\n///    \\brief CopyPayloadNonPod function model start\nclass cfm_copypayloadnonpod : public cf_core::cf_application {\npublic:\n  /// cfm_copypayloadnonpod type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgQ_t;\n\n  /// cfm_copypayloadnonpod type define end\n\n  /// constructor\n  cfm_copypayloadnonpod(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_copypayloadnonpod(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer *Consumer;\n  cfm_producer *Producer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQ_t mq_MsgQ;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CopyPayloadNonPod local declarations' algorithm generated code\n\n  // End of 'CopyPayloadNonPod local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CopyPayloadNonPod function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COPYPAYLOADNONPOD\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CopyPayloadNonPod', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_copypayloadnonpod\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_copypayloadnonpod.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CopyPayloadNonPod definitions' algorithm generated code\n\n// End of 'CopyPayloadNonPod definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_copypayloadnonpod ::cfm_copypayloadnonpod()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQ(\"MsgQ\") {\n  cf_application::init();\n  // instantiation of models\n  Consumer = new cfm_consumer(\"Consumer\");\n  Producer = new cfm_producer(\"Producer\");\n  // connections\n  // model connect to relation\n  Consumer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n  // model connect to relation\n  Producer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_copypayloadnonpod::~cfm_copypayloadnonpod(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CopyPayloadNonPod destructor' algorithm generated code\n\n  // End of 'CopyPayloadNonPod destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer;\n  delete Producer;\n}\n\n//@{\nvoid cfm_copypayloadnonpod::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_copypayloadnonpod::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n#define COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COPYPAYLOADNONPOD_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_copypayloadnonpod\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n#define COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_copypayloadnonpod_global.h\"\n#include \"cfm_copypayloadnonpod_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COPYPAYLOADNONPOD_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}], 'globalName': 'CopyPayloadNonPod'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CopyPayloadNonPod generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_copypayloadnonpod\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoFluentAPIFromExternalIP', 'models': [{'name': 'CoF_Initiator', 'type': 'cofluent:Function'}, {'name': 'iUart', 'type': 'cofluent:SystemCIP'}], 'relations': [{'name': 'MsgBwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}, {'name': 'MsgFwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cofluentapifromexternalip\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n#define COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n\n/// Model Header includes start\n#include \"Uart.h\"\n#include \"cfm_cof_initiator.h\"\n#include \"cfm_cofluentapifromexternalip_global.h\"\n#include \"cfm_cofluentapifromexternalip_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoFluentAPIFromExternalIP includes' algorithm generated code\n\n// End of 'CoFluentAPIFromExternalIP includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoFluentAPIFromExternalIP Function CoFluentAPIFromExternalIP\n//@{\n///        \\page dxpCoFluentAPIFromExternalIP\n//@{\n///    \\brief CoFluentAPIFromExternalIP function model start\nclass cfm_cofluentapifromexternalip : public cf_core::cf_application {\npublic:\n  /// cfm_cofluentapifromexternalip type define start\n  /// systemC IPs typedef\n  typedef Uart iUart_t;\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgBwQ_t;\n  typedef cf_core::cf_message_queue<cft_defmsgq> mq_MsgFwQ_t;\n\n  /// cfm_cofluentapifromexternalip type define end\n\n  /// constructor\n  cfm_cofluentapifromexternalip(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_cofluentapifromexternalip(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_cof_initiator *CoF_Initiator;\n  iUart_t *iUart;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgBwQ_t mq_MsgBwQ;\n  mq_MsgFwQ_t mq_MsgFwQ;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoFluentAPIFromExternalIP local declarations' algorithm generated\n  // code\n\n  // End of 'CoFluentAPIFromExternalIP local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CoFluentAPIFromExternalIP function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COFLUENTAPIFROMEXTERNALIP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoFluentAPIFromExternalIP', 'models': [{'name': 'CoF_Initiator', 'type': 'cofluent:Function'}, {'name': 'iUart', 'type': 'cofluent:SystemCIP'}], 'relations': [{'name': 'MsgBwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}, {'name': 'MsgFwQ', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['CoF_Initiator']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cofluentapifromexternalip\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cofluentapifromexternalip.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoFluentAPIFromExternalIP definitions' algorithm generated code\n\n// End of 'CoFluentAPIFromExternalIP definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cofluentapifromexternalip ::cfm_cofluentapifromexternalip()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgBwQ(\"MsgBwQ\"), mq_MsgFwQ(\"MsgFwQ\") {\n  cf_application::init();\n  // instantiation of models\n  CoF_Initiator = new cfm_cof_initiator(\"CoF_Initiator\");\n  iUart = new cfm_iuart(\"iUart\");\n  // connections\n  // model connect to relation\n  CoF_Initiator->p_mq_MsgBwQ(mq_MsgBwQ.p_target_socket);\n  CoF_Initiator->p_mq_MsgFwQ(mq_MsgFwQ.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cofluentapifromexternalip::~cfm_cofluentapifromexternalip(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoFluentAPIFromExternalIP destructor' algorithm generated code\n\n  // End of 'CoFluentAPIFromExternalIP destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete CoF_Initiator;\n  delete iUart;\n}\n\n//@{\nvoid cfm_cofluentapifromexternalip::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_cofluentapifromexternalip::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoF_Initiator', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgFwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'MsgBwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CoFluentAPIFromExternalIP'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cof_initiator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n#define COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n\n/// Model Header includes start\n#include \"cfm_cofluentapifromexternalip_global.h\"\n#include \"cfm_cofluentapifromexternalip_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defmsgq.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoF_Initiator includes' algorithm generated code\n\n// End of 'CoF_Initiator includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoF_Initiator Function CoF_Initiator\n//@{\n///        \\page dxpCoF_Initiator\n//@{\n///    \\brief CoF_Initiator function model start\nclass cfm_cof_initiator : public cf_core::cf_function {\npublic:\n  /// cfm_cof_initiator type define start\n\n  /// constructor\n  cfm_cof_initiator(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_cof_initiator(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoF_Initiator local declarations' algorithm generated code\n\n  // End of 'CoF_Initiator local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CoF_Initiator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COFLUENTAPIFROMEXTERNALIP_COF_INITIATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoF_Initiator', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgFwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'MsgBwQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}], 'globalName': 'CoFluentAPIFromExternalIP'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cof_initiator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoFluentAPIFromExternalIP generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cof_initiator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cofluentapifromexternalip\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_cof_initiator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoF_Initiator definitions' algorithm generated code\n\n// End of 'CoF_Initiator definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cof_initiator ::cfm_cof_initiator()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cof_initiator::~cfm_cof_initiator(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoF_Initiator destructor' algorithm generated code\n\n  // End of 'CoF_Initiator destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_cof_initiator::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_cof_initiator::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TransactionTrackerMsgQApp', 'models': [{'name': 'Consumer1', 'type': 'cofluent:Function'}, {'name': 'Consumer2', 'type': 'cofluent:Function'}, {'name': 'MessageRouting', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQIn', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'MessageRouting']}, {'name': 'MsgQOut1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer1', 'MessageRouting']}, {'name': 'MsgQOut2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer2', 'MessageRouting']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_transactiontrackermsgqapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n\n/// Model Header includes start\n#include \"cfm_consumer1.h\"\n#include \"cfm_consumer2.h\"\n#include \"cfm_messagerouting.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'TransactionTrackerMsgQApp includes' algorithm generated code\n\n// End of 'TransactionTrackerMsgQApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTransactionTrackerMsgQApp Function TransactionTrackerMsgQApp\n//@{\n///        \\page dxpTransactionTrackerMsgQApp\n//@{\n///    \\brief TransactionTrackerMsgQApp function model start\nclass cfm_transactiontrackermsgqapp : public cf_core::cf_application {\npublic:\n  /// cfm_transactiontrackermsgqapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQIn_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQOut1_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQOut2_t;\n\n  /// cfm_transactiontrackermsgqapp type define end\n\n  /// constructor\n  cfm_transactiontrackermsgqapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_transactiontrackermsgqapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer1 *Consumer1;\n  cfm_consumer2 *Consumer2;\n  cfm_messagerouting *MessageRouting;\n  cfm_producer *Producer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQIn_t mq_MsgQIn;\n  mq_MsgQOut1_t mq_MsgQOut1;\n  mq_MsgQOut2_t mq_MsgQOut2;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'TransactionTrackerMsgQApp local declarations' algorithm generated\n  // code\n\n  // End of 'TransactionTrackerMsgQApp local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief TransactionTrackerMsgQApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TransactionTrackerMsgQApp', 'models': [{'name': 'Consumer1', 'type': 'cofluent:Function'}, {'name': 'Consumer2', 'type': 'cofluent:Function'}, {'name': 'MessageRouting', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQIn', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'MessageRouting']}, {'name': 'MsgQOut1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer1', 'MessageRouting']}, {'name': 'MsgQOut2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer2', 'MessageRouting']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_transactiontrackermsgqapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_transactiontrackermsgqapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'TransactionTrackerMsgQApp definitions' algorithm generated code\n\n// End of 'TransactionTrackerMsgQApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_transactiontrackermsgqapp ::cfm_transactiontrackermsgqapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQIn(\"MsgQIn\"), mq_MsgQOut1(\"MsgQOut1\"),\n      mq_MsgQOut2(\"MsgQOut2\") {\n  cf_application::init();\n  // instantiation of models\n  Consumer1 = new cfm_consumer1(\"Consumer1\");\n  Consumer2 = new cfm_consumer2(\"Consumer2\");\n  MessageRouting = new cfm_messagerouting(\"MessageRouting\");\n  Producer = new cfm_producer(\"Producer\");\n  // connections\n  // model connect to relation\n  Consumer1->p_mq_MsgQOut1(mq_MsgQOut1.p_target_socket);\n  // model connect to relation\n  Consumer2->p_mq_MsgQOut2(mq_MsgQOut2.p_target_socket);\n  // model connect to relation\n  MessageRouting->p_mq_MsgQIn(mq_MsgQIn.p_target_socket);\n  MessageRouting->p_mq_MsgQOut1(mq_MsgQOut1.p_target_socket);\n  MessageRouting->p_mq_MsgQOut2(mq_MsgQOut2.p_target_socket);\n  // model connect to relation\n  Producer->p_mq_MsgQIn(mq_MsgQIn.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_transactiontrackermsgqapp::~cfm_transactiontrackermsgqapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'TransactionTrackerMsgQApp destructor' algorithm generated code\n\n  // End of 'TransactionTrackerMsgQApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer1;\n  delete Consumer2;\n  delete MessageRouting;\n  delete Producer;\n}\n\n//@{\nvoid cfm_transactiontrackermsgqapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_transactiontrackermsgqapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer1', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer1 includes' algorithm generated code\n\n// End of 'Consumer1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer1 Function Consumer1\n//@{\n///        \\page dxpConsumer1\n//@{\n///    \\brief Consumer1 function model start\nclass cfm_consumer1 : public cf_core::cf_function {\npublic:\n  /// cfm_consumer1 type define start\n\n  /// constructor\n  cfm_consumer1(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer1(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer1 local declarations' algorithm generated code\n\n  // End of 'Consumer1 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer1', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer1 definitions' algorithm generated code\n\n// End of 'Consumer1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer1 ::cfm_consumer1()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer1::~cfm_consumer1(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer1 destructor' algorithm generated code\n\n  // End of 'Consumer1 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer1::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer1::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer2', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer2 includes' algorithm generated code\n\n// End of 'Consumer2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer2 Function Consumer2\n//@{\n///        \\page dxpConsumer2\n//@{\n///    \\brief Consumer2 function model start\nclass cfm_consumer2 : public cf_core::cf_function {\npublic:\n  /// cfm_consumer2 type define start\n\n  /// constructor\n  cfm_consumer2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer2(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer2 local declarations' algorithm generated code\n\n  // End of 'Consumer2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_CONSUMER2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer2', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer2 definitions' algorithm generated code\n\n// End of 'Consumer2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer2 ::cfm_consumer2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer2::~cfm_consumer2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer2 destructor' algorithm generated code\n\n  // End of 'Consumer2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n#include <sstream>\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MessageRouting', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_messagerouting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n#define COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n\n/// Model Header includes start\n#include \"cfm_transactiontrackermsgqapp_global.h\"\n#include \"cfm_transactiontrackermsgqapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MessageRouting includes' algorithm generated code\n\n// End of 'MessageRouting includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMessageRouting Function MessageRouting\n//@{\n///        \\page dxpMessageRouting\n//@{\n///    \\brief MessageRouting function model start\nclass cfm_messagerouting : public cf_core::cf_function {\npublic:\n  /// cfm_messagerouting type define start\n\n  /// constructor\n  cfm_messagerouting(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_messagerouting(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MessageRouting local declarations' algorithm generated code\n\n  // End of 'MessageRouting local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief MessageRouting function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TRANSACTIONTRACKERMSGQAPP_MESSAGEROUTING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MessageRouting', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'MsgQOut2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'MsgQOut1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'TransactionTrackerMsgQApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_messagerouting\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TransactionTrackerMsgQApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_messagerouting.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_transactiontrackermsgqapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_messagerouting\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MessageRouting definitions' algorithm generated code\n\n// End of 'MessageRouting definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_messagerouting ::cfm_messagerouting()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_messagerouting::~cfm_messagerouting(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MessageRouting destructor' algorithm generated code\n\n  // End of 'MessageRouting destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_messagerouting::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_messagerouting::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolMapDataTypeApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'ProtocolReceive', 'type': 'cofluent:Function'}, {'name': 'ProtocolSend', 'type': 'cofluent:Function'}], 'relations': [{'name': 'protocol_data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'ProtocolReceive']}, {'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'Producer']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProtocolReceive']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_protocolmapdatatypeapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cfm_protocolreceive.h\"\n#include \"cfm_protocolsend.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProtocolMapDataTypeApp includes' algorithm generated code\n\n// End of 'ProtocolMapDataTypeApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProtocolMapDataTypeApp Function ProtocolMapDataTypeApp\n//@{\n///        \\page dxpProtocolMapDataTypeApp\n//@{\n///    \\brief ProtocolMapDataTypeApp function model start\nclass cfm_protocolmapdatatypeapp : public cf_core::cf_application {\npublic:\n  /// cfm_protocolmapdatatypeapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_protocol_data_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_user_data_in_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_user_data_out_t;\n\n  /// cfm_protocolmapdatatypeapp type define end\n\n  /// constructor\n  cfm_protocolmapdatatypeapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_protocolmapdatatypeapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer *Consumer;\n  cfm_producer *Producer;\n  cfm_protocolreceive *ProtocolReceive;\n  cfm_protocolsend *ProtocolSend;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_protocol_data_t mq_protocol_data;\n  mq_user_data_in_t mq_user_data_in;\n  mq_user_data_out_t mq_user_data_out;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProtocolMapDataTypeApp local declarations' algorithm generated\n  // code\n\n  // End of 'ProtocolMapDataTypeApp local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ProtocolMapDataTypeApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolMapDataTypeApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'ProtocolReceive', 'type': 'cofluent:Function'}, {'name': 'ProtocolSend', 'type': 'cofluent:Function'}], 'relations': [{'name': 'protocol_data', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'ProtocolReceive']}, {'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProtocolSend', 'Producer']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Consumer', 'ProtocolReceive']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_protocolmapdatatypeapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_protocolmapdatatypeapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProtocolMapDataTypeApp definitions' algorithm generated code\n\n// End of 'ProtocolMapDataTypeApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_protocolmapdatatypeapp ::cfm_protocolmapdatatypeapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_protocol_data(\"protocol_data\"),\n      mq_user_data_in(\"user_data_in\"), mq_user_data_out(\"user_data_out\") {\n  cf_application::init();\n  // instantiation of models\n  Consumer = new cfm_consumer(\"Consumer\");\n  Producer = new cfm_producer(\"Producer\");\n  ProtocolReceive = new cfm_protocolreceive(\"ProtocolReceive\");\n  ProtocolSend = new cfm_protocolsend(\"ProtocolSend\");\n  // connections\n  // model connect to relation\n  Consumer->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n  // model connect to relation\n  Producer->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n  // model connect to relation\n  ProtocolReceive->p_mq_protocol_data(mq_protocol_data.p_target_socket);\n  ProtocolReceive->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n  // model connect to relation\n  ProtocolSend->p_mq_protocol_data(mq_protocol_data.p_target_socket);\n  ProtocolSend->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_protocolmapdatatypeapp::~cfm_protocolmapdatatypeapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProtocolMapDataTypeApp destructor' algorithm generated code\n\n  // End of 'ProtocolMapDataTypeApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer;\n  delete Producer;\n  delete ProtocolReceive;\n  delete ProtocolSend;\n}\n\n//@{\nvoid cfm_protocolmapdatatypeapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_protocolmapdatatypeapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolSend', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_protocolsend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProtocolSend includes' algorithm generated code\n\n// End of 'ProtocolSend includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProtocolSend Function ProtocolSend\n//@{\n///        \\page dxpProtocolSend\n//@{\n///    \\brief ProtocolSend function model start\nclass cfm_protocolsend : public cf_core::cf_function {\npublic:\n  /// cfm_protocolsend type define start\n\n  /// constructor\n  cfm_protocolsend(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_protocolsend(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProtocolSend local declarations' algorithm generated code\n\n  // End of 'ProtocolSend local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ProtocolSend function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLSEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolSend', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_protocolsend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_protocolsend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_protocolsend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProtocolSend definitions' algorithm generated code\n\n// End of 'ProtocolSend definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_protocolsend ::cfm_protocolsend()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_protocolsend::~cfm_protocolsend(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProtocolSend destructor' algorithm generated code\n\n  // End of 'ProtocolSend destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_protocolsend::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_protocolsend::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProtocolReceive', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_protocolreceive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n#define COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n\n/// Model Header includes start\n#include \"cfm_protocolmapdatatypeapp_global.h\"\n#include \"cfm_protocolmapdatatypeapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProtocolReceive includes' algorithm generated code\n\n// End of 'ProtocolReceive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProtocolReceive Function ProtocolReceive\n//@{\n///        \\page dxpProtocolReceive\n//@{\n///    \\brief ProtocolReceive function model start\nclass cfm_protocolreceive : public cf_core::cf_function {\npublic:\n  /// cfm_protocolreceive type define start\n\n  /// constructor\n  cfm_protocolreceive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_protocolreceive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProtocolReceive local declarations' algorithm generated code\n\n  // End of 'ProtocolReceive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ProtocolReceive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_PROTOCOLMAPDATATYPEAPP_PROTOCOLRECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProtocolReceive', 'type': 'cofluent:Function', 'ports': [{'name': 'protocol_data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ProtocolMapDataTypeApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_protocolreceive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ProtocolMapDataTypeApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_protocolreceive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_protocolmapdatatypeapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_protocolreceive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProtocolReceive definitions' algorithm generated code\n\n// End of 'ProtocolReceive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_protocolreceive ::cfm_protocolreceive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_protocolreceive::~cfm_protocolreceive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProtocolReceive destructor' algorithm generated code\n\n  // End of 'ProtocolReceive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_protocolreceive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_protocolreceive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MapDataTypeAPIApp', 'models': [{'name': 'ConsumerMap', 'type': 'cofluent:Function'}, {'name': 'ProducerMap', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQMap', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerMap', 'ConsumerMap']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mapdatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP\n#define COFS_MODEL_MAPDATATYPEAPIAPP\n\n/// Model Header includes start\n#include \"cfm_consumermap.h\"\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cfm_producermap.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MapDataTypeAPIApp includes' algorithm generated code\n\n// End of 'MapDataTypeAPIApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMapDataTypeAPIApp Function MapDataTypeAPIApp\n//@{\n///        \\page dxpMapDataTypeAPIApp\n//@{\n///    \\brief MapDataTypeAPIApp function model start\nclass cfm_mapdatatypeapiapp : public cf_core::cf_application {\npublic:\n  /// cfm_mapdatatypeapiapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_map> mq_MsgQMap_t;\n\n  /// cfm_mapdatatypeapiapp type define end\n\n  /// constructor\n  cfm_mapdatatypeapiapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_mapdatatypeapiapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumermap *ConsumerMap;\n  cfm_producermap *ProducerMap;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQMap_t mq_MsgQMap;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MapDataTypeAPIApp local declarations' algorithm generated code\n\n  // End of 'MapDataTypeAPIApp local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief MapDataTypeAPIApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MapDataTypeAPIApp', 'models': [{'name': 'ConsumerMap', 'type': 'cofluent:Function'}, {'name': 'ProducerMap', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQMap', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerMap', 'ConsumerMap']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mapdatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mapdatatypeapiapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MapDataTypeAPIApp definitions' algorithm generated code\n\n// End of 'MapDataTypeAPIApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mapdatatypeapiapp ::cfm_mapdatatypeapiapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQMap(\"MsgQMap\") {\n  cf_application::init();\n  // instantiation of models\n  ConsumerMap = new cfm_consumermap(\"ConsumerMap\");\n  ProducerMap = new cfm_producermap(\"ProducerMap\");\n  // connections\n  // model connect to relation\n  ConsumerMap->p_mq_MsgQMap(mq_MsgQMap.p_target_socket);\n  // model connect to relation\n  ProducerMap->p_mq_MsgQMap(mq_MsgQMap.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mapdatatypeapiapp::~cfm_mapdatatypeapiapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MapDataTypeAPIApp destructor' algorithm generated code\n\n  // End of 'MapDataTypeAPIApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete ConsumerMap;\n  delete ProducerMap;\n}\n\n//@{\nvoid cfm_mapdatatypeapiapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_mapdatatypeapiapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProducerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n#define COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n\n/// Model Header includes start\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProducerMap includes' algorithm generated code\n\n// End of 'ProducerMap includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducerMap Function ProducerMap\n//@{\n///        \\page dxpProducerMap\n//@{\n///    \\brief ProducerMap function model start\nclass cfm_producermap : public cf_core::cf_function {\npublic:\n  /// cfm_producermap type define start\n\n  /// constructor\n  cfm_producermap(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producermap(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProducerMap local declarations' algorithm generated code\n\n  // End of 'ProducerMap local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ProducerMap function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP_PRODUCERMAP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProducerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producermap.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mapdatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producermap\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProducerMap definitions' algorithm generated code\n\n// End of 'ProducerMap definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producermap ::cfm_producermap()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producermap::~cfm_producermap(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProducerMap destructor' algorithm generated code\n\n  // End of 'ProducerMap destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producermap::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producermap::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ConsumerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n#define COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n\n/// Model Header includes start\n#include \"cfm_mapdatatypeapiapp_global.h\"\n#include \"cfm_mapdatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ConsumerMap includes' algorithm generated code\n\n// End of 'ConsumerMap includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumerMap Function ConsumerMap\n//@{\n///        \\page dxpConsumerMap\n//@{\n///    \\brief ConsumerMap function model start\nclass cfm_consumermap : public cf_core::cf_function {\npublic:\n  /// cfm_consumermap type define start\n\n  /// constructor\n  cfm_consumermap(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumermap(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ConsumerMap local declarations' algorithm generated code\n\n  // End of 'ConsumerMap local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ConsumerMap function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MAPDATATYPEAPIAPP_CONSUMERMAP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ConsumerMap', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQMap', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'MapDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumermap\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MapDataTypeAPIApp generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumermap.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mapdatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumermap\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ConsumerMap definitions' algorithm generated code\n\n// End of 'ConsumerMap definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumermap ::cfm_consumermap()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumermap::~cfm_consumermap(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ConsumerMap destructor' algorithm generated code\n\n  // End of 'ConsumerMap destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumermap::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumermap::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'VectorDataTypeAPIApp', 'models': [{'name': 'ConsumerVector', 'type': 'cofluent:Function'}, {'name': 'ProducerVector', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQVector', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerVector', 'ConsumerVector']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_vectordatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator\n * for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP\n#define COFS_MODEL_VECTORDATATYPEAPIAPP\n\n/// Model Header includes start\n#include \"cfm_consumervector.h\"\n#include \"cfm_producervector.h\"\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'VectorDataTypeAPIApp includes' algorithm generated code\n\n// End of 'VectorDataTypeAPIApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgVectorDataTypeAPIApp Function VectorDataTypeAPIApp\n//@{\n///        \\page dxpVectorDataTypeAPIApp\n//@{\n///    \\brief VectorDataTypeAPIApp function model start\nclass cfm_vectordatatypeapiapp : public cf_core::cf_application {\npublic:\n  /// cfm_vectordatatypeapiapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_vector> mq_MsgQVector_t;\n\n  /// cfm_vectordatatypeapiapp type define end\n\n  /// constructor\n  cfm_vectordatatypeapiapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_vectordatatypeapiapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumervector *ConsumerVector;\n  cfm_producervector *ProducerVector;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQVector_t mq_MsgQVector;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'VectorDataTypeAPIApp local declarations' algorithm generated code\n\n  // End of 'VectorDataTypeAPIApp local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief VectorDataTypeAPIApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'VectorDataTypeAPIApp', 'models': [{'name': 'ConsumerVector', 'type': 'cofluent:Function'}, {'name': 'ProducerVector', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQVector', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['ProducerVector', 'ConsumerVector']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_vectordatatypeapiapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator\n * for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_vectordatatypeapiapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'VectorDataTypeAPIApp definitions' algorithm generated code\n\n// End of 'VectorDataTypeAPIApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_vectordatatypeapiapp ::cfm_vectordatatypeapiapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQVector(\"MsgQVector\") {\n  cf_application::init();\n  // instantiation of models\n  ConsumerVector = new cfm_consumervector(\"ConsumerVector\");\n  ProducerVector = new cfm_producervector(\"ProducerVector\");\n  // connections\n  // model connect to relation\n  ConsumerVector->p_mq_MsgQVector(mq_MsgQVector.p_target_socket);\n  // model connect to relation\n  ProducerVector->p_mq_MsgQVector(mq_MsgQVector.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_vectordatatypeapiapp::~cfm_vectordatatypeapiapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'VectorDataTypeAPIApp destructor' algorithm generated code\n\n  // End of 'VectorDataTypeAPIApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete ConsumerVector;\n  delete ProducerVector;\n}\n\n//@{\nvoid cfm_vectordatatypeapiapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_vectordatatypeapiapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ProducerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator\n * for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n#define COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n\n/// Model Header includes start\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProducerVector includes' algorithm generated code\n\n// End of 'ProducerVector includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducerVector Function ProducerVector\n//@{\n///        \\page dxpProducerVector\n//@{\n///    \\brief ProducerVector function model start\nclass cfm_producervector : public cf_core::cf_function {\npublic:\n  /// cfm_producervector type define start\n\n  /// constructor\n  cfm_producervector(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producervector(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProducerVector local declarations' algorithm generated code\n\n  // End of 'ProducerVector local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ProducerVector function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP_PRODUCERVECTOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ProducerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator\n * for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producervector.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_vectordatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producervector\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ProducerVector definitions' algorithm generated code\n\n// End of 'ProducerVector definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producervector ::cfm_producervector()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producervector::~cfm_producervector(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ProducerVector destructor' algorithm generated code\n\n  // End of 'ProducerVector destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producervector::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producervector::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ConsumerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator\n * for SystemC/TLM2\n */\n#ifndef COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n#define COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n\n/// Model Header includes start\n#include \"cfm_vectordatatypeapiapp_global.h\"\n#include \"cfm_vectordatatypeapiapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ConsumerVector includes' algorithm generated code\n\n// End of 'ConsumerVector includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumerVector Function ConsumerVector\n//@{\n///        \\page dxpConsumerVector\n//@{\n///    \\brief ConsumerVector function model start\nclass cfm_consumervector : public cf_core::cf_function {\npublic:\n  /// cfm_consumervector type define start\n\n  /// constructor\n  cfm_consumervector(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumervector(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ConsumerVector local declarations' algorithm generated code\n\n  // End of 'ConsumerVector local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ConsumerVector function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_VECTORDATATYPEAPIAPP_CONSUMERVECTOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ConsumerVector', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQVector', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'VectorDataTypeAPIApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumervector\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of VectorDataTypeAPIApp generated by C++ Generator\n * for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumervector.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_vectordatatypeapiapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumervector\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ConsumerVector definitions' algorithm generated code\n\n// End of 'ConsumerVector definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumervector ::cfm_consumervector()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumervector::~cfm_consumervector(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ConsumerVector destructor' algorithm generated code\n\n  // End of 'ConsumerVector destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumervector::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumervector::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationVectorDataType', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Processing', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Processing']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Processing', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationvectordatatype\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cfm_consumer.h\"\n#include \"cfm_processing.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationVectorDataType includes' algorithm generated code\n\n// End of 'ApplicationVectorDataType includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationVectorDataType Function ApplicationVectorDataType\n//@{\n///        \\page dxpApplicationVectorDataType\n//@{\n///    \\brief ApplicationVectorDataType function model start\nclass cfm_applicationvectordatatype : public cf_core::cf_application {\npublic:\n  /// cfm_applicationvectordatatype type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_vector>\n      mq_user_data_in_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_vector>\n      mq_user_data_out_t;\n\n  /// cfm_applicationvectordatatype type define end\n\n  /// constructor\n  cfm_applicationvectordatatype(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_applicationvectordatatype(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer *Consumer;\n  cfm_processing *Processing;\n  cfm_producer *Producer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_user_data_in_t mq_user_data_in;\n  mq_user_data_out_t mq_user_data_out;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationVectorDataType local declarations' algorithm generated\n  // code\n\n  // End of 'ApplicationVectorDataType local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ApplicationVectorDataType function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationVectorDataType', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Processing', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'user_data_in', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Processing']}, {'name': 'user_data_out', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Processing', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationvectordatatype\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationvectordatatype.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationVectorDataType definitions' algorithm generated code\n\n// End of 'ApplicationVectorDataType definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationvectordatatype ::cfm_applicationvectordatatype()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_user_data_in(\"user_data_in\"),\n      mq_user_data_out(\"user_data_out\") {\n  cf_application::init();\n  // instantiation of models\n  Consumer = new cfm_consumer(\"Consumer\");\n  Processing = new cfm_processing(\"Processing\");\n  Producer = new cfm_producer(\"Producer\");\n  // connections\n  // model connect to relation\n  Consumer->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n  // model connect to relation\n  Processing->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n  Processing->p_mq_user_data_out(mq_user_data_out.p_target_socket);\n  // model connect to relation\n  Producer->p_mq_user_data_in(mq_user_data_in.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationvectordatatype::~cfm_applicationvectordatatype(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationVectorDataType destructor' algorithm generated code\n\n  // End of 'ApplicationVectorDataType destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer;\n  delete Processing;\n  delete Producer;\n}\n\n//@{\nvoid cfm_applicationvectordatatype::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_applicationvectordatatype::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Processing', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_processing\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Processing includes' algorithm generated code\n\n// End of 'Processing includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProcessing Function Processing\n//@{\n///        \\page dxpProcessing\n//@{\n///    \\brief Processing function model start\nclass cfm_processing : public cf_core::cf_function {\npublic:\n  /// cfm_processing type define start\n\n  /// constructor\n  cfm_processing(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_processing(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Processing local declarations' algorithm generated code\n\n  // End of 'Processing local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Processing function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_PROCESSING\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Processing', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_processing\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_processing.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_processing\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Processing definitions' algorithm generated code\n\n// End of 'Processing definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_processing ::cfm_processing()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_processing::~cfm_processing(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Processing destructor' algorithm generated code\n\n  // End of 'Processing destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_processing::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_processing::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n#define COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_applicationvectordatatype_global.h\"\n#include \"cfm_applicationvectordatatype_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONVECTORDATATYPE_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'user_data_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'ApplicationVectorDataType'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationVectorDataType generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationvectordatatype\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CoSimVerilatorChiselApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer1', 'type': 'cofluent:Function'}, {'name': 'Producer2', 'type': 'cofluent:Function'}, {'name': 'adder', 'type': 'cofluent:Function'}], 'relations': [{'name': 'data1', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer1', 'adder']}, {'name': 'data2', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer2', 'adder']}, {'name': 'sum', 'type': 'cofluent:MessageQueue', 'dataType': 'Defsum', 'connectTo': ['adder', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_cosimverilatorchiselapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP\n#define COFS_MODEL_COSIMVERILATORCHISELAPP\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cfm_producer1.h\"\n#include \"cfm_producer2.h\"\n#include \"cofluent.h\"\n#include \"dpi/cofluent_dpi.h\"\n#include \"wrappers/cfm_data1_initiator.h\"\n#include \"wrappers/cfm_data2_initiator.h\"\n#include \"wrappers/cfm_sum_target.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata1.h\"\n#include \"dt/cft_defsum.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoSimVerilatorChiselApp includes' algorithm generated code\n\n// End of 'CoSimVerilatorChiselApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCoSimVerilatorChiselApp Function CoSimVerilatorChiselApp\n//@{\n///        \\page dxpCoSimVerilatorChiselApp\n//@{\n///    \\brief CoSimVerilatorChiselApp function model start\nclass cfm_cosimverilatorchiselapp : public cf_core::cf_application {\npublic:\n  /// cfm_cosimverilatorchiselapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defdata1> mq_data1_t;\n  typedef cf_core::cf_message_queue<cft_defdata1> mq_data2_t;\n  typedef cf_core::cf_message_queue<cft_defsum> mq_sum_t;\n\n  /// cfm_cosimverilatorchiselapp type define end\n\n  /// constructor\n  cfm_cosimverilatorchiselapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_cosimverilatorchiselapp(void);\n  // axi lite master\n  static void data1DPI(ContextHandle self, bool resetn,\n                       /* Write address channel.  */\n                       bool *sig_awvalid, bool sig_awready,\n                       sc_bv<ADDR_WIDTH_DATA1> *sig_awaddr,\n                       sc_bv<3> *sig_awprot,\n                       /* Write data channel.  */\n                       bool *sig_wvalid, bool sig_wready,\n                       sc_bv<DATA_WIDTH_DATA1> *sig_wdata,\n                       sc_bv<DATA_WIDTH_DATA1 / 8> *sig_wstrb,\n                       /* Write response channel.  */\n                       bool sig_bvalid, bool *sig_bready, sc_bv<2> sig_bresp,\n                       /* Read address channel.  */\n                       bool *sig_arvalid, bool sig_arready,\n                       sc_bv<ADDR_WIDTH_DATA1> *sig_araddr,\n                       sc_bv<3> *sig_arprot,\n                       /* Read data channel.  */\n                       bool sig_rvalid, bool *sig_rready,\n                       sc_bv<DATA_WIDTH_DATA1> sig_rdata, sc_bv<2> sig_rresp);\n  // axi lite master\n  static void data2DPI(ContextHandle self, bool resetn,\n                       /* Write address channel.  */\n                       bool *sig_awvalid, bool sig_awready,\n                       sc_bv<ADDR_WIDTH_DATA2> *sig_awaddr,\n                       sc_bv<3> *sig_awprot,\n                       /* Write data channel.  */\n                       bool *sig_wvalid, bool sig_wready,\n                       sc_bv<DATA_WIDTH_DATA2> *sig_wdata,\n                       sc_bv<DATA_WIDTH_DATA2 / 8> *sig_wstrb,\n                       /* Write response channel.  */\n                       bool sig_bvalid, bool *sig_bready, sc_bv<2> sig_bresp,\n                       /* Read address channel.  */\n                       bool *sig_arvalid, bool sig_arready,\n                       sc_bv<ADDR_WIDTH_DATA2> *sig_araddr,\n                       sc_bv<3> *sig_arprot,\n                       /* Read data channel.  */\n                       bool sig_rvalid, bool *sig_rready,\n                       sc_bv<DATA_WIDTH_DATA2> sig_rdata, sc_bv<2> sig_rresp);\n  // axi lite client\n  static void sumDPI(ContextHandle self, bool resetn,\n                     /* Write address channel.  */\n                     bool sig_awvalid, bool *sig_awready,\n                     sc_bv<ADDR_WIDTH_SUM> sig_awaddr, sc_bv<3> sig_awprot,\n                     /* Write data channel.  */\n                     bool sig_wvalid, bool *sig_wready,\n                     sc_bv<DATA_WIDTH_SUM> sig_wdata,\n                     sc_bv<DATA_WIDTH_SUM / 8> sig_wstrb,\n                     /* Write response channel.  */\n                     bool *sig_bvalid, bool sig_bready, sc_bv<2> *sig_bresp,\n                     /* Read address channel.  */\n                     bool sig_arvalid, bool *sig_arready,\n                     sc_bv<ADDR_WIDTH_SUM> sig_araddr, sc_bv<3> sig_arprot,\n                     /* Read data channel.  */\n                     bool *sig_rvalid, bool sig_rready,\n                     sc_bv<DATA_WIDTH_SUM> *sig_rdata, sc_bv<2> *sig_rresp);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer *Consumer;\n  cfm_producer1 *Producer1;\n  cfm_producer2 *Producer2;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_data1_t mq_data1;\n  mq_data2_t mq_data2;\n  mq_sum_t mq_sum;\n  //@}\n\npublic:\n  /// \\name wrappers\n  //@{\n  cfm_data1_initiator data1_initiator;\n  cfm_data2_initiator data2_initiator;\n  cfm_sum_target sum_target;\n  //@}\n  sc_clock clk{\"clk\", 1, SC_NS, 0.5, 0, SC_NS, true};\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoSimVerilatorChiselApp local declarations' algorithm generated\n  // code\n\n  // End of 'CoSimVerilatorChiselApp local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CoSimVerilatorChiselApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CoSimVerilatorChiselApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer1', 'type': 'cofluent:Function'}, {'name': 'Producer2', 'type': 'cofluent:Function'}, {'name': 'adder', 'type': 'cofluent:Function'}], 'relations': [{'name': 'data1', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer1', 'adder']}, {'name': 'data2', 'type': 'cofluent:MessageQueue', 'dataType': 'Defdata1', 'connectTo': ['Producer2', 'adder']}, {'name': 'sum', 'type': 'cofluent:MessageQueue', 'dataType': 'Defsum', 'connectTo': ['adder', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_cosimverilatorchiselapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_cosimverilatorchiselapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CoSimVerilatorChiselApp definitions' algorithm generated code\n\n// End of 'CoSimVerilatorChiselApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_cosimverilatorchiselapp ::cfm_cosimverilatorchiselapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_data1(\"data1\"), mq_data2(\"data2\"),\n      mq_sum(\"sum\") {\n  cf_application::init();\n  // instantiation of models\n  Consumer = new cfm_consumer(\"Consumer\");\n  Producer1 = new cfm_producer1(\"Producer1\");\n  Producer2 = new cfm_producer2(\"Producer2\");\n  adder = new cfm_adder(\"adder\");\n  // connections\n  // model connect to relation\n  Consumer->p_mq_sum(mq_sum.p_target_socket);\n  // model connect to relation\n  Producer1->p_mq_data1(mq_data1.p_target_socket);\n  // model connect to relation\n  Producer2->p_mq_data2(mq_data2.p_target_socket);\n  // model connect to relation\n  adder->p_mq_data1(mq_data1.p_target_socket);\n  adder->p_mq_data2(mq_data2.p_target_socket);\n  adder->p_mq_sum(mq_sum.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_cosimverilatorchiselapp::~cfm_cosimverilatorchiselapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CoSimVerilatorChiselApp destructor' algorithm generated code\n\n  // End of 'CoSimVerilatorChiselApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer;\n  delete Producer1;\n  delete Producer2;\n  delete adder;\n}\n\n//@{\nvoid cfm_cosimverilatorchiselapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_cosimverilatorchiselapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer1', 'type': 'cofluent:Function', 'ports': [{'name': 'data1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n\n/// Model Header includes start\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata1.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer1 includes' algorithm generated code\n\n// End of 'Producer1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer1 Function Producer1\n//@{\n///        \\page dxpProducer1\n//@{\n///    \\brief Producer1 function model start\nclass cfm_producer1 : public cf_core::cf_function {\npublic:\n  /// cfm_producer1 type define start\n\n  /// constructor\n  cfm_producer1(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer1(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer1 local declarations' algorithm generated code\n\n  // End of 'Producer1 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer1', 'type': 'cofluent:Function', 'ports': [{'name': 'data1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer1 definitions' algorithm generated code\n\n// End of 'Producer1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer1 ::cfm_producer1()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer1::~cfm_producer1(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer1 destructor' algorithm generated code\n\n  // End of 'Producer1 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer1::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer1::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer2', 'type': 'cofluent:Function', 'ports': [{'name': 'data2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n\n/// Model Header includes start\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata1.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer2 includes' algorithm generated code\n\n// End of 'Producer2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer2 Function Producer2\n//@{\n///        \\page dxpProducer2\n//@{\n///    \\brief Producer2 function model start\nclass cfm_producer2 : public cf_core::cf_function {\npublic:\n  /// cfm_producer2 type define start\n\n  /// constructor\n  cfm_producer2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer2(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer2 local declarations' algorithm generated code\n\n  // End of 'Producer2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_PRODUCER2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer2', 'type': 'cofluent:Function', 'ports': [{'name': 'data2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Defdata1'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer2 definitions' algorithm generated code\n\n// End of 'Producer2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer2 ::cfm_producer2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer2::~cfm_producer2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer2 destructor' algorithm generated code\n\n  // End of 'Producer2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'sum', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Defsum'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n#define COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_cosimverilatorchiselapp_global.h\"\n#include \"cfm_cosimverilatorchiselapp_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defsum.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_COSIMVERILATORCHISELAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'sum', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Defsum'}], 'globalName': 'CoSimVerilatorChiselApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CoSimVerilatorChiselApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_cosimverilatorchiselapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TLM2LT', 'models': [{'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}, {'name': 'Writer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_tlm2lt\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT\n#define COFS_MODEL_TLM2LT\n\n/// Model Header includes start\n#include \"cfm_reader.h\"\n#include \"cfm_target.h\"\n#include \"cfm_target_2.h\"\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cfm_writer.h\"\n#include \"cofluent.h\"\n#include \"lt_top.h\"\n#include \"wrappers/cfm_initiatorreader_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_initiatorwriter_tlm2_lt_initiator.h\"\n#include \"wrappers/cfm_targetrequest_tlm2_lt_target.h\"\n#include \"wrappers/cfm_targetwrapper_tlm2_lt_target.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'TLM2LT includes' algorithm generated code\n\n// End of 'TLM2LT includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTLM2LT Function TLM2LT\n//@{\n///        \\page dxpTLM2LT\n//@{\n///    \\brief TLM2LT function model start\nclass cfm_tlm2lt : public cf_core::cf_application {\npublic:\n  /// cfm_tlm2lt type define start\n  /// systemC IPs typedef\n  typedef lt_top TLM2Platfom_t;\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_Sync2_t;\n  typedef cf_core::cf_event ev_Sync3_t;\n  typedef cf_core::cf_event ev_Sync_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_InitiatorReader_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_InitiatorWriter_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_ReaderResponse_t;\n  typedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue2_t;\n  typedef cf_core::cf_message_queue<cft_defmsgq> mq_ReferenceQueue3_t;\n  typedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_TargetRequest_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_TargetResponse_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_TargetWrapper_t;\n\n  /// cfm_tlm2lt type define end\n\n  /// constructor\n  cfm_tlm2lt(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_tlm2lt(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_reader *Reader;\n  TLM2Platfom_t *TLM2Platfom;\n  cfm_target *Target;\n  cfm_target_2 *Target_2;\n  cfm_writer *Writer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_Sync2_t ev_Sync2;\n  ev_Sync3_t ev_Sync3;\n  ev_Sync_t ev_Sync;\n  mq_InitiatorReader_t mq_InitiatorReader;\n  mq_InitiatorWriter_t mq_InitiatorWriter;\n  mq_ReaderResponse_t mq_ReaderResponse;\n  mq_ReferenceQueue2_t mq_ReferenceQueue2;\n  mq_ReferenceQueue3_t mq_ReferenceQueue3;\n  mq_ReferenceQueue_t mq_ReferenceQueue;\n  mq_TargetRequest_t mq_TargetRequest;\n  mq_TargetResponse_t mq_TargetResponse;\n  mq_TargetWrapper_t mq_TargetWrapper;\n  //@}\n\nprotected:\n  /// \\name wrappers\n  //@{\n  cfm_initiatorreader_tlm2_lt_initiator initiatorreader_tlm2_lt_initiator;\n  cfm_initiatorwriter_tlm2_lt_initiator initiatorwriter_tlm2_lt_initiator;\n  cfm_targetrequest_tlm2_lt_target targetrequest_tlm2_lt_target;\n  cfm_targetwrapper_tlm2_lt_target targetwrapper_tlm2_lt_target;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'TLM2LT local declarations' algorithm generated code\n\n  // End of 'TLM2LT local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief TLM2LT function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TLM2LT', 'models': [{'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}, {'name': 'Writer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_tlm2lt\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_tlm2lt.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'TLM2LT definitions' algorithm generated code\n\n// End of 'TLM2LT definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_tlm2lt ::cfm_tlm2lt()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), ev_Sync(\"Sync\"), ev_Sync2(\"Sync2\"),\n      ev_Sync3(\"Sync3\"), mq_InitiatorReader(\"InitiatorReader\"),\n      mq_InitiatorWriter(\"InitiatorWriter\"),\n      mq_ReaderResponse(\"ReaderResponse\"), mq_ReferenceQueue(\"ReferenceQueue\"),\n      mq_ReferenceQueue2(\"ReferenceQueue2\"),\n      mq_ReferenceQueue3(\"ReferenceQueue3\"), mq_TargetRequest(\"TargetRequest\"),\n      mq_TargetResponse(\"TargetResponse\"), mq_TargetWrapper(\"TargetWrapper\") {\n  cf_application::init();\n  // instantiation of models\n  Reader = new cfm_reader(\"Reader\");\n  TLM2Platfom = new cfm_tlm2platfom(\"TLM2Platfom\");\n  Target = new cfm_target(\"Target\");\n  Target_2 = new cfm_target_2(\"Target_2\");\n  Writer = new cfm_writer(\"Writer\");\n  // connections\n  // model connect to relation\n  Reader->p_mq_InitiatorReader(mq_InitiatorReader.p_target_socket);\n  Reader->p_mq_ReaderResponse(mq_ReaderResponse.p_target_socket);\n  Reader->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n  Reader->p_ev_Sync(ev_Sync.p_target_socket);\n  // model connect to relation\n  Target->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n  Target->p_ev_Sync2(ev_Sync2.p_target_socket);\n  Target->p_mq_TargetWrapper(mq_TargetWrapper.p_target_socket);\n  // model connect to relation\n  Target_2->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n  Target_2->p_ev_Sync3(ev_Sync3.p_target_socket);\n  Target_2->p_mq_TargetRequest(mq_TargetRequest.p_target_socket);\n  Target_2->p_mq_TargetResponse(mq_TargetResponse.p_target_socket);\n  // model connect to relation\n  Writer->p_mq_InitiatorWriter(mq_InitiatorWriter.p_target_socket);\n  Writer->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n  Writer->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n  Writer->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n  Writer->p_ev_Sync(ev_Sync.p_target_socket);\n  Writer->p_ev_Sync2(ev_Sync2.p_target_socket);\n  Writer->p_ev_Sync3(ev_Sync3.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_tlm2lt::~cfm_tlm2lt(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'TLM2LT destructor' algorithm generated code\n\n  // End of 'TLM2LT destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Reader;\n  delete TLM2Platfom;\n  delete Target;\n  delete Target_2;\n  delete Writer;\n}\n\n//@{\nvoid cfm_tlm2lt::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_tlm2lt::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_WRITER\n#define COFS_MODEL_TLM2LT_WRITER\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Writer includes' algorithm generated code\n\n// End of 'Writer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWriter Function Writer\n//@{\n///        \\page dxpWriter\n//@{\n///    \\brief Writer function model start\nclass cfm_writer : public cf_core::cf_function {\npublic:\n  /// cfm_writer type define start\n\n  /// constructor\n  cfm_writer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_writer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Writer local declarations' algorithm generated code\n\n  // End of 'Writer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Writer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_WRITER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_writer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Writer definitions' algorithm generated code\n\n// End of 'Writer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_writer ::cfm_writer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_writer::~cfm_writer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Writer destructor' algorithm generated code\n\n  // End of 'Writer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_writer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_writer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_TARGET\n#define COFS_MODEL_TLM2LT_TARGET\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target includes' algorithm generated code\n\n// End of 'Target includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget Function Target\n//@{\n///        \\page dxpTarget\n//@{\n///    \\brief Target function model start\nclass cfm_target : public cf_core::cf_function {\npublic:\n  /// cfm_target type define start\n\n  /// constructor\n  cfm_target(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_target(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target local declarations' algorithm generated code\n\n  // End of 'Target local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Target function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_TARGET\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target definitions' algorithm generated code\n\n// End of 'Target definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target ::cfm_target()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target::~cfm_target(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target destructor' algorithm generated code\n\n  // End of 'Target destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_target::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_target::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_READER\n#define COFS_MODEL_TLM2LT_READER\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Reader includes' algorithm generated code\n\n// End of 'Reader includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReader Function Reader\n//@{\n///        \\page dxpReader\n//@{\n///    \\brief Reader function model start\nclass cfm_reader : public cf_core::cf_function {\npublic:\n  /// cfm_reader type define start\n\n  /// constructor\n  cfm_reader(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_reader(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Reader local declarations' algorithm generated code\n\n  // End of 'Reader local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Reader function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_READER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_reader.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reader\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Reader definitions' algorithm generated code\n\n// End of 'Reader definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_reader ::cfm_reader()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_reader::~cfm_reader(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Reader destructor' algorithm generated code\n\n  // End of 'Reader destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_reader::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_reader::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2LT_TARGET_2\n#define COFS_MODEL_TLM2LT_TARGET_2\n\n/// Model Header includes start\n#include \"cfm_tlm2lt_global.h\"\n#include \"cfm_tlm2lt_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target_2 includes' algorithm generated code\n\n// End of 'Target_2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget_2 Function Target_2\n//@{\n///        \\page dxpTarget_2\n//@{\n///    \\brief Target_2 function model start\nclass cfm_target_2 : public cf_core::cf_function {\npublic:\n  /// cfm_target_2 type define start\n\n  /// constructor\n  cfm_target_2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_target_2(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target_2 local declarations' algorithm generated code\n\n  // End of 'Target_2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Target_2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2LT_TARGET_2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2LT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2LT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target_2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2lt\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target_2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target_2 definitions' algorithm generated code\n\n// End of 'Target_2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target_2 ::cfm_target_2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target_2::~cfm_target_2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target_2 destructor' algorithm generated code\n\n  // End of 'Target_2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_target_2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_target_2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'AutomatedPayloadTrackers', 'models': [{'name': 'C1', 'type': 'cofluent:Function'}, {'name': 'C2', 'type': 'cofluent:Function'}, {'name': 'F12', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}, {'name': 'P1', 'type': 'cofluent:Function'}, {'name': 'P2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M1_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P1']}, {'name': 'M1_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'F12']}, {'name': 'M1_3', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'C1']}, {'name': 'M2_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P2']}, {'name': 'M2_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['C2', 'F12']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_automatedpayloadtrackers\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cfm_c1.h\"\n#include \"cfm_c2.h\"\n#include \"cfm_f12.h\"\n#include \"cfm_f2.h\"\n#include \"cfm_p1.h\"\n#include \"cfm_p2.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'AutomatedPayloadTrackers includes' algorithm generated code\n\n// End of 'AutomatedPayloadTrackers includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgAutomatedPayloadTrackers Function AutomatedPayloadTrackers\n//@{\n///        \\page dxpAutomatedPayloadTrackers\n//@{\n///    \\brief AutomatedPayloadTrackers function model start\nclass cfm_automatedpayloadtrackers : public cf_core::cf_application {\npublic:\n  /// cfm_automatedpayloadtrackers type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_1_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_2_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M1_3_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M2_1_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_M2_2_t;\n\n  /// cfm_automatedpayloadtrackers type define end\n\n  /// constructor\n  cfm_automatedpayloadtrackers(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_automatedpayloadtrackers(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_c1 *C1;\n  cfm_c2 *C2;\n  cfm_f12 *F12;\n  cfm_f2 *F2;\n  cfm_p1 *P1;\n  cfm_p2 *P2;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_M1_1_t mq_M1_1;\n  mq_M1_2_t mq_M1_2;\n  mq_M1_3_t mq_M1_3;\n  mq_M2_1_t mq_M2_1;\n  mq_M2_2_t mq_M2_2;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'AutomatedPayloadTrackers local declarations' algorithm generated\n  // code\n\n  // End of 'AutomatedPayloadTrackers local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief AutomatedPayloadTrackers function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'AutomatedPayloadTrackers', 'models': [{'name': 'C1', 'type': 'cofluent:Function'}, {'name': 'C2', 'type': 'cofluent:Function'}, {'name': 'F12', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}, {'name': 'P1', 'type': 'cofluent:Function'}, {'name': 'P2', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M1_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P1']}, {'name': 'M1_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'F12']}, {'name': 'M1_3', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F2', 'C1']}, {'name': 'M2_1', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['F12', 'P2']}, {'name': 'M2_2', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['C2', 'F12']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_automatedpayloadtrackers\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_automatedpayloadtrackers.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'AutomatedPayloadTrackers definitions' algorithm generated code\n\n// End of 'AutomatedPayloadTrackers definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_automatedpayloadtrackers ::cfm_automatedpayloadtrackers()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_M1_1(\"M1_1\"), mq_M1_2(\"M1_2\"), mq_M1_3(\"M1_3\"),\n      mq_M2_1(\"M2_1\"), mq_M2_2(\"M2_2\") {\n  cf_application::init();\n  // instantiation of models\n  C1 = new cfm_c1(\"C1\");\n  C2 = new cfm_c2(\"C2\");\n  F12 = new cfm_f12(\"F12\");\n  F2 = new cfm_f2(\"F2\");\n  P1 = new cfm_p1(\"P1\");\n  P2 = new cfm_p2(\"P2\");\n  // connections\n  // model connect to relation\n  C1->p_mq_M1_3(mq_M1_3.p_target_socket);\n  // model connect to relation\n  C2->p_mq_M2_2(mq_M2_2.p_target_socket);\n  // model connect to relation\n  F12->p_mq_M1_1(mq_M1_1.p_target_socket);\n  F12->p_mq_M1_2(mq_M1_2.p_target_socket);\n  F12->p_mq_M2_1(mq_M2_1.p_target_socket);\n  F12->p_mq_M2_2(mq_M2_2.p_target_socket);\n  // model connect to relation\n  F2->p_mq_M1_2(mq_M1_2.p_target_socket);\n  F2->p_mq_M1_3(mq_M1_3.p_target_socket);\n  // model connect to relation\n  P1->p_mq_M1_1(mq_M1_1.p_target_socket);\n  // model connect to relation\n  P2->p_mq_M2_1(mq_M2_1.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_automatedpayloadtrackers::~cfm_automatedpayloadtrackers(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'AutomatedPayloadTrackers destructor' algorithm generated code\n\n  // End of 'AutomatedPayloadTrackers destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete C1;\n  delete C2;\n  delete F12;\n  delete F2;\n  delete P1;\n  delete P2;\n}\n\n//@{\nvoid cfm_automatedpayloadtrackers::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_automatedpayloadtrackers::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'C2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_c2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'C2 includes' algorithm generated code\n\n// End of 'C2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgC2 Function C2\n//@{\n///        \\page dxpC2\n//@{\n///    \\brief C2 function model start\nclass cfm_c2 : public cf_core::cf_function {\npublic:\n  /// cfm_c2 type define start\n\n  /// constructor\n  cfm_c2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_c2(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'C2 local declarations' algorithm generated code\n\n  // End of 'C2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief C2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'C2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_c2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_c2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_c2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'C2 definitions' algorithm generated code\n\n// End of 'C2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_c2 ::cfm_c2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_c2::~cfm_c2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'C2 destructor' algorithm generated code\n\n  // End of 'C2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_c2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_c2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F2 includes' algorithm generated code\n\n// End of 'F2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF2 Function F2\n//@{\n///        \\page dxpF2\n//@{\n///    \\brief F2 function model start\nclass cfm_f2 : public cf_core::cf_function {\npublic:\n  /// cfm_f2 type define start\n\n  /// constructor\n  cfm_f2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_f2(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F2 local declarations' algorithm generated code\n\n  // End of 'F2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief F2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F2 definitions' algorithm generated code\n\n// End of 'F2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f2 ::cfm_f2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f2::~cfm_f2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F2 destructor' algorithm generated code\n\n  // End of 'F2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_f2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_f2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F12', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f12\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F12 includes' algorithm generated code\n\n// End of 'F12 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF12 Function F12\n//@{\n///        \\page dxpF12\n//@{\n///    \\brief F12 function model start\nclass cfm_f12 : public cf_core::cf_function {\npublic:\n  /// cfm_f12 type define start\n\n  /// constructor\n  cfm_f12(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_f12(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F12 local declarations' algorithm generated code\n\n  // End of 'F12 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief F12 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_F12\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F12', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}, {'name': 'M1_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}, {'name': 'M2_2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f12\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f12.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f12\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F12 definitions' algorithm generated code\n\n// End of 'F12 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f12 ::cfm_f12()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f12::~cfm_f12(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F12 destructor' algorithm generated code\n\n  // End of 'F12 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_f12::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_f12::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'P1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_p1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'P1 includes' algorithm generated code\n\n// End of 'P1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgP1 Function P1\n//@{\n///        \\page dxpP1\n//@{\n///    \\brief P1 function model start\nclass cfm_p1 : public cf_core::cf_function {\npublic:\n  /// cfm_p1 type define start\n\n  /// constructor\n  cfm_p1(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_p1(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'P1 local declarations' algorithm generated code\n\n  // End of 'P1 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief P1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'P1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_p1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_p1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_p1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'P1 definitions' algorithm generated code\n\n// End of 'P1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_p1 ::cfm_p1()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_p1::~cfm_p1(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'P1 destructor' algorithm generated code\n\n  // End of 'P1 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_p1::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_p1::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'P2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_p2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'P2 includes' algorithm generated code\n\n// End of 'P2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgP2 Function P2\n//@{\n///        \\page dxpP2\n//@{\n///    \\brief P2 function model start\nclass cfm_p2 : public cf_core::cf_function {\npublic:\n  /// cfm_p2 type define start\n\n  /// constructor\n  cfm_p2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_p2(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'P2 local declarations' algorithm generated code\n\n  // End of 'P2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief P2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_P2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'P2', 'type': 'cofluent:Function', 'ports': [{'name': 'M2_1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_p2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_p2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_p2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'P2 definitions' algorithm generated code\n\n// End of 'P2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_p2 ::cfm_p2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_p2::~cfm_p2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'P2 destructor' algorithm generated code\n\n  // End of 'P2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_p2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_p2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'C1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_c1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n#define COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n\n/// Model Header includes start\n#include \"cfm_automatedpayloadtrackers_global.h\"\n#include \"cfm_automatedpayloadtrackers_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'C1 includes' algorithm generated code\n\n// End of 'C1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgC1 Function C1\n//@{\n///        \\page dxpC1\n//@{\n///    \\brief C1 function model start\nclass cfm_c1 : public cf_core::cf_function {\npublic:\n  /// cfm_c1 type define start\n\n  /// constructor\n  cfm_c1(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_c1(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'C1 local declarations' algorithm generated code\n\n  // End of 'C1 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief C1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_AUTOMATEDPAYLOADTRACKERS_C1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'C1', 'type': 'cofluent:Function', 'ports': [{'name': 'M1_3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'AutomatedPayloadTrackers'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_c1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of AutomatedPayloadTrackers generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_c1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_automatedpayloadtrackers\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_c1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'C1 definitions' algorithm generated code\n\n// End of 'C1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_c1 ::cfm_c1()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_c1::~cfm_c1(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'C1 destructor' algorithm generated code\n\n  // End of 'C1 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_c1::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_c1::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DDRMemory', 'models': [{'name': 'ClientSide', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ARADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefARADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'AWADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAWADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'BRESPchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBRESPchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'RDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRDATAchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'WDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefWDATAchn', 'connectTo': ['ClientSide', 'Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ddrmemory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY\n#define COFS_MODEL_DDRMEMORY\n\n/// Model Header includes start\n#include \"cfm_clientside.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_target.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ddrmemory_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'DDRMemory includes' algorithm generated code\n\n// End of 'DDRMemory includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDDRMemory Function DDRMemory\n//@{\n///        \\page dxpDDRMemory\n//@{\n///    \\brief DDRMemory function model start\nclass cfm_ddrmemory : public cf_core::cf_application,\n                      public cfm_ddrmemory_dp_if {\npublic:\n  /// cfm_ddrmemory type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defaraddrchn> mq_ARADDRchn_t;\n  typedef cf_core::cf_message_queue<cft_defawaddrchn> mq_AWADDRchn_t;\n  typedef cf_core::cf_message_queue<cft_defbrespchn> mq_BRESPchn_t;\n  typedef cf_core::cf_message_queue<cft_defrdatachn> mq_RDATAchn_t;\n  typedef cf_core::cf_message_queue<cft_defwdatachn> mq_WDATAchn_t;\n\n  /// cfm_ddrmemory type define end\n\n  /// constructor\n  cfm_ddrmemory(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_ddrmemory(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_clientside *ClientSide;\n  cfm_target *Target;\n  //@}\n\npublic:\n  /// Overload function for mq_WDATAchn message queue send time\n  cf_dt::cf_duration mq_WDATAchn_cb_send_time(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_ARADDRchn_t mq_ARADDRchn;\n  mq_AWADDRchn_t mq_AWADDRchn;\n  mq_BRESPchn_t mq_BRESPchn;\n  mq_RDATAchn_t mq_RDATAchn;\n  mq_WDATAchn_t mq_WDATAchn;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'DDRMemory local declarations' algorithm generated code\n\n  // End of 'DDRMemory local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief DDRMemory function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DDRMemory', 'models': [{'name': 'ClientSide', 'type': 'cofluent:Function'}, {'name': 'Target', 'type': 'cofluent:Function'}], 'relations': [{'name': 'ARADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefARADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'AWADDRchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAWADDRchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'BRESPchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBRESPchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'RDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRDATAchn', 'connectTo': ['ClientSide', 'Target']}, {'name': 'WDATAchn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefWDATAchn', 'connectTo': ['ClientSide', 'Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ddrmemory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ddrmemory.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'DDRMemory definitions' algorithm generated code\n\n// End of 'DDRMemory definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ddrmemory ::cfm_ddrmemory()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), cfm_ddrmemory_dp_if(), mq_ARADDRchn(\"ARADDRchn\"),\n      mq_AWADDRchn(\"AWADDRchn\"), mq_BRESPchn(\"BRESPchn\"),\n      mq_RDATAchn(\"RDATAchn\"), mq_WDATAchn(\"WDATAchn\") {\n  cf_application::init();\n  // instantiation of models\n  ClientSide = new cfm_clientside(\"ClientSide\");\n  Target = new cfm_target(\"Target\");\n  // connections\n  // model connect to relation\n  ClientSide->p_mq_ARADDRchn(mq_ARADDRchn.p_target_socket);\n  ClientSide->p_mq_AWADDRchn(mq_AWADDRchn.p_target_socket);\n  ClientSide->p_mq_BRESPchn(mq_BRESPchn.p_target_socket);\n  ClientSide->p_mq_RDATAchn(mq_RDATAchn.p_target_socket);\n  ClientSide->p_mq_WDATAchn(mq_WDATAchn.p_target_socket);\n  // model connect to relation\n  Target->p_mq_ARADDRchn(mq_ARADDRchn.p_target_socket);\n  Target->p_mq_AWADDRchn(mq_AWADDRchn.p_target_socket);\n  Target->p_mq_BRESPchn(mq_BRESPchn.p_target_socket);\n  Target->p_mq_RDATAchn(mq_RDATAchn.p_target_socket);\n  Target->p_mq_WDATAchn(mq_WDATAchn.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ddrmemory::~cfm_ddrmemory(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'DDRMemory destructor' algorithm generated code\n\n  // End of 'DDRMemory destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete ClientSide;\n  delete Target;\n}\n\n//@{\nvoid cfm_ddrmemory::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_ddrmemory::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ClientSide', 'type': 'cofluent:Function', 'models': [{'name': 'Device', 'type': 'cofluent:Function', 'vector': '0, C_Nbr'}, {'name': 'RDDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WRDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Device']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Device']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['WRDmux']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['RDDmux']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Device']}], 'relations': [{'name': 'BRESPin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefBRESPchn', 'connectTo': ['Device', 'WRDmux']}, {'name': 'RDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefRDATAchn', 'connectTo': ['Device', 'RDDmux']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_clientside\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_CLIENTSIDE\n#define COFS_MODEL_DDRMEMORY_CLIENTSIDE\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_device.h\"\n#include \"cfm_rddmux.h\"\n#include \"cfm_wrdmux.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_clientside_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ClientSide includes' algorithm generated code\n\n// End of 'ClientSide includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgClientSide Function ClientSide\n//@{\n///        \\page dxpClientSide\n//@{\n///    \\brief ClientSide function model start\nclass cfm_clientside : public cf_core::cf_function_container,\n                       public cfm_clientside_dp_if {\npublic:\n  /// cfm_clientside type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defbrespchn> mq_BRESPin_t;\n  typedef cf_core::cf_message_queue<cft_defrdatachn> mq_RDATAin_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_clientside, cfm_defaraddrchn>\n      p_mq_ARADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_clientside, cfm_defawaddrchn>\n      p_mq_AWADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_clientside, cfm_defbrespchn>\n      p_mq_BRESPchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_clientside, cfm_defrdatachn>\n      p_mq_RDATAchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_clientside, cfm_defwdatachn>\n      p_mq_WDATAchn_t;\n  /// cfm_clientside type define end\n\n  /// constructor\n  cfm_clientside(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_clientside(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_ARADDRchn_t p_mq_ARADDRchn;\n  p_mq_AWADDRchn_t p_mq_AWADDRchn;\n  p_mq_BRESPchn_t p_mq_BRESPchn;\n  p_mq_RDATAchn_t p_mq_RDATAchn;\n  p_mq_WDATAchn_t p_mq_WDATAchn;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  std::vector<cfm_device *> Device_vec;\n  cfm_rddmux *RDDmux;\n  cfm_wrdmux *WRDmux;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_BRESPin_t *> mq_BRESPin_vec;\n  std::vector<mq_RDATAin_t *> mq_RDATAin_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ClientSide local declarations' algorithm generated code\n\n  // End of 'ClientSide local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ClientSide function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_CLIENTSIDE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ClientSide', 'type': 'cofluent:Function', 'models': [{'name': 'Device', 'type': 'cofluent:Function', 'vector': '0, C_Nbr'}, {'name': 'RDDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WRDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Device']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Device']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['WRDmux']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['RDDmux']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Device']}], 'relations': [{'name': 'BRESPin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefBRESPchn', 'connectTo': ['Device', 'WRDmux']}, {'name': 'RDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, C_Nbr', 'dataType': 'DefRDATAchn', 'connectTo': ['Device', 'RDDmux']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_clientside\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_clientside.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ddrmemory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_clientside\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ClientSide definitions' algorithm generated code\n\n// End of 'ClientSide definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_clientside ::cfm_clientside()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_clientside_dp_if(),\n      mq_BRESPin(\"BRESPin\"), mq_RDATAin(\"RDATAin\"),\n      p_mq_ARADDRchn(\"p_mq_ARADDRchn\"), p_mq_AWADDRchn(\"p_mq_AWADDRchn\"),\n      p_mq_BRESPchn(\"p_mq_BRESPchn\"), p_mq_RDATAchn(\"p_mq_RDATAchn\"),\n      p_mq_WDATAchn(\"p_mq_WDATAchn\") {\n  cf_function_container::init();\n  // instantiation of models\n  for (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n    cfm_device *module = new cfm_device(cf_string(\"Device[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Device_vec.push_back(module);\n  }\n  RDDmux = new cfm_rddmux(\"RDDmux\");\n  WRDmux = new cfm_wrdmux(\"WRDmux\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n    mq_BRESPin_t *module =\n        new mq_BRESPin_t(cf_string(\"BRESPin[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_BRESPin_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n    mq_RDATAin_t *module =\n        new mq_RDATAin_t(cf_string(\"RDATAin[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_RDATAin_vec.push_back(module);\n  }\n  // connections\n  for (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n    cfm_device *module = Device_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(C_Nbr + 1); j++) {\n        module->p_mq_BRESPin(mq_BRESPin_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(C_Nbr + 1); j++) {\n        module->p_mq_RDATAin(mq_RDATAin_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_ARADDRchn(p_mq_ARADDRchn);\n      module->p_mq_AWADDRchn(p_mq_AWADDRchn);\n      module->p_mq_WDATAchn(p_mq_WDATAchn);\n    }\n  }\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n    RDDmux->p_mq_RDATAin(mq_RDATAin_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  RDDmux->p_mq_RDATAchn(p_mq_RDATAchn);\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(C_Nbr + 1); i++) {\n    WRDmux->p_mq_BRESPin(mq_BRESPin_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  WRDmux->p_mq_BRESPchn(p_mq_BRESPchn);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_clientside::~cfm_clientside(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ClientSide destructor' algorithm generated code\n\n  // End of 'ClientSide destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  for (vector<cfm_device *>::const_iterator vi = Device_vec.begin();\n       vi != Device_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete RDDmux;\n  delete WRDmux;\n  // deconstructor for vector relation\n  for (vector<mq_BRESPin_t *>::const_iterator vi = mq_BRESPin_vec.begin();\n       vi != mq_BRESPin_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_RDATAin_t *>::const_iterator vi = mq_RDATAin_vec.begin();\n       vi != mq_RDATAin_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_clientside::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_clientside::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'models': [{'name': 'Memory', 'type': 'cofluent:Function', 'vector': '0, M_Nbr'}, {'name': 'MemoryController', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['MemoryController']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['MemoryController']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['MemoryController']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['MemoryController']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['MemoryController']}], 'relations': [{'name': 'DDRCommand', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryController', 'Memory']}, {'name': 'DQs', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDQs', 'connectTo': ['MemoryController', 'Memory']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_TARGET\n#define COFS_MODEL_DDRMEMORY_TARGET\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_memory.h\"\n#include \"cfm_memorycontroller.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_target_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target includes' algorithm generated code\n\n// End of 'Target includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget Function Target\n//@{\n///        \\page dxpTarget\n//@{\n///    \\brief Target function model start\nclass cfm_target : public cf_core::cf_function_container,\n                   public cfm_target_dp_if {\npublic:\n  /// cfm_target type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defddrcommand> mq_DDRCommand_t;\n  typedef cf_core::cf_message_queue<cft_defdqs> mq_DQs_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_target, cfm_defaraddrchn>\n      p_mq_ARADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_target, cfm_defawaddrchn>\n      p_mq_AWADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_target, cfm_defbrespchn>\n      p_mq_BRESPchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_target, cfm_defrdatachn>\n      p_mq_RDATAchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_target, cfm_defwdatachn>\n      p_mq_WDATAchn_t;\n  /// cfm_target type define end\n\n  /// constructor\n  cfm_target(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_target(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_ARADDRchn_t p_mq_ARADDRchn;\n  p_mq_AWADDRchn_t p_mq_AWADDRchn;\n  p_mq_BRESPchn_t p_mq_BRESPchn;\n  p_mq_RDATAchn_t p_mq_RDATAchn;\n  p_mq_WDATAchn_t p_mq_WDATAchn;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_memorycontroller *MemoryController;\n  std::vector<cfm_memory *> Memory_vec;\n  //@}\n\npublic:\n  /// Overload function for mq_DQs message queue receive time\n  cf_dt::cf_duration mq_DQs_cb_receive_time(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_DDRCommand_t *> mq_DDRCommand_vec;\n  std::vector<mq_DQs_t *> mq_DQs_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target local declarations' algorithm generated code\n\n  // End of 'Target local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Target function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_TARGET\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'models': [{'name': 'Memory', 'type': 'cofluent:Function', 'vector': '0, M_Nbr'}, {'name': 'MemoryController', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['MemoryController']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['MemoryController']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['MemoryController']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['MemoryController']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['MemoryController']}], 'relations': [{'name': 'DDRCommand', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryController', 'Memory']}, {'name': 'DQs', 'type': 'cofluent:MessageQueue', 'vector': '0, M_Nbr', 'dataType': 'DefDQs', 'connectTo': ['MemoryController', 'Memory']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_ddrmemory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target definitions' algorithm generated code\n\n// End of 'Target definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target ::cfm_target()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_target_dp_if(),\n      mq_DDRCommand(\"DDRCommand\"), mq_DQs(\"DQs\"),\n      p_mq_ARADDRchn(\"p_mq_ARADDRchn\"), p_mq_AWADDRchn(\"p_mq_AWADDRchn\"),\n      p_mq_BRESPchn(\"p_mq_BRESPchn\"), p_mq_RDATAchn(\"p_mq_RDATAchn\"),\n      p_mq_WDATAchn(\"p_mq_WDATAchn\") {\n  cf_function_container::init();\n  // instantiation of models\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    cfm_memory *module = new cfm_memory(cf_string(\"Memory[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Memory_vec.push_back(module);\n  }\n  MemoryController = new cfm_memorycontroller(\"MemoryController\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    mq_DDRCommand_t *module =\n        new mq_DDRCommand_t(cf_string(\"DDRCommand[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_DDRCommand_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    mq_DQs_t *module = new mq_DQs_t(cf_string(\"DQs[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_DQs_vec.push_back(module);\n  }\n  // connections\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    cfm_memory *module = Memory_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(M_Nbr + 1); j++) {\n        module->p_mq_DDRCommand(mq_DDRCommand_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(M_Nbr + 1); j++) {\n        module->p_mq_DQs(mq_DQs_vec[j]->p_target_socket);\n      }\n    }\n  }\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    MemoryController->p_mq_DDRCommand(mq_DDRCommand_vec[i]->p_target_socket);\n  }\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    MemoryController->p_mq_DQs(mq_DQs_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  MemoryController->p_mq_ARADDRchn(p_mq_ARADDRchn);\n  MemoryController->p_mq_AWADDRchn(p_mq_AWADDRchn);\n  MemoryController->p_mq_BRESPchn(p_mq_BRESPchn);\n  MemoryController->p_mq_RDATAchn(p_mq_RDATAchn);\n  MemoryController->p_mq_WDATAchn(p_mq_WDATAchn);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target::~cfm_target(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target destructor' algorithm generated code\n\n  // End of 'Target destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  for (vector<cfm_memory *>::const_iterator vi = Memory_vec.begin();\n       vi != Memory_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete MemoryController;\n  // deconstructor for vector relation\n  for (vector<mq_DDRCommand_t *>::const_iterator vi = mq_DDRCommand_vec.begin();\n       vi != mq_DDRCommand_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_DQs_t *>::const_iterator vi = mq_DQs_vec.begin();\n       vi != mq_DQs_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_target::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_target::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Device', 'type': 'cofluent:Function', 'models': [{'name': 'ReceiveWACK', 'type': 'cofluent:Function'}, {'name': 'ReceiverRData', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Sender']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Sender']}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['ReceiveWACK']}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['ReceiverRData']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Sender']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_DEVICE\n#define COFS_MODEL_DDRMEMORY_DEVICE\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_receiverrdata.h\"\n#include \"cfm_receivewack.h\"\n#include \"cfm_sender.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_device_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Device includes' algorithm generated code\n\n// End of 'Device includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDevice Function Device\n//@{\n///        \\page dxpDevice\n//@{\n///    \\brief Device function model start\nclass cfm_device : public cf_core::cf_function_container,\n                   public cfm_device_dp_if {\npublic:\n  /// cfm_device type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_device, cfm_defaraddrchn>\n      p_mq_ARADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_device, cfm_defawaddrchn>\n      p_mq_AWADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_device, cfm_defbrespchn>\n      p_mq_BRESPin_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_device, cfm_defrdatachn>\n      p_mq_RDATAin_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_device, cfm_defwdatachn>\n      p_mq_WDATAchn_t;\n  /// cfm_device type define end\n\n  /// constructor\n  cfm_device(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_device(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_ARADDRchn_t p_mq_ARADDRchn;\n  p_mq_AWADDRchn_t p_mq_AWADDRchn;\n  p_mq_BRESPin_t p_mq_BRESPin;\n  p_mq_RDATAin_t p_mq_RDATAin;\n  p_mq_WDATAchn_t p_mq_WDATAchn;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_receivewack *ReceiveWACK;\n  cfm_receiverrdata *ReceiverRData;\n  cfm_sender *Sender;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Device local declarations' algorithm generated code\n\n  // End of 'Device local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Device function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_DEVICE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Device', 'type': 'cofluent:Function', 'models': [{'name': 'ReceiveWACK', 'type': 'cofluent:Function'}, {'name': 'ReceiverRData', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn', 'connectTo': ['Sender']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn', 'connectTo': ['Sender']}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn', 'connectTo': ['ReceiveWACK']}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn', 'connectTo': ['ReceiverRData']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn', 'connectTo': ['Sender']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_device\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_device.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_clientside\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_device\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Device definitions' algorithm generated code\n\n// End of 'Device definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_device ::cfm_device()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_device_dp_if(),\n      p_mq_ARADDRchn(\"p_mq_ARADDRchn\"), p_mq_AWADDRchn(\"p_mq_AWADDRchn\"),\n      p_mq_BRESPin(\"p_mq_BRESPin\"), p_mq_RDATAin(\"p_mq_RDATAin\"),\n      p_mq_WDATAchn(\"p_mq_WDATAchn\") {\n  cf_function_container::init();\n  // instantiation of models\n  ReceiveWACK = new cfm_receivewack(\"ReceiveWACK\");\n  ReceiverRData = new cfm_receiverrdata(\"ReceiverRData\");\n  Sender = new cfm_sender(\"Sender\");\n  // connections\n  // model connect to port\n  ReceiveWACK->p_mq_BRESPin(p_mq_BRESPin);\n  // model connect to port\n  ReceiverRData->p_mq_RDATAin(p_mq_RDATAin);\n  // model connect to port\n  Sender->p_mq_ARADDRchn(p_mq_ARADDRchn);\n  Sender->p_mq_AWADDRchn(p_mq_AWADDRchn);\n  Sender->p_mq_WDATAchn(p_mq_WDATAchn);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_device::~cfm_device(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Device destructor' algorithm generated code\n\n  // End of 'Device destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete ReceiveWACK;\n  delete ReceiverRData;\n  delete Sender;\n}\n\n//@{\nvoid cfm_device::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_device::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WRDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_wrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WRDMUX\n#define COFS_MODEL_DDRMEMORY_WRDMUX\n\n/// Model Header includes start\n#include \"behavior/cf_function_router.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_wrdmux_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WRDmux includes' algorithm generated code\n\n// End of 'WRDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWRDmux Function WRDmux\n//@{\n///        \\page dxpWRDmux\n//@{\n///    \\brief WRDmux function model start\nclass cfm_wrdmux : public cf_core::cf_function_router, public cfm_wrdmux_dp_if {\npublic:\n  /// cfm_wrdmux type define start\n\n  /// constructor\n  cfm_wrdmux(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_wrdmux(void);\n\npublic:\n  /// \\name input/output ports\n\npublic:\n  /// Overload function for WRDmux router destination method\n  std::string cb_select_destination_name(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WRDmux local declarations' algorithm generated code\n\n  // End of 'WRDmux local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief WRDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WRDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}, {'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_wrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_wrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WRDmux definitions' algorithm generated code\n\n// End of 'WRDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_wrdmux ::cfm_wrdmux()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_router(name), cfm_wrdmux_dp_if() {\n  cf_function_router::init();\n  // connections\n  cf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_wrdmux::~cfm_wrdmux(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WRDmux destructor' algorithm generated code\n\n  // End of 'WRDmux destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_wrdmux::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_wrdmux::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RDDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rddmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RDDMUX\n#define COFS_MODEL_DDRMEMORY_RDDMUX\n\n/// Model Header includes start\n#include \"behavior/cf_function_router.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rddmux_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RDDmux includes' algorithm generated code\n\n// End of 'RDDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRDDmux Function RDDmux\n//@{\n///        \\page dxpRDDmux\n//@{\n///    \\brief RDDmux function model start\nclass cfm_rddmux : public cf_core::cf_function_router, public cfm_rddmux_dp_if {\npublic:\n  /// cfm_rddmux type define start\n\n  /// constructor\n  cfm_rddmux(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_rddmux(void);\n\npublic:\n  /// \\name input/output ports\n\npublic:\n  /// Overload function for RDDmux router destination method\n  std::string cb_select_destination_name(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RDDmux local declarations' algorithm generated code\n\n  // End of 'RDDmux local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief RDDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RDDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RDDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}, {'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rddmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rddmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RDDmux definitions' algorithm generated code\n\n// End of 'RDDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rddmux ::cfm_rddmux()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_router(name), cfm_rddmux_dp_if() {\n  cf_function_router::init();\n  // connections\n  cf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rddmux::~cfm_rddmux(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RDDmux destructor' algorithm generated code\n\n  // End of 'RDDmux destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_rddmux::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_rddmux::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MemoryController', 'type': 'cofluent:Function', 'models': [{'name': 'BackEnd', 'type': 'cofluent:Function'}, {'name': 'FrontEnd', 'type': 'cofluent:Function', 'vector': '0, P_Nbr'}, {'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['FrontEnd']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['BackEnd']}, {'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['BackEnd']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['FrontEnd']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux']}], 'relations': [{'name': 'ARADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux', 'FrontEnd']}, {'name': 'AWADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux', 'FrontEnd']}, {'name': 'DataRead', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefDataRead', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemReadRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemReadRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemWriteRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemWriteRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'WDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux', 'FrontEnd']}, {'name': 'WriteAck', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWriteAck', 'connectTo': ['FrontEnd', 'BackEnd']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memorycontroller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n#define COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n\n/// Model Header includes start\n#include \"cfm_backend.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_frontend.h\"\n#include \"cfm_raddrdmux.h\"\n#include \"cfm_waddrdmux.h\"\n#include \"cfm_wdatadmux.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memorycontroller_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MemoryController includes' algorithm generated code\n\n// End of 'MemoryController includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemoryController Function MemoryController\n//@{\n///        \\page dxpMemoryController\n//@{\n///    \\brief MemoryController function model start\nclass cfm_memorycontroller : public cf_core::cf_function_container,\n                             public cfm_memorycontroller_dp_if {\npublic:\n  /// cfm_memorycontroller type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defaraddrchn> mq_ARADDRin_t;\n  typedef cf_core::cf_message_queue<cft_defawaddrchn> mq_AWADDRin_t;\n  typedef cf_core::cf_message_queue<cft_defdataread> mq_DataRead_t;\n  typedef cf_core::cf_message_queue<cft_defmemreadrequest> mq_MemReadRequest_t;\n  typedef cf_core::cf_message_queue<cft_defmemwriterequest>\n      mq_MemWriteRequest_t;\n  typedef cf_core::cf_message_queue<cft_defwdatachn> mq_WDATAin_t;\n  typedef cf_core::cf_message_queue<cft_defwriteack> mq_WriteAck_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n                                          cfm_defaraddrchn>\n      p_mq_ARADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n                                          cfm_defawaddrchn>\n      p_mq_AWADDRchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cfm_defbrespchn>\n      p_mq_BRESPchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller,\n                                          cfm_defddrcommand>\n      p_mq_DDRCommand_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cfm_defdqs>\n      p_mq_DQs_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cfm_defrdatachn>\n      p_mq_RDATAchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_memorycontroller, cfm_defwdatachn>\n      p_mq_WDATAchn_t;\n  /// cfm_memorycontroller type define end\n\n  /// constructor\n  cfm_memorycontroller(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_memorycontroller(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_ARADDRchn_t p_mq_ARADDRchn;\n  p_mq_AWADDRchn_t p_mq_AWADDRchn;\n  p_mq_BRESPchn_t p_mq_BRESPchn;\n  p_mq_DDRCommand_t p_mq_DDRCommand;\n  p_mq_DQs_t p_mq_DQs;\n  p_mq_RDATAchn_t p_mq_RDATAchn;\n  p_mq_WDATAchn_t p_mq_WDATAchn;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_backend *BackEnd;\n  std::vector<cfm_frontend *> FrontEnd_vec;\n  cfm_raddrdmux *RAddrDmux;\n  cfm_waddrdmux *WAddrDmux;\n  cfm_wdatadmux *WdataDmux;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_ARADDRin_t *> mq_ARADDRin_vec;\n  std::vector<mq_AWADDRin_t *> mq_AWADDRin_vec;\n  std::vector<mq_DataRead_t *> mq_DataRead_vec;\n  mq_MemReadRequest_t mq_MemReadRequest;\n  mq_MemWriteRequest_t mq_MemWriteRequest;\n  std::vector<mq_WDATAin_t *> mq_WDATAin_vec;\n  std::vector<mq_WriteAck_t *> mq_WriteAck_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MemoryController local declarations' algorithm generated code\n\n  // End of 'MemoryController local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief MemoryController function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORYCONTROLLER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MemoryController', 'type': 'cofluent:Function', 'models': [{'name': 'BackEnd', 'type': 'cofluent:Function'}, {'name': 'FrontEnd', 'type': 'cofluent:Function', 'vector': '0, P_Nbr'}, {'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction'}, {'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux']}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['FrontEnd']}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['BackEnd']}, {'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['BackEnd']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['FrontEnd']}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux']}], 'relations': [{'name': 'ARADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefARADDRchn', 'connectTo': ['RAddrDmux', 'FrontEnd']}, {'name': 'AWADDRin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefAWADDRchn', 'connectTo': ['WAddrDmux', 'FrontEnd']}, {'name': 'DataRead', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefDataRead', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemReadRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemReadRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'MemWriteRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMemWriteRequest', 'connectTo': ['FrontEnd', 'BackEnd']}, {'name': 'WDATAin', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWDATAchn', 'connectTo': ['WdataDmux', 'FrontEnd']}, {'name': 'WriteAck', 'type': 'cofluent:MessageQueue', 'vector': '0, P_Nbr', 'dataType': 'DefWriteAck', 'connectTo': ['FrontEnd', 'BackEnd']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memorycontroller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memorycontroller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_target\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memorycontroller\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MemoryController definitions' algorithm generated code\n\n// End of 'MemoryController definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memorycontroller ::cfm_memorycontroller()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_memorycontroller_dp_if(),\n      mq_ARADDRin(\"ARADDRin\"), mq_AWADDRin(\"AWADDRin\"), mq_DataRead(\"DataRead\"),\n      mq_MemReadRequest(\"MemReadRequest\"),\n      mq_MemWriteRequest(\"MemWriteRequest\"), mq_WDATAin(\"WDATAin\"),\n      mq_WriteAck(\"WriteAck\"), p_mq_ARADDRchn(\"p_mq_ARADDRchn\"),\n      p_mq_AWADDRchn(\"p_mq_AWADDRchn\"), p_mq_BRESPchn(\"p_mq_BRESPchn\"),\n      p_mq_DDRCommand(\"p_mq_DDRCommand\"), p_mq_DQs(\"p_mq_DQs\"),\n      p_mq_RDATAchn(\"p_mq_RDATAchn\"), p_mq_WDATAchn(\"p_mq_WDATAchn\") {\n  cf_function_container::init();\n  // instantiation of models\n  BackEnd = new cfm_backend(\"BackEnd\");\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    cfm_frontend *module =\n        new cfm_frontend(cf_string(\"FrontEnd[%d]\", i).c_str());\n    CF_ASSERT(module)\n    FrontEnd_vec.push_back(module);\n  }\n  RAddrDmux = new cfm_raddrdmux(\"RAddrDmux\");\n  WAddrDmux = new cfm_waddrdmux(\"WAddrDmux\");\n  WdataDmux = new cfm_wdatadmux(\"WdataDmux\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    mq_ARADDRin_t *module =\n        new mq_ARADDRin_t(cf_string(\"ARADDRin[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_ARADDRin_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    mq_AWADDRin_t *module =\n        new mq_AWADDRin_t(cf_string(\"AWADDRin[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_AWADDRin_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    mq_DataRead_t *module =\n        new mq_DataRead_t(cf_string(\"DataRead[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_DataRead_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    mq_WDATAin_t *module =\n        new mq_WDATAin_t(cf_string(\"WDATAin[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_WDATAin_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    mq_WriteAck_t *module =\n        new mq_WriteAck_t(cf_string(\"WriteAck[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_WriteAck_vec.push_back(module);\n  }\n  // connections\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    BackEnd->p_mq_DataRead(mq_DataRead_vec[i]->p_target_socket);\n  }\n  BackEnd->p_mq_MemReadRequest(mq_MemReadRequest.p_target_socket);\n  BackEnd->p_mq_MemWriteRequest(mq_MemWriteRequest.p_target_socket);\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    BackEnd->p_mq_WriteAck(mq_WriteAck_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  BackEnd->p_mq_DDRCommand(p_mq_DDRCommand);\n  BackEnd->p_mq_DQs(p_mq_DQs);\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    cfm_frontend *module = FrontEnd_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n        module->p_mq_ARADDRin(mq_ARADDRin_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n        module->p_mq_AWADDRin(mq_AWADDRin_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n        module->p_mq_DataRead(mq_DataRead_vec[j]->p_target_socket);\n      }\n      module->p_mq_MemReadRequest(mq_MemReadRequest.p_target_socket);\n      module->p_mq_MemWriteRequest(mq_MemReadRequest.p_target_socket);\n      for (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n        module->p_mq_WDATAin(mq_WDATAin_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(P_Nbr + 1); j++) {\n        module->p_mq_WriteAck(mq_WriteAck_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_BRESPchn(p_mq_BRESPchn);\n      module->p_mq_RDATAchn(p_mq_RDATAchn);\n    }\n  }\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    RAddrDmux->p_mq_ARADDRin(mq_ARADDRin_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  RAddrDmux->p_mq_ARADDRchn(p_mq_ARADDRchn);\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    WAddrDmux->p_mq_AWADDRin(mq_AWADDRin_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  WAddrDmux->p_mq_AWADDRchn(p_mq_AWADDRchn);\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(P_Nbr + 1); i++) {\n    WdataDmux->p_mq_WDATAin(mq_WDATAin_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  WdataDmux->p_mq_WDATAchn(p_mq_WDATAchn);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memorycontroller::~cfm_memorycontroller(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MemoryController destructor' algorithm generated code\n\n  // End of 'MemoryController destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete BackEnd;\n  for (vector<cfm_frontend *>::const_iterator vi = FrontEnd_vec.begin();\n       vi != FrontEnd_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete RAddrDmux;\n  delete WAddrDmux;\n  delete WdataDmux;\n  // deconstructor for vector relation\n  for (vector<mq_ARADDRin_t *>::const_iterator vi = mq_ARADDRin_vec.begin();\n       vi != mq_ARADDRin_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_AWADDRin_t *>::const_iterator vi = mq_AWADDRin_vec.begin();\n       vi != mq_AWADDRin_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_DataRead_t *>::const_iterator vi = mq_DataRead_vec.begin();\n       vi != mq_DataRead_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_WDATAin_t *>::const_iterator vi = mq_WDATAin_vec.begin();\n       vi != mq_WDATAin_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_WriteAck_t *>::const_iterator vi = mq_WriteAck_vec.begin();\n       vi != mq_WriteAck_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_memorycontroller::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_memorycontroller::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Memory', 'type': 'cofluent:Function', 'models': [{'name': 'BankDmuxer', 'type': 'cofluent:Function'}, {'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'vector': '0, NbBanksperMemory'}], 'ports': [{'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand', 'connectTo': ['BankDmuxer']}, {'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs', 'connectTo': ['MemoryCommandExecution']}], 'relations': [{'name': 'DDRAction', 'type': 'cofluent:MessageQueue', 'vector': '0, NbBanksperMemory', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryCommandExecution', 'BankDmuxer']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORY\n#define COFS_MODEL_DDRMEMORY_MEMORY\n\n/// Model Header includes start\n#include \"cfm_bankdmuxer.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_memorycommandexecution.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memory_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defdqs.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Memory includes' algorithm generated code\n\n// End of 'Memory includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemory Function Memory\n//@{\n///        \\page dxpMemory\n//@{\n///    \\brief Memory function model start\nclass cfm_memory : public cf_core::cf_function_container,\n                   public cfm_memory_dp_if {\npublic:\n  /// cfm_memory type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defddrcommand> mq_DDRAction_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_memory, cfm_defddrcommand>\n      p_mq_DDRCommand_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_memory, cfm_defdqs> p_mq_DQs_t;\n  /// cfm_memory type define end\n\n  /// constructor\n  cfm_memory(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_memory(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_DDRCommand_t p_mq_DDRCommand;\n  p_mq_DQs_t p_mq_DQs;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_bankdmuxer *BankDmuxer;\n  std::vector<cfm_memorycommandexecution *> MemoryCommandExecution_vec;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_DDRAction_t *> mq_DDRAction_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Memory local declarations' algorithm generated code\n\n  // End of 'Memory local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Memory function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORY\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Memory', 'type': 'cofluent:Function', 'models': [{'name': 'BankDmuxer', 'type': 'cofluent:Function'}, {'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'vector': '0, NbBanksperMemory'}], 'ports': [{'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand', 'connectTo': ['BankDmuxer']}, {'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs', 'connectTo': ['MemoryCommandExecution']}], 'relations': [{'name': 'DDRAction', 'type': 'cofluent:MessageQueue', 'vector': '0, NbBanksperMemory', 'dataType': 'DefDDRCommand', 'connectTo': ['MemoryCommandExecution', 'BankDmuxer']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memory\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memory.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_target\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memory\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Memory definitions' algorithm generated code\n\n// End of 'Memory definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memory ::cfm_memory()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_memory_dp_if(),\n      mq_DDRAction(\"DDRAction\"), p_mq_DDRCommand(\"p_mq_DDRCommand\"),\n      p_mq_DQs(\"p_mq_DQs\") {\n  cf_function_container::init();\n  // instantiation of models\n  BankDmuxer = new cfm_bankdmuxer(\"BankDmuxer\");\n  for (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n    cfm_memorycommandexecution *module = new cfm_memorycommandexecution(\n        cf_string(\"MemoryCommandExecution[%d]\", i).c_str());\n    CF_ASSERT(module)\n    MemoryCommandExecution_vec.push_back(module);\n  }\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n    mq_DDRAction_t *module =\n        new mq_DDRAction_t(cf_string(\"DDRAction[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_DDRAction_vec.push_back(module);\n  }\n  // connections\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n    BankDmuxer->p_mq_DDRAction(mq_DDRAction_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  BankDmuxer->p_mq_DDRCommand(p_mq_DDRCommand);\n  for (cf_count i = 0; i < (cf_count)(NbBanksperMemory + 1); i++) {\n    cfm_memorycommandexecution *module = MemoryCommandExecution_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(NbBanksperMemory + 1); j++) {\n        module->p_mq_DDRAction(mq_DDRAction_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_DQs(p_mq_DQs);\n    }\n  }\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memory::~cfm_memory(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Memory destructor' algorithm generated code\n\n  // End of 'Memory destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete BankDmuxer;\n  for (vector<cfm_memorycommandexecution *>::const_iterator vi =\n           MemoryCommandExecution_vec.begin();\n       vi != MemoryCommandExecution_vec.end(); vi++) {\n    delete (*vi);\n  }\n  // deconstructor for vector relation\n  for (vector<mq_DDRAction_t *>::const_iterator vi = mq_DDRAction_vec.begin();\n       vi != mq_DDRAction_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_memory::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_memory::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_SENDER\n#define COFS_MODEL_DDRMEMORY_SENDER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Sender includes' algorithm generated code\n\n// End of 'Sender includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSender Function Sender\n//@{\n///        \\page dxpSender\n//@{\n///    \\brief Sender function model start\nclass cfm_sender : public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n  /// cfm_sender type define start\n\n  /// constructor\n  cfm_sender(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_sender(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Sender local declarations' algorithm generated code\n\n  // End of 'Sender local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Sender function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_SENDER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Sender definitions' algorithm generated code\n\n// End of 'Sender definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sender ::cfm_sender()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_sender_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sender::~cfm_sender(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Sender destructor' algorithm generated code\n\n  // End of 'Sender destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_sender::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_sender::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReceiverRData', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receiverrdata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n#define COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiverrdata_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReceiverRData includes' algorithm generated code\n\n// End of 'ReceiverRData includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiverRData Function ReceiverRData\n//@{\n///        \\page dxpReceiverRData\n//@{\n///    \\brief ReceiverRData function model start\nclass cfm_receiverrdata : public cf_core::cf_function,\n                          public cfm_receiverrdata_dp_if {\npublic:\n  /// cfm_receiverrdata type define start\n\n  /// constructor\n  cfm_receiverrdata(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_receiverrdata(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReceiverRData local declarations' algorithm generated code\n\n  // End of 'ReceiverRData local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ReceiverRData function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RECEIVERRDATA\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReceiverRData', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receiverrdata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receiverrdata.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiverrdata\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReceiverRData definitions' algorithm generated code\n\n// End of 'ReceiverRData definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receiverrdata ::cfm_receiverrdata()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_receiverrdata_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receiverrdata::~cfm_receiverrdata(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReceiverRData destructor' algorithm generated code\n\n  // End of 'ReceiverRData destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_receiverrdata::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_receiverrdata::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReceiveWACK', 'type': 'cofluent:Function', 'ports': [{'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receivewack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RECEIVEWACK\n#define COFS_MODEL_DDRMEMORY_RECEIVEWACK\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receivewack_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbrespchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReceiveWACK includes' algorithm generated code\n\n// End of 'ReceiveWACK includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiveWACK Function ReceiveWACK\n//@{\n///        \\page dxpReceiveWACK\n//@{\n///    \\brief ReceiveWACK function model start\nclass cfm_receivewack : public cf_core::cf_function,\n                        public cfm_receivewack_dp_if {\npublic:\n  /// cfm_receivewack type define start\n\n  /// constructor\n  cfm_receivewack(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_receivewack(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReceiveWACK local declarations' algorithm generated code\n\n  // End of 'ReceiveWACK local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ReceiveWACK function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RECEIVEWACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReceiveWACK', 'type': 'cofluent:Function', 'ports': [{'name': 'BRESPin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receivewack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receivewack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_device\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receivewack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReceiveWACK definitions' algorithm generated code\n\n// End of 'ReceiveWACK definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receivewack ::cfm_receivewack()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_receivewack_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receivewack::~cfm_receivewack(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReceiveWACK destructor' algorithm generated code\n\n  // End of 'ReceiveWACK destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_receivewack::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_receivewack::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_waddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WADDRDMUX\n#define COFS_MODEL_DDRMEMORY_WADDRDMUX\n\n/// Model Header includes start\n#include \"behavior/cf_function_router.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_waddrdmux_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defawaddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WAddrDmux includes' algorithm generated code\n\n// End of 'WAddrDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWAddrDmux Function WAddrDmux\n//@{\n///        \\page dxpWAddrDmux\n//@{\n///    \\brief WAddrDmux function model start\nclass cfm_waddrdmux : public cf_core::cf_function_router,\n                      public cfm_waddrdmux_dp_if {\npublic:\n  /// cfm_waddrdmux type define start\n\n  /// constructor\n  cfm_waddrdmux(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_waddrdmux(void);\n\npublic:\n  /// \\name input/output ports\n\npublic:\n  /// Overload function for WAddrDmux router destination method\n  std::string cb_select_destination_name(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WAddrDmux local declarations' algorithm generated code\n\n  // End of 'WAddrDmux local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief WAddrDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WADDRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAWADDRchn'}, {'name': 'AWADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_waddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_waddrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WAddrDmux definitions' algorithm generated code\n\n// End of 'WAddrDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_waddrdmux ::cfm_waddrdmux()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_router(name), cfm_waddrdmux_dp_if() {\n  cf_function_router::init();\n  // connections\n  cf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_waddrdmux::~cfm_waddrdmux(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WAddrDmux destructor' algorithm generated code\n\n  // End of 'WAddrDmux destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_waddrdmux::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_waddrdmux::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_wdatadmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WDATADMUX\n#define COFS_MODEL_DDRMEMORY_WDATADMUX\n\n/// Model Header includes start\n#include \"behavior/cf_function_router.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_wdatadmux_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WdataDmux includes' algorithm generated code\n\n// End of 'WdataDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWdataDmux Function WdataDmux\n//@{\n///        \\page dxpWdataDmux\n//@{\n///    \\brief WdataDmux function model start\nclass cfm_wdatadmux : public cf_core::cf_function_router,\n                      public cfm_wdatadmux_dp_if {\npublic:\n  /// cfm_wdatadmux type define start\n\n  /// constructor\n  cfm_wdatadmux(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_wdatadmux(void);\n\npublic:\n  /// \\name input/output ports\n\npublic:\n  /// Overload function for WdataDmux router destination method\n  std::string cb_select_destination_name(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WdataDmux local declarations' algorithm generated code\n\n  // End of 'WdataDmux local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief WdataDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WDATADMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WdataDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWDATAchn'}, {'name': 'WDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_wdatadmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_wdatadmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WdataDmux definitions' algorithm generated code\n\n// End of 'WdataDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_wdatadmux ::cfm_wdatadmux()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_router(name), cfm_wdatadmux_dp_if() {\n  cf_function_router::init();\n  // connections\n  cf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_wdatadmux::~cfm_wdatadmux(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WdataDmux destructor' algorithm generated code\n\n  // End of 'WdataDmux destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_wdatadmux::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_wdatadmux::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_raddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RADDRDMUX\n#define COFS_MODEL_DDRMEMORY_RADDRDMUX\n\n/// Model Header includes start\n#include \"behavior/cf_function_router.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_raddrdmux_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RAddrDmux includes' algorithm generated code\n\n// End of 'RAddrDmux includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRAddrDmux Function RAddrDmux\n//@{\n///        \\page dxpRAddrDmux\n//@{\n///    \\brief RAddrDmux function model start\nclass cfm_raddrdmux : public cf_core::cf_function_router,\n                      public cfm_raddrdmux_dp_if {\npublic:\n  /// cfm_raddrdmux type define start\n\n  /// constructor\n  cfm_raddrdmux(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_raddrdmux(void);\n\npublic:\n  /// \\name input/output ports\n\npublic:\n  /// Overload function for RAddrDmux router destination method\n  std::string cb_select_destination_name(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RAddrDmux local declarations' algorithm generated code\n\n  // End of 'RAddrDmux local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief RAddrDmux function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RADDRDMUX\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RAddrDmux', 'type': 'cofluent:RoutingFunction', 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefARADDRchn'}, {'name': 'ARADDRchn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_raddrdmux\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_raddrdmux.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RAddrDmux definitions' algorithm generated code\n\n// End of 'RAddrDmux definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_raddrdmux ::cfm_raddrdmux()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_router(name), cfm_raddrdmux_dp_if() {\n  cf_function_router::init();\n  // connections\n  cf_function_router::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_raddrdmux::~cfm_raddrdmux(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RAddrDmux destructor' algorithm generated code\n\n  // End of 'RAddrDmux destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_raddrdmux::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_raddrdmux::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'FrontEnd', 'type': 'cofluent:Function', 'models': [{'name': 'ReadDataDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDriver', 'type': 'cofluent:Function'}, {'name': 'SendWAckDriver', 'type': 'cofluent:Function'}, {'name': 'WriteDriver', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['ReadDriver']}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WriteDriver']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['SendWAckDriver']}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead', 'connectTo': ['ReadDataDriver']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest', 'connectTo': ['ReadDriver']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest', 'connectTo': ['WriteDriver']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['ReadDataDriver']}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WriteDriver']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck', 'connectTo': ['SendWAckDriver']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_frontend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_FRONTEND\n#define COFS_MODEL_DDRMEMORY_FRONTEND\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_readdatadriver.h\"\n#include \"cfm_readdriver.h\"\n#include \"cfm_sendwackdriver.h\"\n#include \"cfm_writedriver.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_frontend_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defrdatachn.h\"\n#include \"dt/cft_defwdatachn.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'FrontEnd includes' algorithm generated code\n\n// End of 'FrontEnd includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgFrontEnd Function FrontEnd\n//@{\n///        \\page dxpFrontEnd\n//@{\n///    \\brief FrontEnd function model start\nclass cfm_frontend : public cf_core::cf_function_container,\n                     public cfm_frontend_dp_if {\npublic:\n  /// cfm_frontend type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defaraddrchn>\n      p_mq_ARADDRin_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defawaddrchn>\n      p_mq_AWADDRin_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defbrespchn>\n      p_mq_BRESPchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defdataread>\n      p_mq_DataRead_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defmemreadrequest>\n      p_mq_MemReadRequest_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defmemwriterequest>\n      p_mq_MemWriteRequest_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defrdatachn>\n      p_mq_RDATAchn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defwdatachn>\n      p_mq_WDATAin_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_frontend, cfm_defwriteack>\n      p_mq_WriteAck_t;\n  /// cfm_frontend type define end\n\n  /// constructor\n  cfm_frontend(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_frontend(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_ARADDRin_t p_mq_ARADDRin;\n  p_mq_AWADDRin_t p_mq_AWADDRin;\n  p_mq_BRESPchn_t p_mq_BRESPchn;\n  p_mq_DataRead_t p_mq_DataRead;\n  p_mq_MemReadRequest_t p_mq_MemReadRequest;\n  p_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n  p_mq_RDATAchn_t p_mq_RDATAchn;\n  p_mq_WDATAin_t p_mq_WDATAin;\n  p_mq_WriteAck_t p_mq_WriteAck;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_readdatadriver *ReadDataDriver;\n  cfm_readdriver *ReadDriver;\n  cfm_sendwackdriver *SendWAckDriver;\n  cfm_writedriver *WriteDriver;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'FrontEnd local declarations' algorithm generated code\n\n  // End of 'FrontEnd local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief FrontEnd function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_FRONTEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'FrontEnd', 'type': 'cofluent:Function', 'models': [{'name': 'ReadDataDriver', 'type': 'cofluent:Function'}, {'name': 'ReadDriver', 'type': 'cofluent:Function'}, {'name': 'SendWAckDriver', 'type': 'cofluent:Function'}, {'name': 'WriteDriver', 'type': 'cofluent:Function'}], 'ports': [{'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn', 'connectTo': ['ReadDriver']}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn', 'connectTo': ['WriteDriver']}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn', 'connectTo': ['SendWAckDriver']}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead', 'connectTo': ['ReadDataDriver']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest', 'connectTo': ['ReadDriver']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest', 'connectTo': ['WriteDriver']}, {'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn', 'connectTo': ['ReadDataDriver']}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn', 'connectTo': ['WriteDriver']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck', 'connectTo': ['SendWAckDriver']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_frontend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_frontend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memorycontroller\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_frontend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'FrontEnd definitions' algorithm generated code\n\n// End of 'FrontEnd definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_frontend ::cfm_frontend()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_frontend_dp_if(),\n      p_mq_ARADDRin(\"p_mq_ARADDRin\"), p_mq_AWADDRin(\"p_mq_AWADDRin\"),\n      p_mq_BRESPchn(\"p_mq_BRESPchn\"), p_mq_DataRead(\"p_mq_DataRead\"),\n      p_mq_MemReadRequest(\"p_mq_MemReadRequest\"),\n      p_mq_MemWriteRequest(\"p_mq_MemWriteRequest\"),\n      p_mq_RDATAchn(\"p_mq_RDATAchn\"), p_mq_WDATAin(\"p_mq_WDATAin\"),\n      p_mq_WriteAck(\"p_mq_WriteAck\") {\n  cf_function_container::init();\n  // instantiation of models\n  ReadDataDriver = new cfm_readdatadriver(\"ReadDataDriver\");\n  ReadDriver = new cfm_readdriver(\"ReadDriver\");\n  SendWAckDriver = new cfm_sendwackdriver(\"SendWAckDriver\");\n  WriteDriver = new cfm_writedriver(\"WriteDriver\");\n  // connections\n  // model connect to port\n  ReadDataDriver->p_mq_DataRead(p_mq_DataRead);\n  ReadDataDriver->p_mq_RDATAchn(p_mq_RDATAchn);\n  // model connect to port\n  ReadDriver->p_mq_ARADDRin(p_mq_ARADDRin);\n  ReadDriver->p_mq_MemReadRequest(p_mq_MemReadRequest);\n  // model connect to port\n  SendWAckDriver->p_mq_BRESPchn(p_mq_BRESPchn);\n  SendWAckDriver->p_mq_WriteAck(p_mq_WriteAck);\n  // model connect to port\n  WriteDriver->p_mq_AWADDRin(p_mq_AWADDRin);\n  WriteDriver->p_mq_MemWriteRequest(p_mq_MemWriteRequest);\n  WriteDriver->p_mq_WDATAin(p_mq_WDATAin);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_frontend::~cfm_frontend(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'FrontEnd destructor' algorithm generated code\n\n  // End of 'FrontEnd destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete ReadDataDriver;\n  delete ReadDriver;\n  delete SendWAckDriver;\n  delete WriteDriver;\n}\n\n//@{\nvoid cfm_frontend::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_frontend::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BackEnd', 'type': 'cofluent:Function', 'models': [{'name': 'Arbitration', 'type': 'cofluent:Function'}, {'name': 'CollectRequests', 'type': 'cofluent:Function'}, {'name': 'DDRCommandGeneration', 'type': 'cofluent:Function'}, {'name': 'ResponseForward', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['DDRCommandGeneration']}, {'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['ResponseForward']}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead', 'connectTo': ['ResponseForward']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest', 'connectTo': ['CollectRequests']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest', 'connectTo': ['CollectRequests']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck', 'connectTo': ['ResponseForward', 'Arbitration']}], 'relations': [{'name': 'ListRequestsPtr', 'type': 'cofluent:SharedVariable', 'dataType': 'DefListRequestsPtr', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'MemoryStatus', 'type': 'cofluent:SharedVariable', 'vector': '0, M_Nbr', 'dataType': 'DefMemoryStatus', 'connectTo': ['DDRCommandGeneration']}, {'name': 'RequestCounter', 'type': 'cofluent:Event', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'RequestInformation', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequestInformation', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'Requests2Memory', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequests2Memory', 'connectTo': ['Arbitration', 'DDRCommandGeneration']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_backend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_BACKEND\n#define COFS_MODEL_DDRMEMORY_BACKEND\n\n/// Model Header includes start\n#include \"cfm_arbitration.h\"\n#include \"cfm_collectrequests.h\"\n#include \"cfm_ddrcommandgeneration.h\"\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cfm_responseforward.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_backend_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defmemorystatus.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_defrequests2memory.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BackEnd includes' algorithm generated code\n\n// End of 'BackEnd includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBackEnd Function BackEnd\n//@{\n///        \\page dxpBackEnd\n//@{\n///    \\brief BackEnd function model start\nclass cfm_backend : public cf_core::cf_function_container,\n                    public cfm_backend_dp_if {\npublic:\n  /// cfm_backend type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_RequestCounter_t;\n  typedef cf_core::cf_message_queue<cft_defrequestinformation>\n      mq_RequestInformation_t;\n  typedef cf_core::cf_message_queue<cft_defrequests2memory>\n      mq_Requests2Memory_t;\n  typedef cf_core::cf_shared_variable<cft_deflistrequestsptr>\n      sv_ListRequestsPtr_t;\n  typedef cf_core::cf_shared_variable<cft_defmemorystatus> sv_MemoryStatus_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_backend, cfm_defddrcommand>\n      p_mq_DDRCommand_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_backend, cfm_defdqs> p_mq_DQs_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_backend, cfm_defdataread>\n      p_mq_DataRead_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_backend, cfm_defmemreadrequest>\n      p_mq_MemReadRequest_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_backend, cfm_defmemwriterequest>\n      p_mq_MemWriteRequest_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_backend, cfm_defwriteack>\n      p_mq_WriteAck_t;\n  /// cfm_backend type define end\n\n  /// constructor\n  cfm_backend(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_backend(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_DDRCommand_t p_mq_DDRCommand;\n  p_mq_DQs_t p_mq_DQs;\n  p_mq_DataRead_t p_mq_DataRead;\n  p_mq_MemReadRequest_t p_mq_MemReadRequest;\n  p_mq_MemWriteRequest_t p_mq_MemWriteRequest;\n  p_mq_WriteAck_t p_mq_WriteAck;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_arbitration *Arbitration;\n  cfm_collectrequests *CollectRequests;\n  cfm_ddrcommandgeneration *DDRCommandGeneration;\n  cfm_responseforward *ResponseForward;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_RequestCounter_t ev_RequestCounter;\n  mq_RequestInformation_t mq_RequestInformation;\n  mq_Requests2Memory_t mq_Requests2Memory;\n  sv_ListRequestsPtr_t sv_ListRequestsPtr;\n  std::vector<sv_MemoryStatus_t *> sv_MemoryStatus_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BackEnd local declarations' algorithm generated code\n\n  // End of 'BackEnd local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BackEnd function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_BACKEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BackEnd', 'type': 'cofluent:Function', 'models': [{'name': 'Arbitration', 'type': 'cofluent:Function'}, {'name': 'CollectRequests', 'type': 'cofluent:Function'}, {'name': 'DDRCommandGeneration', 'type': 'cofluent:Function'}, {'name': 'ResponseForward', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand', 'connectTo': ['DDRCommandGeneration']}, {'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs', 'connectTo': ['ResponseForward']}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead', 'connectTo': ['ResponseForward']}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest', 'connectTo': ['CollectRequests']}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest', 'connectTo': ['CollectRequests']}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck', 'connectTo': ['ResponseForward', 'Arbitration']}], 'relations': [{'name': 'ListRequestsPtr', 'type': 'cofluent:SharedVariable', 'dataType': 'DefListRequestsPtr', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'MemoryStatus', 'type': 'cofluent:SharedVariable', 'vector': '0, M_Nbr', 'dataType': 'DefMemoryStatus', 'connectTo': ['DDRCommandGeneration']}, {'name': 'RequestCounter', 'type': 'cofluent:Event', 'connectTo': ['CollectRequests', 'Arbitration']}, {'name': 'RequestInformation', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequestInformation', 'connectTo': ['ResponseForward', 'Arbitration']}, {'name': 'Requests2Memory', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRequests2Memory', 'connectTo': ['Arbitration', 'DDRCommandGeneration']}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_backend\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_backend.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memorycontroller\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_backend\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BackEnd definitions' algorithm generated code\n\n// End of 'BackEnd definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_backend ::cfm_backend()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_backend_dp_if(),\n      ev_RequestCounter(\"RequestCounter\"),\n      mq_RequestInformation(\"RequestInformation\"),\n      mq_Requests2Memory(\"Requests2Memory\"), p_mq_DDRCommand(\"p_mq_DDRCommand\"),\n      p_mq_DQs(\"p_mq_DQs\"), p_mq_DataRead(\"p_mq_DataRead\"),\n      p_mq_MemReadRequest(\"p_mq_MemReadRequest\"),\n      p_mq_MemWriteRequest(\"p_mq_MemWriteRequest\"),\n      p_mq_WriteAck(\"p_mq_WriteAck\"), sv_ListRequestsPtr(\"ListRequestsPtr\"),\n      sv_MemoryStatus(\"MemoryStatus\") {\n  cf_function_container::init();\n  // instantiation of models\n  Arbitration = new cfm_arbitration(\"Arbitration\");\n  CollectRequests = new cfm_collectrequests(\"CollectRequests\");\n  DDRCommandGeneration = new cfm_ddrcommandgeneration(\"DDRCommandGeneration\");\n  ResponseForward = new cfm_responseforward(\"ResponseForward\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    sv_MemoryStatus_t *module =\n        new sv_MemoryStatus_t(cf_string(\"MemoryStatus[%d]\", i).c_str());\n    CF_ASSERT(module)\n    sv_MemoryStatus_vec.push_back(module);\n  }\n  // connections\n  // model connect to relation\n  Arbitration->p_sv_ListRequestsPtr(sv_ListRequestsPtr.p_target_socket);\n  Arbitration->p_ev_RequestCounter(ev_RequestCounter.p_target_socket);\n  Arbitration->p_mq_RequestInformation(mq_RequestInformation.p_target_socket);\n  Arbitration->p_mq_Requests2Memory(mq_Requests2Memory.p_target_socket);\n  // model connect to port\n  Arbitration->p_mq_WriteAck(p_mq_WriteAck);\n  // model connect to relation\n  CollectRequests->p_sv_ListRequestsPtr(sv_ListRequestsPtr.p_target_socket);\n  CollectRequests->p_ev_RequestCounter(ev_RequestCounter.p_target_socket);\n  // model connect to port\n  CollectRequests->p_mq_MemReadRequest(p_mq_MemReadRequest);\n  CollectRequests->p_mq_MemWriteRequest(p_mq_MemWriteRequest);\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(M_Nbr + 1); i++) {\n    DDRCommandGeneration->p_sv_MemoryStatus(\n        sv_MemoryStatus_vec[i]->p_target_socket);\n  }\n  DDRCommandGeneration->p_mq_Requests2Memory(\n      mq_Requests2Memory.p_target_socket);\n  // model connect to port\n  DDRCommandGeneration->p_mq_DDRCommand(p_mq_DDRCommand);\n  // model connect to relation\n  ResponseForward->p_mq_RequestInformation(\n      mq_RequestInformation.p_target_socket);\n  // model connect to port\n  ResponseForward->p_mq_DQs(p_mq_DQs);\n  ResponseForward->p_mq_DataRead(p_mq_DataRead);\n  ResponseForward->p_mq_WriteAck(p_mq_WriteAck);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_backend::~cfm_backend(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BackEnd destructor' algorithm generated code\n\n  // End of 'BackEnd destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Arbitration;\n  delete CollectRequests;\n  delete DDRCommandGeneration;\n  delete ResponseForward;\n  // deconstructor for vector relation\n  for (vector<sv_MemoryStatus_t *>::const_iterator vi =\n           sv_MemoryStatus_vec.begin();\n       vi != sv_MemoryStatus_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_backend::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_backend::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_memorycommandexecution\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n#define COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_memorycommandexecution_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defdqs.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MemoryCommandExecution includes' algorithm generated code\n\n// End of 'MemoryCommandExecution includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMemoryCommandExecution Function MemoryCommandExecution\n//@{\n///        \\page dxpMemoryCommandExecution\n//@{\n///    \\brief MemoryCommandExecution function model start\nclass cfm_memorycommandexecution : public cf_core::cf_function,\n                                   public cfm_memorycommandexecution_dp_if {\npublic:\n  /// cfm_memorycommandexecution type define start\n\n  /// constructor\n  cfm_memorycommandexecution(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_memorycommandexecution(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MemoryCommandExecution local declarations' algorithm generated\n  // code\n\n  // End of 'MemoryCommandExecution local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief MemoryCommandExecution function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_MEMORYCOMMANDEXECUTION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MemoryCommandExecution', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDQs'}, {'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_memorycommandexecution\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_memorycommandexecution.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_memorycommandexecution\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MemoryCommandExecution definitions' algorithm generated code\n\n// End of 'MemoryCommandExecution definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_memorycommandexecution ::cfm_memorycommandexecution()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_memorycommandexecution_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_memorycommandexecution::~cfm_memorycommandexecution(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MemoryCommandExecution destructor' algorithm generated code\n\n  // End of 'MemoryCommandExecution destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_memorycommandexecution::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_memorycommandexecution::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BankDmuxer', 'type': 'cofluent:Function', 'ports': [{'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bankdmuxer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_BANKDMUXER\n#define COFS_MODEL_DDRMEMORY_BANKDMUXER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bankdmuxer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defddrcommand.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BankDmuxer includes' algorithm generated code\n\n// End of 'BankDmuxer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBankDmuxer Function BankDmuxer\n//@{\n///        \\page dxpBankDmuxer\n//@{\n///    \\brief BankDmuxer function model start\nclass cfm_bankdmuxer : public cf_core::cf_function,\n                       public cfm_bankdmuxer_dp_if {\npublic:\n  /// cfm_bankdmuxer type define start\n\n  /// constructor\n  cfm_bankdmuxer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_bankdmuxer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BankDmuxer local declarations' algorithm generated code\n\n  // End of 'BankDmuxer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BankDmuxer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_BANKDMUXER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BankDmuxer', 'type': 'cofluent:Function', 'ports': [{'name': 'DDRAction', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bankdmuxer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bankdmuxer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_memory\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bankdmuxer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BankDmuxer definitions' algorithm generated code\n\n// End of 'BankDmuxer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bankdmuxer ::cfm_bankdmuxer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_bankdmuxer_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bankdmuxer::~cfm_bankdmuxer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BankDmuxer destructor' algorithm generated code\n\n  // End of 'BankDmuxer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_bankdmuxer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_bankdmuxer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'WriteDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_writedriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_WRITEDRIVER\n#define COFS_MODEL_DDRMEMORY_WRITEDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_writedriver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defawaddrchn.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n#include \"dt/cft_defwdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WriteDriver includes' algorithm generated code\n\n// End of 'WriteDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWriteDriver Function WriteDriver\n//@{\n///        \\page dxpWriteDriver\n//@{\n///    \\brief WriteDriver function model start\nclass cfm_writedriver : public cf_core::cf_function,\n                        public cfm_writedriver_dp_if {\npublic:\n  /// cfm_writedriver type define start\n\n  /// constructor\n  cfm_writedriver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_writedriver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WriteDriver local declarations' algorithm generated code\n\n  // End of 'WriteDriver local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief WriteDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_WRITEDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'WriteDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemWriteRequest'}, {'name': 'WDATAin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWDATAchn'}, {'name': 'AWADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAWADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_writedriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_writedriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writedriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'WriteDriver definitions' algorithm generated code\n\n// End of 'WriteDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_writedriver ::cfm_writedriver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_writedriver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_writedriver::~cfm_writedriver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'WriteDriver destructor' algorithm generated code\n\n  // End of 'WriteDriver destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_writedriver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_writedriver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReadDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_readdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_READDRIVER\n#define COFS_MODEL_DDRMEMORY_READDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_readdriver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defaraddrchn.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReadDriver includes' algorithm generated code\n\n// End of 'ReadDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReadDriver Function ReadDriver\n//@{\n///        \\page dxpReadDriver\n//@{\n///    \\brief ReadDriver function model start\nclass cfm_readdriver : public cf_core::cf_function,\n                       public cfm_readdriver_dp_if {\npublic:\n  /// cfm_readdriver type define start\n\n  /// constructor\n  cfm_readdriver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_readdriver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReadDriver local declarations' algorithm generated code\n\n  // End of 'ReadDriver local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ReadDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_READDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReadDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMemReadRequest'}, {'name': 'ARADDRin', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefARADDRchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_readdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_readdriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_readdriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReadDriver definitions' algorithm generated code\n\n// End of 'ReadDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_readdriver ::cfm_readdriver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_readdriver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_readdriver::~cfm_readdriver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReadDriver destructor' algorithm generated code\n\n  // End of 'ReadDriver destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_readdriver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_readdriver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'SendWAckDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sendwackdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n#define COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sendwackdriver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbrespchn.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'SendWAckDriver includes' algorithm generated code\n\n// End of 'SendWAckDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSendWAckDriver Function SendWAckDriver\n//@{\n///        \\page dxpSendWAckDriver\n//@{\n///    \\brief SendWAckDriver function model start\nclass cfm_sendwackdriver : public cf_core::cf_function,\n                           public cfm_sendwackdriver_dp_if {\npublic:\n  /// cfm_sendwackdriver type define start\n\n  /// constructor\n  cfm_sendwackdriver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_sendwackdriver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'SendWAckDriver local declarations' algorithm generated code\n\n  // End of 'SendWAckDriver local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief SendWAckDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_SENDWACKDRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'SendWAckDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefWriteAck'}, {'name': 'BRESPchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBRESPchn'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sendwackdriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sendwackdriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sendwackdriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'SendWAckDriver definitions' algorithm generated code\n\n// End of 'SendWAckDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sendwackdriver ::cfm_sendwackdriver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_sendwackdriver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sendwackdriver::~cfm_sendwackdriver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'SendWAckDriver destructor' algorithm generated code\n\n  // End of 'SendWAckDriver destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_sendwackdriver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_sendwackdriver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ReadDataDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_readdatadriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_READDATADRIVER\n#define COFS_MODEL_DDRMEMORY_READDATADRIVER\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_readdatadriver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defrdatachn.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReadDataDriver includes' algorithm generated code\n\n// End of 'ReadDataDriver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReadDataDriver Function ReadDataDriver\n//@{\n///        \\page dxpReadDataDriver\n//@{\n///    \\brief ReadDataDriver function model start\nclass cfm_readdatadriver : public cf_core::cf_function,\n                           public cfm_readdatadriver_dp_if {\npublic:\n  /// cfm_readdatadriver type define start\n\n  /// constructor\n  cfm_readdatadriver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_readdatadriver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReadDataDriver local declarations' algorithm generated code\n\n  // End of 'ReadDataDriver local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ReadDataDriver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_READDATADRIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ReadDataDriver', 'type': 'cofluent:Function', 'ports': [{'name': 'RDATAchn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRDATAchn'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataRead'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_readdatadriver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_readdatadriver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_frontend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_readdatadriver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ReadDataDriver definitions' algorithm generated code\n\n// End of 'ReadDataDriver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_readdatadriver ::cfm_readdatadriver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_readdatadriver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_readdatadriver::~cfm_readdatadriver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ReadDataDriver destructor' algorithm generated code\n\n  // End of 'ReadDataDriver destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_readdatadriver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_readdatadriver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CollectRequests', 'type': 'cofluent:Function', 'ports': [{'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_collectrequests\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n#define COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_collectrequests_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defmemreadrequest.h\"\n#include \"dt/cft_defmemwriterequest.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CollectRequests includes' algorithm generated code\n\n// End of 'CollectRequests includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCollectRequests Function CollectRequests\n//@{\n///        \\page dxpCollectRequests\n//@{\n///    \\brief CollectRequests function model start\nclass cfm_collectrequests : public cf_core::cf_function,\n                            public cfm_collectrequests_dp_if {\npublic:\n  /// cfm_collectrequests type define start\n\n  /// constructor\n  cfm_collectrequests(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_collectrequests(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CollectRequests local declarations' algorithm generated code\n\n  // End of 'CollectRequests local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CollectRequests function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_COLLECTREQUESTS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CollectRequests', 'type': 'cofluent:Function', 'ports': [{'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'MemReadRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemReadRequest'}, {'name': 'MemWriteRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMemWriteRequest'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_collectrequests\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_collectrequests.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_collectrequests\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CollectRequests definitions' algorithm generated code\n\n// End of 'CollectRequests definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_collectrequests ::cfm_collectrequests()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_collectrequests_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_collectrequests::~cfm_collectrequests(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CollectRequests destructor' algorithm generated code\n\n  // End of 'CollectRequests destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_collectrequests::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_collectrequests::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ResponseForward', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequestInformation'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_responseforward\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n#define COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_responseforward_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdataread.h\"\n#include \"dt/cft_defdqs.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ResponseForward includes' algorithm generated code\n\n// End of 'ResponseForward includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgResponseForward Function ResponseForward\n//@{\n///        \\page dxpResponseForward\n//@{\n///    \\brief ResponseForward function model start\nclass cfm_responseforward : public cf_core::cf_function,\n                            public cfm_responseforward_dp_if {\npublic:\n  /// cfm_responseforward type define start\n\n  /// constructor\n  cfm_responseforward(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_responseforward(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ResponseForward local declarations' algorithm generated code\n\n  // End of 'ResponseForward local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ResponseForward function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_RESPONSEFORWARD\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ResponseForward', 'type': 'cofluent:Function', 'ports': [{'name': 'DQs', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDQs'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequestInformation'}, {'name': 'DataRead', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataRead'}, {'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_responseforward\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_responseforward.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_responseforward\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ResponseForward definitions' algorithm generated code\n\n// End of 'ResponseForward definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_responseforward ::cfm_responseforward()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_responseforward_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_responseforward::~cfm_responseforward(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ResponseForward destructor' algorithm generated code\n\n  // End of 'ResponseForward destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_responseforward::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_responseforward::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Arbitration', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequestInformation'}, {'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequests2Memory'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_arbitration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_ARBITRATION\n#define COFS_MODEL_DDRMEMORY_ARBITRATION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_arbitration_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_deflistrequestsptr.h\"\n#include \"dt/cft_defrequestinformation.h\"\n#include \"dt/cft_defrequests2memory.h\"\n#include \"dt/cft_defwriteack.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Arbitration includes' algorithm generated code\n\n// End of 'Arbitration includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgArbitration Function Arbitration\n//@{\n///        \\page dxpArbitration\n//@{\n///    \\brief Arbitration function model start\nclass cfm_arbitration : public cf_core::cf_function,\n                        public cfm_arbitration_dp_if {\npublic:\n  /// cfm_arbitration type define start\n\n  /// constructor\n  cfm_arbitration(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_arbitration(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Arbitration local declarations' algorithm generated code\n\n  // End of 'Arbitration local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Arbitration function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_ARBITRATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Arbitration', 'type': 'cofluent:Function', 'ports': [{'name': 'WriteAck', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefWriteAck'}, {'name': 'RequestInformation', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequestInformation'}, {'name': 'ListRequestsPtr', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefListRequestsPtr'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRequests2Memory'}, {'name': 'RequestCounter', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_arbitration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_arbitration.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_arbitration\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Arbitration definitions' algorithm generated code\n\n// End of 'Arbitration definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_arbitration ::cfm_arbitration()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_arbitration_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_arbitration::~cfm_arbitration(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Arbitration destructor' algorithm generated code\n\n  // End of 'Arbitration destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_arbitration::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_arbitration::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DDRCommandGeneration', 'type': 'cofluent:Function', 'ports': [{'name': 'MemoryStatus', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefMemoryStatus'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequests2Memory'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ddrcommandgeneration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n#define COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n\n/// Model Header includes start\n#include \"cfm_ddrmemory_global.h\"\n#include \"cfm_ddrmemory_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ddrcommandgeneration_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defddrcommand.h\"\n#include \"dt/cft_defmemorystatus.h\"\n#include \"dt/cft_defrequests2memory.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'DDRCommandGeneration includes' algorithm generated code\n\n// End of 'DDRCommandGeneration includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDDRCommandGeneration Function DDRCommandGeneration\n//@{\n///        \\page dxpDDRCommandGeneration\n//@{\n///    \\brief DDRCommandGeneration function model start\nclass cfm_ddrcommandgeneration : public cf_core::cf_function,\n                                 public cfm_ddrcommandgeneration_dp_if {\npublic:\n  /// cfm_ddrcommandgeneration type define start\n\n  /// constructor\n  cfm_ddrcommandgeneration(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_ddrcommandgeneration(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'DDRCommandGeneration local declarations' algorithm generated code\n\n  // End of 'DDRCommandGeneration local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief DDRCommandGeneration function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DDRMEMORY_DDRCOMMANDGENERATION\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DDRCommandGeneration', 'type': 'cofluent:Function', 'ports': [{'name': 'MemoryStatus', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefMemoryStatus'}, {'name': 'Requests2Memory', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRequests2Memory'}, {'name': 'DDRCommand', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDDRCommand'}], 'globalName': 'DDRMemory'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ddrcommandgeneration\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of DDRMemory generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ddrcommandgeneration.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_backend\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ddrcommandgeneration\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'DDRCommandGeneration definitions' algorithm generated code\n\n// End of 'DDRCommandGeneration definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ddrcommandgeneration ::cfm_ddrcommandgeneration()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_ddrcommandgeneration_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ddrcommandgeneration::~cfm_ddrcommandgeneration(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'DDRCommandGeneration destructor' algorithm generated code\n\n  // End of 'DDRCommandGeneration destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_ddrcommandgeneration::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_ddrcommandgeneration::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example3App', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'OS', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inheritance_example3app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cfm_os.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n#include <vector>\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inheritance_example3App includes' algorithm generated code\n\n// End of 'Inheritance_example3App includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInheritance_example3App Function Inheritance_example3App\n//@{\n///        \\page dxpInheritance_example3App\n//@{\n///    \\brief Inheritance_example3App function model start\nclass cfm_inheritance_example3app : public cf_core::cf_application {\npublic:\n  /// cfm_inheritance_example3app type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n  /// cfm_inheritance_example3app type define end\n\n  /// constructor\n  cfm_inheritance_example3app(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inheritance_example3app(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  std::vector<cfm_consumer *> Consumer_vec;\n  cfm_os *OS;\n  std::vector<cfm_producer *> Producer_vec;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_MsgQ_t *> mq_MsgQ_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inheritance_example3App local declarations' algorithm generated\n  // code\n\n  // End of 'Inheritance_example3App local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Inheritance_example3App function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example3App', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'OS', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Consumer', 'Producer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inheritance_example3app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inheritance_example3app.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inheritance_example3App definitions' algorithm generated code\n\n// End of 'Inheritance_example3App definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inheritance_example3app ::cfm_inheritance_example3app()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQ(\"MsgQ\") {\n  cf_application::init();\n  // instantiation of models\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_consumer *module =\n        new cfm_consumer(cf_string(\"Consumer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Consumer_vec.push_back(module);\n  }\n  OS = new cfm_os(\"OS\");\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_producer *module =\n        new cfm_producer(cf_string(\"Producer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Producer_vec.push_back(module);\n  }\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    mq_MsgQ_t *module = new mq_MsgQ_t(cf_string(\"MsgQ[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQ_vec.push_back(module);\n  }\n  // connections\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_consumer *module = Consumer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(1 + 1); j++) {\n        module->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n      }\n    }\n  }\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_producer *module = Producer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(1 + 1); j++) {\n        module->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n      }\n    }\n  }\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inheritance_example3app::~cfm_inheritance_example3app(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inheritance_example3App destructor' algorithm generated code\n\n  // End of 'Inheritance_example3App destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  for (vector<cfm_consumer *>::const_iterator vi = Consumer_vec.begin();\n       vi != Consumer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete OS;\n  for (vector<cfm_producer *>::const_iterator vi = Producer_vec.begin();\n       vi != Producer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  // deconstructor for vector relation\n  for (vector<mq_MsgQ_t *>::const_iterator vi = mq_MsgQ_vec.begin();\n       vi != mq_MsgQ_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_inheritance_example3app::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inheritance_example3app::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OS', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_os\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n\n/// Model Header includes start\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OS includes' algorithm generated code\n#include \"user_processor_base_class.h\"\n// End of 'OS includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOS Function OS\n//@{\n///        \\page dxpOS\n//@{\n///    \\brief OS function model start\nclass cfm_os : public cf_core::cf_function {\npublic:\n  /// cfm_os type define start\n\n  /// cfm_os type define end\n\n  /// constructor\n  cfm_os(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_os(void);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OS local declarations' algorithm generated code\n\n  // End of 'OS local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OS function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_OS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OS', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_os\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_os.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_os\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OS definitions' algorithm generated code\n\n// End of 'OS definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_os ::cfm_os()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_os::~cfm_os(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OS destructor' algorithm generated code\n  delete sel_processor;\n  // End of 'OS destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_os::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_os::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n#define COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_inheritance_example3app_global.h\"\n#include \"cfm_inheritance_example3app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE3APP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'Inheritance_example3App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example3App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example3app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'datacenter', 'models': [{'name': 'DataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'ServerRoom', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}], 'relations': [{'name': 'MsgQToDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_datacenter\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER\n#define COFS_MODEL_DATACENTER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cfm_datacenterswitch.h\"\n#include \"cfm_serverroom.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_datacenter_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'datacenter includes' algorithm generated code\n#include <chrono>\n// End of 'datacenter includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgdatacenter Function datacenter\n//@{\n///        \\page dxpdatacenter\n//@{\n///    \\brief datacenter function model start\nclass cfm_datacenter : public cf_core::cf_application,\n                       public cfm_datacenter_dp_if {\npublic:\n  /// cfm_datacenter type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToDataCenterSwitch_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToServerRoom_t;\n\n  /// cfm_datacenter type define end\n\n  /// constructor\n  cfm_datacenter(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_datacenter(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_datacenterswitch *DataCenterSwitch;\n  std::vector<cfm_serverroom *> ServerRoom_vec;\n  //@}\n\npublic:\n  /// Overload function for mq_MsgQToDataCenterSwitch message queue send time\n  cf_dt::cf_duration\n  mq_MsgQToDataCenterSwitch_cb_send_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToDataCenterSwitch message queue receive time\n  cf_dt::cf_duration\n  mq_MsgQToDataCenterSwitch_cb_receive_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToServerRoom message queue send time\n  cf_dt::cf_duration\n  mq_MsgQToServerRoom_cb_send_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToServerRoom message queue receive time\n  cf_dt::cf_duration\n  mq_MsgQToServerRoom_cb_receive_time(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_MsgQToDataCenterSwitch_t *> mq_MsgQToDataCenterSwitch_vec;\n  std::vector<mq_MsgQToServerRoom_t *> mq_MsgQToServerRoom_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'datacenter local declarations' algorithm generated code\n\n  // End of 'datacenter local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief datacenter function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'datacenter', 'models': [{'name': 'DataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'ServerRoom', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}], 'relations': [{'name': 'MsgQToDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['ServerRoom', 'DataCenterSwitch']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_datacenter\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_datacenter.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'datacenter definitions' algorithm generated code\nvoid merge_and_sort_vector(std::vector<cf_dt::cf_time> &vect1,\n                           std::vector<cf_dt::cf_time> &vect2) {\n  vect1.insert(vect1.begin(), vect2.begin(), vect2.end());\n}\n// End of 'datacenter definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_datacenter ::cfm_datacenter()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), cfm_datacenter_dp_if(),\n      mq_MsgQToDataCenterSwitch(\"MsgQToDataCenterSwitch\"),\n      mq_MsgQToServerRoom(\"MsgQToServerRoom\") {\n  cf_application::init();\n  // instantiation of models\n  DataCenterSwitch = new cfm_datacenterswitch(\"DataCenterSwitch\");\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    cfm_serverroom *module =\n        new cfm_serverroom(cf_string(\"ServerRoom[%d]\", i).c_str());\n    CF_ASSERT(module)\n    ServerRoom_vec.push_back(module);\n  }\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    mq_MsgQToDataCenterSwitch_t *module = new mq_MsgQToDataCenterSwitch_t(\n        cf_string(\"MsgQToDataCenterSwitch[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQToDataCenterSwitch_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    mq_MsgQToServerRoom_t *module =\n        new mq_MsgQToServerRoom_t(cf_string(\"MsgQToServerRoom[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQToServerRoom_vec.push_back(module);\n  }\n  // connections\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    DataCenterSwitch->p_mq_MsgQToDataCenterSwitch(\n        mq_MsgQToDataCenterSwitch_vec[i]->p_target_socket);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    DataCenterSwitch->p_mq_MsgQToServerRoom(\n        mq_MsgQToServerRoom_vec[i]->p_target_socket);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    cfm_serverroom *module = ServerRoom_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n        module->p_mq_MsgQToDataCenterSwitch(\n            mq_MsgQToDataCenterSwitch_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n        module->p_mq_MsgQToServerRoom(\n            mq_MsgQToServerRoom_vec[j]->p_target_socket);\n      }\n    }\n  }\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_datacenter::~cfm_datacenter(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'datacenter destructor' algorithm generated code\n\n  // End of 'datacenter destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete DataCenterSwitch;\n  for (vector<cfm_serverroom *>::const_iterator vi = ServerRoom_vec.begin();\n       vi != ServerRoom_vec.end(); vi++) {\n    delete (*vi);\n  }\n  // deconstructor for vector relation\n  for (vector<mq_MsgQToDataCenterSwitch_t *>::const_iterator vi =\n           mq_MsgQToDataCenterSwitch_vec.begin();\n       vi != mq_MsgQToDataCenterSwitch_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_MsgQToServerRoom_t *>::const_iterator vi =\n           mq_MsgQToServerRoom_vec.begin();\n       vi != mq_MsgQToServerRoom_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_datacenter::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_datacenter::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ServerRoom', 'type': 'cofluent:Function', 'models': [{'name': 'AGGSwitch', 'type': 'cofluent:Function'}, {'name': 'Rack', 'type': 'cofluent:Function', 'vector': '0, dpRackNb'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}], 'relations': [{'name': 'MsgQToAggSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}, {'name': 'MsgQToRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_serverroom\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_SERVERROOM\n#define COFS_MODEL_DATACENTER_SERVERROOM\n\n/// Model Header includes start\n#include \"cfm_aggswitch.h\"\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cfm_rack.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_serverroom_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ServerRoom includes' algorithm generated code\n\n// End of 'ServerRoom includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgServerRoom Function ServerRoom\n//@{\n///        \\page dxpServerRoom\n//@{\n///    \\brief ServerRoom function model start\nclass cfm_serverroom : public cf_core::cf_function_container,\n                       public cfm_serverroom_dp_if {\npublic:\n  /// cfm_serverroom type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToAggSwitch_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToRack_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_serverroom, cfm_defpacket>\n      p_mq_MsgQToDataCenterSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_serverroom, cfm_defpacket>\n      p_mq_MsgQToServerRoom_t;\n  /// cfm_serverroom type define end\n\n  /// constructor\n  cfm_serverroom(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_serverroom(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n  p_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_aggswitch *AGGSwitch;\n  std::vector<cfm_rack *> Rack_vec;\n  //@}\n\npublic:\n  /// Overload function for mq_MsgQToAggSwitch message queue send time\n  cf_dt::cf_duration\n  mq_MsgQToAggSwitch_cb_send_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToAggSwitch message queue receive time\n  cf_dt::cf_duration\n  mq_MsgQToAggSwitch_cb_receive_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToRack message queue send time\n  cf_dt::cf_duration mq_MsgQToRack_cb_send_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToRack message queue receive time\n  cf_dt::cf_duration\n  mq_MsgQToRack_cb_receive_time(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_MsgQToAggSwitch_t *> mq_MsgQToAggSwitch_vec;\n  std::vector<mq_MsgQToRack_t *> mq_MsgQToRack_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ServerRoom local declarations' algorithm generated code\n\n  // End of 'ServerRoom local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ServerRoom function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_SERVERROOM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ServerRoom', 'type': 'cofluent:Function', 'models': [{'name': 'AGGSwitch', 'type': 'cofluent:Function'}, {'name': 'Rack', 'type': 'cofluent:Function', 'vector': '0, dpRackNb'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch']}], 'relations': [{'name': 'MsgQToAggSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}, {'name': 'MsgQToRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['AGGSwitch', 'Rack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_serverroom\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_serverroom.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenter\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_serverroom\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ServerRoom definitions' algorithm generated code\n\n// End of 'ServerRoom definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_serverroom ::cfm_serverroom()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_serverroom_dp_if(),\n      mq_MsgQToAggSwitch(\"MsgQToAggSwitch\"), mq_MsgQToRack(\"MsgQToRack\"),\n      p_mq_MsgQToDataCenterSwitch(\"p_mq_MsgQToDataCenterSwitch\"),\n      p_mq_MsgQToServerRoom(\"p_mq_MsgQToServerRoom\") {\n  cf_function_container::init();\n  // instantiation of models\n  AGGSwitch = new cfm_aggswitch(\"AGGSwitch\");\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    cfm_rack *module = new cfm_rack(cf_string(\"Rack[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Rack_vec.push_back(module);\n  }\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    mq_MsgQToAggSwitch_t *module =\n        new mq_MsgQToAggSwitch_t(cf_string(\"MsgQToAggSwitch[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQToAggSwitch_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    mq_MsgQToRack_t *module =\n        new mq_MsgQToRack_t(cf_string(\"MsgQToRack[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQToRack_vec.push_back(module);\n  }\n  // connections\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    AGGSwitch->p_mq_MsgQToAggSwitch(mq_MsgQToAggSwitch_vec[i]->p_target_socket);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    AGGSwitch->p_mq_MsgQToRack(mq_MsgQToRack_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  AGGSwitch->p_mq_MsgQToDataCenterSwitch(p_mq_MsgQToDataCenterSwitch);\n  AGGSwitch->p_mq_MsgQToServerRoom(p_mq_MsgQToServerRoom);\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    cfm_rack *module = Rack_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n        module->p_mq_MsgQToAggSwitch(\n            mq_MsgQToAggSwitch_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n        module->p_mq_MsgQToRack(mq_MsgQToRack_vec[j]->p_target_socket);\n      }\n    }\n  }\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_serverroom::~cfm_serverroom(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ServerRoom destructor' algorithm generated code\n\n  // End of 'ServerRoom destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete AGGSwitch;\n  for (vector<cfm_rack *>::const_iterator vi = Rack_vec.begin();\n       vi != Rack_vec.end(); vi++) {\n    delete (*vi);\n  }\n  // deconstructor for vector relation\n  for (vector<mq_MsgQToAggSwitch_t *>::const_iterator vi =\n           mq_MsgQToAggSwitch_vec.begin();\n       vi != mq_MsgQToAggSwitch_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_MsgQToRack_t *>::const_iterator vi = mq_MsgQToRack_vec.begin();\n       vi != mq_MsgQToRack_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_serverroom::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_serverroom::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'DataCenterSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'Inbound', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'Outbound', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Inbound']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Outbound']}], 'relations': [{'name': 'MsgQRouting_in', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Inbound', 'RoutingFunction']}, {'name': 'MsgQRouting_out', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Outbound', 'RoutingFunction']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_datacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_DATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_DATACENTERSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cfm_datacenterswitch_routingfunction.h\"\n#include \"cfm_inbound.h\"\n#include \"cfm_outbound.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_datacenterswitch_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'DataCenterSwitch includes' algorithm generated code\n\n// End of 'DataCenterSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgDataCenterSwitch Function DataCenterSwitch\n//@{\n///        \\page dxpDataCenterSwitch\n//@{\n///    \\brief DataCenterSwitch function model start\nclass cfm_datacenterswitch : public cf_core::cf_function_container,\n                             public cfm_datacenterswitch_dp_if {\npublic:\n  /// cfm_datacenterswitch type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQRouting_in_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQRouting_out_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_datacenterswitch, cfm_defpacket>\n      p_mq_MsgQToDataCenterSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_datacenterswitch, cfm_defpacket>\n      p_mq_MsgQToServerRoom_t;\n  /// cfm_datacenterswitch type define end\n\n  /// constructor\n  cfm_datacenterswitch(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_datacenterswitch(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n  p_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  std::vector<cfm_inbound *> Inbound_vec;\n  std::vector<cfm_outbound *> Outbound_vec;\n  cfm_datacenterswitch_routingfunction *RoutingFunction;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_MsgQRouting_in_t *> mq_MsgQRouting_in_vec;\n  std::vector<mq_MsgQRouting_out_t *> mq_MsgQRouting_out_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'DataCenterSwitch local declarations' algorithm generated code\n\n  // End of 'DataCenterSwitch local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief DataCenterSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_DATACENTERSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'DataCenterSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'Inbound', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'Outbound', 'type': 'cofluent:Function', 'vector': '0, dpServerRoomNb'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Inbound']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Outbound']}], 'relations': [{'name': 'MsgQRouting_in', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Inbound', 'RoutingFunction']}, {'name': 'MsgQRouting_out', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerRoomNb', 'dataType': 'DefPacket', 'connectTo': ['Outbound', 'RoutingFunction']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_datacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_datacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenter\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_datacenterswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'DataCenterSwitch definitions' algorithm generated code\n\n// End of 'DataCenterSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_datacenterswitch ::cfm_datacenterswitch()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_datacenterswitch_dp_if(),\n      mq_MsgQRouting_in(\"MsgQRouting_in\"),\n      mq_MsgQRouting_out(\"MsgQRouting_out\"),\n      p_mq_MsgQToDataCenterSwitch(\"p_mq_MsgQToDataCenterSwitch\"),\n      p_mq_MsgQToServerRoom(\"p_mq_MsgQToServerRoom\") {\n  cf_function_container::init();\n  // instantiation of models\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    cfm_inbound *module = new cfm_inbound(cf_string(\"Inbound[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Inbound_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    cfm_outbound *module =\n        new cfm_outbound(cf_string(\"Outbound[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Outbound_vec.push_back(module);\n  }\n  RoutingFunction = new cfm_routingfunction(\"RoutingFunction\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    mq_MsgQRouting_in_t *module =\n        new mq_MsgQRouting_in_t(cf_string(\"MsgQRouting_in[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQRouting_in_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    mq_MsgQRouting_out_t *module =\n        new mq_MsgQRouting_out_t(cf_string(\"MsgQRouting_out[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQRouting_out_vec.push_back(module);\n  }\n  // connections\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    cfm_inbound *module = Inbound_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n        module->p_mq_MsgQRouting_in(mq_MsgQRouting_in_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_MsgQToDataCenterSwitch(p_mq_MsgQToDataCenterSwitch);\n    }\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    cfm_outbound *module = Outbound_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpServerRoomNb + 1); j++) {\n        module->p_mq_MsgQRouting_out(\n            mq_MsgQRouting_out_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_MsgQToServerRoom(p_mq_MsgQToServerRoom);\n    }\n  }\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    RoutingFunction->p_mq_MsgQRouting_in(\n        mq_MsgQRouting_in_vec[i]->p_target_socket);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerRoomNb + 1); i++) {\n    RoutingFunction->p_mq_MsgQRouting_out(\n        mq_MsgQRouting_out_vec[i]->p_target_socket);\n  }\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_datacenterswitch::~cfm_datacenterswitch(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'DataCenterSwitch destructor' algorithm generated code\n\n  // End of 'DataCenterSwitch destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  for (vector<cfm_inbound *>::const_iterator vi = Inbound_vec.begin();\n       vi != Inbound_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<cfm_outbound *>::const_iterator vi = Outbound_vec.begin();\n       vi != Outbound_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete RoutingFunction;\n  // deconstructor for vector relation\n  for (vector<mq_MsgQRouting_in_t *>::const_iterator vi =\n           mq_MsgQRouting_in_vec.begin();\n       vi != mq_MsgQRouting_in_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_MsgQRouting_out_t *>::const_iterator vi =\n           mq_MsgQRouting_out_vec.begin();\n       vi != mq_MsgQRouting_out_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_datacenterswitch::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_datacenterswitch::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'AGGSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundRack', 'type': 'cofluent:Function', 'vector': '0, dpRackNb'}, {'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundRack', 'type': 'cofluent:Function', 'vector': '0, dpRackNb'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundRack']}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundDataCenterSwitch']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundRack']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundDataCenterSwitch']}], 'relations': [{'name': 'MsgQInboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundDataCenterSwitch']}, {'name': 'MsgQInboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundRack']}, {'name': 'MsgQOutboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundDataCenterSwitch']}, {'name': 'MsgQOutboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundRack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_aggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_AGGSWITCH\n#define COFS_MODEL_DATACENTER_AGGSWITCH\n\n/// Model Header includes start\n#include \"cfm_aggswitch_routingfunction.h\"\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cfm_inbounddatacenterswitch.h\"\n#include \"cfm_inboundrack.h\"\n#include \"cfm_outbounddatacenterswitch.h\"\n#include \"cfm_outboundrack.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_aggswitch_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'AGGSwitch includes' algorithm generated code\n\n// End of 'AGGSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgAGGSwitch Function AGGSwitch\n//@{\n///        \\page dxpAGGSwitch\n//@{\n///    \\brief AGGSwitch function model start\nclass cfm_aggswitch : public cf_core::cf_function_container,\n                      public cfm_aggswitch_dp_if {\npublic:\n  /// cfm_aggswitch type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defpacket>\n      mq_MsgQInboundDataCenterSwitch_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundRack_t;\n  typedef cf_core::cf_message_queue<cft_defpacket>\n      mq_MsgQOutboundDataCenterSwitch_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundRack_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cfm_defpacket>\n      p_mq_MsgQToAggSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cfm_defpacket>\n      p_mq_MsgQToDataCenterSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cfm_defpacket>\n      p_mq_MsgQToRack_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_aggswitch, cfm_defpacket>\n      p_mq_MsgQToServerRoom_t;\n  /// cfm_aggswitch type define end\n\n  /// constructor\n  cfm_aggswitch(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_aggswitch(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n  p_mq_MsgQToDataCenterSwitch_t p_mq_MsgQToDataCenterSwitch;\n  p_mq_MsgQToRack_t p_mq_MsgQToRack;\n  p_mq_MsgQToServerRoom_t p_mq_MsgQToServerRoom;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_inbounddatacenterswitch *InboundDataCenterSwitch;\n  std::vector<cfm_inboundrack *> InboundRack_vec;\n  cfm_outbounddatacenterswitch *OutboundDataCenterSwitch;\n  std::vector<cfm_outboundrack *> OutboundRack_vec;\n  cfm_aggswitch_routingfunction *RoutingFunction;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQInboundDataCenterSwitch_t mq_MsgQInboundDataCenterSwitch;\n  std::vector<mq_MsgQInboundRack_t *> mq_MsgQInboundRack_vec;\n  mq_MsgQOutboundDataCenterSwitch_t mq_MsgQOutboundDataCenterSwitch;\n  std::vector<mq_MsgQOutboundRack_t *> mq_MsgQOutboundRack_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'AGGSwitch local declarations' algorithm generated code\n\n  // End of 'AGGSwitch local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief AGGSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_AGGSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'AGGSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundRack', 'type': 'cofluent:Function', 'vector': '0, dpRackNb'}, {'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundRack', 'type': 'cofluent:Function', 'vector': '0, dpRackNb'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundRack']}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundDataCenterSwitch']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundRack']}, {'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundDataCenterSwitch']}], 'relations': [{'name': 'MsgQInboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundDataCenterSwitch']}, {'name': 'MsgQInboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundRack']}, {'name': 'MsgQOutboundDataCenterSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundDataCenterSwitch']}, {'name': 'MsgQOutboundRack', 'type': 'cofluent:MessageQueue', 'vector': '0, dpRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundRack']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_aggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_aggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_serverroom\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_aggswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'AGGSwitch definitions' algorithm generated code\n\n// End of 'AGGSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_aggswitch ::cfm_aggswitch()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_aggswitch_dp_if(),\n      mq_MsgQInboundDataCenterSwitch(\"MsgQInboundDataCenterSwitch\"),\n      mq_MsgQInboundRack(\"MsgQInboundRack\"),\n      mq_MsgQOutboundDataCenterSwitch(\"MsgQOutboundDataCenterSwitch\"),\n      mq_MsgQOutboundRack(\"MsgQOutboundRack\"),\n      p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\"),\n      p_mq_MsgQToDataCenterSwitch(\"p_mq_MsgQToDataCenterSwitch\"),\n      p_mq_MsgQToRack(\"p_mq_MsgQToRack\"),\n      p_mq_MsgQToServerRoom(\"p_mq_MsgQToServerRoom\") {\n  cf_function_container::init();\n  // instantiation of models\n  InboundDataCenterSwitch =\n      new cfm_inbounddatacenterswitch(\"InboundDataCenterSwitch\");\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    cfm_inboundrack *module =\n        new cfm_inboundrack(cf_string(\"InboundRack[%d]\", i).c_str());\n    CF_ASSERT(module)\n    InboundRack_vec.push_back(module);\n  }\n  OutboundDataCenterSwitch =\n      new cfm_outbounddatacenterswitch(\"OutboundDataCenterSwitch\");\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    cfm_outboundrack *module =\n        new cfm_outboundrack(cf_string(\"OutboundRack[%d]\", i).c_str());\n    CF_ASSERT(module)\n    OutboundRack_vec.push_back(module);\n  }\n  RoutingFunction = new cfm_routingfunction(\"RoutingFunction\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    mq_MsgQInboundRack_t *module =\n        new mq_MsgQInboundRack_t(cf_string(\"MsgQInboundRack[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQInboundRack_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    mq_MsgQOutboundRack_t *module =\n        new mq_MsgQOutboundRack_t(cf_string(\"MsgQOutboundRack[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQOutboundRack_vec.push_back(module);\n  }\n  // connections\n  // model connect to relation\n  InboundDataCenterSwitch->p_mq_MsgQInboundDataCenterSwitch(\n      mq_MsgQInboundDataCenterSwitch.p_target_socket);\n  // model connect to port\n  InboundDataCenterSwitch->p_mq_MsgQToServerRoom(p_mq_MsgQToServerRoom);\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    cfm_inboundrack *module = InboundRack_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n        module->p_mq_MsgQInboundRack(\n            mq_MsgQInboundRack_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_MsgQToAggSwitch(p_mq_MsgQToAggSwitch);\n    }\n  }\n  // model connect to relation\n  OutboundDataCenterSwitch->p_mq_MsgQOutboundDataCenterSwitch(\n      mq_MsgQOutboundDataCenterSwitch.p_target_socket);\n  // model connect to port\n  OutboundDataCenterSwitch->p_mq_MsgQToDataCenterSwitch(\n      p_mq_MsgQToDataCenterSwitch);\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    cfm_outboundrack *module = OutboundRack_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpRackNb + 1); j++) {\n        module->p_mq_MsgQOutboundRack(\n            mq_MsgQOutboundRack_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_MsgQToRack(p_mq_MsgQToRack);\n    }\n  }\n  // model connect to relation\n  RoutingFunction->p_mq_MsgQInboundDataCenterSwitch(\n      mq_MsgQInboundDataCenterSwitch.p_target_socket);\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    RoutingFunction->p_mq_MsgQInboundRack(\n        mq_MsgQInboundRack_vec[i]->p_target_socket);\n  }\n  RoutingFunction->p_mq_MsgQOutboundDataCenterSwitch(\n      mq_MsgQOutboundDataCenterSwitch.p_target_socket);\n  for (cf_count i = 0; i < (cf_count)(dpRackNb + 1); i++) {\n    RoutingFunction->p_mq_MsgQOutboundRack(\n        mq_MsgQOutboundRack_vec[i]->p_target_socket);\n  }\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_aggswitch::~cfm_aggswitch(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'AGGSwitch destructor' algorithm generated code\n\n  // End of 'AGGSwitch destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete InboundDataCenterSwitch;\n  for (vector<cfm_inboundrack *>::const_iterator vi = InboundRack_vec.begin();\n       vi != InboundRack_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete OutboundDataCenterSwitch;\n  for (vector<cfm_outboundrack *>::const_iterator vi = OutboundRack_vec.begin();\n       vi != OutboundRack_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete RoutingFunction;\n  // deconstructor for vector relation\n  for (vector<mq_MsgQInboundRack_t *>::const_iterator vi =\n           mq_MsgQInboundRack_vec.begin();\n       vi != mq_MsgQInboundRack_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_MsgQOutboundRack_t *>::const_iterator vi =\n           mq_MsgQOutboundRack_vec.begin();\n       vi != mq_MsgQOutboundRack_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_aggswitch::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_aggswitch::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Rack', 'type': 'cofluent:Function', 'models': [{'name': 'Server', 'type': 'cofluent:Function', 'vector': '0, dpServerPerRackNb'}, {'name': 'ToRSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}], 'relations': [{'name': 'MsgQServerToToRSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}, {'name': 'MsgQToServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_RACK\n#define COFS_MODEL_DATACENTER_RACK\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cfm_server.h\"\n#include \"cfm_torswitch.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rack_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Rack includes' algorithm generated code\n\n// End of 'Rack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRack Function Rack\n//@{\n///        \\page dxpRack\n//@{\n///    \\brief Rack function model start\nclass cfm_rack : public cf_core::cf_function_container, public cfm_rack_dp_if {\npublic:\n  /// cfm_rack type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQServerToToRSwitch_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQToServer_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_rack, cfm_defpacket>\n      p_mq_MsgQToAggSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_rack, cfm_defpacket>\n      p_mq_MsgQToRack_t;\n  /// cfm_rack type define end\n\n  /// constructor\n  cfm_rack(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_rack(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n  p_mq_MsgQToRack_t p_mq_MsgQToRack;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  std::vector<cfm_server *> Server_vec;\n  cfm_torswitch *ToRSwitch;\n  //@}\n\npublic:\n  /// Overload function for mq_MsgQServerToToRSwitch message queue receive time\n  cf_dt::cf_duration\n  mq_MsgQServerToToRSwitch_cb_receive_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToServer message queue send time\n  cf_dt::cf_duration\n  mq_MsgQToServer_cb_send_time(cf_core::cf_payload_b *_trans);\n  /// Overload function for mq_MsgQToServer message queue receive time\n  cf_dt::cf_duration\n  mq_MsgQToServer_cb_receive_time(cf_core::cf_payload_b *_trans);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_MsgQServerToToRSwitch_t *> mq_MsgQServerToToRSwitch_vec;\n  std::vector<mq_MsgQToServer_t *> mq_MsgQToServer_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Rack local declarations' algorithm generated code\n\n  // End of 'Rack local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Rack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_RACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Rack', 'type': 'cofluent:Function', 'models': [{'name': 'Server', 'type': 'cofluent:Function', 'vector': '0, dpServerPerRackNb'}, {'name': 'ToRSwitch', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['ToRSwitch']}], 'relations': [{'name': 'MsgQServerToToRSwitch', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}, {'name': 'MsgQToServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['Server', 'ToRSwitch']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_serverroom\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Rack definitions' algorithm generated code\n\n// End of 'Rack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rack ::cfm_rack()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_rack_dp_if(),\n      mq_MsgQServerToToRSwitch(\"MsgQServerToToRSwitch\"),\n      mq_MsgQToServer(\"MsgQToServer\"),\n      p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\"),\n      p_mq_MsgQToRack(\"p_mq_MsgQToRack\") {\n  cf_function_container::init();\n  // instantiation of models\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    cfm_server *module = new cfm_server(cf_string(\"Server[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Server_vec.push_back(module);\n  }\n  ToRSwitch = new cfm_torswitch(\"ToRSwitch\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    mq_MsgQServerToToRSwitch_t *module = new mq_MsgQServerToToRSwitch_t(\n        cf_string(\"MsgQServerToToRSwitch[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQServerToToRSwitch_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    mq_MsgQToServer_t *module =\n        new mq_MsgQToServer_t(cf_string(\"MsgQToServer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQToServer_vec.push_back(module);\n  }\n  // connections\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    cfm_server *module = Server_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n        module->p_mq_MsgQServerToToRSwitch(\n            mq_MsgQServerToToRSwitch_vec[j]->p_target_socket);\n      }\n      for (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n        module->p_mq_MsgQToServer(mq_MsgQToServer_vec[j]->p_target_socket);\n      }\n    }\n  }\n  // model connect to relation\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    ToRSwitch->p_mq_MsgQServerToToRSwitch(\n        mq_MsgQServerToToRSwitch_vec[i]->p_target_socket);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    ToRSwitch->p_mq_MsgQToServer(mq_MsgQToServer_vec[i]->p_target_socket);\n  }\n  // model connect to port\n  ToRSwitch->p_mq_MsgQToAggSwitch(p_mq_MsgQToAggSwitch);\n  ToRSwitch->p_mq_MsgQToRack(p_mq_MsgQToRack);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rack::~cfm_rack(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Rack destructor' algorithm generated code\n\n  // End of 'Rack destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  for (vector<cfm_server *>::const_iterator vi = Server_vec.begin();\n       vi != Server_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete ToRSwitch;\n  // deconstructor for vector relation\n  for (vector<mq_MsgQServerToToRSwitch_t *>::const_iterator vi =\n           mq_MsgQServerToToRSwitch_vec.begin();\n       vi != mq_MsgQServerToToRSwitch_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_MsgQToServer_t *>::const_iterator vi =\n           mq_MsgQToServer_vec.begin();\n       vi != mq_MsgQToServer_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_rack::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_rack::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQRouting_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUND\n#define COFS_MODEL_DATACENTER_INBOUND\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inbound_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inbound includes' algorithm generated code\n\n// End of 'Inbound includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInbound Function Inbound\n//@{\n///        \\page dxpInbound\n//@{\n///    \\brief Inbound function model start\nclass cfm_inbound : public cf_core::cf_function, public cfm_inbound_dp_if {\npublic:\n  /// cfm_inbound type define start\n\n  /// constructor\n  cfm_inbound(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inbound(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inbound local declarations' algorithm generated code\n\n  // End of 'Inbound local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Inbound function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQRouting_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inbound.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenterswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inbound\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inbound definitions' algorithm generated code\n\n// End of 'Inbound definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inbound ::cfm_inbound()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_inbound_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inbound::~cfm_inbound(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inbound destructor' algorithm generated code\n\n  // End of 'Inbound destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_inbound::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inbound::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Outbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQRouting_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUND\n#define COFS_MODEL_DATACENTER_OUTBOUND\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outbound_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Outbound includes' algorithm generated code\n\n// End of 'Outbound includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutbound Function Outbound\n//@{\n///        \\page dxpOutbound\n//@{\n///    \\brief Outbound function model start\nclass cfm_outbound : public cf_core::cf_function, public cfm_outbound_dp_if {\npublic:\n  /// cfm_outbound type define start\n\n  /// constructor\n  cfm_outbound(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_outbound(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Outbound local declarations' algorithm generated code\n\n  // End of 'Outbound local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Outbound function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Outbound', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQRouting_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outbound\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outbound.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_datacenterswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outbound\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Outbound definitions' algorithm generated code\n\n// End of 'Outbound definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outbound ::cfm_outbound()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_outbound_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outbound::~cfm_outbound(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Outbound destructor' algorithm generated code\n\n  // End of 'Outbound destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_outbound::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_outbound::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outbounddatacenterswitch_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundDataCenterSwitch includes' algorithm generated code\n\n// End of 'OutboundDataCenterSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundDataCenterSwitch Function OutboundDataCenterSwitch\n//@{\n///        \\page dxpOutboundDataCenterSwitch\n//@{\n///    \\brief OutboundDataCenterSwitch function model start\nclass cfm_outbounddatacenterswitch : public cf_core::cf_function,\n                                     public cfm_outbounddatacenterswitch_dp_if {\npublic:\n  /// cfm_outbounddatacenterswitch type define start\n\n  /// constructor\n  cfm_outbounddatacenterswitch(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_outbounddatacenterswitch(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundDataCenterSwitch local declarations' algorithm generated\n  // code\n\n  // End of 'OutboundDataCenterSwitch local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OutboundDataCenterSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDDATACENTERSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outbounddatacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outbounddatacenterswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundDataCenterSwitch definitions' algorithm generated code\n\n// End of 'OutboundDataCenterSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outbounddatacenterswitch ::cfm_outbounddatacenterswitch()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_outbounddatacenterswitch_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outbounddatacenterswitch::~cfm_outbounddatacenterswitch(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundDataCenterSwitch destructor' algorithm generated code\n\n  // End of 'OutboundDataCenterSwitch destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_outbounddatacenterswitch::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_outbounddatacenterswitch::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n#define COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inbounddatacenterswitch_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundDataCenterSwitch includes' algorithm generated code\n\n// End of 'InboundDataCenterSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundDataCenterSwitch Function InboundDataCenterSwitch\n//@{\n///        \\page dxpInboundDataCenterSwitch\n//@{\n///    \\brief InboundDataCenterSwitch function model start\nclass cfm_inbounddatacenterswitch : public cf_core::cf_function,\n                                    public cfm_inbounddatacenterswitch_dp_if {\npublic:\n  /// cfm_inbounddatacenterswitch type define start\n\n  /// constructor\n  cfm_inbounddatacenterswitch(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inbounddatacenterswitch(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundDataCenterSwitch local declarations' algorithm generated\n  // code\n\n  // End of 'InboundDataCenterSwitch local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief InboundDataCenterSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDDATACENTERSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundDataCenterSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServerRoom', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundDataCenterSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inbounddatacenterswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inbounddatacenterswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inbounddatacenterswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundDataCenterSwitch definitions' algorithm generated code\n\n// End of 'InboundDataCenterSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inbounddatacenterswitch ::cfm_inbounddatacenterswitch()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_inbounddatacenterswitch_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inbounddatacenterswitch::~cfm_inbounddatacenterswitch(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundDataCenterSwitch destructor' algorithm generated code\n\n  // End of 'InboundDataCenterSwitch destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_inbounddatacenterswitch::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inbounddatacenterswitch::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDRACK\n#define COFS_MODEL_DATACENTER_INBOUNDRACK\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundrack_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundRack includes' algorithm generated code\n\n// End of 'InboundRack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundRack Function InboundRack\n//@{\n///        \\page dxpInboundRack\n//@{\n///    \\brief InboundRack function model start\nclass cfm_inboundrack : public cf_core::cf_function,\n                        public cfm_inboundrack_dp_if {\npublic:\n  /// cfm_inboundrack type define start\n\n  /// constructor\n  cfm_inboundrack(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inboundrack(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundRack local declarations' algorithm generated code\n\n  // End of 'InboundRack local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief InboundRack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDRACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inboundrack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundrack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundRack definitions' algorithm generated code\n\n// End of 'InboundRack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inboundrack ::cfm_inboundrack()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_inboundrack_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inboundrack::~cfm_inboundrack(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundRack destructor' algorithm generated code\n\n  // End of 'InboundRack destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_inboundrack::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inboundrack::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDRACK\n#define COFS_MODEL_DATACENTER_OUTBOUNDRACK\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundrack_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundRack includes' algorithm generated code\n\n// End of 'OutboundRack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundRack Function OutboundRack\n//@{\n///        \\page dxpOutboundRack\n//@{\n///    \\brief OutboundRack function model start\nclass cfm_outboundrack : public cf_core::cf_function,\n                         public cfm_outboundrack_dp_if {\npublic:\n  /// cfm_outboundrack type define start\n\n  /// constructor\n  cfm_outboundrack(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_outboundrack(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundRack local declarations' algorithm generated code\n\n  // End of 'OutboundRack local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OutboundRack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDRACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundRack', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outboundrack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outboundrack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_aggswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundrack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundRack definitions' algorithm generated code\n\n// End of 'OutboundRack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outboundrack ::cfm_outboundrack()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_outboundrack_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outboundrack::~cfm_outboundrack(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundRack destructor' algorithm generated code\n\n  // End of 'OutboundRack destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_outboundrack::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_outboundrack::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Server', 'type': 'cofluent:Function', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Producer']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Consumer']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_server\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_SERVER\n#define COFS_MODEL_DATACENTER_SERVER\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_server_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Server includes' algorithm generated code\n\n// End of 'Server includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgServer Function Server\n//@{\n///        \\page dxpServer\n//@{\n///    \\brief Server function model start\nclass cfm_server : public cf_core::cf_function_container,\n                   public cfm_server_dp_if {\npublic:\n  /// cfm_server type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_server, cfm_defpacket>\n      p_mq_MsgQServerToToRSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_server, cfm_defpacket>\n      p_mq_MsgQToServer_t;\n  /// cfm_server type define end\n\n  /// constructor\n  cfm_server(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_server(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n  p_mq_MsgQToServer_t p_mq_MsgQToServer;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer *Consumer;\n  cfm_producer *Producer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Server local declarations' algorithm generated code\n\n  // End of 'Server local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Server function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_SERVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Server', 'type': 'cofluent:Function', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['Producer']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['Consumer']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_server\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_server.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_server\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Server definitions' algorithm generated code\n\n// End of 'Server definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_server ::cfm_server()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_server_dp_if(),\n      p_mq_MsgQServerToToRSwitch(\"p_mq_MsgQServerToToRSwitch\"),\n      p_mq_MsgQToServer(\"p_mq_MsgQToServer\") {\n  cf_function_container::init();\n  // instantiation of models\n  Consumer = new cfm_consumer(\"Consumer\");\n  Producer = new cfm_producer(\"Producer\");\n  // connections\n  // model connect to port\n  Consumer->p_mq_MsgQToServer(p_mq_MsgQToServer);\n  // model connect to port\n  Producer->p_mq_MsgQServerToToRSwitch(p_mq_MsgQServerToToRSwitch);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_server::~cfm_server(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Server destructor' algorithm generated code\n\n  // End of 'Server destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer;\n  delete Producer;\n}\n\n//@{\nvoid cfm_server::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_server::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ToRSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundServer', 'type': 'cofluent:Function', 'vector': '0, dpServerPerRackNb'}, {'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundServer', 'type': 'cofluent:Function', 'vector': '0, dpServerPerRackNb'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundServer']}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundAGGSwitch']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundAGGSwitch']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundServer']}], 'relations': [{'name': 'MsgQInboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundAGGSwitch']}, {'name': 'MsgQInboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['InboundServer', 'RoutingFunction']}, {'name': 'MsgQOutboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundAGGSwitch']}, {'name': 'MsgQOutboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundServer']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_torswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_TORSWITCH\n#define COFS_MODEL_DATACENTER_TORSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cfm_inboundaggswitch.h\"\n#include \"cfm_inboundserver.h\"\n#include \"cfm_outboundaggswitch.h\"\n#include \"cfm_outboundserver.h\"\n#include \"cfm_torswitch_routingfunction.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_torswitch_dp_if.h\"\n#include <vector>\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ToRSwitch includes' algorithm generated code\n\n// End of 'ToRSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgToRSwitch Function ToRSwitch\n//@{\n///        \\page dxpToRSwitch\n//@{\n///    \\brief ToRSwitch function model start\nclass cfm_torswitch : public cf_core::cf_function_container,\n                      public cfm_torswitch_dp_if {\npublic:\n  /// cfm_torswitch type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundAGGSwitch_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQInboundServer_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundAGGSwitch_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_MsgQOutboundServer_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cfm_defpacket>\n      p_mq_MsgQServerToToRSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cfm_defpacket>\n      p_mq_MsgQToAggSwitch_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cfm_defpacket>\n      p_mq_MsgQToRack_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_torswitch, cfm_defpacket>\n      p_mq_MsgQToServer_t;\n  /// cfm_torswitch type define end\n\n  /// constructor\n  cfm_torswitch(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_torswitch(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_MsgQServerToToRSwitch_t p_mq_MsgQServerToToRSwitch;\n  p_mq_MsgQToAggSwitch_t p_mq_MsgQToAggSwitch;\n  p_mq_MsgQToRack_t p_mq_MsgQToRack;\n  p_mq_MsgQToServer_t p_mq_MsgQToServer;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_inboundaggswitch *InboundAGGSwitch;\n  std::vector<cfm_inboundserver *> InboundServer_vec;\n  cfm_outboundaggswitch *OutboundAGGSwitch;\n  std::vector<cfm_outboundserver *> OutboundServer_vec;\n  cfm_torswitch_routingfunction *RoutingFunction;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQInboundAGGSwitch_t mq_MsgQInboundAGGSwitch;\n  std::vector<mq_MsgQInboundServer_t *> mq_MsgQInboundServer_vec;\n  mq_MsgQOutboundAGGSwitch_t mq_MsgQOutboundAGGSwitch;\n  std::vector<mq_MsgQOutboundServer_t *> mq_MsgQOutboundServer_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ToRSwitch local declarations' algorithm generated code\n\n  // End of 'ToRSwitch local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ToRSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_TORSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ToRSwitch', 'type': 'cofluent:Function', 'models': [{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'InboundServer', 'type': 'cofluent:Function', 'vector': '0, dpServerPerRackNb'}, {'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function'}, {'name': 'OutboundServer', 'type': 'cofluent:Function', 'vector': '0, dpServerPerRackNb'}, {'name': 'RoutingFunction', 'type': 'cofluent:RoutingFunction'}], 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundServer']}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundAGGSwitch']}, {'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket', 'connectTo': ['InboundAGGSwitch']}, {'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket', 'connectTo': ['OutboundServer']}], 'relations': [{'name': 'MsgQInboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'InboundAGGSwitch']}, {'name': 'MsgQInboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['InboundServer', 'RoutingFunction']}, {'name': 'MsgQOutboundAGGSwitch', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundAGGSwitch']}, {'name': 'MsgQOutboundServer', 'type': 'cofluent:MessageQueue', 'vector': '0, dpServerPerRackNb', 'dataType': 'DefPacket', 'connectTo': ['RoutingFunction', 'OutboundServer']}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_torswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_torswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_torswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ToRSwitch definitions' algorithm generated code\n\n// End of 'ToRSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_torswitch ::cfm_torswitch()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_torswitch_dp_if(),\n      mq_MsgQInboundAGGSwitch(\"MsgQInboundAGGSwitch\"),\n      mq_MsgQInboundServer(\"MsgQInboundServer\"),\n      mq_MsgQOutboundAGGSwitch(\"MsgQOutboundAGGSwitch\"),\n      mq_MsgQOutboundServer(\"MsgQOutboundServer\"),\n      p_mq_MsgQServerToToRSwitch(\"p_mq_MsgQServerToToRSwitch\"),\n      p_mq_MsgQToAggSwitch(\"p_mq_MsgQToAggSwitch\"),\n      p_mq_MsgQToRack(\"p_mq_MsgQToRack\"),\n      p_mq_MsgQToServer(\"p_mq_MsgQToServer\") {\n  cf_function_container::init();\n  // instantiation of models\n  InboundAGGSwitch = new cfm_inboundaggswitch(\"InboundAGGSwitch\");\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    cfm_inboundserver *module =\n        new cfm_inboundserver(cf_string(\"InboundServer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    InboundServer_vec.push_back(module);\n  }\n  OutboundAGGSwitch = new cfm_outboundaggswitch(\"OutboundAGGSwitch\");\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    cfm_outboundserver *module =\n        new cfm_outboundserver(cf_string(\"OutboundServer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    OutboundServer_vec.push_back(module);\n  }\n  RoutingFunction = new cfm_routingfunction(\"RoutingFunction\");\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    mq_MsgQInboundServer_t *module = new mq_MsgQInboundServer_t(\n        cf_string(\"MsgQInboundServer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQInboundServer_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    mq_MsgQOutboundServer_t *module = new mq_MsgQOutboundServer_t(\n        cf_string(\"MsgQOutboundServer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQOutboundServer_vec.push_back(module);\n  }\n  // connections\n  // model connect to relation\n  InboundAGGSwitch->p_mq_MsgQInboundAGGSwitch(\n      mq_MsgQInboundAGGSwitch.p_target_socket);\n  // model connect to port\n  InboundAGGSwitch->p_mq_MsgQToRack(p_mq_MsgQToRack);\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    cfm_inboundserver *module = InboundServer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n        module->p_mq_MsgQInboundServer(\n            mq_MsgQInboundServer_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_MsgQServerToToRSwitch(p_mq_MsgQServerToToRSwitch);\n    }\n  }\n  // model connect to relation\n  OutboundAGGSwitch->p_mq_MsgQOutboundAGGSwitch(\n      mq_MsgQOutboundAGGSwitch.p_target_socket);\n  // model connect to port\n  OutboundAGGSwitch->p_mq_MsgQToAggSwitch(p_mq_MsgQToAggSwitch);\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    cfm_outboundserver *module = OutboundServer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(dpServerPerRackNb + 1); j++) {\n        module->p_mq_MsgQOutboundServer(\n            mq_MsgQOutboundServer_vec[j]->p_target_socket);\n      }\n      // model connect to port\n      module->p_mq_MsgQToServer(p_mq_MsgQToServer);\n    }\n  }\n  // model connect to relation\n  RoutingFunction->p_mq_MsgQInboundAGGSwitch(\n      mq_MsgQInboundAGGSwitch.p_target_socket);\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    RoutingFunction->p_mq_MsgQInboundServer(\n        mq_MsgQInboundServer_vec[i]->p_target_socket);\n  }\n  RoutingFunction->p_mq_MsgQOutboundAGGSwitch(\n      mq_MsgQOutboundAGGSwitch.p_target_socket);\n  for (cf_count i = 0; i < (cf_count)(dpServerPerRackNb + 1); i++) {\n    RoutingFunction->p_mq_MsgQOutboundServer(\n        mq_MsgQOutboundServer_vec[i]->p_target_socket);\n  }\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_torswitch::~cfm_torswitch(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ToRSwitch destructor' algorithm generated code\n\n  // End of 'ToRSwitch destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete InboundAGGSwitch;\n  for (vector<cfm_inboundserver *>::const_iterator vi =\n           InboundServer_vec.begin();\n       vi != InboundServer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete OutboundAGGSwitch;\n  for (vector<cfm_outboundserver *>::const_iterator vi =\n           OutboundServer_vec.begin();\n       vi != OutboundServer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  delete RoutingFunction;\n  // deconstructor for vector relation\n  for (vector<mq_MsgQInboundServer_t *>::const_iterator vi =\n           mq_MsgQInboundServer_vec.begin();\n       vi != mq_MsgQInboundServer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<mq_MsgQOutboundServer_t *>::const_iterator vi =\n           mq_MsgQOutboundServer_vec.begin();\n       vi != mq_MsgQOutboundServer_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_torswitch::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_torswitch::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_PRODUCER\n#define COFS_MODEL_DATACENTER_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function, public cfm_producer_dp_if {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_server\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_producer_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_CONSUMER\n#define COFS_MODEL_DATACENTER_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_consumer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function, public cfm_consumer_dp_if {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_server\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_consumer_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDSERVER\n#define COFS_MODEL_DATACENTER_INBOUNDSERVER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundserver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundServer includes' algorithm generated code\n\n// End of 'InboundServer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundServer Function InboundServer\n//@{\n///        \\page dxpInboundServer\n//@{\n///    \\brief InboundServer function model start\nclass cfm_inboundserver : public cf_core::cf_function,\n                          public cfm_inboundserver_dp_if {\npublic:\n  /// cfm_inboundserver type define start\n\n  /// constructor\n  cfm_inboundserver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inboundserver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundServer local declarations' algorithm generated code\n\n  // End of 'InboundServer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief InboundServer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDSERVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQInboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQServerToToRSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inboundserver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundserver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundServer definitions' algorithm generated code\n\n// End of 'InboundServer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inboundserver ::cfm_inboundserver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_inboundserver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inboundserver::~cfm_inboundserver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundServer destructor' algorithm generated code\n\n  // End of 'InboundServer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_inboundserver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inboundserver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n#define COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundserver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundServer includes' algorithm generated code\n\n// End of 'OutboundServer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundServer Function OutboundServer\n//@{\n///        \\page dxpOutboundServer\n//@{\n///    \\brief OutboundServer function model start\nclass cfm_outboundserver : public cf_core::cf_function,\n                           public cfm_outboundserver_dp_if {\npublic:\n  /// cfm_outboundserver type define start\n\n  /// constructor\n  cfm_outboundserver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_outboundserver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundServer local declarations' algorithm generated code\n\n  // End of 'OutboundServer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OutboundServer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDSERVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundServer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToServer', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}, {'name': 'MsgQOutboundServer', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outboundserver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outboundserver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundserver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundServer definitions' algorithm generated code\n\n// End of 'OutboundServer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outboundserver ::cfm_outboundserver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_outboundserver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outboundserver::~cfm_outboundserver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundServer destructor' algorithm generated code\n\n  // End of 'OutboundServer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_outboundserver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_outboundserver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n#define COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_inboundaggswitch_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundAGGSwitch includes' algorithm generated code\n\n// End of 'InboundAGGSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInboundAGGSwitch Function InboundAGGSwitch\n//@{\n///        \\page dxpInboundAGGSwitch\n//@{\n///    \\brief InboundAGGSwitch function model start\nclass cfm_inboundaggswitch : public cf_core::cf_function,\n                             public cfm_inboundaggswitch_dp_if {\npublic:\n  /// cfm_inboundaggswitch type define start\n\n  /// constructor\n  cfm_inboundaggswitch(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inboundaggswitch(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundAGGSwitch local declarations' algorithm generated code\n\n  // End of 'InboundAGGSwitch local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief InboundAGGSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_INBOUNDAGGSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'InboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQToRack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQInboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inboundaggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_inboundaggswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'InboundAGGSwitch definitions' algorithm generated code\n\n// End of 'InboundAGGSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inboundaggswitch ::cfm_inboundaggswitch()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_inboundaggswitch_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inboundaggswitch::~cfm_inboundaggswitch(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'InboundAGGSwitch destructor' algorithm generated code\n\n  // End of 'InboundAGGSwitch destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_inboundaggswitch::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inboundaggswitch::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_outboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n#define COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n\n/// Model Header includes start\n#include \"cfm_datacenter_global.h\"\n#include \"cfm_datacenter_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_outboundaggswitch_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundAGGSwitch includes' algorithm generated code\n\n// End of 'OutboundAGGSwitch includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOutboundAGGSwitch Function OutboundAGGSwitch\n//@{\n///        \\page dxpOutboundAGGSwitch\n//@{\n///    \\brief OutboundAGGSwitch function model start\nclass cfm_outboundaggswitch : public cf_core::cf_function,\n                              public cfm_outboundaggswitch_dp_if {\npublic:\n  /// cfm_outboundaggswitch type define start\n\n  /// constructor\n  cfm_outboundaggswitch(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_outboundaggswitch(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundAGGSwitch local declarations' algorithm generated code\n\n  // End of 'OutboundAGGSwitch local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OutboundAGGSwitch function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_DATACENTER_OUTBOUNDAGGSWITCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OutboundAGGSwitch', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQOutboundAGGSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'MsgQToAggSwitch', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'datacenter'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_outboundaggswitch\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of datacenter generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_outboundaggswitch.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_torswitch\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_outboundaggswitch\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OutboundAGGSwitch definitions' algorithm generated code\n\n// End of 'OutboundAGGSwitch definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_outboundaggswitch ::cfm_outboundaggswitch()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_outboundaggswitch_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_outboundaggswitch::~cfm_outboundaggswitch(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OutboundAGGSwitch destructor' algorithm generated code\n\n  // End of 'OutboundAGGSwitch destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_outboundaggswitch::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_outboundaggswitch::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationModel', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL\n#define COFS_MODEL_APPLICATIONMODEL\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_receiver.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationmodel_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationModel includes' algorithm generated code\n\n// End of 'ApplicationModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationModel Function ApplicationModel\n//@{\n///        \\page dxpApplicationModel\n//@{\n///    \\brief ApplicationModel function model start\nclass cfm_applicationmodel : public cf_core::cf_application,\n                             public cfm_applicationmodel_dp_if {\npublic:\n  /// cfm_applicationmodel type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defack> mq_Ack_t;\n  typedef cf_core::cf_message_queue<cft_defmsg> mq_Msg_t;\n\n  /// cfm_applicationmodel type define end\n\n  /// constructor\n  cfm_applicationmodel(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_applicationmodel(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_producer *Producer;\n  cfm_receiver *Receiver;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_Ack_t mq_Ack;\n  mq_Msg_t mq_Msg;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationModel local declarations' algorithm generated code\n\n  // End of 'ApplicationModel local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ApplicationModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationModel', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationmodel.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationModel definitions' algorithm generated code\n\n// End of 'ApplicationModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationmodel ::cfm_applicationmodel()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), cfm_applicationmodel_dp_if(), mq_Ack(\"Ack\"),\n      mq_Msg(\"Msg\") {\n  cf_application::init();\n  // instantiation of models\n  Producer = new cfm_producer(\"Producer\");\n  Receiver = new cfm_receiver(\"Receiver\");\n  // connections\n  // model connect to relation\n  Producer->p_mq_Ack(mq_Ack.p_target_socket);\n  Producer->p_mq_Msg(mq_Msg.p_target_socket);\n  // model connect to relation\n  Receiver->p_mq_Ack(mq_Ack.p_target_socket);\n  Receiver->p_mq_Msg(mq_Msg.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationmodel::~cfm_applicationmodel(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationModel destructor' algorithm generated code\n\n  // End of 'ApplicationModel destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Producer;\n  delete Receiver;\n}\n\n//@{\nvoid cfm_applicationmodel::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_applicationmodel::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}], 'relations': [{'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Generator', 'Sender']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Generator', 'Sender']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_PRODUCER\n#define COFS_MODEL_APPLICATIONMODEL_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cfm_generator.h\"\n#include \"cfm_sender.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_deftestprod.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function_container,\n                     public cfm_producer_dp_if {\npublic:\n  /// cfm_producer type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_Req_t;\n  typedef cf_core::cf_shared_variable<cft_defdatavar> sv_DataVar_t;\n  typedef cf_core::cf_shared_variable<cft_deftestprod> sv_TestProd_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_producer, cfm_defack> p_mq_Ack_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_producer, cfm_defmsg> p_mq_Msg_t;\n  /// cfm_producer type define end\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_Ack_t p_mq_Ack;\n  p_mq_Msg_t p_mq_Msg;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_generator *Generator;\n  cfm_sender *Sender;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_Req_t ev_Req;\n  sv_DataVar_t sv_DataVar;\n  sv_TestProd_t sv_TestProd;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}], 'relations': [{'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Generator', 'Sender']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Generator', 'Sender']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_producer_dp_if(), ev_Req(\"Req\"),\n      p_mq_Ack(\"p_mq_Ack\"), p_mq_Msg(\"p_mq_Msg\"), sv_DataVar(\"DataVar\"),\n      sv_TestProd(\"TestProd\") {\n  cf_function_container::init();\n  // instantiation of models\n  Generator = new cfm_generator(\"Generator\");\n  Sender = new cfm_sender(\"Sender\");\n  // connections\n  // model connect to relation\n  Generator->p_sv_DataVar(sv_DataVar.p_target_socket);\n  Generator->p_ev_Req(ev_Req.p_target_socket);\n  Generator->p_sv_TestProd(sv_TestProd.p_target_socket);\n  // model connect to relation\n  Sender->p_sv_DataVar(sv_DataVar.p_target_socket);\n  Sender->p_ev_Req(ev_Req.p_target_socket);\n  // model connect to port\n  Sender->p_mq_Ack(p_mq_Ack);\n  Sender->p_mq_Msg(p_mq_Msg);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Generator;\n  delete Sender;\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_RECEIVER\n#define COFS_MODEL_APPLICATIONMODEL_RECEIVER\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Receiver includes' algorithm generated code\n\n// End of 'Receiver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiver Function Receiver\n//@{\n///        \\page dxpReceiver\n//@{\n///    \\brief Receiver function model start\nclass cfm_receiver : public cf_core::cf_function, public cfm_receiver_dp_if {\npublic:\n  /// cfm_receiver type define start\n\n  /// constructor\n  cfm_receiver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_receiver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Receiver local declarations' algorithm generated code\n\n  // End of 'Receiver local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Receiver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_RECEIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receiver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Receiver definitions' algorithm generated code\n\n// End of 'Receiver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receiver ::cfm_receiver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_receiver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receiver::~cfm_receiver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Receiver destructor' algorithm generated code\n\n  // End of 'Receiver destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_receiver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_receiver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_GENERATOR\n#define COFS_MODEL_APPLICATIONMODEL_GENERATOR\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_generator_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Generator includes' algorithm generated code\n\n// End of 'Generator includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgGenerator Function Generator\n//@{\n///        \\page dxpGenerator\n//@{\n///    \\brief Generator function model start\nclass cfm_generator : public cf_core::cf_function, public cfm_generator_dp_if {\npublic:\n  /// cfm_generator type define start\n\n  /// constructor\n  cfm_generator(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_generator(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Generator local declarations' algorithm generated code\n\n  // End of 'Generator local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Generator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_GENERATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_generator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_generator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Generator definitions' algorithm generated code\n\n// End of 'Generator definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_generator ::cfm_generator()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_generator_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_generator::~cfm_generator(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Generator destructor' algorithm generated code\n\n  // End of 'Generator destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_generator::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_generator::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODEL_SENDER\n#define COFS_MODEL_APPLICATIONMODEL_SENDER\n\n/// Model Header includes start\n#include \"cfm_applicationmodel_global.h\"\n#include \"cfm_applicationmodel_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Sender includes' algorithm generated code\n\n// End of 'Sender includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSender Function Sender\n//@{\n///        \\page dxpSender\n//@{\n///    \\brief Sender function model start\nclass cfm_sender : public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n  /// cfm_sender type define start\n\n  /// constructor\n  cfm_sender(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_sender(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Sender local declarations' algorithm generated code\n\n  // End of 'Sender local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Sender function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODEL_SENDER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Sender definitions' algorithm generated code\n\n// End of 'Sender definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sender ::cfm_sender()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_sender_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sender::~cfm_sender(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Sender destructor' algorithm generated code\n\n  // End of 'Sender destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_sender::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_sender::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'ApplicationModelRefinement', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_applicationmodelrefinement\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cfm_receiver.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_applicationmodelrefinement_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationModelRefinement includes' algorithm generated code\n\n// End of 'ApplicationModelRefinement includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgApplicationModelRefinement Function\n///    ApplicationModelRefinement\n//@{\n///        \\page dxpApplicationModelRefinement\n//@{\n///    \\brief ApplicationModelRefinement function model start\nclass cfm_applicationmodelrefinement\n    : public cf_core::cf_application,\n      public cfm_applicationmodelrefinement_dp_if {\npublic:\n  /// cfm_applicationmodelrefinement type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defack> mq_Ack_t;\n  typedef cf_core::cf_message_queue<cft_defmsg> mq_Msg_t;\n\n  /// cfm_applicationmodelrefinement type define end\n\n  /// constructor\n  cfm_applicationmodelrefinement(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_applicationmodelrefinement(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_producer *Producer;\n  cfm_receiver *Receiver;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_Ack_t mq_Ack;\n  mq_Msg_t mq_Msg;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationModelRefinement local declarations' algorithm\n  // generated code\n\n  // End of 'ApplicationModelRefinement local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief ApplicationModelRefinement function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'ApplicationModelRefinement', 'models': [{'name': 'Producer', 'type': 'cofluent:Function'}, {'name': 'Receiver', 'type': 'cofluent:Function'}], 'relations': [{'name': 'Ack', 'type': 'cofluent:MessageQueue', 'dataType': 'DefAck', 'connectTo': ['Producer', 'Receiver']}, {'name': 'Msg', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsg', 'connectTo': ['Producer', 'Receiver']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_applicationmodelrefinement\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_applicationmodelrefinement.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'ApplicationModelRefinement definitions' algorithm generated code\n\n// End of 'ApplicationModelRefinement definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_applicationmodelrefinement ::cfm_applicationmodelrefinement()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), cfm_applicationmodelrefinement_dp_if(),\n      mq_Ack(\"Ack\"), mq_Msg(\"Msg\") {\n  cf_application::init();\n  // instantiation of models\n  Producer = new cfm_producer(\"Producer\");\n  Receiver = new cfm_receiver(\"Receiver\");\n  // connections\n  // model connect to relation\n  Producer->p_mq_Ack(mq_Ack.p_target_socket);\n  Producer->p_mq_Msg(mq_Msg.p_target_socket);\n  // model connect to relation\n  Receiver->p_mq_Ack(mq_Ack.p_target_socket);\n  Receiver->p_mq_Msg(mq_Msg.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_applicationmodelrefinement::~cfm_applicationmodelrefinement(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'ApplicationModelRefinement destructor' algorithm generated code\n\n  // End of 'ApplicationModelRefinement destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Producer;\n  delete Receiver;\n}\n\n//@{\nvoid cfm_applicationmodelrefinement::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_applicationmodelrefinement::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}], 'relations': [{'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Sender', 'Generator']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Sender', 'Generator']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cfm_generator.h\"\n#include \"cfm_sender.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_producer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_defmsg.h\"\n#include \"dt/cft_deftestprod.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function_container,\n                     public cfm_producer_dp_if {\npublic:\n  /// cfm_producer type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_Req_t;\n  typedef cf_core::cf_shared_variable<cft_defdatavar> sv_DataVar_t;\n  typedef cf_core::cf_shared_variable<cft_deftestprod> sv_TestProd_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_producer, cfm_defack> p_mq_Ack_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_producer, cfm_defmsg> p_mq_Msg_t;\n  /// cfm_producer type define end\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_Ack_t p_mq_Ack;\n  p_mq_Msg_t p_mq_Msg;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_generator *Generator;\n  cfm_sender *Sender;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_Req_t ev_Req;\n  sv_DataVar_t sv_DataVar;\n  sv_TestProd_t sv_TestProd;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'models': [{'name': 'Generator', 'type': 'cofluent:Function'}, {'name': 'Sender', 'type': 'cofluent:Function'}], 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck', 'connectTo': ['Sender']}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg', 'connectTo': ['Sender']}], 'relations': [{'name': 'DataVar', 'type': 'cofluent:SharedVariable', 'dataType': 'DefDataVar', 'connectTo': ['Sender', 'Generator']}, {'name': 'Req', 'type': 'cofluent:Event', 'connectTo': ['Sender', 'Generator']}, {'name': 'TestProd', 'type': 'cofluent:SharedVariable', 'dataType': 'DefTestProd', 'connectTo': ['Generator']}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodelrefinement\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_producer_dp_if(), ev_Req(\"Req\"),\n      p_mq_Ack(\"p_mq_Ack\"), p_mq_Msg(\"p_mq_Msg\"), sv_DataVar(\"DataVar\"),\n      sv_TestProd(\"TestProd\") {\n  cf_function_container::init();\n  // instantiation of models\n  Generator = new cfm_generator(\"Generator\");\n  Sender = new cfm_sender(\"Sender\");\n  // connections\n  // model connect to relation\n  Generator->p_sv_DataVar(sv_DataVar.p_target_socket);\n  Generator->p_ev_Req(ev_Req.p_target_socket);\n  Generator->p_sv_TestProd(sv_TestProd.p_target_socket);\n  // model connect to relation\n  Sender->p_sv_DataVar(sv_DataVar.p_target_socket);\n  Sender->p_ev_Req(ev_Req.p_target_socket);\n  // model connect to port\n  Sender->p_mq_Ack(p_mq_Ack);\n  Sender->p_mq_Msg(p_mq_Msg);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Generator;\n  delete Sender;\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_receiver_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Receiver includes' algorithm generated code\n\n// End of 'Receiver includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReceiver Function Receiver\n//@{\n///        \\page dxpReceiver\n//@{\n///    \\brief Receiver function model start\nclass cfm_receiver : public cf_core::cf_function, public cfm_receiver_dp_if {\npublic:\n  /// cfm_receiver type define start\n\n  /// constructor\n  cfm_receiver(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_receiver(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Receiver local declarations' algorithm generated code\n\n  // End of 'Receiver local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Receiver function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_RECEIVER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Receiver', 'type': 'cofluent:Function', 'ports': [{'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefAck'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsg'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_receiver\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_receiver.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_applicationmodelrefinement\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_receiver\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Receiver definitions' algorithm generated code\n\n// End of 'Receiver definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_receiver ::cfm_receiver()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_receiver_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_receiver::~cfm_receiver(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Receiver destructor' algorithm generated code\n\n  // End of 'Receiver destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_receiver::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_receiver::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_sender_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defack.h\"\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_defmsg.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Sender includes' algorithm generated code\n\n// End of 'Sender includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSender Function Sender\n//@{\n///        \\page dxpSender\n//@{\n///    \\brief Sender function model start\nclass cfm_sender : public cf_core::cf_function, public cfm_sender_dp_if {\npublic:\n  /// cfm_sender type define start\n\n  /// constructor\n  cfm_sender(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_sender(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Sender local declarations' algorithm generated code\n\n  // End of 'Sender local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Sender function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_SENDER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Sender', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Msg', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsg'}, {'name': 'Ack', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefAck'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefDataVar'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_sender\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_sender.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_sender\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Sender definitions' algorithm generated code\n\n// End of 'Sender definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_sender ::cfm_sender()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_sender_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_sender::~cfm_sender(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Sender destructor' algorithm generated code\n\n  // End of 'Sender destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_sender::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_sender::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n#define COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n\n/// Model Header includes start\n#include \"cfm_applicationmodelrefinement_global.h\"\n#include \"cfm_applicationmodelrefinement_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_generator_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdatavar.h\"\n#include \"dt/cft_deftestprod.h\"\n\n// Start of 'Generator includes' algorithm generated code\n\n// End of 'Generator includes' algorithm generated code\n/// Model Header includes end\n\n///    \\defgroup dxgGenerator Function Generator\n//@{\n///        \\page dxpGenerator\n//@{\n///    \\brief Generator function model start\nclass cfm_generator : public cf_core::cf_function, public cfm_generator_dp_if {\npublic:\n  /// cfm_generator type define start\n\n  /// constructor\n  cfm_generator(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_generator(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  // Start of 'Generator local declarations' algorithm generated code\n\n  // End of 'Generator local declarations' algorithm generated code\n};\n///    \\brief Generator function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_APPLICATIONMODELREFINEMENT_GENERATOR\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Generator', 'type': 'cofluent:Function', 'ports': [{'name': 'Req', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataVar', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefDataVar'}, {'name': 'TestProd', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefTestProd'}], 'globalName': 'ApplicationModelRefinement'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_generator\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of ApplicationModelRefinement generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_generator.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_producer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_generator\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n// Start of 'Generator definitions' algorithm generated code\n\n// End of 'Generator definitions' algorithm generated code\n\n/// \\name constructor\n//@{\ncfm_generator ::cfm_generator()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_generator_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_generator::~cfm_generator(void) {\n  // Start of 'Generator destructor' algorithm generated code\n\n  // End of 'Generator destructor' algorithm generated code\n}\n}\n\n//@{\nvoid cfm_generator::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_generator::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HybridSchedulingApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hybridschedulingapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_controller.h\"\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HybridSchedulingApp includes' algorithm generated code\n\n// End of 'HybridSchedulingApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHybridSchedulingApp Function HybridSchedulingApp\n//@{\n///        \\page dxpHybridSchedulingApp\n//@{\n///    \\brief HybridSchedulingApp function model start\nclass cfm_hybridschedulingapp : public cf_core::cf_application {\npublic:\n  /// cfm_hybridschedulingapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n  /// cfm_hybridschedulingapp type define end\n\n  /// constructor\n  cfm_hybridschedulingapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_hybridschedulingapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_consumer *Consumer;\n  cfm_controller *Controller;\n  cfm_producer *Producer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQ_t mq_MsgQ;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HybridSchedulingApp local declarations' algorithm generated code\n\n  // End of 'HybridSchedulingApp local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief HybridSchedulingApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HybridSchedulingApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function'}, {'name': 'Controller', 'type': 'cofluent:Function'}, {'name': 'Producer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hybridschedulingapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hybridschedulingapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HybridSchedulingApp definitions' algorithm generated code\n\n// End of 'HybridSchedulingApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hybridschedulingapp ::cfm_hybridschedulingapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQ(\"MsgQ\") {\n  cf_application::init();\n  // instantiation of models\n  Consumer = new cfm_consumer(\"Consumer\");\n  Controller = new cfm_controller(\"Controller\");\n  Producer = new cfm_producer(\"Producer\");\n  // connections\n  // model connect to relation\n  Consumer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n  // model connect to relation\n  Producer->p_mq_MsgQ(mq_MsgQ.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hybridschedulingapp::~cfm_hybridschedulingapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HybridSchedulingApp destructor' algorithm generated code\n\n  // End of 'HybridSchedulingApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Consumer;\n  delete Controller;\n  delete Producer;\n}\n\n//@{\nvoid cfm_hybridschedulingapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_hybridschedulingapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n#ifndef COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n#define COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n\n/// Model Header includes start\n#include \"cfm_hybridschedulingapp_global.h\"\n#include \"cfm_hybridschedulingapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Controller includes' algorithm generated code\n\n// End of 'Controller includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgController Function Controller\n//@{\n///        \\page dxpController\n//@{\n///    \\brief Controller function model start\nclass cfm_controller : public cf_core::cf_function {\npublic:\n  /// cfm_controller type define start\n\n  /// cfm_controller type define end\n\n  /// constructor\n  cfm_controller(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_controller(void);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Controller local declarations' algorithm generated code\n\n  // End of 'Controller local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Controller function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HYBRIDSCHEDULINGAPP_CONTROLLER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Controller', 'type': 'cofluent:Function', 'globalName': 'HybridSchedulingApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_controller\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HybridSchedulingApp generated by C++ Generator\n * for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_controller.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hybridschedulingapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_controller\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Controller definitions' algorithm generated code\n\n// End of 'Controller definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_controller ::cfm_controller()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_controller::~cfm_controller(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Controller destructor' algorithm generated code\n\n  // End of 'Controller destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_controller::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_controller::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Inheritance_example2App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_inheritance_example2app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP\n\n/// Model Header includes start\n#include \"cfm_f1.h\"\n#include \"cfm_f2.h\"\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inheritance_example2App includes' algorithm generated code\n\n// End of 'Inheritance_example2App includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgInheritance_example2App Function Inheritance_example2App\n//@{\n///        \\page dxpInheritance_example2App\n//@{\n///    \\brief Inheritance_example2App function model start\nclass cfm_inheritance_example2app : public cf_core::cf_application {\npublic:\n  /// cfm_inheritance_example2app type define start\n\n  /// cfm_inheritance_example2app type define end\n\n  /// constructor\n  cfm_inheritance_example2app(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_inheritance_example2app(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_f1 *F1;\n  cfm_f2 *F2;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inheritance_example2App local declarations' algorithm generated\n  // code\n\n  // End of 'Inheritance_example2App local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Inheritance_example2App function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Inheritance_example2App', 'models': [{'name': 'F1', 'type': 'cofluent:Function'}, {'name': 'F2', 'type': 'cofluent:Function'}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_inheritance_example2app\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_inheritance_example2app.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Inheritance_example2App definitions' algorithm generated code\n\n// End of 'Inheritance_example2App definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_inheritance_example2app ::cfm_inheritance_example2app()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name) {\n  cf_application::init();\n  // instantiation of models\n  F1 = new cfm_f1(\"F1\");\n  F2 = new cfm_f2(\"F2\");\n  // connections\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_inheritance_example2app::~cfm_inheritance_example2app(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Inheritance_example2App destructor' algorithm generated code\n\n  // End of 'Inheritance_example2App destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete F1;\n  delete F2;\n}\n\n//@{\nvoid cfm_inheritance_example2app::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_inheritance_example2app::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n\n/// Model Header includes start\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n\n/*Start of 'Inherited classes header' from F1's model property generated code*/\n#include \"camera_class.h\"\n/*End of 'Inherited classes header' from F1's model property generated code*/\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F1 includes' algorithm generated code\n// End of 'F1 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n///    \\defgroup dxgF1 Function F1\n//@{\n///        \\page dxpF1\n//@{\n///    \\brief F1 function model start\nclass cfm_f1 :\n    /*Start of 'Inherited classes declaration' from F1's property generated\n       code*/\n    public camera_class,\n    public cf_core::cf_function\n/*End of 'Inherited classes declaration' from F1's property generated code*/\n{\npublic:\n  /// cfm_f1 type define start\n\n  /// cfm_f1 type define end\n\n  /// constructor\n  cfm_f1(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_f1(void);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F1 local declarations' algorithm generated code\n\n  // End of 'F1 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief F1 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP_F1\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F1', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f1\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f1.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example2app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f1\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F1 definitions' algorithm generated code\n\n// End of 'F1 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f1 ::cfm_f1()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      Start of 'Inherited classes call' from\n      F1's model property generated code*/camera_class(640{ cf_function::init();\n// connections\ncf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f1::~cfm_f1(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F1 destructor' algorithm generated code\n\n  // End of 'F1 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_f1::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_f1::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n#define COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n\n/// Model Header includes start\n#include \"cfm_inheritance_example2app_global.h\"\n#include \"cfm_inheritance_example2app_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F2 includes' algorithm generated code\n\n// End of 'F2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgF2 Function F2\n//@{\n///        \\page dxpF2\n//@{\n///    \\brief F2 function model start\nclass cfm_f2 : public cf_core::cf_function {\npublic:\n  /// cfm_f2 type define start\n\n  /// cfm_f2 type define end\n\n  /// constructor\n  cfm_f2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_f2(void);\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F2 local declarations' algorithm generated code\n\n  // End of 'F2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief F2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_INHERITANCE_EXAMPLE2APP_F2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'F2', 'type': 'cofluent:Function', 'globalName': 'Inheritance_example2App'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_f2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Inheritance_example2App generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_f2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_inheritance_example2app\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_f2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'F2 definitions' algorithm generated code\n\n// End of 'F2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_f2 ::cfm_f2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_f2::~cfm_f2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'F2 destructor' algorithm generated code\n\n  // End of 'F2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_f2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_f2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CustomizedDispatcherApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_customizeddispatcherapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n#include <vector>\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CustomizedDispatcherApp includes' algorithm generated code\n\n// End of 'CustomizedDispatcherApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCustomizedDispatcherApp Function CustomizedDispatcherApp\n//@{\n///        \\page dxpCustomizedDispatcherApp\n//@{\n///    \\brief CustomizedDispatcherApp function model start\nclass cfm_customizeddispatcherapp : public cf_core::cf_application {\npublic:\n  /// cfm_customizeddispatcherapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n  /// cfm_customizeddispatcherapp type define end\n\n  /// constructor\n  cfm_customizeddispatcherapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_customizeddispatcherapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  std::vector<cfm_consumer *> Consumer_vec;\n  std::vector<cfm_producer *> Producer_vec;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  std::vector<mq_MsgQ_t *> mq_MsgQ_vec;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CustomizedDispatcherApp local declarations' algorithm generated\n  // code\n\n  // End of 'CustomizedDispatcherApp local declarations' algorithm generated\n  // code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CustomizedDispatcherApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CustomizedDispatcherApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'vector': '0, 1', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_customizeddispatcherapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_customizeddispatcherapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CustomizedDispatcherApp definitions' algorithm generated code\n\n// End of 'CustomizedDispatcherApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_customizeddispatcherapp ::cfm_customizeddispatcherapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQ(\"MsgQ\") {\n  cf_application::init();\n  // instantiation of models\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_consumer *module =\n        new cfm_consumer(cf_string(\"Consumer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Consumer_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_producer *module =\n        new cfm_producer(cf_string(\"Producer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Producer_vec.push_back(module);\n  }\n  // instantiation of relations\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    mq_MsgQ_t *module = new mq_MsgQ_t(cf_string(\"MsgQ[%d]\", i).c_str());\n    CF_ASSERT(module)\n    mq_MsgQ_vec.push_back(module);\n  }\n  // connections\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_consumer *module = Consumer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(1 + 1); j++) {\n        module->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n      }\n    }\n  }\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_producer *module = Producer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      for (cf_count j = 0; j < (cf_count)(1 + 1); j++) {\n        module->p_mq_MsgQ(mq_MsgQ_vec[j]->p_target_socket);\n      }\n    }\n  }\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_customizeddispatcherapp::~cfm_customizeddispatcherapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CustomizedDispatcherApp destructor' algorithm generated code\n\n  // End of 'CustomizedDispatcherApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  for (vector<cfm_consumer *>::const_iterator vi = Consumer_vec.begin();\n       vi != Consumer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<cfm_producer *>::const_iterator vi = Producer_vec.begin();\n       vi != Producer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  // deconstructor for vector relation\n  for (vector<mq_MsgQ_t *>::const_iterator vi = mq_MsgQ_vec.begin();\n       vi != mq_MsgQ_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_customizeddispatcherapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_customizeddispatcherapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizeddispatcherapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n#define COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_customizeddispatcherapp_global.h\"\n#include \"cfm_customizeddispatcherapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDDISPATCHERAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedDispatcherApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedDispatcherApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizeddispatcherapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CustomizedSchedulerApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_customizedschedulerapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n\n/// Model Header includes start\n#include \"cfm_consumer.h\"\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cfm_producer.h\"\n#include \"cofluent.h\"\n#include <vector>\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CustomizedSchedulerApp includes' algorithm generated code\n\n// End of 'CustomizedSchedulerApp includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCustomizedSchedulerApp Function CustomizedSchedulerApp\n//@{\n///        \\page dxpCustomizedSchedulerApp\n//@{\n///    \\brief CustomizedSchedulerApp function model start\nclass cfm_customizedschedulerapp : public cf_core::cf_application {\npublic:\n  /// cfm_customizedschedulerapp type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_int> mq_MsgQ_t;\n\n  /// cfm_customizedschedulerapp type define end\n\n  /// constructor\n  cfm_customizedschedulerapp(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_customizedschedulerapp(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  std::vector<cfm_consumer *> Consumer_vec;\n  std::vector<cfm_producer *> Producer_vec;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_MsgQ_t mq_MsgQ;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CustomizedSchedulerApp local declarations' algorithm generated\n  // code\n\n  // End of 'CustomizedSchedulerApp local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CustomizedSchedulerApp function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CustomizedSchedulerApp', 'models': [{'name': 'Consumer', 'type': 'cofluent:Function', 'vector': '0, 1'}, {'name': 'Producer', 'type': 'cofluent:Function', 'vector': '0, 1'}], 'relations': [{'name': 'MsgQ', 'type': 'cofluent:MessageQueue', 'dataType': 'default', 'connectTo': ['Producer', 'Consumer']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_customizedschedulerapp\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_customizedschedulerapp.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CustomizedSchedulerApp definitions' algorithm generated code\n\n// End of 'CustomizedSchedulerApp definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_customizedschedulerapp ::cfm_customizedschedulerapp()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_MsgQ(\"MsgQ\") {\n  cf_application::init();\n  // instantiation of models\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_consumer *module =\n        new cfm_consumer(cf_string(\"Consumer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Consumer_vec.push_back(module);\n  }\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_producer *module =\n        new cfm_producer(cf_string(\"Producer[%d]\", i).c_str());\n    CF_ASSERT(module)\n    Producer_vec.push_back(module);\n  }\n  // connections\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_consumer *module = Consumer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      module->p_mq_MsgQ(mq_MemReadRequest.p_target_socket);\n    }\n  }\n  for (cf_count i = 0; i < (cf_count)(1 + 1); i++) {\n    cfm_producer *module = Producer_vec[i];\n    if (module != nullptr) {\n      // model connect to relation\n      module->p_mq_MsgQ(mq_MemReadRequest.p_target_socket);\n    }\n  }\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_customizedschedulerapp::~cfm_customizedschedulerapp(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CustomizedSchedulerApp destructor' algorithm generated code\n\n  // End of 'CustomizedSchedulerApp destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  for (vector<cfm_consumer *>::const_iterator vi = Consumer_vec.begin();\n       vi != Consumer_vec.end(); vi++) {\n    delete (*vi);\n  }\n  for (vector<cfm_producer *>::const_iterator vi = Producer_vec.begin();\n       vi != Producer_vec.end(); vi++) {\n    delete (*vi);\n  }\n}\n\n//@{\nvoid cfm_customizedschedulerapp::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_customizedschedulerapp::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n\n/// Model Header includes start\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer includes' algorithm generated code\n\n// End of 'Producer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgProducer Function Producer\n//@{\n///        \\page dxpProducer\n//@{\n///    \\brief Producer function model start\nclass cfm_producer : public cf_core::cf_function {\npublic:\n  /// cfm_producer type define start\n\n  /// constructor\n  cfm_producer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_producer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer local declarations' algorithm generated code\n\n  // End of 'Producer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Producer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_PRODUCER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Producer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_producer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_producer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizedschedulerapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_producer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Producer definitions' algorithm generated code\n\n// End of 'Producer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_producer ::cfm_producer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_producer::~cfm_producer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Producer destructor' algorithm generated code\n\n  // End of 'Producer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_producer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_producer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++\n * Generator for SystemC/TLM2\n */\n#ifndef COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n#define COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n\n/// Model Header includes start\n#include \"cfm_customizedschedulerapp_global.h\"\n#include \"cfm_customizedschedulerapp_global_types.h\"\n#include \"cofluent.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer includes' algorithm generated code\n\n// End of 'Consumer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgConsumer Function Consumer\n//@{\n///        \\page dxpConsumer\n//@{\n///    \\brief Consumer function model start\nclass cfm_consumer : public cf_core::cf_function {\npublic:\n  /// cfm_consumer type define start\n\n  /// constructor\n  cfm_consumer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_consumer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer local declarations' algorithm generated code\n\n  // End of 'Consumer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Consumer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_CUSTOMIZEDSCHEDULERAPP_CONSUMER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Consumer', 'type': 'cofluent:Function', 'ports': [{'name': 'MsgQ', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'default'}], 'globalName': 'CustomizedSchedulerApp'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_consumer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of CustomizedSchedulerApp generated by C++\n * Generator for SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_consumer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_customizedschedulerapp\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_consumer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Consumer definitions' algorithm generated code\n\n// End of 'Consumer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_consumer ::cfm_consumer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_consumer::~cfm_consumer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Consumer destructor' algorithm generated code\n\n  // End of 'Consumer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_consumer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_consumer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'MyModel', 'models': [{'name': 'packet_in', 'type': 'cofluent:Function'}, {'name': 'packet_out', 'type': 'cofluent:Function'}, {'name': 'packet_process', 'type': 'cofluent:Function'}], 'relations': [{'name': 'p_in', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_in', 'packet_process']}, {'name': 'p_out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_out', 'packet_process']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_mymodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL\n#define COFS_MODEL_MYMODEL\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cfm_packet_in.h\"\n#include \"cfm_packet_out.h\"\n#include \"cfm_packet_process.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MyModel includes' algorithm generated code\n\n// End of 'MyModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgMyModel Function MyModel\n//@{\n///        \\page dxpMyModel\n//@{\n///    \\brief MyModel function model start\nclass cfm_mymodel : public cf_core::cf_application {\npublic:\n  /// cfm_mymodel type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_p_in_t;\n  typedef cf_core::cf_message_queue<cft_defpacket> mq_p_out_t;\n\n  /// cfm_mymodel type define end\n\n  /// constructor\n  cfm_mymodel(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_mymodel(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_packet_in *packet_in;\n  cfm_packet_out *packet_out;\n  cfm_packet_process *packet_process;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_p_in_t mq_p_in;\n  mq_p_out_t mq_p_out;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MyModel local declarations' algorithm generated code\n\n  // End of 'MyModel local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief MyModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'MyModel', 'models': [{'name': 'packet_in', 'type': 'cofluent:Function'}, {'name': 'packet_out', 'type': 'cofluent:Function'}, {'name': 'packet_process', 'type': 'cofluent:Function'}], 'relations': [{'name': 'p_in', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_in', 'packet_process']}, {'name': 'p_out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefPacket', 'connectTo': ['packet_out', 'packet_process']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_mymodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_mymodel.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'MyModel definitions' algorithm generated code\n\n// End of 'MyModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_mymodel ::cfm_mymodel()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), mq_p_in(\"p_in\"), mq_p_out(\"p_out\") {\n  cf_application::init();\n  // instantiation of models\n  packet_in = new cfm_packet_in(\"packet_in\");\n  packet_out = new cfm_packet_out(\"packet_out\");\n  packet_process = new cfm_packet_process(\"packet_process\");\n  // connections\n  // model connect to relation\n  packet_in->p_mq_p_in(mq_p_in.p_target_socket);\n  // model connect to relation\n  packet_out->p_mq_p_out(mq_p_out.p_target_socket);\n  // model connect to relation\n  packet_process->p_mq_p_in(mq_p_in.p_target_socket);\n  packet_process->p_mq_p_out(mq_p_out.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_mymodel::~cfm_mymodel(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'MyModel destructor' algorithm generated code\n\n  // End of 'MyModel destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete packet_in;\n  delete packet_out;\n  delete packet_process;\n}\n\n//@{\nvoid cfm_mymodel::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_mymodel::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_in', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_packet_in\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_IN\n#define COFS_MODEL_MYMODEL_PACKET_IN\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'packet_in includes' algorithm generated code\n\n// End of 'packet_in includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgpacket_in Function packet_in\n//@{\n///        \\page dxppacket_in\n//@{\n///    \\brief packet_in function model start\nclass cfm_packet_in : public cf_core::cf_function {\npublic:\n  /// cfm_packet_in type define start\n\n  /// constructor\n  cfm_packet_in(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_packet_in(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'packet_in local declarations' algorithm generated code\n\n  // End of 'packet_in local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief packet_in function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL_PACKET_IN\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_in', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_packet_in\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_packet_in.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_in\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'packet_in definitions' algorithm generated code\n// synchronization event callback definition\nvoid cfm_packet_in::my_callback(){// notify internal synchronization event\n                                  CF_CSL_NOTIFY_SYNC_EV}\n// End of 'packet_in definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_packet_in ::cfm_packet_in()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_packet_in::~cfm_packet_in(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'packet_in destructor' algorithm generated code\n\n  // End of 'packet_in destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_packet_in::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_packet_in::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_out', 'type': 'cofluent:Function', 'ports': [{'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_packet_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_OUT\n#define COFS_MODEL_MYMODEL_PACKET_OUT\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'packet_out includes' algorithm generated code\n\n// End of 'packet_out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgpacket_out Function packet_out\n//@{\n///        \\page dxppacket_out\n//@{\n///    \\brief packet_out function model start\nclass cfm_packet_out : public cf_core::cf_function {\npublic:\n  /// cfm_packet_out type define start\n\n  /// constructor\n  cfm_packet_out(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_packet_out(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'packet_out local declarations' algorithm generated code\n\n  // End of 'packet_out local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief packet_out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL_PACKET_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_out', 'type': 'cofluent:Function', 'ports': [{'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_packet_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_packet_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'packet_out definitions' algorithm generated code\n\n// End of 'packet_out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_packet_out ::cfm_packet_out()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_packet_out::~cfm_packet_out(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'packet_out destructor' algorithm generated code\n\n  // End of 'packet_out destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_packet_out::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_packet_out::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'packet_process', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_packet_process\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_MYMODEL_PACKET_PROCESS\n#define COFS_MODEL_MYMODEL_PACKET_PROCESS\n\n/// Model Header includes start\n#include \"cfm_mymodel_global.h\"\n#include \"cfm_mymodel_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defpacket.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'packet_process includes' algorithm generated code\n\n// End of 'packet_process includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgpacket_process Function packet_process\n//@{\n///        \\page dxppacket_process\n//@{\n///    \\brief packet_process function model start\nclass cfm_packet_process : public cf_core::cf_function {\npublic:\n  /// cfm_packet_process type define start\n\n  /// constructor\n  cfm_packet_process(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_packet_process(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'packet_process local declarations' algorithm generated code\n\n  // End of 'packet_process local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief packet_process function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_MYMODEL_PACKET_PROCESS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'packet_process', 'type': 'cofluent:Function', 'ports': [{'name': 'p_in', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefPacket'}, {'name': 'p_out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefPacket'}], 'globalName': 'MyModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_packet_process\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of MyModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_packet_process.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_mymodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_packet_process\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'packet_process definitions' algorithm generated code\n\n// End of 'packet_process definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_packet_process ::cfm_packet_process()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_packet_process::~cfm_packet_process(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'packet_process destructor' algorithm generated code\n\n  // End of 'packet_process destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_packet_process::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_packet_process::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'TLM2AT', 'models': [{'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}, {'name': 'Writer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_tlm2at\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT\n#define COFS_MODEL_TLM2AT\n\n/// Model Header includes start\n#include \"at_top.h\"\n#include \"cfm_reader.h\"\n#include \"cfm_target.h\"\n#include \"cfm_target_2.h\"\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cfm_writer.h\"\n#include \"cofluent.h\"\n#include \"wrappers/cfm_initiatorreader_tlm2_at_initiator.h\"\n#include \"wrappers/cfm_initiatorwriter_tlm2_at_initiator.h\"\n#include \"wrappers/cfm_targetrequest_tlm2_at_target.h\"\n#include \"wrappers/cfm_targetwrapper_tlm2_at_target.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'TLM2AT includes' algorithm generated code\n\n// End of 'TLM2AT includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTLM2AT Function TLM2AT\n//@{\n///        \\page dxpTLM2AT\n//@{\n///    \\brief TLM2AT function model start\nclass cfm_tlm2at : public cf_core::cf_application {\npublic:\n  /// cfm_tlm2at type define start\n  /// systemC IPs typedef\n  typedef at_top TLM2Platfom_t;\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_Sync2_t;\n  typedef cf_core::cf_event ev_Sync3_t;\n  typedef cf_core::cf_event ev_Sync_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_InitiatorReader_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_InitiatorWriter_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_ReaderResponse_t;\n  typedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue2_t;\n  typedef cf_core::cf_message_queue<cft_defmsgq> mq_ReferenceQueue3_t;\n  typedef cf_core::cf_message_queue<cft_defdata> mq_ReferenceQueue_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_TargetRequest_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_TargetResponse_t;\n  typedef cf_core::cf_message_queue<cf_core::cf_payload_tlm2>\n      mq_TargetWrapper_t;\n\n  /// cfm_tlm2at type define end\n\n  /// constructor\n  cfm_tlm2at(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_tlm2at(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_reader *Reader;\n  TLM2Platfom_t *TLM2Platfom;\n  cfm_target *Target;\n  cfm_target_2 *Target_2;\n  cfm_writer *Writer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_Sync2_t ev_Sync2;\n  ev_Sync3_t ev_Sync3;\n  ev_Sync_t ev_Sync;\n  mq_InitiatorReader_t mq_InitiatorReader;\n  mq_InitiatorWriter_t mq_InitiatorWriter;\n  mq_ReaderResponse_t mq_ReaderResponse;\n  mq_ReferenceQueue2_t mq_ReferenceQueue2;\n  mq_ReferenceQueue3_t mq_ReferenceQueue3;\n  mq_ReferenceQueue_t mq_ReferenceQueue;\n  mq_TargetRequest_t mq_TargetRequest;\n  mq_TargetResponse_t mq_TargetResponse;\n  mq_TargetWrapper_t mq_TargetWrapper;\n  //@}\n\nprotected:\n  /// \\name wrappers\n  //@{\n  cfm_initiatorreader_tlm2_at_initiator initiatorreader_tlm2_at_initiator;\n  cfm_initiatorwriter_tlm2_at_initiator initiatorwriter_tlm2_at_initiator;\n  cfm_targetrequest_tlm2_at_target targetrequest_tlm2_at_target;\n  cfm_targetwrapper_tlm2_at_target targetwrapper_tlm2_at_target;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'TLM2AT local declarations' algorithm generated code\n\n  // End of 'TLM2AT local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief TLM2AT function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'TLM2AT', 'models': [{'name': 'Reader', 'type': 'cofluent:Function'}, {'name': 'TLM2Platfom', 'type': 'cofluent:SystemCIP'}, {'name': 'Target', 'type': 'cofluent:Function'}, {'name': 'Target_2', 'type': 'cofluent:Function'}, {'name': 'Writer', 'type': 'cofluent:Function'}], 'relations': [{'name': 'InitiatorReader', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Reader']}, {'name': 'InitiatorWriter', 'type': 'cofluent:MessageQueue', 'dataType': 'Initiator', 'connectTo': ['Writer']}, {'name': 'ReaderResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Reader']}, {'name': 'ReferenceQueue', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target_2']}, {'name': 'ReferenceQueue2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefData', 'connectTo': ['Writer', 'Target']}, {'name': 'ReferenceQueue3', 'type': 'cofluent:MessageQueue', 'dataType': 'DefMsgQ', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Reader']}, {'name': 'Sync2', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target']}, {'name': 'Sync3', 'type': 'cofluent:Event', 'connectTo': ['Writer', 'Target_2']}, {'name': 'TargetRequest', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetResponse', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target_2']}, {'name': 'TargetWrapper', 'type': 'cofluent:MessageQueue', 'dataType': 'Target', 'connectTo': ['Target']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_tlm2at\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_tlm2at.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'TLM2AT definitions' algorithm generated code\n\n// End of 'TLM2AT definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_tlm2at ::cfm_tlm2at()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), ev_Sync(\"Sync\"), ev_Sync2(\"Sync2\"),\n      ev_Sync3(\"Sync3\"), mq_InitiatorReader(\"InitiatorReader\"),\n      mq_InitiatorWriter(\"InitiatorWriter\"),\n      mq_ReaderResponse(\"ReaderResponse\"), mq_ReferenceQueue(\"ReferenceQueue\"),\n      mq_ReferenceQueue2(\"ReferenceQueue2\"),\n      mq_ReferenceQueue3(\"ReferenceQueue3\"), mq_TargetRequest(\"TargetRequest\"),\n      mq_TargetResponse(\"TargetResponse\"), mq_TargetWrapper(\"TargetWrapper\") {\n  cf_application::init();\n  // instantiation of models\n  Reader = new cfm_reader(\"Reader\");\n  TLM2Platfom = new cfm_tlm2platfom(\"TLM2Platfom\");\n  Target = new cfm_target(\"Target\");\n  Target_2 = new cfm_target_2(\"Target_2\");\n  Writer = new cfm_writer(\"Writer\");\n  // connections\n  // model connect to relation\n  Reader->p_mq_InitiatorReader(mq_InitiatorReader.p_target_socket);\n  Reader->p_mq_ReaderResponse(mq_ReaderResponse.p_target_socket);\n  Reader->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n  Reader->p_ev_Sync(ev_Sync.p_target_socket);\n  // model connect to relation\n  Target->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n  Target->p_ev_Sync2(ev_Sync2.p_target_socket);\n  Target->p_mq_TargetWrapper(mq_TargetWrapper.p_target_socket);\n  // model connect to relation\n  Target_2->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n  Target_2->p_ev_Sync3(ev_Sync3.p_target_socket);\n  Target_2->p_mq_TargetRequest(mq_TargetRequest.p_target_socket);\n  Target_2->p_mq_TargetResponse(mq_TargetResponse.p_target_socket);\n  // model connect to relation\n  Writer->p_mq_InitiatorWriter(mq_InitiatorWriter.p_target_socket);\n  Writer->p_mq_ReferenceQueue(mq_ReferenceQueue.p_target_socket);\n  Writer->p_mq_ReferenceQueue2(mq_ReferenceQueue2.p_target_socket);\n  Writer->p_mq_ReferenceQueue3(mq_ReferenceQueue3.p_target_socket);\n  Writer->p_ev_Sync(ev_Sync.p_target_socket);\n  Writer->p_ev_Sync2(ev_Sync2.p_target_socket);\n  Writer->p_ev_Sync3(ev_Sync3.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_tlm2at::~cfm_tlm2at(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'TLM2AT destructor' algorithm generated code\n\n  // End of 'TLM2AT destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Reader;\n  delete TLM2Platfom;\n  delete Target;\n  delete Target_2;\n  delete Writer;\n}\n\n//@{\nvoid cfm_tlm2at::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_tlm2at::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_WRITER\n#define COFS_MODEL_TLM2AT_WRITER\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Writer includes' algorithm generated code\n\n// End of 'Writer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgWriter Function Writer\n//@{\n///        \\page dxpWriter\n//@{\n///    \\brief Writer function model start\nclass cfm_writer : public cf_core::cf_function {\npublic:\n  /// cfm_writer type define start\n\n  /// constructor\n  cfm_writer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_writer(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Writer local declarations' algorithm generated code\n\n  // End of 'Writer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Writer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_WRITER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Writer', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'InitiatorWriter', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefData'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefMsgQ'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_writer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_writer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_writer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Writer definitions' algorithm generated code\n\n// End of 'Writer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_writer ::cfm_writer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_writer::~cfm_writer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Writer destructor' algorithm generated code\n\n  // End of 'Writer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_writer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_writer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_TARGET\n#define COFS_MODEL_TLM2AT_TARGET\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target includes' algorithm generated code\n\n// End of 'Target includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget Function Target\n//@{\n///        \\page dxpTarget\n//@{\n///    \\brief Target function model start\nclass cfm_target : public cf_core::cf_function {\npublic:\n  /// cfm_target type define start\n\n  /// constructor\n  cfm_target(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_target(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target local declarations' algorithm generated code\n\n  // End of 'Target local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Target function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_TARGET\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'TargetWrapper', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync2', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target definitions' algorithm generated code\n\n// End of 'Target definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target ::cfm_target()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target::~cfm_target(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target destructor' algorithm generated code\n\n  // End of 'Target destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_target::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_target::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_READER\n#define COFS_MODEL_TLM2AT_READER\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defmsgq.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Reader includes' algorithm generated code\n\n// End of 'Reader includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgReader Function Reader\n//@{\n///        \\page dxpReader\n//@{\n///    \\brief Reader function model start\nclass cfm_reader : public cf_core::cf_function {\npublic:\n  /// cfm_reader type define start\n\n  /// constructor\n  cfm_reader(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_reader(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Reader local declarations' algorithm generated code\n\n  // End of 'Reader local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Reader function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_READER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Reader', 'type': 'cofluent:Function', 'ports': [{'name': 'ReferenceQueue3', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefMsgQ'}, {'name': 'InitiatorReader', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Initiator'}, {'name': 'ReaderResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'Sync', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_reader\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_reader.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_reader\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Reader definitions' algorithm generated code\n\n// End of 'Reader definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_reader ::cfm_reader()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_reader::~cfm_reader(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Reader destructor' algorithm generated code\n\n  // End of 'Reader destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_reader::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_reader::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_TLM2AT_TARGET_2\n#define COFS_MODEL_TLM2AT_TARGET_2\n\n/// Model Header includes start\n#include \"cfm_tlm2at_global.h\"\n#include \"cfm_tlm2at_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n\n#include \"communication/cf_payload_tlm2.h\"\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target_2 includes' algorithm generated code\n\n// End of 'Target_2 includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgTarget_2 Function Target_2\n//@{\n///        \\page dxpTarget_2\n//@{\n///    \\brief Target_2 function model start\nclass cfm_target_2 : public cf_core::cf_function {\npublic:\n  /// cfm_target_2 type define start\n\n  /// constructor\n  cfm_target_2(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_target_2(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target_2 local declarations' algorithm generated code\n\n  // End of 'Target_2 local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Target_2 function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_TLM2AT_TARGET_2\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Target_2', 'type': 'cofluent:Function', 'ports': [{'name': 'TargetRequest', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'Target'}, {'name': 'TargetResponse', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'Target'}, {'name': 'ReferenceQueue', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefData'}, {'name': 'Sync3', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'TLM2AT'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_target_2\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of TLM2AT generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_target_2.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_tlm2at\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_target_2\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Target_2 definitions' algorithm generated code\n\n// End of 'Target_2 definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_target_2 ::cfm_target_2()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_target_2::~cfm_target_2(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Target_2 destructor' algorithm generated code\n\n  // End of 'Target_2 destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_target_2::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_target_2::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'HwDeviceModel', 'models': [{'name': 'hwDeviceTest', 'type': 'cofluent:Function'}], 'relations': [{'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwdevicemodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL\n#define COFS_MODEL_HWDEVICEMODEL\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cfm_hwdevicetest.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defframe.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HwDeviceModel includes' algorithm generated code\n\n// End of 'HwDeviceModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgHwDeviceModel Function HwDeviceModel\n//@{\n///        \\page dxpHwDeviceModel\n//@{\n///    \\brief HwDeviceModel function model start\nclass cfm_hwdevicemodel : public cf_core::cf_application {\npublic:\n  /// cfm_hwdevicemodel type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_shared_variable<cft_defframe> sv_inputStream_t;\n  typedef cf_core::cf_shared_variable<cft_defframe> sv_outputStream_t;\n\n  /// cfm_hwdevicemodel type define end\n\n  /// constructor\n  cfm_hwdevicemodel(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_hwdevicemodel(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_hwdevicetest *hwDeviceTest;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  sv_inputStream_t sv_inputStream;\n  sv_outputStream_t sv_outputStream;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HwDeviceModel local declarations' algorithm generated code\n\n  // End of 'HwDeviceModel local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief HwDeviceModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'HwDeviceModel', 'models': [{'name': 'hwDeviceTest', 'type': 'cofluent:Function'}], 'relations': [{'name': 'inputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}, {'name': 'outputStream', 'type': 'cofluent:SharedVariable', 'dataType': 'DefFrame', 'connectTo': ['hwDeviceTest']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwdevicemodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwdevicemodel.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'HwDeviceModel definitions' algorithm generated code\n\n// End of 'HwDeviceModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwdevicemodel ::cfm_hwdevicemodel()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), sv_inputStream(\"inputStream\"),\n      sv_outputStream(\"outputStream\") {\n  cf_application::init();\n  // instantiation of models\n  hwDeviceTest = new cfm_hwdevicetest(\"hwDeviceTest\");\n  // connections\n  // model connect to relation\n  hwDeviceTest->p_sv_inputStream(sv_inputStream.p_target_socket);\n  hwDeviceTest->p_sv_outputStream(sv_outputStream.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwdevicemodel::~cfm_hwdevicemodel(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'HwDeviceModel destructor' algorithm generated code\n\n  // End of 'HwDeviceModel destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete hwDeviceTest;\n}\n\n//@{\nvoid cfm_hwdevicemodel::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_hwdevicemodel::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwDeviceTest', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'hwTestBench', 'type': 'cofluent:Function'}], 'ports': [{'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}], 'relations': [{'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'hwTestBench']}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwdevicetest\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n#define COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cfm_hwmodel.h\"\n#include \"cfm_hwtestbench.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'hwDeviceTest includes' algorithm generated code\n\n// End of 'hwDeviceTest includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxghwDeviceTest Function hwDeviceTest\n//@{\n///        \\page dxphwDeviceTest\n//@{\n///    \\brief hwDeviceTest function model start\nclass cfm_hwdevicetest : public cf_core::cf_function_container {\npublic:\n  /// cfm_hwdevicetest type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_startProcess_t;\n  typedef cf_core::cf_message_queue<cft_defframe> mq_inputFrame_t;\n  typedef cf_core::cf_message_queue<cft_defframe> mq_outputFrame_t;\n  typedef cf_core::cf_shared_variable<cft_defprocessingmode>\n      sv_processingMode_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_sv_initiator_socket<cfm_hwdevicetest, cfm_defframe>\n      p_sv_inputStream_t;\n  typedef cf_core::cf_sv_initiator_socket<cfm_hwdevicetest, cfm_defframe>\n      p_sv_outputStream_t; /// cfm_hwdevicetest type define end\n\n  /// constructor\n  cfm_hwdevicetest(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_hwdevicetest(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_sv_inputStream_t p_sv_inputStream;\n  p_sv_outputStream_t p_sv_outputStream;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_hwmodel *hwModel;\n  cfm_hwtestbench *hwTestBench;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_startProcess_t ev_startProcess;\n  mq_inputFrame_t mq_inputFrame;\n  mq_outputFrame_t mq_outputFrame;\n  sv_processingMode_t sv_processingMode;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'hwDeviceTest local declarations' algorithm generated code\n\n  // End of 'hwDeviceTest local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief hwDeviceTest function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL_HWDEVICETEST\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwDeviceTest', 'type': 'cofluent:Function', 'models': [{'name': 'hwModel', 'type': 'cofluent:Function'}, {'name': 'hwTestBench', 'type': 'cofluent:Function'}], 'ports': [{'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame', 'connectTo': ['hwTestBench']}], 'relations': [{'name': 'inputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'outputFrame', 'type': 'cofluent:MessageQueue', 'dataType': 'DefFrame', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'processingMode', 'type': 'cofluent:SharedVariable', 'dataType': 'DefProcessingMode', 'connectTo': ['hwModel', 'hwTestBench']}, {'name': 'startProcess', 'type': 'cofluent:Event', 'connectTo': ['hwModel', 'hwTestBench']}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwdevicetest\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwdevicetest.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicemodel\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwdevicetest\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'hwDeviceTest definitions' algorithm generated code\n\n// End of 'hwDeviceTest definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwdevicetest ::cfm_hwdevicetest()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), ev_startProcess(\"startProcess\"),\n      mq_inputFrame(\"inputFrame\"), mq_outputFrame(\"outputFrame\"),\n      p_sv_inputStream(\"p_sv_inputStream\"),\n      p_sv_outputStream(\"p_sv_outputStream\"),\n      sv_processingMode(\"processingMode\") {\n  cf_function_container::init();\n  // instantiation of models\n  hwModel = new cfm_hwmodel(\"hwModel\");\n  hwTestBench = new cfm_hwtestbench(\"hwTestBench\");\n  // connections\n  // model connect to relation\n  hwModel->p_mq_inputFrame(mq_inputFrame.p_target_socket);\n  hwModel->p_mq_outputFrame(mq_outputFrame.p_target_socket);\n  hwModel->p_sv_processingMode(sv_processingMode.p_target_socket);\n  hwModel->p_ev_startProcess(ev_startProcess.p_target_socket);\n  // model connect to relation\n  hwTestBench->p_mq_inputFrame(mq_inputFrame.p_target_socket);\n  hwTestBench->p_mq_outputFrame(mq_outputFrame.p_target_socket);\n  hwTestBench->p_sv_processingMode(sv_processingMode.p_target_socket);\n  hwTestBench->p_ev_startProcess(ev_startProcess.p_target_socket);\n  // model connect to port\n  hwTestBench->p_mq_inputStream(p_mq_inputStream);\n  hwTestBench->p_mq_outputStream(p_mq_outputStream);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwdevicetest::~cfm_hwdevicetest(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'hwDeviceTest destructor' algorithm generated code\n\n  // End of 'hwDeviceTest destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete hwModel;\n  delete hwTestBench;\n}\n\n//@{\nvoid cfm_hwdevicetest::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_hwdevicetest::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWMODEL\n#define COFS_MODEL_HWDEVICEMODEL_HWMODEL\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'hwModel includes' algorithm generated code\n\n// End of 'hwModel includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxghwModel Function hwModel\n//@{\n///        \\page dxphwModel\n//@{\n///    \\brief hwModel function model start\nclass cfm_hwmodel : public cf_core::cf_function {\npublic:\n  /// cfm_hwmodel type define start\n\n  /// constructor\n  cfm_hwmodel(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_hwmodel(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'hwModel local declarations' algorithm generated code\n\n  // End of 'hwModel local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief hwModel function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL_HWMODEL\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwModel', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'IN', 'dataType': 'DefProcessingMode'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwmodel\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwmodel.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicetest\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwmodel\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'hwModel definitions' algorithm generated code\nvoid cfm_hwmodel::revert_frame() {\n\n  /* Reverting the image means that Pixel 0 becomes Pixel N-1, where N is the\n   * frame size (in Pixels) In YUV 422 format, it implies to:\n   *   - Revert the Y table, located at offset 0\n   *   - Revert the U table, located at offset N\n   *   - Revert the V table, located at offset N*1.5\n   */\n  unsigned char *outpayload = outputFrame.payload;\n  unsigned char *inpayload = inputFrame.payload;\n\n  // 'U' table Offset\n  int offsetU = (int)(NbPixelsPerLineMax * NbLinesMax);\n  // 'V' table offset\n  int offsetV = (int)(NbPixelsPerLineMax * NbLinesMax * 1.5);\n\n  // 4-Pixel block index in a line\n  int pixel_block_idx = 0;\n\n  // Line index\n  int line_idx;\n\n  // 4-Pixel block offset, from the beginning of the frame\n  int current_block_ofs = 0;\n\n  // For each frame line\n  for (line_idx = 0; line_idx < NbLinesMax; line_idx++) {\n    // For each pixel block\n    for (pixel_block_idx = 0; pixel_block_idx < NbPixelsPerLineMax / 4;\n         pixel_block_idx++) {\n\n      // Revert the Y table\n      outpayload[offsetU - 1 - current_block_ofs] =\n          inpayload[current_block_ofs + 0];\n      outpayload[offsetU - 1 - current_block_ofs - 1] =\n          inpayload[current_block_ofs + 1];\n      outpayload[offsetU - 1 - current_block_ofs - 2] =\n          inpayload[current_block_ofs + 2];\n      outpayload[offsetU - 1 - current_block_ofs - 3] =\n          inpayload[current_block_ofs + 3];\n\n      // Revert the U table\n      outpayload[offsetV - 1 - current_block_ofs / 2 - 0] =\n          inpayload[offsetU + current_block_ofs / 2 + 0];\n      outpayload[offsetV - 1 - current_block_ofs / 2 - 1] =\n          inpayload[offsetU + current_block_ofs / 2 + 1];\n\n      // Revert the V table\n      outpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1 -\n                 current_block_ofs / 2 - 0] =\n          inpayload[offsetV + current_block_ofs / 2 + 0];\n      outpayload[NbPixelsPerLineMax * NbLinesMax * 2 - 1 -\n                 current_block_ofs / 2 - 1] =\n          inpayload[offsetV + current_block_ofs / 2 + 1];\n\n      current_block_ofs += 4;\n    }\n  }\n}\n// End of 'hwModel definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwmodel ::cfm_hwmodel()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwmodel::~cfm_hwmodel(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'hwModel destructor' algorithm generated code\n\n  // End of 'hwModel destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_hwmodel::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_hwmodel::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'hwTestBench', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_hwtestbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n#define COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n\n/// Model Header includes start\n#include \"cfm_hwdevicemodel_global.h\"\n#include \"cfm_hwdevicemodel_global_types.h\"\n#include \"cofluent.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defframe.h\"\n#include \"dt/cft_defprocessingmode.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'hwTestBench includes' algorithm generated code\n\n// End of 'hwTestBench includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxghwTestBench Function hwTestBench\n//@{\n///        \\page dxphwTestBench\n//@{\n///    \\brief hwTestBench function model start\nclass cfm_hwtestbench : public cf_core::cf_function {\npublic:\n  /// cfm_hwtestbench type define start\n\n  /// constructor\n  cfm_hwtestbench(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_hwtestbench(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'hwTestBench local declarations' algorithm generated code\n\n  // End of 'hwTestBench local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief hwTestBench function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_HWDEVICEMODEL_HWTESTBENCH\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'hwTestBench', 'type': 'cofluent:Function', 'ports': [{'name': 'startProcess', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'inputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'processingMode', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefProcessingMode'}, {'name': 'outputFrame', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefFrame'}, {'name': 'inputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}, {'name': 'outputStream', 'type': 'SHARED_VARIABLE', 'direction': 'OUT', 'dataType': 'DefFrame'}], 'globalName': 'HwDeviceModel'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_hwtestbench\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of HwDeviceModel generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_hwtestbench.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_hwdevicetest\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_hwtestbench\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'hwTestBench definitions' algorithm generated code\n\n// End of 'hwTestBench definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_hwtestbench ::cfm_hwtestbench()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name) {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_hwtestbench::~cfm_hwtestbench(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'hwTestBench destructor' algorithm generated code\n\n  // End of 'hwTestBench destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_hwtestbench::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_hwtestbench::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Bluetooth_IPs', 'models': [{'name': 'BT_System', 'type': 'cofluent:Function'}, {'name': 'Slave_Stub', 'type': 'cofluent:Function'}, {'name': 'Start', 'type': 'cofluent:Function'}], 'relations': [{'name': 'BaseBand_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'BaseBand_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'startEv', 'type': 'cofluent:Event', 'connectTo': ['BT_System', 'Start']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bluetooth_ips\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS\n#define COFS_MODEL_BLUETOOTH_IPS\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cfm_bt_system.h\"\n#include \"cfm_slave_stub.h\"\n#include \"cfm_start.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bluetooth_ips_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Bluetooth_IPs includes' algorithm generated code\n\n// End of 'Bluetooth_IPs includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBluetooth_IPs Function Bluetooth_IPs\n//@{\n///        \\page dxpBluetooth_IPs\n//@{\n///    \\brief Bluetooth_IPs function model start\nclass cfm_bluetooth_ips : public cf_core::cf_application,\n                          public cfm_bluetooth_ips_dp_if {\npublic:\n  /// cfm_bluetooth_ips type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_startEv_t;\n  typedef cf_core::cf_message_queue<cft_defbaseband> mq_BaseBand_In_t;\n  typedef cf_core::cf_message_queue<cft_defbaseband> mq_BaseBand_Out_t;\n\n  /// cfm_bluetooth_ips type define end\n\n  /// constructor\n  cfm_bluetooth_ips(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_bluetooth_ips(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_bt_system *BT_System;\n  cfm_slave_stub *Slave_Stub;\n  cfm_start *Start;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_startEv_t ev_startEv;\n  mq_BaseBand_In_t mq_BaseBand_In;\n  mq_BaseBand_Out_t mq_BaseBand_Out;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Bluetooth_IPs local declarations' algorithm generated code\n\n  // End of 'Bluetooth_IPs local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Bluetooth_IPs function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Bluetooth_IPs', 'models': [{'name': 'BT_System', 'type': 'cofluent:Function'}, {'name': 'Slave_Stub', 'type': 'cofluent:Function'}, {'name': 'Start', 'type': 'cofluent:Function'}], 'relations': [{'name': 'BaseBand_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'BaseBand_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand', 'connectTo': ['Slave_Stub', 'BT_System']}, {'name': 'startEv', 'type': 'cofluent:Event', 'connectTo': ['BT_System', 'Start']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bluetooth_ips\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bluetooth_ips.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Bluetooth_IPs definitions' algorithm generated code\n\n// End of 'Bluetooth_IPs definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bluetooth_ips ::cfm_bluetooth_ips()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), cfm_bluetooth_ips_dp_if(), ev_startEv(\"startEv\"),\n      mq_BaseBand_In(\"BaseBand_In\"), mq_BaseBand_Out(\"BaseBand_Out\") {\n  cf_application::init();\n  // instantiation of models\n  BT_System = new cfm_bt_system(\"BT_System\");\n  Slave_Stub = new cfm_slave_stub(\"Slave_Stub\");\n  Start = new cfm_start(\"Start\");\n  // connections\n  // model connect to relation\n  BT_System->p_mq_BaseBand_In(mq_BaseBand_In.p_target_socket);\n  BT_System->p_mq_BaseBand_Out(mq_BaseBand_Out.p_target_socket);\n  BT_System->p_ev_startEv(ev_startEv.p_target_socket);\n  // model connect to relation\n  Slave_Stub->p_mq_BaseBand_In(mq_BaseBand_In.p_target_socket);\n  Slave_Stub->p_mq_BaseBand_Out(mq_BaseBand_Out.p_target_socket);\n  // model connect to relation\n  Start->p_ev_startEv(ev_startEv.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bluetooth_ips::~cfm_bluetooth_ips(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Bluetooth_IPs destructor' algorithm generated code\n\n  // End of 'Bluetooth_IPs destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete BT_System;\n  delete Slave_Stub;\n  delete Start;\n}\n\n//@{\nvoid cfm_bluetooth_ips::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_bluetooth_ips::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Slave_Stub', 'type': 'cofluent:Function', 'models': [{'name': 'In_Stub', 'type': 'cofluent:Function'}, {'name': 'Out_Stub', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['In_Stub']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['Out_Stub']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_slave_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cfm_in_stub.h\"\n#include \"cfm_out_stub.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_slave_stub_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Slave_Stub includes' algorithm generated code\n\n// End of 'Slave_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgSlave_Stub Function Slave_Stub\n//@{\n///        \\page dxpSlave_Stub\n//@{\n///    \\brief Slave_Stub function model start\nclass cfm_slave_stub : public cf_core::cf_function_container,\n                       public cfm_slave_stub_dp_if {\npublic:\n  /// cfm_slave_stub type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_slave_stub, cfm_defbaseband>\n      p_mq_BaseBand_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_slave_stub, cfm_defbaseband>\n      p_mq_BaseBand_Out_t;\n  /// cfm_slave_stub type define end\n\n  /// constructor\n  cfm_slave_stub(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_slave_stub(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_BaseBand_In_t p_mq_BaseBand_In;\n  p_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_in_stub *In_Stub;\n  cfm_out_stub *Out_Stub;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Slave_Stub local declarations' algorithm generated code\n\n  // End of 'Slave_Stub local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Slave_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_SLAVE_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Slave_Stub', 'type': 'cofluent:Function', 'models': [{'name': 'In_Stub', 'type': 'cofluent:Function'}, {'name': 'Out_Stub', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['In_Stub']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['Out_Stub']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_slave_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_slave_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_slave_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Slave_Stub definitions' algorithm generated code\n\n// End of 'Slave_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_slave_stub ::cfm_slave_stub()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_slave_stub_dp_if(),\n      p_mq_BaseBand_In(\"p_mq_BaseBand_In\"),\n      p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\") {\n  cf_function_container::init();\n  // instantiation of models\n  In_Stub = new cfm_in_stub(\"In_Stub\");\n  Out_Stub = new cfm_out_stub(\"Out_Stub\");\n  // connections\n  // model connect to port\n  In_Stub->p_mq_BaseBand_In(p_mq_BaseBand_In);\n  // model connect to port\n  Out_Stub->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_slave_stub::~cfm_slave_stub(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Slave_Stub destructor' algorithm generated code\n\n  // End of 'Slave_Stub destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete In_Stub;\n  delete Out_Stub;\n}\n\n//@{\nvoid cfm_slave_stub::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_slave_stub::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BT_System', 'type': 'cofluent:Function', 'models': [{'name': 'BT_Stack', 'type': 'cofluent:Function'}, {'name': 'FileSystem', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['BT_Stack']}], 'relations': [{'name': 'Data', 'type': 'cofluent:SharedVariable', 'dataType': 'DefData', 'connectTo': ['FileSystem']}, {'name': 'DataIn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataIn', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'DataOut', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataOut', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'ReadWrite', 'type': 'cofluent:MessageQueue', 'dataType': 'DefReadWrite', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'WrOK', 'type': 'cofluent:Event', 'connectTo': ['FileSystem', 'BT_Stack']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bt_system\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n#define COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cfm_bt_stack.h\"\n#include \"cfm_filesystem.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bt_system_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BT_System includes' algorithm generated code\n\n// End of 'BT_System includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBT_System Function BT_System\n//@{\n///        \\page dxpBT_System\n//@{\n///    \\brief BT_System function model start\nclass cfm_bt_system : public cf_core::cf_function_container,\n                      public cfm_bt_system_dp_if {\npublic:\n  /// cfm_bt_system type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_WrOK_t;\n  typedef cf_core::cf_message_queue<cft_defdatain> mq_DataIn_t;\n  typedef cf_core::cf_message_queue<cft_defdataout> mq_DataOut_t;\n  typedef cf_core::cf_message_queue<cft_defreadwrite> mq_ReadWrite_t;\n  typedef cf_core::cf_shared_variable<cft_defdata> sv_Data_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_ev_initiator_socket<datatype> p_ev_startEv_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_bt_system, cfm_defbaseband>\n      p_mq_BaseBand_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_bt_system, cfm_defbaseband>\n      p_mq_BaseBand_Out_t;\n  /// cfm_bt_system type define end\n\n  /// constructor\n  cfm_bt_system(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_bt_system(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_ev_startEv_t p_ev_startEv;\n  p_mq_BaseBand_In_t p_mq_BaseBand_In;\n  p_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_bt_stack *BT_Stack;\n  cfm_filesystem *FileSystem;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_WrOK_t ev_WrOK;\n  mq_DataIn_t mq_DataIn;\n  mq_DataOut_t mq_DataOut;\n  mq_ReadWrite_t mq_ReadWrite;\n  sv_Data_t sv_Data;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BT_System local declarations' algorithm generated code\n\n  // End of 'BT_System local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BT_System function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BT_SYSTEM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BT_System', 'type': 'cofluent:Function', 'models': [{'name': 'BT_Stack', 'type': 'cofluent:Function'}, {'name': 'FileSystem', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BT_Stack']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['BT_Stack']}], 'relations': [{'name': 'Data', 'type': 'cofluent:SharedVariable', 'dataType': 'DefData', 'connectTo': ['FileSystem']}, {'name': 'DataIn', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataIn', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'DataOut', 'type': 'cofluent:MessageQueue', 'dataType': 'DefDataOut', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'ReadWrite', 'type': 'cofluent:MessageQueue', 'dataType': 'DefReadWrite', 'connectTo': ['FileSystem', 'BT_Stack']}, {'name': 'WrOK', 'type': 'cofluent:Event', 'connectTo': ['FileSystem', 'BT_Stack']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bt_system\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bt_system.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bt_system\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BT_System definitions' algorithm generated code\n\n// End of 'BT_System definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bt_system ::cfm_bt_system()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_bt_system_dp_if(), ev_WrOK(\"WrOK\"),\n      mq_DataIn(\"DataIn\"), mq_DataOut(\"DataOut\"), mq_ReadWrite(\"ReadWrite\"),\n      p_ev_startEv(\"p_ev_startEv\"), p_mq_BaseBand_In(\"p_mq_BaseBand_In\"),\n      p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\"), sv_Data(\"Data\") {\n  cf_function_container::init();\n  // instantiation of models\n  BT_Stack = new cfm_bt_stack(\"BT_Stack\");\n  FileSystem = new cfm_filesystem(\"FileSystem\");\n  // connections\n  // model connect to relation\n  BT_Stack->p_mq_DataIn(mq_DataIn.p_target_socket);\n  BT_Stack->p_mq_DataOut(mq_DataOut.p_target_socket);\n  BT_Stack->p_mq_ReadWrite(mq_ReadWrite.p_target_socket);\n  BT_Stack->p_ev_WrOK(ev_WrOK.p_target_socket);\n  // model connect to port\n  BT_Stack->p_mq_BaseBand_In(p_mq_BaseBand_In);\n  BT_Stack->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n  BT_Stack->p_mq_startEv(p_mq_startEv);\n  // model connect to relation\n  FileSystem->p_sv_Data(sv_Data.p_target_socket);\n  FileSystem->p_mq_DataIn(mq_DataIn.p_target_socket);\n  FileSystem->p_mq_DataOut(mq_DataOut.p_target_socket);\n  FileSystem->p_mq_ReadWrite(mq_ReadWrite.p_target_socket);\n  FileSystem->p_ev_WrOK(ev_WrOK.p_target_socket);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bt_system::~cfm_bt_system(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BT_System destructor' algorithm generated code\n\n  // End of 'BT_System destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete BT_Stack;\n  delete FileSystem;\n}\n\n//@{\nvoid cfm_bt_system::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_bt_system::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Start', 'type': 'cofluent:Function', 'ports': [{'name': 'startEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_start\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_START\n#define COFS_MODEL_BLUETOOTH_IPS_START\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_start_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Start includes' algorithm generated code\n\n// End of 'Start includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgStart Function Start\n//@{\n///        \\page dxpStart\n//@{\n///    \\brief Start function model start\nclass cfm_start : public cf_core::cf_function, public cfm_start_dp_if {\npublic:\n  /// cfm_start type define start\n\n  /// constructor\n  cfm_start(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_start(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Start local declarations' algorithm generated code\n\n  // End of 'Start local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Start function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_START\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Start', 'type': 'cofluent:Function', 'ports': [{'name': 'startEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_start\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_start.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bluetooth_ips\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_start\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Start definitions' algorithm generated code\n\n// End of 'Start definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_start ::cfm_start()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_start_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_start::~cfm_start(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Start destructor' algorithm generated code\n\n  // End of 'Start destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_start::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_start::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'In_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_in_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_in_stub_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'In_Stub includes' algorithm generated code\n\n// End of 'In_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgIn_Stub Function In_Stub\n//@{\n///        \\page dxpIn_Stub\n//@{\n///    \\brief In_Stub function model start\nclass cfm_in_stub : public cf_core::cf_function, public cfm_in_stub_dp_if {\npublic:\n  /// cfm_in_stub type define start\n\n  /// constructor\n  cfm_in_stub(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_in_stub(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'In_Stub local declarations' algorithm generated code\n\n  // End of 'In_Stub local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief In_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_IN_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'In_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_in_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_in_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_slave_stub\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_in_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'In_Stub definitions' algorithm generated code\n\n// End of 'In_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_in_stub ::cfm_in_stub()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_in_stub_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_in_stub::~cfm_in_stub(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'In_Stub destructor' algorithm generated code\n\n  // End of 'In_Stub destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_in_stub::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_in_stub::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'Out_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_out_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n#define COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_out_stub_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Out_Stub includes' algorithm generated code\n\n// End of 'Out_Stub includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOut_Stub Function Out_Stub\n//@{\n///        \\page dxpOut_Stub\n//@{\n///    \\brief Out_Stub function model start\nclass cfm_out_stub : public cf_core::cf_function, public cfm_out_stub_dp_if {\npublic:\n  /// cfm_out_stub type define start\n\n  /// constructor\n  cfm_out_stub(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_out_stub(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Out_Stub local declarations' algorithm generated code\n\n  // End of 'Out_Stub local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief Out_Stub function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OUT_STUB\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'Out_Stub', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_out_stub\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_out_stub.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_slave_stub\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_out_stub\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'Out_Stub definitions' algorithm generated code\n\n// End of 'Out_Stub definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_out_stub ::cfm_out_stub()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_out_stub_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_out_stub::~cfm_out_stub(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Out_Stub destructor' algorithm generated code\n\n  // End of 'Out_Stub destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_out_stub::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_out_stub::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'FileSystem', 'type': 'cofluent:Function', 'ports': [{'name': 'Data', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefData'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataOut'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataIn'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefReadWrite'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_filesystem\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n#define COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_filesystem_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdata.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'FileSystem includes' algorithm generated code\n\n// End of 'FileSystem includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgFileSystem Function FileSystem\n//@{\n///        \\page dxpFileSystem\n//@{\n///    \\brief FileSystem function model start\nclass cfm_filesystem : public cf_core::cf_function,\n                       public cfm_filesystem_dp_if {\npublic:\n  /// cfm_filesystem type define start\n\n  /// constructor\n  cfm_filesystem(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_filesystem(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'FileSystem local declarations' algorithm generated code\n\n  // End of 'FileSystem local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief FileSystem function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_FILESYSTEM\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'FileSystem', 'type': 'cofluent:Function', 'ports': [{'name': 'Data', 'type': 'SHARED_VARIABLE', 'direction': 'IN_OUT', 'dataType': 'DefData'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataOut'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataIn'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefReadWrite'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_filesystem\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_filesystem.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_system\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_filesystem\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'FileSystem definitions' algorithm generated code\n\n// End of 'FileSystem definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_filesystem ::cfm_filesystem()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_filesystem_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_filesystem::~cfm_filesystem(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'FileSystem destructor' algorithm generated code\n\n  // End of 'FileSystem destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_filesystem::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_filesystem::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BT_Stack', 'type': 'cofluent:Function', 'models': [{'name': 'BaseBand_Layer', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Layer', 'type': 'cofluent:Function'}, {'name': 'OBEX_Layer', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Layer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Layer']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Layer']}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Layer']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}], 'relations': [{'name': 'L2CAP_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_In', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'OBEX_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'OBEX_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'RFCOMM_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'RFCOMM_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bt_stack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n#define COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n\n/// Model Header includes start\n#include \"cfm_baseband_layer.h\"\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cfm_l2cap_layer.h\"\n#include \"cfm_obex_layer.h\"\n#include \"cfm_rfcomm_layer.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bt_stack_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defl2cap_out.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BT_Stack includes' algorithm generated code\n\n// End of 'BT_Stack includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBT_Stack Function BT_Stack\n//@{\n///        \\page dxpBT_Stack\n//@{\n///    \\brief BT_Stack function model start\nclass cfm_bt_stack : public cf_core::cf_function_container,\n                     public cfm_bt_stack_dp_if {\npublic:\n  /// cfm_bt_stack type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defl2cap_in> mq_L2CAP_In_t;\n  typedef cf_core::cf_message_queue<cft_defl2cap_out> mq_L2CAP_Out_t;\n  typedef cf_core::cf_message_queue<cft_defobex_in> mq_OBEX_In_t;\n  typedef cf_core::cf_message_queue<cft_defobex_out> mq_OBEX_Out_t;\n  typedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFCOMM_In_t;\n  typedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFCOMM_Out_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_ev_initiator_socket<datatype> p_ev_WrOK_t;\n  typedef cf_core::cf_ev_initiator_socket<datatype> p_ev_startEv_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cfm_defbaseband>\n      p_mq_BaseBand_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cfm_defbaseband>\n      p_mq_BaseBand_Out_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cfm_defdatain>\n      p_mq_DataIn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cfm_defdataout>\n      p_mq_DataOut_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_bt_stack, cfm_defreadwrite>\n      p_mq_ReadWrite_t;\n  /// cfm_bt_stack type define end\n\n  /// constructor\n  cfm_bt_stack(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_bt_stack(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_ev_WrOK_t p_ev_WrOK;\n  p_ev_startEv_t p_ev_startEv;\n  p_mq_BaseBand_In_t p_mq_BaseBand_In;\n  p_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n  p_mq_DataIn_t p_mq_DataIn;\n  p_mq_DataOut_t p_mq_DataOut;\n  p_mq_ReadWrite_t p_mq_ReadWrite;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_baseband_layer *BaseBand_Layer;\n  cfm_l2cap_layer *L2CAP_Layer;\n  cfm_obex_layer *OBEX_Layer;\n  cfm_rfcomm_layer *RFCOMM_Layer;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_L2CAP_In_t mq_L2CAP_In;\n  mq_L2CAP_Out_t mq_L2CAP_Out;\n  mq_OBEX_In_t mq_OBEX_In;\n  mq_OBEX_Out_t mq_OBEX_Out;\n  mq_RFCOMM_In_t mq_RFCOMM_In;\n  mq_RFCOMM_Out_t mq_RFCOMM_Out;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BT_Stack local declarations' algorithm generated code\n\n  // End of 'BT_Stack local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BT_Stack function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BT_STACK\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BT_Stack', 'type': 'cofluent:Function', 'models': [{'name': 'BaseBand_Layer', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Layer', 'type': 'cofluent:Function'}, {'name': 'OBEX_Layer', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Layer', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BaseBand_Layer']}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Layer']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Layer']}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Layer']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Layer']}], 'relations': [{'name': 'L2CAP_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_In', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'L2CAP_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BaseBand_Layer', 'L2CAP_Layer']}, {'name': 'OBEX_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'OBEX_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Layer', 'RFCOMM_Layer']}, {'name': 'RFCOMM_In', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}, {'name': 'RFCOMM_Out', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Layer', 'L2CAP_Layer']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bt_stack\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bt_stack.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_system\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bt_stack\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BT_Stack definitions' algorithm generated code\n\n// End of 'BT_Stack definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bt_stack ::cfm_bt_stack()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_bt_stack_dp_if(),\n      mq_L2CAP_In(\"L2CAP_In\"), mq_L2CAP_Out(\"L2CAP_Out\"), mq_OBEX_In(\"OBEX_In\"),\n      mq_OBEX_Out(\"OBEX_Out\"), mq_RFCOMM_In(\"RFCOMM_In\"),\n      mq_RFCOMM_Out(\"RFCOMM_Out\"), p_ev_WrOK(\"p_ev_WrOK\"),\n      p_ev_startEv(\"p_ev_startEv\"), p_mq_BaseBand_In(\"p_mq_BaseBand_In\"),\n      p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\"), p_mq_DataIn(\"p_mq_DataIn\"),\n      p_mq_DataOut(\"p_mq_DataOut\"), p_mq_ReadWrite(\"p_mq_ReadWrite\") {\n  cf_function_container::init();\n  // instantiation of models\n  BaseBand_Layer = new cfm_baseband_layer(\"BaseBand_Layer\");\n  L2CAP_Layer = new cfm_l2cap_layer(\"L2CAP_Layer\");\n  OBEX_Layer = new cfm_obex_layer(\"OBEX_Layer\");\n  RFCOMM_Layer = new cfm_rfcomm_layer(\"RFCOMM_Layer\");\n  // connections\n  // model connect to relation\n  BaseBand_Layer->p_mq_L2CAP_In(mq_L2CAP_In.p_target_socket);\n  BaseBand_Layer->p_mq_L2CAP_Out(mq_L2CAP_Out.p_target_socket);\n  // model connect to port\n  BaseBand_Layer->p_mq_BaseBand_In(p_mq_BaseBand_In);\n  BaseBand_Layer->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n  // model connect to relation\n  L2CAP_Layer->p_mq_L2CAP_In(mq_L2CAP_In.p_target_socket);\n  L2CAP_Layer->p_mq_L2CAP_Out(mq_L2CAP_Out.p_target_socket);\n  L2CAP_Layer->p_mq_RFCOMM_In(mq_RFCOMM_In.p_target_socket);\n  L2CAP_Layer->p_mq_RFCOMM_Out(mq_RFCOMM_Out.p_target_socket);\n  // model connect to relation\n  OBEX_Layer->p_mq_OBEX_In(mq_OBEX_In.p_target_socket);\n  OBEX_Layer->p_mq_OBEX_Out(mq_OBEX_Out.p_target_socket);\n  // model connect to port\n  OBEX_Layer->p_mq_DataIn(p_mq_DataIn);\n  OBEX_Layer->p_mq_DataOut(p_mq_DataOut);\n  OBEX_Layer->p_mq_ReadWrite(p_mq_ReadWrite);\n  OBEX_Layer->p_mq_WrOK(p_mq_WrOK);\n  OBEX_Layer->p_mq_startEv(p_mq_startEv);\n  // model connect to relation\n  RFCOMM_Layer->p_mq_OBEX_In(mq_OBEX_In.p_target_socket);\n  RFCOMM_Layer->p_mq_OBEX_Out(mq_OBEX_Out.p_target_socket);\n  RFCOMM_Layer->p_mq_RFCOMM_In(mq_RFCOMM_In.p_target_socket);\n  RFCOMM_Layer->p_mq_RFCOMM_Out(mq_RFCOMM_Out.p_target_socket);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bt_stack::~cfm_bt_stack(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BT_Stack destructor' algorithm generated code\n\n  // End of 'BT_Stack destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete BaseBand_Layer;\n  delete L2CAP_Layer;\n  delete OBEX_Layer;\n  delete RFCOMM_Layer;\n}\n\n//@{\nvoid cfm_bt_stack::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_bt_stack::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Receive', 'type': 'cofluent:Function'}, {'name': 'OBEX_Send', 'type': 'cofluent:Function'}, {'name': 'OB_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Receive']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Send']}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Receive']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out', 'connectTo': ['OB_Out']}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Receive']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Send']}], 'relations': [{'name': 'OB_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Receive', 'OB_Out']}, {'name': 'OB_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Send', 'OB_Out']}, {'name': 'continueEv', 'type': 'cofluent:Event', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cfm_ob_out.h\"\n#include \"cfm_obex_receive.h\"\n#include \"cfm_obex_send.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_layer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OBEX_Layer includes' algorithm generated code\n\n// End of 'OBEX_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Layer Function OBEX_Layer\n//@{\n///        \\page dxpOBEX_Layer\n//@{\n///    \\brief OBEX_Layer function model start\nclass cfm_obex_layer : public cf_core::cf_function_container,\n                       public cfm_obex_layer_dp_if {\npublic:\n  /// cfm_obex_layer type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_continueEv_t;\n  typedef cf_core::cf_message_queue<cft_defobex_out> mq_OB_Out1_t;\n  typedef cf_core::cf_message_queue<cft_defobex_out> mq_OB_Out2_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_ev_initiator_socket<datatype> p_ev_WrOK_t;\n  typedef cf_core::cf_ev_initiator_socket<datatype> p_ev_startEv_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cfm_defdatain>\n      p_mq_DataIn_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cfm_defdataout>\n      p_mq_DataOut_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cfm_defobex_in>\n      p_mq_OBEX_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cfm_defobex_out>\n      p_mq_OBEX_Out_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_obex_layer, cfm_defreadwrite>\n      p_mq_ReadWrite_t;\n  /// cfm_obex_layer type define end\n\n  /// constructor\n  cfm_obex_layer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_obex_layer(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_ev_WrOK_t p_ev_WrOK;\n  p_ev_startEv_t p_ev_startEv;\n  p_mq_DataIn_t p_mq_DataIn;\n  p_mq_DataOut_t p_mq_DataOut;\n  p_mq_OBEX_In_t p_mq_OBEX_In;\n  p_mq_OBEX_Out_t p_mq_OBEX_Out;\n  p_mq_ReadWrite_t p_mq_ReadWrite;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_obex_receive *OBEX_Receive;\n  cfm_obex_send *OBEX_Send;\n  cfm_ob_out *OB_Out;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_continueEv_t ev_continueEv;\n  mq_OB_Out1_t mq_OB_Out1;\n  mq_OB_Out2_t mq_OB_Out2;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OBEX_Layer local declarations' algorithm generated code\n\n  // End of 'OBEX_Layer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OBEX_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'OBEX_Receive', 'type': 'cofluent:Function'}, {'name': 'OBEX_Send', 'type': 'cofluent:Function'}, {'name': 'OB_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn', 'connectTo': ['OBEX_Receive']}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut', 'connectTo': ['OBEX_Send']}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In', 'connectTo': ['OBEX_Receive']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out', 'connectTo': ['OB_Out']}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Receive']}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN', 'connectTo': ['OBEX_Send']}], 'relations': [{'name': 'OB_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Receive', 'OB_Out']}, {'name': 'OB_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefOBEX_Out', 'connectTo': ['OBEX_Send', 'OB_Out']}, {'name': 'continueEv', 'type': 'cofluent:Event', 'connectTo': ['OBEX_Send', 'OBEX_Receive']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OBEX_Layer definitions' algorithm generated code\n\n// End of 'OBEX_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_layer ::cfm_obex_layer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_obex_layer_dp_if(),\n      ev_continueEv(\"continueEv\"), mq_OB_Out1(\"OB_Out1\"), mq_OB_Out2(\"OB_Out2\"),\n      p_ev_WrOK(\"p_ev_WrOK\"), p_ev_startEv(\"p_ev_startEv\"),\n      p_mq_DataIn(\"p_mq_DataIn\"), p_mq_DataOut(\"p_mq_DataOut\"),\n      p_mq_OBEX_In(\"p_mq_OBEX_In\"), p_mq_OBEX_Out(\"p_mq_OBEX_Out\"),\n      p_mq_ReadWrite(\"p_mq_ReadWrite\") {\n  cf_function_container::init();\n  // instantiation of models\n  OBEX_Receive = new cfm_obex_receive(\"OBEX_Receive\");\n  OBEX_Send = new cfm_obex_send(\"OBEX_Send\");\n  OB_Out = new cfm_ob_out(\"OB_Out\");\n  // connections\n  // model connect to relation\n  OBEX_Receive->p_mq_OB_Out1(mq_OB_Out1.p_target_socket);\n  OBEX_Receive->p_ev_continueEv(ev_continueEv.p_target_socket);\n  // model connect to port\n  OBEX_Receive->p_mq_DataIn(p_mq_DataIn);\n  OBEX_Receive->p_mq_OBEX_In(p_mq_OBEX_In);\n  OBEX_Receive->p_mq_ReadWrite(p_mq_ReadWrite);\n  OBEX_Receive->p_mq_WrOK(p_mq_WrOK);\n  // model connect to relation\n  OBEX_Send->p_mq_OB_Out2(mq_OB_Out2.p_target_socket);\n  OBEX_Send->p_ev_continueEv(ev_continueEv.p_target_socket);\n  // model connect to port\n  OBEX_Send->p_mq_DataOut(p_mq_DataOut);\n  OBEX_Send->p_mq_ReadWrite(p_mq_ReadWrite);\n  OBEX_Send->p_mq_startEv(p_mq_startEv);\n  // model connect to relation\n  OB_Out->p_mq_OB_Out1(mq_OB_Out1.p_target_socket);\n  OB_Out->p_mq_OB_Out2(mq_OB_Out2.p_target_socket);\n  // model connect to port\n  OB_Out->p_mq_OBEX_Out(p_mq_OBEX_Out);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_layer::~cfm_obex_layer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OBEX_Layer destructor' algorithm generated code\n\n  // End of 'OBEX_Layer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete OBEX_Receive;\n  delete OBEX_Send;\n  delete OB_Out;\n}\n\n//@{\nvoid cfm_obex_layer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_obex_layer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'CreditsOrData', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Receive', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Send', 'type': 'cofluent:Function'}, {'name': 'RFC_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In', 'connectTo': ['RFCOMM_Receive']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out', 'connectTo': ['RFCOMM_Send']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In', 'connectTo': ['CreditsOrData']}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFC_Out']}], 'relations': [{'name': 'RFC_Cdts', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Send', 'CreditsOrData']}, {'name': 'RFC_Data', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Receive', 'CreditsOrData']}, {'name': 'RFC_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Receive', 'RFC_Out']}, {'name': 'RFC_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Send', 'RFC_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cfm_creditsordata.h\"\n#include \"cfm_rfc_out.h\"\n#include \"cfm_rfcomm_receive.h\"\n#include \"cfm_rfcomm_send.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_layer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFCOMM_Layer includes' algorithm generated code\n\n// End of 'RFCOMM_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Layer Function RFCOMM_Layer\n//@{\n///        \\page dxpRFCOMM_Layer\n//@{\n///    \\brief RFCOMM_Layer function model start\nclass cfm_rfcomm_layer : public cf_core::cf_function_container,\n                         public cfm_rfcomm_layer_dp_if {\npublic:\n  /// cfm_rfcomm_layer type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFC_Cdts_t;\n  typedef cf_core::cf_message_queue<cft_defrfcomm_in> mq_RFC_Data_t;\n  typedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFC_Out1_t;\n  typedef cf_core::cf_message_queue<cft_defrfcomm_out> mq_RFC_Out2_t;\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cfm_defobex_in>\n      p_mq_OBEX_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cfm_defobex_out>\n      p_mq_OBEX_Out_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cfm_defrfcomm_in>\n      p_mq_RFCOMM_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_rfcomm_layer, cfm_defrfcomm_out>\n      p_mq_RFCOMM_Out_t;\n  /// cfm_rfcomm_layer type define end\n\n  /// constructor\n  cfm_rfcomm_layer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_rfcomm_layer(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_OBEX_In_t p_mq_OBEX_In;\n  p_mq_OBEX_Out_t p_mq_OBEX_Out;\n  p_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n  p_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_creditsordata *CreditsOrData;\n  cfm_rfcomm_receive *RFCOMM_Receive;\n  cfm_rfcomm_send *RFCOMM_Send;\n  cfm_rfc_out *RFC_Out;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  mq_RFC_Cdts_t mq_RFC_Cdts;\n  mq_RFC_Data_t mq_RFC_Data;\n  mq_RFC_Out1_t mq_RFC_Out1;\n  mq_RFC_Out2_t mq_RFC_Out2;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFCOMM_Layer local declarations' algorithm generated code\n\n  // End of 'RFCOMM_Layer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief RFCOMM_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'CreditsOrData', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Receive', 'type': 'cofluent:Function'}, {'name': 'RFCOMM_Send', 'type': 'cofluent:Function'}, {'name': 'RFC_Out', 'type': 'cofluent:Function'}], 'ports': [{'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In', 'connectTo': ['RFCOMM_Receive']}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out', 'connectTo': ['RFCOMM_Send']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In', 'connectTo': ['CreditsOrData']}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFC_Out']}], 'relations': [{'name': 'RFC_Cdts', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Send', 'CreditsOrData']}, {'name': 'RFC_Data', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_In', 'connectTo': ['RFCOMM_Receive', 'CreditsOrData']}, {'name': 'RFC_Out1', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Receive', 'RFC_Out']}, {'name': 'RFC_Out2', 'type': 'cofluent:MessageQueue', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['RFCOMM_Send', 'RFC_Out']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFCOMM_Layer definitions' algorithm generated code\n\n// End of 'RFCOMM_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_layer ::cfm_rfcomm_layer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_rfcomm_layer_dp_if(),\n      mq_RFC_Cdts(\"RFC_Cdts\"), mq_RFC_Data(\"RFC_Data\"), mq_RFC_Out1(\"RFC_Out1\"),\n      mq_RFC_Out2(\"RFC_Out2\"), p_mq_OBEX_In(\"p_mq_OBEX_In\"),\n      p_mq_OBEX_Out(\"p_mq_OBEX_Out\"), p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\"),\n      p_mq_RFCOMM_Out(\"p_mq_RFCOMM_Out\") {\n  cf_function_container::init();\n  // instantiation of models\n  CreditsOrData = new cfm_creditsordata(\"CreditsOrData\");\n  RFCOMM_Receive = new cfm_rfcomm_receive(\"RFCOMM_Receive\");\n  RFCOMM_Send = new cfm_rfcomm_send(\"RFCOMM_Send\");\n  RFC_Out = new cfm_rfc_out(\"RFC_Out\");\n  // connections\n  // model connect to relation\n  CreditsOrData->p_mq_RFC_Cdts(mq_RFC_Cdts.p_target_socket);\n  CreditsOrData->p_mq_RFC_Data(mq_RFC_Data.p_target_socket);\n  // model connect to port\n  CreditsOrData->p_mq_RFCOMM_In(p_mq_RFCOMM_In);\n  // model connect to relation\n  RFCOMM_Receive->p_mq_RFC_Data(mq_RFC_Data.p_target_socket);\n  RFCOMM_Receive->p_mq_RFC_Out1(mq_RFC_Out1.p_target_socket);\n  // model connect to port\n  RFCOMM_Receive->p_mq_OBEX_In(p_mq_OBEX_In);\n  // model connect to relation\n  RFCOMM_Send->p_mq_RFC_Cdts(mq_RFC_Cdts.p_target_socket);\n  RFCOMM_Send->p_mq_RFC_Out2(mq_RFC_Out2.p_target_socket);\n  // model connect to port\n  RFCOMM_Send->p_mq_OBEX_Out(p_mq_OBEX_Out);\n  // model connect to relation\n  RFC_Out->p_mq_RFC_Out1(mq_RFC_Out1.p_target_socket);\n  RFC_Out->p_mq_RFC_Out2(mq_RFC_Out2.p_target_socket);\n  // model connect to port\n  RFC_Out->p_mq_RFCOMM_Out(p_mq_RFCOMM_Out);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_layer::~cfm_rfcomm_layer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFCOMM_Layer destructor' algorithm generated code\n\n  // End of 'RFCOMM_Layer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete CreditsOrData;\n  delete RFCOMM_Receive;\n  delete RFCOMM_Send;\n  delete RFC_Out;\n}\n\n//@{\nvoid cfm_rfcomm_layer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_rfcomm_layer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BaseBand_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'BB_Receive', 'type': 'cofluent:Function'}, {'name': 'BB_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Receive']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Send']}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In', 'connectTo': ['BB_Receive']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BB_Send']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_baseband_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n\n/// Model Header includes start\n#include \"cfm_bb_receive.h\"\n#include \"cfm_bb_send.h\"\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_baseband_layer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BaseBand_Layer includes' algorithm generated code\n\n// End of 'BaseBand_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBaseBand_Layer Function BaseBand_Layer\n//@{\n///        \\page dxpBaseBand_Layer\n//@{\n///    \\brief BaseBand_Layer function model start\nclass cfm_baseband_layer : public cf_core::cf_function_container,\n                           public cfm_baseband_layer_dp_if {\npublic:\n  /// cfm_baseband_layer type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cfm_defbaseband>\n      p_mq_BaseBand_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cfm_defbaseband>\n      p_mq_BaseBand_Out_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cfm_defl2cap_in>\n      p_mq_L2CAP_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_baseband_layer, cfm_defl2cap_out>\n      p_mq_L2CAP_Out_t;\n  /// cfm_baseband_layer type define end\n\n  /// constructor\n  cfm_baseband_layer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_baseband_layer(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_BaseBand_In_t p_mq_BaseBand_In;\n  p_mq_BaseBand_Out_t p_mq_BaseBand_Out;\n  p_mq_L2CAP_In_t p_mq_L2CAP_In;\n  p_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_bb_receive *BB_Receive;\n  cfm_bb_send *BB_Send;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BaseBand_Layer local declarations' algorithm generated code\n\n  // End of 'BaseBand_Layer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BaseBand_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BASEBAND_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BaseBand_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'BB_Receive', 'type': 'cofluent:Function'}, {'name': 'BB_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Receive']}, {'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand', 'connectTo': ['BB_Send']}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In', 'connectTo': ['BB_Receive']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out', 'connectTo': ['BB_Send']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_baseband_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_baseband_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_baseband_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BaseBand_Layer definitions' algorithm generated code\n\n// End of 'BaseBand_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_baseband_layer ::cfm_baseband_layer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_baseband_layer_dp_if(),\n      p_mq_BaseBand_In(\"p_mq_BaseBand_In\"),\n      p_mq_BaseBand_Out(\"p_mq_BaseBand_Out\"), p_mq_L2CAP_In(\"p_mq_L2CAP_In\"),\n      p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\") {\n  cf_function_container::init();\n  // instantiation of models\n  BB_Receive = new cfm_bb_receive(\"BB_Receive\");\n  BB_Send = new cfm_bb_send(\"BB_Send\");\n  // connections\n  // model connect to port\n  BB_Receive->p_mq_BaseBand_In(p_mq_BaseBand_In);\n  BB_Receive->p_mq_L2CAP_In(p_mq_L2CAP_In);\n  // model connect to port\n  BB_Send->p_mq_BaseBand_Out(p_mq_BaseBand_Out);\n  BB_Send->p_mq_L2CAP_Out(p_mq_L2CAP_Out);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_baseband_layer::~cfm_baseband_layer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BaseBand_Layer destructor' algorithm generated code\n\n  // End of 'BaseBand_Layer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete BB_Receive;\n  delete BB_Send;\n}\n\n//@{\nvoid cfm_baseband_layer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_baseband_layer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'L2CAP_Receive', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out', 'connectTo': ['L2CAP_Send']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['L2CAP_Send']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cfm_l2cap_receive.h\"\n#include \"cfm_l2cap_send.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_layer_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defl2cap_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'L2CAP_Layer includes' algorithm generated code\n\n// End of 'L2CAP_Layer includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Layer Function L2CAP_Layer\n//@{\n///        \\page dxpL2CAP_Layer\n//@{\n///    \\brief L2CAP_Layer function model start\nclass cfm_l2cap_layer : public cf_core::cf_function_container,\n                        public cfm_l2cap_layer_dp_if {\npublic:\n  /// cfm_l2cap_layer type define start\n\n  /// ports typedef\n  // set of port, sort alphabetically, format: cf_type<dataType> port_name\n  typedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cfm_defl2cap_in>\n      p_mq_L2CAP_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cfm_defl2cap_out>\n      p_mq_L2CAP_Out_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cfm_defrfcomm_in>\n      p_mq_RFCOMM_In_t;\n  typedef cf_core::cf_mq_initiator_socket<cfm_l2cap_layer, cfm_defrfcomm_out>\n      p_mq_RFCOMM_Out_t;\n  /// cfm_l2cap_layer type define end\n\n  /// constructor\n  cfm_l2cap_layer(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_l2cap_layer(void);\n\npublic:\n  /// \\name input/output ports\n  //@{\n  // set of port, sort alphabetically. format: port_type port_name\n  p_mq_L2CAP_In_t p_mq_L2CAP_In;\n  p_mq_L2CAP_Out_t p_mq_L2CAP_Out;\n  p_mq_RFCOMM_In_t p_mq_RFCOMM_In;\n  p_mq_RFCOMM_Out_t p_mq_RFCOMM_Out;\n  //@}\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_l2cap_receive *L2CAP_Receive;\n  cfm_l2cap_send *L2CAP_Send;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'L2CAP_Layer local declarations' algorithm generated code\n\n  // End of 'L2CAP_Layer local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief L2CAP_Layer function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_LAYER\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Layer', 'type': 'cofluent:Function', 'models': [{'name': 'L2CAP_Receive', 'type': 'cofluent:Function'}, {'name': 'L2CAP_Send', 'type': 'cofluent:Function'}], 'ports': [{'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out', 'connectTo': ['L2CAP_Send']}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In', 'connectTo': ['L2CAP_Receive']}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out', 'connectTo': ['L2CAP_Send']}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_layer\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_layer.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_bt_stack\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_layer\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'L2CAP_Layer definitions' algorithm generated code\n\n// End of 'L2CAP_Layer definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_layer ::cfm_l2cap_layer()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function_container(name), cfm_l2cap_layer_dp_if(),\n      p_mq_L2CAP_In(\"p_mq_L2CAP_In\"), p_mq_L2CAP_Out(\"p_mq_L2CAP_Out\"),\n      p_mq_RFCOMM_In(\"p_mq_RFCOMM_In\"), p_mq_RFCOMM_Out(\"p_mq_RFCOMM_Out\") {\n  cf_function_container::init();\n  // instantiation of models\n  L2CAP_Receive = new cfm_l2cap_receive(\"L2CAP_Receive\");\n  L2CAP_Send = new cfm_l2cap_send(\"L2CAP_Send\");\n  // connections\n  // model connect to port\n  L2CAP_Receive->p_mq_L2CAP_In(p_mq_L2CAP_In);\n  L2CAP_Receive->p_mq_RFCOMM_In(p_mq_RFCOMM_In);\n  // model connect to port\n  L2CAP_Send->p_mq_L2CAP_Out(p_mq_L2CAP_Out);\n  L2CAP_Send->p_mq_RFCOMM_Out(p_mq_RFCOMM_Out);\n  cf_function_container::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_layer::~cfm_l2cap_layer(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'L2CAP_Layer destructor' algorithm generated code\n\n  // End of 'L2CAP_Layer destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete L2CAP_Receive;\n  delete L2CAP_Send;\n}\n\n//@{\nvoid cfm_l2cap_layer::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_l2cap_layer::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_send_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdataout.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OBEX_Send includes' algorithm generated code\n\n// End of 'OBEX_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Send Function OBEX_Send\n//@{\n///        \\page dxpOBEX_Send\n//@{\n///    \\brief OBEX_Send function model start\nclass cfm_obex_send : public cf_core::cf_function, public cfm_obex_send_dp_if {\npublic:\n  /// cfm_obex_send type define start\n\n  /// constructor\n  cfm_obex_send(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_obex_send(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OBEX_Send local declarations' algorithm generated code\n\n  // End of 'OBEX_Send local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OBEX_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataOut', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefDataOut'}, {'name': 'startEv', 'type': 'EVENT', 'direction': 'IN'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OBEX_Send definitions' algorithm generated code\n\n// End of 'OBEX_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_send ::cfm_obex_send()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_obex_send_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_send::~cfm_obex_send(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OBEX_Send destructor' algorithm generated code\n\n  // End of 'OBEX_Send destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_obex_send::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_obex_send::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OBEX_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_obex_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_obex_receive_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defdatain.h\"\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defreadwrite.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OBEX_Receive includes' algorithm generated code\n\n// End of 'OBEX_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOBEX_Receive Function OBEX_Receive\n//@{\n///        \\page dxpOBEX_Receive\n//@{\n///    \\brief OBEX_Receive function model start\nclass cfm_obex_receive : public cf_core::cf_function,\n                         public cfm_obex_receive_dp_if {\npublic:\n  /// cfm_obex_receive type define start\n\n  /// constructor\n  cfm_obex_receive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_obex_receive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OBEX_Receive local declarations' algorithm generated code\n\n  // End of 'OBEX_Receive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OBEX_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OBEX_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OBEX_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'continueEv', 'type': 'EVENT', 'direction': 'OUT'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}, {'name': 'ReadWrite', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefReadWrite'}, {'name': 'DataIn', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefDataIn'}, {'name': 'WrOK', 'type': 'EVENT', 'direction': 'IN'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_obex_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_obex_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_obex_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OBEX_Receive definitions' algorithm generated code\n\n// End of 'OBEX_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_obex_receive ::cfm_obex_receive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_obex_receive_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_obex_receive::~cfm_obex_receive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OBEX_Receive destructor' algorithm generated code\n\n  // End of 'OBEX_Receive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_obex_receive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_obex_receive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OB_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_ob_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n#define COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_ob_out_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defobex_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OB_Out includes' algorithm generated code\n\n// End of 'OB_Out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOB_Out Function OB_Out\n//@{\n///        \\page dxpOB_Out\n//@{\n///    \\brief OB_Out function model start\nclass cfm_ob_out : public cf_core::cf_function, public cfm_ob_out_dp_if {\npublic:\n  /// cfm_ob_out type define start\n\n  /// constructor\n  cfm_ob_out(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_ob_out(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OB_Out local declarations' algorithm generated code\n\n  // End of 'OB_Out local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OB_Out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_OB_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OB_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'OB_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OB_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_ob_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_ob_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_obex_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_ob_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OB_Out definitions' algorithm generated code\n\n// End of 'OB_Out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_ob_out ::cfm_ob_out()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_ob_out_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_ob_out::~cfm_ob_out(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OB_Out destructor' algorithm generated code\n\n  // End of 'OB_Out destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_ob_out::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_ob_out::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_receive_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defobex_in.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFCOMM_Receive includes' algorithm generated code\n\n// End of 'RFCOMM_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Receive Function RFCOMM_Receive\n//@{\n///        \\page dxpRFCOMM_Receive\n//@{\n///    \\brief RFCOMM_Receive function model start\nclass cfm_rfcomm_receive : public cf_core::cf_function,\n                           public cfm_rfcomm_receive_dp_if {\npublic:\n  /// cfm_rfcomm_receive type define start\n\n  /// constructor\n  cfm_rfcomm_receive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_rfcomm_receive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFCOMM_Receive local declarations' algorithm generated code\n\n  // End of 'RFCOMM_Receive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief RFCOMM_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefOBEX_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFCOMM_Receive definitions' algorithm generated code\n\n// End of 'RFCOMM_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_receive ::cfm_rfcomm_receive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_rfcomm_receive_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_receive::~cfm_rfcomm_receive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFCOMM_Receive destructor' algorithm generated code\n\n  // End of 'RFCOMM_Receive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_rfcomm_receive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_rfcomm_receive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFCOMM_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfcomm_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfcomm_send_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defobex_out.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFCOMM_Send includes' algorithm generated code\n\n// End of 'RFCOMM_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFCOMM_Send Function RFCOMM_Send\n//@{\n///        \\page dxpRFCOMM_Send\n//@{\n///    \\brief RFCOMM_Send function model start\nclass cfm_rfcomm_send : public cf_core::cf_function,\n                        public cfm_rfcomm_send_dp_if {\npublic:\n  /// cfm_rfcomm_send type define start\n\n  /// constructor\n  cfm_rfcomm_send(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_rfcomm_send(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFCOMM_Send local declarations' algorithm generated code\n\n  // End of 'RFCOMM_Send local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief RFCOMM_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFCOMM_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFCOMM_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}, {'name': 'OBEX_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefOBEX_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfcomm_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfcomm_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfcomm_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFCOMM_Send definitions' algorithm generated code\n\n// End of 'RFCOMM_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfcomm_send ::cfm_rfcomm_send()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_rfcomm_send_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfcomm_send::~cfm_rfcomm_send(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFCOMM_Send destructor' algorithm generated code\n\n  // End of 'RFCOMM_Send destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_rfcomm_send::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_rfcomm_send::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'CreditsOrData', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_creditsordata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n#define COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_creditsordata_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defrfcomm_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CreditsOrData includes' algorithm generated code\n\n// End of 'CreditsOrData includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgCreditsOrData Function CreditsOrData\n//@{\n///        \\page dxpCreditsOrData\n//@{\n///    \\brief CreditsOrData function model start\nclass cfm_creditsordata : public cf_core::cf_function,\n                          public cfm_creditsordata_dp_if {\npublic:\n  /// cfm_creditsordata type define start\n\n  /// constructor\n  cfm_creditsordata(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_creditsordata(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CreditsOrData local declarations' algorithm generated code\n\n  // End of 'CreditsOrData local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief CreditsOrData function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_CREDITSORDATA\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'CreditsOrData', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Data', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFC_Cdts', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_creditsordata\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_creditsordata.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_creditsordata\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'CreditsOrData definitions' algorithm generated code\n\n// End of 'CreditsOrData definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_creditsordata ::cfm_creditsordata()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_creditsordata_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_creditsordata::~cfm_creditsordata(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'CreditsOrData destructor' algorithm generated code\n\n  // End of 'CreditsOrData destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_creditsordata::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_creditsordata::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'RFC_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_rfc_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n#define COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_rfc_out_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFC_Out includes' algorithm generated code\n\n// End of 'RFC_Out includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgRFC_Out Function RFC_Out\n//@{\n///        \\page dxpRFC_Out\n//@{\n///    \\brief RFC_Out function model start\nclass cfm_rfc_out : public cf_core::cf_function, public cfm_rfc_out_dp_if {\npublic:\n  /// cfm_rfc_out type define start\n\n  /// constructor\n  cfm_rfc_out(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_rfc_out(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFC_Out local declarations' algorithm generated code\n\n  // End of 'RFC_Out local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief RFC_Out function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_RFC_OUT\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'RFC_Out', 'type': 'cofluent:Function', 'ports': [{'name': 'RFC_Out1', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFC_Out2', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_rfc_out\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_rfc_out.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_rfcomm_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_rfc_out\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'RFC_Out definitions' algorithm generated code\n\n// End of 'RFC_Out definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_rfc_out ::cfm_rfc_out()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_rfc_out_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_rfc_out::~cfm_rfc_out(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'RFC_Out destructor' algorithm generated code\n\n  // End of 'RFC_Out destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_rfc_out::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_rfc_out::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BB_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bb_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bb_receive_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BB_Receive includes' algorithm generated code\n\n// End of 'BB_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBB_Receive Function BB_Receive\n//@{\n///        \\page dxpBB_Receive\n//@{\n///    \\brief BB_Receive function model start\nclass cfm_bb_receive : public cf_core::cf_function,\n                       public cfm_bb_receive_dp_if {\npublic:\n  /// cfm_bb_receive type define start\n\n  /// constructor\n  cfm_bb_receive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_bb_receive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BB_Receive local declarations' algorithm generated code\n\n  // End of 'BB_Receive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BB_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BB_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BB_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bb_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bb_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_baseband_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bb_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BB_Receive definitions' algorithm generated code\n\n// End of 'BB_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bb_receive ::cfm_bb_receive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_bb_receive_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bb_receive::~cfm_bb_receive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BB_Receive destructor' algorithm generated code\n\n  // End of 'BB_Receive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_bb_receive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_bb_receive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'BB_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_bb_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_bb_send_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n#include \"dt/cft_defl2cap_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BB_Send includes' algorithm generated code\n\n// End of 'BB_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgBB_Send Function BB_Send\n//@{\n///        \\page dxpBB_Send\n//@{\n///    \\brief BB_Send function model start\nclass cfm_bb_send : public cf_core::cf_function, public cfm_bb_send_dp_if {\npublic:\n  /// cfm_bb_send type define start\n\n  /// constructor\n  cfm_bb_send(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_bb_send(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BB_Send local declarations' algorithm generated code\n\n  // End of 'BB_Send local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief BB_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_BB_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'BB_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'BaseBand_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefBaseBand'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_bb_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_bb_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_baseband_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_bb_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'BB_Send definitions' algorithm generated code\n\n// End of 'BB_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_bb_send ::cfm_bb_send()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_bb_send_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_bb_send::~cfm_bb_send(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'BB_Send destructor' algorithm generated code\n\n  // End of 'BB_Send destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_bb_send::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_bb_send::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_receive_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defl2cap_in.h\"\n#include \"dt/cft_defrfcomm_in.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'L2CAP_Receive includes' algorithm generated code\n\n// End of 'L2CAP_Receive includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Receive Function L2CAP_Receive\n//@{\n///        \\page dxpL2CAP_Receive\n//@{\n///    \\brief L2CAP_Receive function model start\nclass cfm_l2cap_receive : public cf_core::cf_function,\n                          public cfm_l2cap_receive_dp_if {\npublic:\n  /// cfm_l2cap_receive type define start\n\n  /// constructor\n  cfm_l2cap_receive(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_l2cap_receive(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'L2CAP_Receive local declarations' algorithm generated code\n\n  // End of 'L2CAP_Receive local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief L2CAP_Receive function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_RECEIVE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Receive', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_In', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefRFCOMM_In'}, {'name': 'L2CAP_In', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefL2CAP_In'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_receive\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_receive.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_l2cap_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_receive\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'L2CAP_Receive definitions' algorithm generated code\n\n// End of 'L2CAP_Receive definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_receive ::cfm_l2cap_receive()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_l2cap_receive_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_receive::~cfm_l2cap_receive(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'L2CAP_Receive destructor' algorithm generated code\n\n  // End of 'L2CAP_Receive destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_l2cap_receive::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_l2cap_receive::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'L2CAP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_l2cap_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n#define COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n\n/// Model Header includes start\n#include \"cfm_bluetooth_ips_global.h\"\n#include \"cfm_bluetooth_ips_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_l2cap_send_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defl2cap_out.h\"\n#include \"dt/cft_defrfcomm_out.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'L2CAP_Send includes' algorithm generated code\n\n// End of 'L2CAP_Send includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgL2CAP_Send Function L2CAP_Send\n//@{\n///        \\page dxpL2CAP_Send\n//@{\n///    \\brief L2CAP_Send function model start\nclass cfm_l2cap_send : public cf_core::cf_function,\n                       public cfm_l2cap_send_dp_if {\npublic:\n  /// cfm_l2cap_send type define start\n\n  /// constructor\n  cfm_l2cap_send(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_l2cap_send(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'L2CAP_Send local declarations' algorithm generated code\n\n  // End of 'L2CAP_Send local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief L2CAP_Send function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_BLUETOOTH_IPS_L2CAP_SEND\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'L2CAP_Send', 'type': 'cofluent:Function', 'ports': [{'name': 'RFCOMM_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'IN', 'dataType': 'DefRFCOMM_Out'}, {'name': 'L2CAP_Out', 'type': 'MESSAGE_QUEUE', 'direction': 'OUT', 'dataType': 'DefL2CAP_Out'}], 'globalName': 'Bluetooth_IPs'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_l2cap_send\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of Bluetooth_IPs generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_l2cap_send.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_l2cap_layer\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_l2cap_send\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'L2CAP_Send definitions' algorithm generated code\n\n// End of 'L2CAP_Send definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_l2cap_send ::cfm_l2cap_send()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_l2cap_send_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_l2cap_send::~cfm_l2cap_send(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'L2CAP_Send destructor' algorithm generated code\n\n  // End of 'L2CAP_Send destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_l2cap_send::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_l2cap_send::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'OPP_UseCase', 'models': [{'name': 'Master', 'type': 'cofluent:Function'}, {'name': 'Slave', 'type': 'cofluent:Function'}, {'name': 'StartFunc', 'type': 'cofluent:Function'}, {'name': 'UnusedFunc', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M2S', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'S2M', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'StartEv', 'type': 'cofluent:Event', 'connectTo': ['StartFunc']}, {'name': 'UnusedEv', 'type': 'cofluent:Event', 'connectTo': ['UnusedFunc']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_opp_usecase\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE\n#define COFS_MODEL_OPP_USECASE\n\n/// Model Header includes start\n#include \"cfm_bt_system.h\"\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cfm_startfunc.h\"\n#include \"cfm_unusedfunc.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_opp_usecase_dp_if.h\"\n// set of dataType, sort alphabetically\n#include \"dt/cft_defbaseband.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OPP_UseCase includes' algorithm generated code\n\n// End of 'OPP_UseCase includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgOPP_UseCase Function OPP_UseCase\n//@{\n///        \\page dxpOPP_UseCase\n//@{\n///    \\brief OPP_UseCase function model start\nclass cfm_opp_usecase : public cf_core::cf_application,\n                        public cfm_opp_usecase_dp_if {\npublic:\n  /// cfm_opp_usecase type define start\n  /// relations typedef\n  // set of relation, sort alphabetically. format: cf_type<dataType>\n  // relation_name\n  typedef cf_core::cf_event ev_StartEv_t;\n  typedef cf_core::cf_event ev_UnusedEv_t;\n  typedef cf_core::cf_message_queue<cft_defbaseband> mq_M2S_t;\n  typedef cf_core::cf_message_queue<cft_defbaseband> mq_S2M_t;\n\n  /// cfm_opp_usecase type define end\n\n  /// constructor\n  cfm_opp_usecase(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_opp_usecase(void);\n\npublic:\n  /// \\name functions\n  //@{\n  // set of model, sort alphabetically. format: model_type* model_name\n  cfm_bt_system *Master;\n  cfm_bt_system *Slave;\n  cfm_startfunc *StartFunc;\n  cfm_unusedfunc *UnusedFunc;\n  //@}\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\npublic:\n  /// \\name relations\n  //@{\n  // set of relation, sort alphabetically. format: relation_type relation_name\n  ev_StartEv_t ev_StartEv;\n  ev_UnusedEv_t ev_UnusedEv;\n  mq_M2S_t mq_M2S;\n  mq_S2M_t mq_S2M;\n  //@}\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OPP_UseCase local declarations' algorithm generated code\n\n  // End of 'OPP_UseCase local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief OPP_UseCase function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'OPP_UseCase', 'models': [{'name': 'Master', 'type': 'cofluent:Function'}, {'name': 'Slave', 'type': 'cofluent:Function'}, {'name': 'StartFunc', 'type': 'cofluent:Function'}, {'name': 'UnusedFunc', 'type': 'cofluent:Function'}], 'relations': [{'name': 'M2S', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'S2M', 'type': 'cofluent:MessageQueue', 'dataType': 'DefBaseBand'}, {'name': 'StartEv', 'type': 'cofluent:Event', 'connectTo': ['StartFunc']}, {'name': 'UnusedEv', 'type': 'cofluent:Event', 'connectTo': ['UnusedFunc']}]}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_opp_usecase\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_opp_usecase.h\"\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'OPP_UseCase definitions' algorithm generated code\n\n// End of 'OPP_UseCase definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_opp_usecase ::cfm_opp_usecase()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_application(name), cfm_opp_usecase_dp_if(), ev_StartEv(\"StartEv\"),\n      ev_UnusedEv(\"UnusedEv\"), mq_M2S(\"M2S\"), mq_S2M(\"S2M\") {\n  cf_application::init();\n  // instantiation of models\n  Master = new cfm_master(\"Master\");\n  Slave = new cfm_slave(\"Slave\");\n  StartFunc = new cfm_startfunc(\"StartFunc\");\n  UnusedFunc = new cfm_unusedfunc(\"UnusedFunc\");\n  // connections\n  // model connect to relation\n  StartFunc->p_ev_StartEv(ev_StartEv.p_target_socket);\n  // model connect to relation\n  UnusedFunc->p_ev_UnusedEv(ev_UnusedEv.p_target_socket);\n  cf_application::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_opp_usecase::~cfm_opp_usecase(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'OPP_UseCase destructor' algorithm generated code\n\n  // End of 'OPP_UseCase destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n  // deconstruct for models\n  delete Master;\n  delete Slave;\n  delete StartFunc;\n  delete UnusedFunc;\n}\n\n//@{\nvoid cfm_opp_usecase::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_opp_usecase::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'StartFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'StartEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_startfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE_STARTFUNC\n#define COFS_MODEL_OPP_USECASE_STARTFUNC\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_startfunc_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'StartFunc includes' algorithm generated code\n\n// End of 'StartFunc includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgStartFunc Function StartFunc\n//@{\n///        \\page dxpStartFunc\n//@{\n///    \\brief StartFunc function model start\nclass cfm_startfunc : public cf_core::cf_function, public cfm_startfunc_dp_if {\npublic:\n  /// cfm_startfunc type define start\n\n  /// constructor\n  cfm_startfunc(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_startfunc(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'StartFunc local declarations' algorithm generated code\n\n  // End of 'StartFunc local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief StartFunc function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE_STARTFUNC\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'StartFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'StartEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_startfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_startfunc.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_opp_usecase\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_startfunc\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'StartFunc definitions' algorithm generated code\n\n// End of 'StartFunc definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_startfunc ::cfm_startfunc()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_startfunc_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_startfunc::~cfm_startfunc(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'StartFunc destructor' algorithm generated code\n\n  // End of 'StartFunc destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_startfunc::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_startfunc::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class declarations code of the following CoFLuent sturcture. The output is in c++ header file format.\n{'name': 'UnusedFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'UnusedEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*!\n * \\class cfm_unusedfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for\n * SystemC/TLM2\n */\n#ifndef COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n#define COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n\n/// Model Header includes start\n#include \"cfm_opp_usecase_global.h\"\n#include \"cfm_opp_usecase_global_types.h\"\n#include \"cofluent.h\"\n#include \"dp/cfm_unusedfunc_dp_if.h\"\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UnusedFunc includes' algorithm generated code\n\n// End of 'UnusedFunc includes' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n/// Model Header includes end\n\n///    \\defgroup dxgUnusedFunc Function UnusedFunc\n//@{\n///        \\page dxpUnusedFunc\n//@{\n///    \\brief UnusedFunc function model start\nclass cfm_unusedfunc : public cf_core::cf_function,\n                       public cfm_unusedfunc_dp_if {\npublic:\n  /// cfm_unusedfunc type define start\n\n  /// constructor\n  cfm_unusedfunc(sc_core::sc_module_name name);\n\n  /// destructor\n  virtual ~cfm_unusedfunc(void);\n\npublic:\n  /// \\name input/output ports\n\nprotected:\n  /// initialize attributes\n  void cb_init_attributes(void);\n  /// initialize definitions\n  void cb_init_local_vars(void);\n\n  /// Model private fields start\n  /// Model private fields end\n\n  /// \\name user-defined local declarations\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UnusedFunc local declarations' algorithm generated code\n\n  // End of 'UnusedFunc local declarations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n};\n///    \\brief UnusedFunc function model end\n\n//@}\n//@}\n#endif // COFS_MODEL_OPP_USECASE_UNUSEDFUNC\n\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    },
    {
        "Instruction": "Please act as CoFlunet structure code generator. Please generate the c++ class implementation code of the following CoFLuent sturcture. The output is in c++ cpp file format.\n{'name': 'UnusedFunc', 'type': 'cofluent:Function', 'ports': [{'name': 'UnusedEv', 'type': 'EVENT', 'direction': 'OUT'}], 'globalName': 'OPP_UseCase'}",
        "Response": [
            "//<#!@READ-ONLY-SECTION-START@!#>\n/*\n * \\class cfm_unusedfunc\n * \\brief Intel(R) CoFluent(TM) Studio - Intel Corporation\n * \\details Simulation model of OPP_UseCase generated by C++ Generator for\n * SystemC/TLM2\n */\n/// Model Source includes start\n#include \"cfm_unusedfunc.h\"\n#ifdef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#undef COFLUENT_CONTAINER_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_CONTAINER_FUNCTION_CLASS_NAME cfm_opp_usecase\n#ifdef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#undef COFLUENT_SELF_FUNCTION_CLASS_NAME\n#endif\n#define COFLUENT_SELF_FUNCTION_CLASS_NAME cfm_unusedfunc\n/// Model Source includes end\nusing namespace std;\nusing namespace sc_core;\nusing namespace cf_dt;\nusing namespace cf_pk;\nusing namespace cf_core;\n\n//<#!@READ-ONLY-SECTION-END@!#>\n// Start of 'UnusedFunc definitions' algorithm generated code\n\n// End of 'UnusedFunc definitions' algorithm generated code\n//<#!@READ-ONLY-SECTION-START@!#>\n\n/// \\name constructor\n//@{\ncfm_unusedfunc ::cfm_unusedfunc()\n    : // instantiation of non-vector Event, MessageQueue, SharedVariable\n      cf_function(name), cfm_unusedfunc_dp_if() {\n  cf_function::init();\n  // connections\n  cf_function::elab_end();\n}\n//@}\n\n/// \\name destructor\n//@{\ncfm_unusedfunc::~cfm_unusedfunc(void) {\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'UnusedFunc destructor' algorithm generated code\n\n  // End of 'UnusedFunc destructor' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n\n//@{\nvoid cfm_unusedfunc::cb_init_attributes() {\n\n  // initialize function attributes\n\n  return;\n}\n//@}\n\n//@{\nvoid cfm_unusedfunc::cb_init_local_vars(void) {\n\n  //<#!@READ-ONLY-SECTION-END@!#>\n  // Start of 'Router25 initializations' algorithm generated code\n\n  // End of 'Router25 initializations' algorithm generated code\n  //<#!@READ-ONLY-SECTION-START@!#>\n}\n//@}\n//<#!@READ-ONLY-SECTION-END@!#>"
        ]
    }
]