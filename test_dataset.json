[
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"SoftwareDefinedRadioApp\" constructor=\"\" includes=\"\" postSimulation=\"cf_trace_report(&quot;************************************************************&quot;);&#13;&#10;cf_trace_report(&quot;Frames = %i&quot;, TotalFrames);&#13;&#10;cf_trace_gui_f_param(&quot;Frames&quot;, (int) TotalFrames);&#13;&#10;if(TotalFrames&gt;0){&#13;&#10;cf_trace_report(&quot;AverageFrameLatency = %i ms&quot;, &#13;&#10;&#09;(int) (AverageFrameLatency.to_scalar(CF_MS) / TotalFrames));&#13;&#10;cf_trace_gui_f_param(&quot;AverageFrameLatency&quot;, &#13;&#10;&#09;(int) (AverageFrameLatency.to_scalar(CF_MS) / TotalFrames), &quot;ms&quot;);&#13;&#10;}&#13;&#10;cf_trace_report(&quot;TotalSizeFrames = %i MB&quot;,&#13;&#10;&#09;(int) TotalSizeFrames.to_scalar(CF_MBYTE));&#13;&#10;cf_trace_gui_f_param(&quot;TotalFramesSize&quot;,&#13;&#10;&#09;(int) TotalSizeFrames.to_scalar(CF_MBYTE), &quot;MB&quot;);&#13;&#10;cf_trace_report(&quot;Bursts = %i&quot;, TotalBursts);&#13;&#10;cf_trace_gui_f_param(&quot;Bursts&quot;, (int) TotalBursts);&#13;&#10;if(TotalBursts&gt;0){&#13;&#10;cf_trace_report(&quot;AverageBurstLatency = %i ms&quot;,&#13;&#10;&#09;(int) (AverageBurstLatency.to_scalar(CF_MS) / TotalBursts));&#13;&#10;cf_trace_gui_f_param(&quot;AverageBurstLatency&quot;,&#13;&#10;&#09;(int) (AverageBurstLatency.to_scalar(CF_MS) / TotalBursts), &quot;ms&quot;);&#13;&#10;}&#13;&#10;cf_trace_report(&quot;************************************************************&quot;);\" version=\"5.0.0_alpha2_20130531-1453\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" postElaboration=\"\" globalTypeDeclarations=\"#define BURSTPERIOD 1000&#13;&#10;#define NVIDEO 120&#13;&#10;#define MAXBYTESINFRAME 233280&#13;&#10;typedef int DefVideoIndex;&#13;&#10;typedef int DefBurstsInVideo;&#13;&#10;typedef int DefFramesInBurst;&#13;&#10;typedef enum{NOCASE,CALL,VIDEO} DefUseCase;&#13;&#10;typedef enum{START,STOP,SUSPEND,RESUME,FILEREQUEST,VIDEOREQUEST} DefCommand;&#13;&#10;typedef enum{STARTFILE,ENDFILE,FILEDATA} DefFileInfo;&#13;&#10;typedef enum{BURSTVIDEO, FRAMEVIDEO} DefVideoInfo;\" globalDeclarations=\"extern int TotalBursts;&#13;&#10;extern int TotalFrames;&#13;&#10;extern cf_dt::cf_time AverageBurstLatency;&#13;&#10;extern cf_dt::cf_time AverageFrameLatency;&#13;&#10;extern cf_dt::cf_data_size TotalSizeFrames;&#13;&#10;extern int TabSendBurstSize[48];&#13;&#10;extern int cptSendBurstSize;\" globalDefinitions=\"int TotalBursts = 0;&#13;&#10;int TotalFrames = 0;&#13;&#10;cf_dt::cf_time AverageBurstLatency( 0.0 , CF_US );&#13;&#10;cf_dt::cf_time AverageFrameLatency( 0.0 , CF_US );&#13;&#10;cf_dt::cf_data_size TotalSizeFrames = cf_data_size( 0, CF_BYTE );&#13;&#10;&#13;&#10;int TabSendBurstSize[48]={460000, 2760000, 920000, 4140000, 2760000, 2300000, 1840000, 4140000, 4140000, 3680000, 920000, 4140000, 3680000, 2760000, 1840000, 460000, 460000, 1840000, 920000, 920000, 4600000, 2300000, 920000, 460000, 460000, 1840000, 2760000, 2760000, 3220000, 3220000, 920000, 3220000, 2300000, 1840000, 460000, 3220000, 3680000, 4140000, 2760000, 1840000, 4140000, 3680000, 4600000, 4600000, 2760000, 920000, 2300000, 1380000};&#13;&#10;int cptSendBurstSize=0;\">\n  <dataTypes name=\"DefCall\" definition=\"typedef struct{&#13;&#09;DefUseCase UseCase;&#13;&#09;DefCommand Command;&#13;&#09;DefVideoIndex VideoIndex;&#13;&#09;DefFileInfo FileInfo;&#09;&#13;}DefCall;\" tracePayload=\"    trace &lt;&lt; 0;\" />\n  <dataTypes name=\"DefNet\" definition=\"typedef struct{&#13;&#09;DefVideoIndex VideoIndex;&#13;&#09;DefFramesInBurst FramesInBurst;&#13;&#09;DefBurstsInVideo BurstsInVideo;&#09;&#13;}DefNet;\" tracePayload=\"    trace &lt;&lt; 0;\" />\n  <dataTypes name=\"DefVideo\" definition=\"typedef struct{&#13;&#09;cf_dt::cf_time TimeStampSend;&#13;&#09;cf_dt::cf_time TimeStampGoal; &#09;&#13;&#09;DefVideoInfo VideoInfo;&#13;&#09;DefFramesInBurst FramesInBurst;&#09;&#13;}DefVideo;\" copyPayload=\"\" tracePayload=\"    trace &lt;&lt; 0;\" readTime=\"\" writeTime=\"\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"SoftwareDefinedRadioAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"MobilePhone\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n      <ports name=\"NetToDVB\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"Video\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"NetToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"UMTSToNet\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"Response\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"Request\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"MobilePhoneStructSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"ApplicationLayer\" constructor=\"\" includes=\"\" declarations=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"Video\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"RTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"AppToCtrl\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"HTTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"AppToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"Response\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"Request\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"ApplicationLayerStrucSt\">\n            <models xsi:type=\"cofluent:Function\" name=\"CallApplication\" constructor=\"\" declarations=\"bool SendToCtrl;&#13;bool SendToUser;&#13;bool SendToCallStack;&#13;int FileIndex;\" definitions=\"\" cyclePeriod=\"10 ns\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n              <ports name=\"AppToCtrl\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"HTTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"AppToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"Response\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"Request\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"CallApplicationBehBh\">\n                <statements xsi:type=\"cofluent:Operation\" name=\"Init\" algorithm=\"&#09;SendToUser=false;&#09;&#10;&#09;SendToCtrl=false;&#09;&#10;&#09;SendToCallStack=false;&#09;&#10;&#09;FileIndex=0;\" executionTime=\"10 ms\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop1\" condition=\"\" />\n                <statements xsi:type=\"cofluent:MultipleGuardedStatement\" name=\"MultipleWait\">\n                  <guardedBranches />\n                  <guardedBranches />\n                </statements>\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond1\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"FromUser\" algorithm=\"&#09;SendToUser=false;&#09;&#10;&#09;SendToCtrl=false;&#09;&#10;&#09;SendToCallStack=false;&#09;&#10;&#09;switch(Request.UseCase){&#09;&#09;&#10;&#09;&#09;case NOCASE:&#09;&#09;&#09;&#10;&#09;&#09;&#09;AppToHTTP.Command=Request.Command;&#09;&#09;&#09;&#10;&#09;&#09;&#09;if(Request.Command==FILEREQUEST){&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;cf_trace_report(&quot;App: Received file request&quot;);&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;AppToHTTP.VideoIndex=Request.VideoIndex;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;SendToCallStack=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;}else if (Request.Command==VIDEOREQUEST) {&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;cf_trace_report(&quot;App: Received video request&quot;);&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;AppToHTTP.VideoIndex=Request.VideoIndex;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;SendToCallStack=true;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;AppToCtrl.UseCase=VIDEO;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;AppToCtrl.Command=START;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;SendToCtrl=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;}&#09;&#09;&#09;&#10;&#09;&#09;&#09;break;&#09;&#09;&#10;&#09;&#09;case CALL:&#09;&#09;&#09;&#10;&#09;&#09;&#09;AppToCtrl.UseCase=Request.UseCase;&#09;&#09;&#09;&#10;&#09;&#09;&#09;AppToCtrl.Command=Request.Command;&#09;&#09;&#09;&#10;&#09;&#09;&#09;SendToCtrl=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;break;&#09;&#09;&#10;&#09;&#09;case VIDEO:&#09;&#09;&#09;&#10;&#09;&#09;&#09;AppToCtrl.UseCase=Request.UseCase;&#09;&#09;&#09;&#10;&#09;&#09;&#09;AppToCtrl.Command=Request.Command;&#09;&#09;&#09;&#10;&#09;&#09;&#09;SendToCtrl=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;break;&#09;&#09;&#10;&#09;&#09;default:&#09;&#09;&#09;&#10;&#09;&#09;&#09;break;&#09;&#10;&#09;}\" executionTime=\"20 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond2\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"FromCallStack\" algorithm=\"&#09;SendToUser=false;&#09;&#10;&#09;SendToCtrl=false;&#09;&#10;&#09;SendToCallStack=false;&#09;&#10;&#09;if(HTTPToApp.FileInfo==STARTFILE){&#09;&#09;&#10;&#09;&#09;FileIndex=0;&#09;&#10;&#09;}else if(HTTPToApp.FileInfo==FILEDATA){&#09;&#09;&#10;&#09;&#09;FileIndex++;&#09;&#10;&#09;}else if(HTTPToApp.FileInfo==ENDFILE){&#09;&#09;&#10;&#09;&#09;SendToUser=true;&#09;&#09;&#10;&#09;&#09;FileIndex=0;&#09;&#10;&#09;}\" executionTime=\"20 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action1\" duration=\" us\" condition=\"SendToCallStack\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action2\" duration=\" us\" condition=\"SendToUser\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action11\" duration=\" us\" condition=\"SendToCtrl\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"VideoApplication\" declarations=\"cf_dt::cf_data_size SizeFrame;\" definitions=\"\" cyclePeriod=\"10 ns\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n              <ports name=\"Video\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"RTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"VideoApplicationBehaviorBh\">\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond21\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop25\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"Display\" algorithm=\"&#09;SizeFrame=RTPToApp_trans.get_user_data_length(); &#10;&#09;TotalSizeFrames+=SizeFrame;&#09;&#10;&#09;TotalFrames++;&#09;&#09;\" executionTime=\"5 ms\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action32\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n              </refinement>\n            </models>\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"CallProtocolStack\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"NetToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"UMTSToNet\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"HTTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"AppToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"CallProtocolStackStrucSt\">\n            <models xsi:type=\"cofluent:Function\" name=\"HTTPTCP\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n              <ports name=\"IPToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"HTTPToIP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"HTTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"AppToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"HTTPTCPStrucSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"HTTPTCP_Send\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" affinity=\"\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"HTTPToIP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"AppToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"HTTPTCP_SBBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop2\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond3\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"UpHTTP\" algorithm=\"&#09;HTTPToIP=AppToHTTP;\" executionTime=\"30 ms\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action3\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"HTTPTCP_Receive\" includes=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"IPToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"HTTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"HTTPTCP_RBBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop3\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond4\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"DownHTTP\" algorithm=\"&#09;HTTPToApp=IPToHTTP;\" executionTime=\"30 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action5\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"IPCall\" includes=\"\" declarations=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n              <ports name=\"UMTSToIP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"IPToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"IPToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"HTTPToIP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"IPCallStrucSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"IPCall_Send\" includes=\"\" initializations=\"\" cyclePeriod=\"10 ns\" scope=\"ENVIRONMENT\" doNotStart=\"true\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"IPToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"HTTPToIP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"IPCall_SendBehBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop4\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond5\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"UpIP\" algorithm=\"&#09;IPToUMTS=HTTPToIP;\" executionTime=\"30 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action6\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"IPCall_Receive\" includes=\"\" declarations=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" affinity=\"\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"UMTSToIP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"IPToHTTP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"IPCall_RecBehBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop5\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond6\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"DownIP\" algorithm=\"&#09;IPToHTTP=UMTSToIP;\" executionTime=\"30 ms\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action7\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"UMTS\" includes=\"\" cyclePeriod=\"10 ns\">\n              <ports name=\"UMTSToIP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"NetToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"UMTSToNet\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"IPToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"UMTSStrucSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"UMTS_Send\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" affinity=\"\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"IPToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"UMTSToNet\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"UMTS_SendBehBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop41\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond40\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"UpUMTS\" algorithm=\"&#09;UMTSToNet=IPToUMTS;\" executionTime=\"30 ms\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action54\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"UMTS_Receive\" constructor=\"\" includes=\"\" declarations=\"\" initializations=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" affinity=\"\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"UMTSToIP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"NetToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"UMTS_RecBehBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop42\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond41\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"DownUMTS\" algorithm=\"&#09;UMTSToIP=NetToUMTS;\" executionTime=\"30 ms\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action55\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n              </refinement>\n            </models>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"HTTPToIP\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"IPToHTTP\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"IPToUMTS\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"UMTSToIP\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"VideoProtocolStack\" constructor=\"\" declarations=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"NetToDVB\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"RTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"VideoProtocolStackStrucSt\">\n            <models xsi:type=\"cofluent:Function\" name=\"RTPUDP\" constructor=\"\" declarations=\"int SyncFramesDuration;&#13;int DelayDuration;&#13;int FramesInBurst;&#13;int TimeDifference;\" definitions=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" priority=\"2\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n              <ports name=\"RTPToApp\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"IPToRTP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"RTPUDPBehaviorBh\">\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond18\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop23\" condition=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action29\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"SyncFrames\" algorithm=\"&#09;RTPToApp_trans=IPToRTP_trans;&#09;&#10;&#09;RTPToApp_trans.set_user_data_length(IPToRTP_trans.get_user_data_length());&#10;&#09;TimeDifference=(int)IPToRTP.TimeStampGoal.to_scalar(CF_MS)-(int)cf_time_stamp().to_scalar(CF_MS);&#09;&#10;&#09;if(TimeDifference&gt;0){&#09;&#09;&#10;&#09;&#09;wait(TimeDifference,SC_MS);&#09;&#10;&#09;}&#09;&#10;&#09;SyncFramesDuration=20000;//us&#09;&#10;&#09;AverageFrameLatency+=cf_dt::cf_time(cf_time_stamp().to_scalar(CF_MS)-IPToRTP.TimeStampSend.to_scalar(CF_MS), CF_MS);&#09;&#09;\" executionTime=\"SyncFramesDuration us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"Delay\" algorithm=\"&#09;DelayDuration=((BURSTPERIOD*1000)/IPToRTP.FramesInBurst)-(SyncFramesDuration+200);//us\" executionTime=\"DelayDuration us\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" type=\"PASSIVE\" dynamicResourceLoad=\"\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"IPVideo\" constructor=\"\" declarations=\"int FramesInBurst;&#13;int IndexFrame;&#13;int TimeDifference;&#13;int Size;\" definitions=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n              <ports name=\"IPToRTP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"MPEToIP\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"IPVideoBehaviorBh\">\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop20\" condition=\"\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond16\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop21\" condition=\"FramesInBurst\" type=\"MULTIPLICATION\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"ExtractFrames\" algorithm=\"&#09;IndexFrame++;&#09;&#10;&#09;IPToRTP_trans.set_user_data_length( cf_data_size( (cf_dt::cf_data_size_st)Size,&#09;CF_BYTE));&#09;&#10;&#09;IPToRTP.VideoInfo=FRAMEVIDEO;&#09;&#10;&#09;IPToRTP.FramesInBurst=MPEToIP.FramesInBurst;&#09;&#10;&#09;IPToRTP.TimeStampGoal=cf_dt::cf_time(MPEToIP.TimeStampGoal.to_scalar(CF_MS)+(IndexFrame*1000/FramesInBurst)+BurstSyncDelay*1000,CF_MS);&#09;&#10;&#09;IPToRTP.TimeStampSend=cf_dt::cf_time(cf_time_stamp().to_scalar(CF_MS), CF_MS);&#09;&#10;&#09;TimeDifference= (int)MPEToIP.TimeStampGoal.to_scalar(CF_MS)-(int)cf_time_stamp().to_scalar(CF_MS);&#09;&#10;&#09;if(TimeDifference&gt;0){&#09;&#09;&#10;&#09;&#09;cf_wait(TimeDifference,CF_MS);&#09;&#10;&#09;}&#09;&#09;\" executionTime=\"2 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action28\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"GetFramesNumber\" algorithm=\"&#09;FramesInBurst=MPEToIP.FramesInBurst;&#09;&#10;&#09;Size=(int)(((MPEToIP_trans.get_user_data_length().to_scalar(CF_BYTE))/FramesInBurst)*10);&#10;&#09;IndexFrame=0;\" executionTime=\"10 us\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"MPETSL\" declarations=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" priority=\"1\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n              <ports name=\"NetToDVB\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"MPEToIP\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"MPETSLBehaviorBh\">\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop19\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"GetBurst\" algorithm=\"&#09;MPEToIP_trans=NetToDVB_trans;&#10;&#09;MPEToIP_trans.set_user_data_length(NetToDVB_trans.get_user_data_length());&#10;&#09;AverageBurstLatency+=cf_dt::cf_time(cf_time_stamp().to_scalar(CF_MS)-NetToDVB.TimeStampSend.to_scalar(CF_MS), CF_MS);&#09;&#10;&#09;TotalBursts++;\" executionTime=\"100 ms\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action25\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond17\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n              </refinement>\n            </models>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MPEToIP\" capacity=\"BurstBufferSize\" concurrency=\"1\" sendTime=\"1 ms\" receiveTime=\"1 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"IPToRTP\" capacity=\"FramesBufferSize\" concurrency=\"1\" sendTime=\"100 us\" receiveTime=\"100 us\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Controller\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"bool SendToCallStack;&#13;bool SendToVideoStack;\" initializations=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n          <ports name=\"AppToCtrl\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"ControllerBehaviorBh\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop10\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"DynamicControl\" algorithm=\"&#09;cf_beh_handle CtrlToCallStack_trans(&quot;/SoftwareDefinedRadioApp/MobilePhone/CallProtocolStack&quot;);&#10;&#09;cf_beh_handle CtrlToVideoStack_trans(&quot;/SoftwareDefinedRadioApp/MobilePhone/VideoProtocolStack&quot;);&#10;&#09;&#10;&#09;SendToCallStack =false;&#09;&#10;&#09;SendToVideoStack=false;&#09;&#10;&#09;switch(AppToCtrl.UseCase){&#09;&#09;&#10;&#09;&#09;case CALL:&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;switch(AppToCtrl.Command){&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;case START:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;CtrlToCallStack_trans.start();&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Ctrl: Start CallStack&quot;);&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;SendToCallStack=true;&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;case STOP:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;CtrlToCallStack_trans.stop();&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Ctrl: Stop CallStack&quot;);&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;SendToCallStack=true;&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;case RESUME:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;CtrlToCallStack_trans.resume();&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Ctrl: Resume CallStack&quot;);&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;SendToCallStack=true;&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;default:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#10;&#09;&#09;&#09;}&#09;&#09;&#10;&#09;&#09;case VIDEO:&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;switch(AppToCtrl.Command){&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;case START:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;CtrlToVideoStack_trans.start();&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Ctrl: Start VideoStack&quot;);&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;SendToVideoStack=true;&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;case STOP:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;CtrlToVideoStack_trans.stop();&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Ctrl: Stop VideoStack&quot;);&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;SendToVideoStack=true;&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;case RESUME:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;CtrlToVideoStack_trans.resume();&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Ctrl: Resume VideoStack&quot;);&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;SendToVideoStack=true;&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;default:&#09;&#09;&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;&#09;break;&#09;&#09;&#09;&#10;&#09;&#09;&#09;}&#09;&#09;&#10;&#09;&#09;&#09;default:&#09;&#09;&#09;&#10;&#09;&#09;&#09;&#09;break;&#09;&#10;&#09;&#09;}\" executionTime=\"10 ms\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"Cond10\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"AppToHTTP\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"HTTPToApp\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"AppToCtrl\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"RTPToApp\" capacity=\"1\" concurrency=\"1\" sendTime=\"100 us\" receiveTime=\"1 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Networks\" includes=\"\" declarations=\"DefNet initSem;\" initializations=\"sv_VideoFiles.init_value(initSem);\" cyclePeriod=\"10 ns\">\n      <ports name=\"NetToDVB\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"NetToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"UMTSToNet\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"NetworksStrucSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"InteractiveNetwork\" constructor=\"\" declarations=\"int StartSize;&#13;int EndSize;&#13;int FileSize;&#13;&#13;bool FileRequest;&#13;bool ExitLoop;&#13;bool Sending;&#13;bool FullLink;&#13;bool ExitWaiting;&#13;&#13;int VideoIndex;&#13;int index;&#13;int VideoSendIndex;&#13;&#13;DefVideoIndex VideoInd[4];&#13;DefFramesInBurst FramesInBurst[4];&#13;DefBurstsInVideo BurstsInVideo[4];\" definitions=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"VideoFiles\" type=\"SHARED_VARIABLE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"VideoNet\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"NetToUMTS\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"UMTSToNet\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"IntNetBehBh\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop8\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"Cond9\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"GetRequest\" algorithm=\"&#09;VideoIndex=0;&#09;&#10;&#09;FileRequest=false;&#09;&#10;&#09;Sending=true;&#09;&#10;&#09;ExitLoop=false;&#09;&#10;&#09;if(UMTSToNet.Command == FILEREQUEST){&#09;&#09;&#10;&#09;&#09;FileRequest=true;&#09;&#09;&#10;&#09;&#09;cf_trace_report(&quot;INet: Received file request&quot;);&#09;&#10;&#09;}else{&#10;&#09;&#09;cf_trace_report(&quot;INet: FileRequest=false&quot;);&#09;&#09;&#09;&#10;&#09;&#09;VideoIndex=VideoInd[VideoSendIndex];&#09;&#09;&#10;&#09;&#09;VideoNet.VideoIndex=VideoIndex;&#10;&#09;&#09;VideoNet.BurstsInVideo=BurstsInVideo[VideoSendIndex];&#09;&#09;&#10;&#09;&#09;VideoNet.FramesInBurst=FramesInBurst[VideoSendIndex];&#09;&#09;&#10;&#09;&#09;VideoSendIndex++;&#09;&#10;&#09;}\" executionTime=\"10 ms\" />\n            <statements xsi:type=\"cofluent:AlternativeStatement\">\n              <conditionalBranches condition=\"\" />\n              <conditionalBranches condition=\"FileRequest==true\" />\n            </statements>\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop9\" condition=\"ExitLoop==false\" type=\"CONDITIONAL\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"SendFile\" algorithm=\"&#09;if(VideoIndex==0){&#09;&#09;&#10;&#09;&#09;NetToUMTS.FileInfo=STARTFILE;&#09;&#10;&#09;}else if(VideoIndex&lt;=NVIDEO){&#09;&#09;&#10;&#09;&#09;NetToUMTS.FileInfo=FILEDATA;&#09;&#10;&#09;}else{&#09;&#09;&#10;&#09;&#09;NetToUMTS.FileInfo=ENDFILE;&#09;&#09;&#10;&#09;&#09;ExitLoop=true;  &#09;&#09;&#10;&#09;&#09;cf_trace_report(&quot;INet: File sent&quot;);&#09;&#10;&#09;}&#09;&#10;&#09;VideoIndex++;\" executionTime=\"10 ms\" systematicRead=\"true\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"ActionFile\" duration=\" us\" condition=\"Sending\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Init\" algorithm=\"&#09;FileRequest=false;&#09;&#10;&#09;VideoIndex=0;&#09;&#10;&#09;StartSize=400000;&#09;&#10;&#09;EndSize=400000;&#09;&#10;&#09;FileSize=1000000;&#09;&#10;&#09;VideoSendIndex=0;&#09;&#09;&#10;&#09;VideoInd[0]=0; &#10;&#09;FramesInBurst[0]=FramesPerSecond; &#10;&#09;BurstsInVideo[0]=32;&#09;&#09;&#10;&#09;VideoInd[1]=1; &#10;&#09;FramesInBurst[1]=FramesPerSecond; &#10;&#09;BurstsInVideo[1]=16;&#09;&#10;&#09;VideoInd[2]=2; &#10;&#09;FramesInBurst[2]=FramesPerSecond; &#10;&#09;BurstsInVideo[2]=23;&#09;&#10;&#09;VideoInd[3]=3; &#10;&#09;FramesInBurst[3]=FramesPerSecond; &#10;&#09;BurstsInVideo[3]=33;&#09;\" executionTime=\"10 ms\" systematicWrite=\"true\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"Action15\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"DelaySend\" algorithm=\"\" executionTime=\"30 ms\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"CheckFull\" algorithm=\"&#09;FullLink=false;&#09;&#10;&#09;index=0;&#09;&#10;&#09;if( p_mq_NetToUMTS.is_full() ){&#09;&#09;&#10;&#09;&#09;FullLink=true;&#09;&#09;&#10;&#09;&#09;ExitWaiting=false;&#09;&#09;&#10;&#09;}\" executionTime=\"10 ms\" />\n            <statements xsi:type=\"cofluent:AlternativeStatement\">\n              <conditionalBranches condition=\"FullLink==true\" />\n              <conditionalBranches condition=\"\" />\n            </statements>\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop40\" condition=\"ExitWaiting==false\" type=\"CONDITIONAL\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Waiting\" algorithm=\"&#09;Sending=false;&#09;&#10;&#09;ExitWaiting=false;&#09;&#10;&#09;ExitLoop=false;&#09;&#10;&#09;if( p_mq_NetToUMTS.is_full()){&#09;&#09;&#10;&#09;&#09;index++;&#09;&#09;&#10;&#09;&#09;if(index==CallTimeout){&#09;&#09;&#09;&#10;&#09;&#09;&#09;ExitWaiting=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;ExitLoop=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;p_mq_NetToUMTS.flush(); &#09;&#09;&#09;&#10;&#09;&#09;&#09;cf_trace_report(&quot;INet: TimeOut&quot;);&#09;&#09;&#10;&#09;&#09;}&#09;&#09;&#10;&#09;}else{&#09;&#09;&#10;&#09;&#09;ExitWaiting=true;&#09;&#09;&#10;&#09;&#09;Sending=true;&#09;&#09;&#10;&#09;&#09;if(VideoIndex==0){&#09;&#09;&#09;&#10;&#09;&#09;&#09;NetToUMTS.FileInfo=STARTFILE;&#09;&#09;&#10;&#09;&#09;}else if(VideoIndex&lt;=NVIDEO){&#09;&#09;&#09;&#10;&#09;&#09;&#09;NetToUMTS.FileInfo=FILEDATA;&#09;&#09;&#10;&#09;&#09;}else{&#09;&#09;&#09;&#10;&#09;&#09;&#09;NetToUMTS.FileInfo=ENDFILE;&#09;&#09;&#09;&#10;&#09;&#09;&#09;ExitLoop=true;  &#09;&#09;&#09;&#10;&#09;&#09;&#09;cf_trace_report(&quot;INet: File sent&quot;);&#09;&#09;&#10;&#09;&#09;}&#09;&#09;&#10;&#09;&#09;VideoIndex++;&#09;&#09;&#10;&#09;}\" executionTime=\"1 s\" systematicRead=\"true\" type=\"PASSIVE\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"Action53\" duration=\" us\" condition=\"Sending\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"BroadcastNetwork\" constructor=\"\" includes=\"\" declarations=\"bool ExitBurstLoop;&#13;bool FullLink;&#13;bool ExitWaiting;&#13;bool SendWaiting;&#13;int IndexBurst;&#13;int BurstSize;&#13;int IndexWaiting;&#13;int FramesInBurst;&#13;int BurstsInVideo;&#13;bool Init;\" definitions=\"\" initializations=\"Init=true;\" cyclePeriod=\"10 ns\">\n          <ports name=\"NetToDVB\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"BurstClock\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"VideoFiles\" type=\"SHARED_VARIABLE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"VideoNet\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"BroadcastNetBehBh\">\n            <statements xsi:type=\"cofluent:InputAction\" name=\"Cond11\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop12\" condition=\"ExitBurstLoop==false\" type=\"CONDITIONAL\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop15\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"ActionReady\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"Cond22\" timeout=\" ms\" priority=\"\" duration=\" us\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Begin\" algorithm=\"&#09;cf_beh_handle CtrlClk_trans(&quot;/SoftwareDefinedRadioApp/Networks/ClockGenerator&quot;);&#10;&#09;&#10;&#09;ExitBurstLoop=false;&#09;&#10;&#09;IndexBurst = 0;&#09;&#10;&#09;FramesInBurst=VideoNet.FramesInBurst;&#09;&#10;&#09;BurstsInVideo=VideoNet.BurstsInVideo;&#09;&#10;&#09;CtrlClk_trans.start();&#10;&#09;cf_trace_report(&quot;BNet: Sending video %i (%i im/s)&quot;, VideoNet.VideoIndex, VideoNet.FramesInBurst);\" executionTime=\"10 ms\" systematicRead=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"SendBurst\" algorithm=\"&#09;if(DATA==RAND)&#10;&#09;{&#10;&#09;&#09;BurstSize=(int)((MAXBYTESINFRAME/10000)*cf_util_rand_int(1,10)*FramesInBurst*BURSTPERIOD);&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;BurstSize=TabSendBurstSize[cptSendBurstSize];&#10;&#09;&#09;cptSendBurstSize++;&#10;&#09;}&#09;&#10;&#09;&#10;&#09;NetToDVB_trans.set_user_data_length(cf_data_size((cf_dt::cf_data_size_st)BurstSize,CF_BYTE)); &#09;&#10;&#09;NetToDVB.TimeStampSend=cf_dt::cf_time(cf_time_stamp().to_scalar(CF_MS), CF_MS); &#09;&#10;&#09;NetToDVB.TimeStampGoal=cf_dt::cf_time(cf_time_stamp().to_scalar(CF_MS)+BurstSyncDelay*1000,CF_MS);&#09;&#10;&#09;NetToDVB.VideoInfo=BURSTVIDEO;&#09;&#10;&#09;NetToDVB.FramesInBurst=FramesInBurst;&#09;&#10;&#09;IndexBurst++;&#09;&#10;&#09;if(IndexBurst==BurstsInVideo){&#09;&#09;&#10;&#09;&#09;ExitBurstLoop=true;&#09;&#09;&#10;&#09;&#09;cf_trace_report(&quot;BNet: sent video&quot;);&#09;&#10;&#09;}\" executionTime=\"10 ms\" systematicRead=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"End\" algorithm=\"&#09;cf_beh_handle CtrlClk_trans(&quot;/SoftwareDefinedRadioApp/Networks/ClockGenerator&quot;);&#10;&#09;CtrlClk_trans.stop();\" executionTime=\"10 us\" />\n            <statements xsi:type=\"cofluent:AlternativeStatement\">\n              <conditionalBranches condition=\"\" />\n              <conditionalBranches condition=\"FullLink==true\" />\n            </statements>\n            <statements xsi:type=\"cofluent:Operation\" name=\"CheckFull\" algorithm=\"&#09;ExitWaiting=false;&#09;&#10;&#09;IndexWaiting=0;&#09;&#10;&#09;FullLink= p_mq_NetToDVB.is_full();\" executionTime=\"10 us\" systematicRead=\"true\" systematicWrite=\"true\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop39\" condition=\"ExitWaiting==false\" type=\"CONDITIONAL\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Waiting\" algorithm=\"&#09;SendWaiting=false;&#09;&#10;&#09;FullLink= p_mq_NetToDVB.is_full();&#09;&#10;&#09;if(FullLink) {&#09;&#09;&#10;&#09;&#09;IndexWaiting++;&#09;&#09;&#10;&#09;&#09;if(IndexWaiting==VideoTimeout){&#09;&#09;&#09;&#10;&#09;&#09;&#09;p_mq_NetToDVB.flush(); &#09;&#09;&#09;&#10;&#09;&#09;&#09;ExitWaiting=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;ExitBurstLoop=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;cf_trace_report(&quot;BNet: TimeOut&quot;);&#09;&#09;&#10;&#09;&#09;}&#09;&#10;&#09;}else{&#09;&#09;&#10;&#09;&#09;IndexBurst++;&#09;&#09;&#10;&#09;&#09;BurstSize=(int)((MAXBYTESINFRAME/10000)*cf_util_rand_int(1,10)*FramesInBurst*BURSTPERIOD);&#09;&#10;&#09;&#09;NetToDVB_trans.set_user_data_length(cf_data_size((cf_dt::cf_data_size_st)BurstSize,CF_BYTE));&#09;&#09;&#10;&#09;&#09;NetToDVB.TimeStampGoal=cf_dt::cf_time(cf_time_stamp().to_scalar(CF_MS)+BurstSyncDelay*1000,CF_MS);&#09;&#09;&#10;&#09;&#09;NetToDVB.VideoInfo=BURSTVIDEO;&#09;&#09;&#10;&#09;&#09;NetToDVB.FramesInBurst=FramesInBurst;&#09;&#09;&#10;&#09;&#09;SendWaiting=true;&#09;&#09;&#10;&#09;&#09;ExitWaiting=true;&#09;&#09;&#10;&#09;&#09;if(IndexBurst==BurstsInVideo){&#09;&#09;&#09;&#10;&#09;&#09;&#09;ExitBurstLoop=true;&#09;&#09;&#09;&#10;&#09;&#09;&#09;cf_trace_report(&quot;BNet: sent video&quot;);&#09;&#09;&#10;&#09;&#09;}&#09;&#10;&#09;}\" executionTime=\"10 us\" systematicRead=\"true\" systematicWrite=\"true\" type=\"PASSIVE\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"Cond39\" timeout=\" ms\" priority=\"\" duration=\" us\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"ActionWaiting\" duration=\" us\" condition=\"SendWaiting\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"ClockGenerator\" constructor=\"\" includes=\"\" declarations=\"\" initializations=\"\" cyclePeriod=\"10 ns\" doNotStart=\"true\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n          <ports name=\"BurstClock\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"ClockGenBehBh\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop13\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"BurstDelay1\" algorithm=\"\" executionTime=\"BURSTPERIOD* 10/ 100 ms\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"Action21\" duration=\" us\" condition=\"\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"BurstDelay2\" algorithm=\"\" executionTime=\"BURSTPERIOD* 90/ 100 ms\" systematicRead=\"true\" systematicWrite=\"true\" type=\"PASSIVE\" />\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"VideoNet\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"VideoFiles\" concurrency=\"1\" counter=\"\" writeTime=\"10 ms\" readTime=\"10 ms\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:Event\" name=\"BurstClock\" policy=\"FUGITIVE\" setTime=\"0 ms\" getTime=\"0 ms\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"User\" includes=\"\" declarations=\"\" definitions=\"\" cyclePeriod=\"10 ns\">\n      <ports name=\"Video\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"Response\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"Request\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"UserStrucSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"Requesting\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"int Index;&#13;double UserDelay;&#13;&#13;double Delay[13];&#13;DefUseCase UseCase[13];&#13;DefCommand Command[13];\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n          <ports name=\"Request\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"RequestingBehBh\" documentation=\"\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop0\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"SendRequest\" algorithm=\"&#09;UserDelay &#09;&#09;= Delay[Index];&#09;&#10;&#09;Request.UseCase&#09;= UseCase[Index];&#09;&#10;&#09;Request.Command&#09;= Command[Index];&#09;&#10;&#09;if(Scenario==BothStatic){&#09;&#09;&#10;&#09;&#09;Index = (Index + 1) % 4;&#09;&#10;&#09;}else if(Scenario==DynamicVideo){&#09;&#09;&#10;&#09;&#09;Index = (Index + 1) % 11;&#09;&#10;&#09;}else if(Scenario==DynamicCall){&#09;&#09;&#10;&#09;&#09;Index = (Index + 1) % 11;&#09;&#10;&#09;}else if(Scenario==BothDynamic){&#09;&#09;&#10;&#09;&#09;Index = (Index + 1) % 13;&#09;&#10;&#09;}\" executionTime=\"UserDelay s\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"Action0\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Init\" algorithm=\"&#09;Index=0;&#09;&#10;&#09;if(Scenario==BothStatic){&#09;&#10;&#09;&#09;Delay[0] =19.0;&#09;&#09;&#10;&#09;&#09;UseCase[0] =CALL; &#09;&#10;&#09;&#09;Command[0] =START;&#09;&#10;&#09;&#09;Delay[1] =23.0;&#09;&#09;&#10;&#09;&#09;UseCase[1] =NOCASE;&#09;&#10;&#09;&#09;Command[1] =FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[2] =68.0;&#09;&#09;&#10;&#09;&#09;UseCase[2] =NOCASE;&#09;&#10;&#09;&#09;Command[2] =FILEREQUEST;&#09;&#10;&#09;&#09;Delay[3] =100.0;&#09;&#10;&#09;&#09;UseCase[3] =CALL;&#09;&#10;&#09;&#09;Command[3] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[4] =10000.0;&#09;&#10;&#09;&#09;UseCase[4] =NOCASE;&#09;&#10;&#09;&#09;Command[4] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[5] =10000.0;&#09;&#10;&#09;&#09;UseCase[5] =NOCASE;&#09;&#10;&#09;&#09;Command[5] =STOP;&#09;&#10;&#09;&#09;Delay[6] =10000.0;&#09;&#10;&#09;&#09;UseCase[6] =NOCASE;&#09;&#10;&#09;&#09;Command[6] =STOP;&#09;&#09;&#09;&#10;&#09;&#09;Delay[7] =10000.0;&#09;&#10;&#09;&#09;UseCase[7] =NOCASE;&#09;&#10;&#09;&#09;Command[7] =STOP;&#09;&#10;&#09;&#09;Delay[8] =10000.0;&#09;&#10;&#09;&#09;UseCase[8] =NOCASE;&#09;&#10;&#09;&#09;Command[8] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[9] =10000.0;&#09;&#10;&#09;&#09;UseCase[9] =NOCASE;&#09;&#10;&#09;&#09;Command[9] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[10]=10000.0;&#09;&#10;&#09;&#09;UseCase[10]=NOCASE;&#09;&#10;&#09;&#09;Command[10]=STOP;&#09;&#09;&#09;&#10;&#09;&#09;Delay[11]=10000.0;&#09;&#10;&#09;&#09;UseCase[11]=NOCASE;&#09;&#10;&#09;&#09;Command[11]=STOP;&#09;&#09;&#10;&#09;&#09;Delay[12]=10000.0;&#09;&#10;&#09;&#09;UseCase[12]=NOCASE;&#09;&#10;&#09;&#09;Command[12]=STOP;&#09;&#10;&#09;}else if(Scenario==DynamicVideo){&#09;&#09;&#10;&#09;&#09;Delay[0] =6.0;&#09;&#09;&#10;&#09;&#09;UseCase[0] =CALL; &#09;&#10;&#09;&#09;Command[0] =START;&#09;&#09;&#10;&#09;&#09;Delay[1] =11.0;&#09;&#09;&#10;&#09;&#09;UseCase[1] =NOCASE;&#09;&#10;&#09;&#09;Command[1] =FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[2] =25.6;&#09;&#09;&#10;&#09;&#09;UseCase[2] =VIDEO;&#09;&#10;&#09;&#09;Command[2] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[3] =5.3;&#09;&#09;&#10;&#09;&#09;UseCase[3] =VIDEO;&#09;&#10;&#09;&#09;Command[3] =RESUME;&#09;&#09;&#10;&#09;&#09;Delay[4] =4.6;&#09;&#09;&#10;&#09;&#09;UseCase[4] =VIDEO;&#09;&#10;&#09;&#09;Command[4] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[5] =7.2;&#09;&#09;&#10;&#09;&#09;UseCase[5] =VIDEO;&#09;&#10;&#09;&#09;Command[5] = RESUME;&#09;&#09;&#10;&#09;&#09;Delay[6] =26.0;&#09;&#09;&#10;&#09;&#09;UseCase[6] =NOCASE;&#09;&#10;&#09;&#09;Command[6] =FILEREQUEST;&#09;&#09;&#09;&#10;&#09;&#09;Delay[7] =20.1;&#09;&#09;&#10;&#09;&#09;UseCase[7] =VIDEO;&#09;&#10;&#09;&#09;Command[7] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[8] =8.5;&#09;&#09;&#10;&#09;&#09;UseCase[8] =VIDEO;&#09;&#10;&#09;&#09;Command[8] =RESUME;&#09;&#09;&#10;&#09;&#09;Delay[9] =3.6;&#09;&#09;&#10;&#09;&#09;UseCase[9] =VIDEO;&#09;&#10;&#09;&#09;Command[9] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[10]=100.0;&#09;&#10;&#09;&#09;UseCase[10]=VIDEO;&#09;&#10;&#09;&#09;Command[10]=START;&#09;&#09;&#09;&#10;&#09;&#09;Delay[11]=10000.0;&#09;&#10;&#09;&#09;UseCase[11]=NOCASE;&#09;&#10;&#09;&#09;Command[11]=STOP;&#09;&#09;&#10;&#09;&#09;Delay[12]=10000.0;&#09;&#10;&#09;&#09;UseCase[12]=NOCASE;&#09;&#10;&#09;&#09;Command[12]=STOP;&#09;&#10;&#09;}else if(Scenario==DynamicCall){&#09;&#09;&#10;&#09;&#09;Delay[0] =5.0;&#09;&#09;&#10;&#09;&#09;UseCase[0] =CALL; &#09;&#10;&#09;&#09;Command[0] =START;&#09;&#09;&#10;&#09;&#09;Delay[1] =6.5;&#09;&#09;&#10;&#09;&#09;UseCase[1] =NOCASE;&#09;&#10;&#09;&#09;Command[1] =FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[2] =3.0;&#09;&#09;&#10;&#09;&#09;UseCase[2] =CALL;&#09;&#10;&#09;&#09;Command[2] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[3] =8.0;&#09;&#09;&#10;&#09;&#09;UseCase[3] =CALL;&#09;&#10;&#09;&#09;Command[3] =RESUME;&#09;&#09;&#10;&#09;&#09;Delay[4] =52.3;&#09;&#09;&#10;&#09;&#09;UseCase[4] =NOCASE;&#09;&#10;&#09;&#09;Command[4] =FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[5] =3.0;&#09;&#09;&#10;&#09;&#09;UseCase[5] =CALL;&#09;&#10;&#09;&#09;Command[5] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[6] =36.5;&#09;&#09;&#10;&#09;&#09;UseCase[6] =CALL;&#09;&#10;&#09;&#09;Command[6] =START;&#09;&#09;&#09;&#10;&#09;&#09;Delay[7] =5.0;&#09;&#09;&#10;&#09;&#09;UseCase[7] =NOCASE;&#09;&#10;&#09;&#09;Command[7] =FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[8] =3.5;&#09;&#09;&#10;&#09;&#09;UseCase[8] =CALL;&#09;&#10;&#09;&#09;Command[8] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[9] =10.5;&#09;&#09;&#10;&#09;&#09;UseCase[9] =CALL;&#09;&#10;&#09;&#09;Command[9] =RESUME;&#09;&#09;&#10;&#09;&#09;Delay[10]=100.0;&#09;&#10;&#09;&#09;UseCase[10]=CALL;&#09;&#10;&#09;&#09;Command[10]=STOP;&#09;&#09;&#09;&#10;&#09;&#09;Delay[11]=10000.0;&#09;&#10;&#09;&#09;UseCase[11]=NOCASE;&#09;&#10;&#09;&#09;Command[11]=STOP;&#09;&#09;&#10;&#09;&#09;Delay[12]=10000.0;&#09;&#10;&#09;&#09;UseCase[12]=NOCASE;&#09;&#10;&#09;&#09;Command[12]=STOP;&#09;&#10;&#09;}else if(Scenario==BothDynamic){&#09;&#09;&#10;&#09;&#09;Delay[0] =7.5;&#09;&#09;&#10;&#09;&#09;UseCase[0] =CALL; &#09;&#10;&#09;&#09;Command[0] =START;&#09;&#09;&#10;&#09;&#09;Delay[1] =8.1;&#09;&#09;&#10;&#09;&#09;UseCase[1] =NOCASE;&#09;&#10;&#09;&#09;Command[1] =FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[2] =21.7;&#09;&#09;&#10;&#09;&#09;UseCase[2] =VIDEO;&#09;&#10;&#09;&#09;Command[2] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[3] =11.7;&#09;&#09;&#10;&#09;&#09;UseCase[3] =VIDEO;&#09;&#10;&#09;&#09;Command[3] =RESUME;&#09;&#09;&#10;&#09;&#09;Delay[4] =13.8;&#09;&#09;&#10;&#09;&#09;UseCase[4] =VIDEO;&#09;&#10;&#09;&#09;Command[4] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[5] =6;&#09;&#09;&#10;&#09;&#09;UseCase[5] =VIDEO; &#09;&#10;&#09;&#09;Command[5] =RESUME;&#09;&#09;&#10;&#09;&#09;Delay[6] =14.1;&#09;&#09;&#10;&#09;&#09;UseCase[6] =NOCASE;&#09;&#10;&#09;&#09;Command[6] =FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[7] =2.5;&#09;&#09;&#10;&#09;&#09;UseCase[7] =CALL;&#09;&#10;&#09;&#09;Command[7] =STOP;&#09;&#09;&#10;&#09;&#09;Delay[8] =9;&#09;&#09;&#10;&#09;&#09;UseCase[8] =CALL;&#09;&#10;&#09;&#09;Command[8] =RESUME;&#09;&#09;&#09;&#09;&#10;&#09;&#09;Delay[9] =26.3;&#09;&#09;&#10;&#09;&#09;UseCase[9]=NOCASE;&#09;&#10;&#09;&#09;Command[9]=FILEREQUEST;&#09;&#09;&#10;&#09;&#09;Delay[10]=30.0;&#09;&#09;&#10;&#09;&#09;UseCase[10]=CALL;&#09;&#10;&#09;&#09;Command[10]=STOP;&#09;&#09;&#10;&#09;&#09;Delay[11]=30.0;&#09;&#09;&#10;&#09;&#09;UseCase[11]=VIDEO;&#09;&#10;&#09;&#09;Command[11]=STOP;&#09;&#09;&#10;&#09;&#09;Delay[12]=30.0;&#09;&#09;&#10;&#09;&#09;UseCase[12]=VIDEO;&#09;&#10;&#09;&#09;Command[12]=STOP;&#09;&#09;&#10;&#09;}\" executionTime=\"10 us\" systematicRead=\"true\" systematicWrite=\"true\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Watching\" constructor=\"\" declarations=\"\" definitions=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"Video\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"WatchingBehaviorBh\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop33\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"Cond31\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Watch\" executionTime=\"1 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Init\" algorithm=\"\" executionTime=\"1 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Reading\" constructor=\"\" declarations=\"int VideoIndex;\" definitions=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"Request\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"Response\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"ReadingBehaviorBh\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop35\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Read\" algorithm=\"&#09;cf_trace_report(&quot;User: File received&quot;);&#09;&#10;&#09;cf_trace_report(&quot;User: Selected video %i&quot;,VideoIndex);&#09;&#10;&#09;Request.UseCase=NOCASE;&#09;&#10;&#09;Request.Command=VIDEOREQUEST;&#09;&#10;&#09;Request.VideoIndex=VideoIndex;&#09;&#10;&#09;VideoIndex=(VideoIndex+1)%NVIDEO;\" executionTime=\"10 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"Cond35\" timeout=\" ms\" priority=\"\" duration=\" us\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"Action47\" duration=\" us\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Init\" algorithm=\"&#09;VideoIndex=0;\" executionTime=\"10 ms\" systematicRead=\"true\" systematicWrite=\"true\" />\n          </refinement>\n        </models>\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"Request\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"NetToUMTS\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"UMTSToNet\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"Response\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"Video\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ms\" receiveTime=\"1 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"NetToDVB\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ms\" receiveTime=\"10 ms\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"CoSimVCSUVMApp\" version=\"x.y.z_Dev_dev\" target=\"\" includeInheritedHeader=\"\" inheritanceClass=\"\" callToInheritedConstructors=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"CoSimVCSUVMAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"read\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"cf_trace_report(&quot;received data: %c&quot;, read);&#13;&#10;\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"ProcessingFunction\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"VCS_COSIM_INTERFACE\">\n      <ports name=\"read\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <ports name=\"data\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProcessingFunctionBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"read =data-32;&#13;&#10;cf_trace_report(&quot;read in processing:%c&quot;, read);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" declarations=\"unsigned int datalen;\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"data\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"data ='a';&#13;&#10;datalen=1;\" executionTime=\"100 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"datalen--\" type=\"CONDITIONAL\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"cf_trace_report(&quot;data input:%c&quot;, data);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"read\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"data\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"2 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"Inheritance_example1App\" version=\"8.1.0_charles_1\" target=\"\" includeInheritedHeader=\"\" inheritanceClass=\"\" callToInheritedConstructors=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"Inheritance_example1AppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"F1\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"F1Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"display();\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"F2\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"F2Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"display();\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"CopyPayloadNonPod\" version=\"6.0.0_alpha2_20150504-2059\" cyclePeriod=\"10 ns\" affinity=\"&#10;0  \" priority=\"&#10;1  \" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"&#10;100  \">\n  <dataTypes name=\"DefMsgQ\" definition=\"#include &lt;iostream&gt;&#10;using namespace std;&#10;struct DefMsgQ&#10;{&#10;    int field1;&#10;    float field2;&#10;    string field3;&#10;    &#10;    DefMsgQ() {&#10;       field1 = 0;&#10;       field2 = 0.0;&#10;       field3 = &quot;N/A&quot;;&#10;    };&#10;    &#10;&#10;    DefMsgQ&amp; operator=(DefMsgQ rhs)&#10;&#09;{&#10;&#09;  field1 = rhs.field1;&#10;&#09;  field2 = rhs.field2;&#10;&#09;  field3 = rhs.field3;&#10;&#09;  &#09;  &#10;&#09;  return *this;&#10;&#09;};&#10;&#09;&#10;&#09;friend std::ostream&amp;  operator&lt;&lt; (std::ostream&amp; os, const DefMsgQ&amp; _p){&#10;      &#09;os &lt;&lt; &quot;field1: &quot; &lt;&lt; _p.field1 &lt;&lt; &quot; - field2: &quot; &lt;&lt; _p.field2 &lt;&lt; &quot; - field3: &quot; &lt;&lt; _p.field3; &#10;      &#09;return os;&#10;      }&#10;&#10;&#09;&#10;    ~DefMsgQ() {&#10;       &#10;    };&#10;    &#10;};\" copyPayload=\"&#09;for (unsigned int i = 0; i &lt; _atom_count; i++)&#10;      *(_address + i) = *(_value + i);\" tracePayload=\"    trace &lt;&lt; get_data();\" readTime=\"\" writeTime=\"\" allocatePayload=\"&#09;&#09;r = new DefMsgQ[_atom_count];\" deallocatePayload=\"    delete[] _address;\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"CopyPayloadNonPodSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpInit\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpDisplay\" algorithm=\"&#09;// Use of the user-class stream operator '&lt;&lt;' to display values&#10;&#09;cout &lt;&lt; &quot;[Consumer]: &quot; &lt;&lt; MsgQ &lt;&lt; endl;&#10;&#09;&#10;&#09;// Use of the Intel CoFluent Studio programming interface cf_trace_report for reporting during simulation&#10;&#09;cf_trace_report(&quot;field1: %d - field2: %f - field3: %s&quot;, MsgQ.field1, MsgQ.field2, MsgQ.field3.c_str());\" executionTime=\"40 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" declarations=\"int cpt;&#13;&#10;int Value[100];\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpInit\" algorithm=\"&#09;cpt = 0;\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpDisplay\" algorithm=\"&#09;// Use of the user-class stream operator '&lt;&lt;' to display values&#10;&#09;cout &lt;&lt; &quot;[Producer]: &quot; &lt;&lt; MsgQ &lt;&lt; endl;&#10;&#09;&#10;&#09;// Use of the Intel CoFluent Studio programming interface cf_trace_report for reporting during simulation&#10;&#09;cf_trace_report(&quot;field1: %d - field2: %f - field3: %s&quot;, MsgQ.field1, MsgQ.field2, MsgQ.field3.c_str());&#09;\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpProd\" algorithm=\"&#09;MsgQ.field1 = cpt;&#10;   &#09;MsgQ.field2 = cpt + 0.1;&#10;&#10;&#09;switch (cpt)&#10;&#09;{&#10;&#09;&#09;case 0:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 0&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 1:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 1&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 2:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 2&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 3:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 3&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 4:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 4&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 5:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 5&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 6:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 6&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 7:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 7&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;case 8:&#10;&#09;&#09;&#09;MsgQ.field3 = &quot;Msg N 8&quot;;&#10;&#09;&#09;break;&#10;&#09;&#09;default:&#10;&#09;&#09;break;&#10;&#09;}   &#09;&#10;&#09;cpt++;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQ\" capacity=\"10\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"CoFluentAPIFromExternalIP\" version=\"5.0.0_r1_20131015-0039\" cyclePeriod=\"10 ns\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <dataTypes name=\"DefMsgQ\" definition=\"typedef int DefMsgQ;\" tracePayload=\"&#09;trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"DefShVar\" definition=\"typedef int DefShVar;\" tracePayload=\"&#09;trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"Initiator\" definition=\"typedef int Initiator;\" tracePayload=\"&#09;trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"Target\" definition=\"typedef int Target;\" tracePayload=\"&#09;trace &lt;&lt; get_data();\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"CoFluentAPIFromExternalIPSt\" documentation=\"\">\n    <models xsi:type=\"cofluent:SystemCIP\" name=\"iUart\" documentation=\"\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" className=\"Uart\" generateInclude=\"true\">\n      <ports name=\"p_mq_request\" documentation=\"\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"p_mq_response\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"CoF_Initiator\" documentation=\"\" initializations=\"MsgFwQ = 0;&#13;&#10;MsgBwQ = 0;\" cyclePeriod=\" ns\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgFwQ\" documentation=\"\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"MsgBwQ\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"CoF_InitiatorBh\" documentation=\"\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"10\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"SendMsg\" algorithm=\"    MsgFwQ ++;&#10;    cf_trace_report(&quot;Sending Message %d...&quot;, MsgFwQ);\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"ReceiveMsg\" algorithm=\"    cf_trace_report(&quot;Receive Message %d...&quot;, MsgBwQ);\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgFwQ\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgBwQ\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"TransactionTrackerMsgQApp\" version=\"6.1.0_beta1_20151021-2100\" declarations=\"\" initializations=\"\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"TransactionTrackerMsgQAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer1\" declarations=\"\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQOut1\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"Consumer1Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"receive_out1\" algorithm=\"&#09;cf_trace_report(&quot;Timeline tracking %s&quot;, MsgQOut1_trans.get_timeline_track().c_str());\" executionTime=\"20 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer2\" declarations=\"\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQOut2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"Consumer2Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"receive_out2\" algorithm=\"&#09;cf_trace_report(&quot;Timeline tracking %s&quot;, MsgQOut2_trans.get_timeline_track().c_str());&#09;\" executionTime=\"20 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" constructor=\"\" includes=\" #include &lt;sstream&gt;\" destructor=\"\" declarations=\"int TempInt;\" definitions=\"\" initializations=\"TempInt = 0;\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQIn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"&#09;cf_trace_report(&quot;Trabsaction tracking when MsgQIn = 1 and 2&quot;);\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"4\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"set_tracker\" algorithm=\"&#09;MsgQIn = TempInt;&#10;&#09;&#10;&#09;/* Condition to track transaction when data sent is 1 or 2*/&#10;&#09;if( (TempInt &gt;= 1) &amp;&amp; (TempInt &lt;= 2) ) {&#10;        /*set the timeline track string*/&#10;&#09;&#09;std::ostringstream track;&#10;&#09;&#09;track &lt;&lt; &quot;MsgQIn= &quot; &lt;&lt; TempInt;&#10;&#09;&#10;&#09;&#09;MsgQIn_trans.set_timeline_track(track.str());&#10;&#09;}&#10;&#09;else&#10;&#09;&#09;MsgQIn_trans.unset_timeline_track();&#10;&#09;&#09;&#09;&#10;&#09;TempInt++;\" executionTime=\"100 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"MessageRouting\" declarations=\"bool CondOut1 = false;\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQIn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"MsgQOut2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"MsgQOut1\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"MessageRoutingBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"routing\" algorithm=\"&#09;if (CondOut1== true)&#10;&#09;{&#10;&#09;&#09;/**MsgQIn =&gt; MsgQOut2**/&#10;&#09;&#09;CondOut1 = false;&#10;&#09;&#09;&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;/**MsgQIn =&gt; MsgQOut1**/&#10;&#09;&#09;CondOut1 = true;&#10;&#09;}\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:AlternativeStatement\" name=\"Alternative\">\n          <conditionalBranches name=\"Branch\" condition=\"CondOut1\" />\n          <conditionalBranches name=\"Branch2\" condition=\"\" />\n        </statements>\n        <statements xsi:type=\"cofluent:Operation\" name=\"to_out2\" algorithm=\"&#09;MsgQOut2 = MsgQIn + 1;&#09;&#10;&#09;&#10;&#09;/*Replicate tracking information*/ &#10;&#09;MsgQOut2_trans.copy_tracking(MsgQIn_trans);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"to_out1\" algorithm=\"&#09;MsgQOut1 = MsgQIn + 1;&#09;&#10;&#09;&#10;&#09;/*Replicate tracking information*/ &#10;&#09;MsgQOut1_trans.copy_tracking(MsgQIn_trans);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQOut2\" capacity=\"3\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQIn\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQOut1\" capacity=\"3\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"ProtocolMapDataTypeApp\" version=\"6.1.0_beta1_20151012-2100\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"ProtocolMapDataTypeAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"ProtocolSend\" includes=\"\" declarations=\"int number_of_packets;\" initializations=\"number_of_packets = 0;\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"protocol_data\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"user_data_in\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProtocolSendBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"fragment\" algorithm=\"&#09;protocol_data_trans = user_data_in_trans;&#10;&#09;number_of_packets =(int) (user_data_in_trans.get_user_data_length() / cf_dt::cf_data_size(5,CF_BYTE));&#10;&#09;protocol_data_trans.set_map_data&lt;int&gt;(&quot;number_of_packets&quot;,number_of_packets);&#10;&#09;&#10;&#09;cf_trace_report( &quot;number_of_packets to send = %d&quot;, number_of_packets);\" executionTime=\"5 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"send\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop2\" condition=\"number_of_packets\" type=\"MULTIPLICATION\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" declarations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"user_data_out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"&#09;cf_trace_report( &quot;data = %d&quot;, user_data_out_trans.get_map_data&lt;int&gt;(&quot;data&quot;) );\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" declarations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"user_data_in\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"&#09;int varInt = 18071968;&#10;&#10;&#09;user_data_in_trans.set_map_data&lt;int&gt;(&quot;data&quot;, varInt);&#10;&#09;user_data_in_trans.set_user_data_length( cf_dt::cf_data_size(20,CF_BYTE) );\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"ProtocolReceive\" declarations=\"int number_of_packets;\" initializations=\"number_of_packets = 0;\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"protocol_data\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"user_data_out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProtocolReceiveBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"gather_and_send\" algorithm=\"&#09;protocol_data_trans.delete_map_data(&quot;number_of_packets&quot;);&#10;&#09;user_data_out_trans = protocol_data_trans;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop2\" condition=\"number_of_packets\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"init_data_receive\" algorithm=\"&#09;number_of_packets = 1;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"receive\" algorithm=\"&#09;number_of_packets = protocol_data_trans.get_map_data&lt;int&gt;(&quot;number_of_packets&quot;);&#09;\" executionTime=\"5 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"protocol_data\" capacity=\"1\" concurrency=\"1\" sendTime=\"2 ns\" receiveTime=\"3 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" predefinedType=\"MAP\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"user_data_in\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" predefinedType=\"MAP\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"user_data_out\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" predefinedType=\"MAP\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"MapDataTypeAPIApp\" version=\"6.1.0_beta1_20151012-2100\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"MapDataTypeAPIAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"ProducerMap\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQMap\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerMapBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"&#09;int varInt = 85;&#10;&#09;double varDouble = 8.05;&#10;&#09;char varChar = 'a';&#10;&#09;&#10;&#09;MsgQMap_trans.set_map_data&lt;int&gt;(&quot;key_int&quot;, varInt);&#10;&#09;MsgQMap_trans.set_map_data&lt;double&gt;(&quot;key_double&quot;, varDouble);&#10;&#09;MsgQMap_trans.set_map_data&lt;char&gt;(&quot;key_char&quot;, varChar);&#09;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"ConsumerMap\" constructor=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQMap\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerMapBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"&#09;cf_trace_report(&quot;*****map received by using get_map_data*****&quot;);&#10;&#09;cf_trace_report(&quot;                key_int = %d                &quot;, MsgQMap_trans.get_map_data&lt;int&gt;(&quot;key_int&quot;));&#10;&#09;cf_trace_report(&quot;                key_double = %f             &quot;, MsgQMap_trans.get_map_data&lt;double&gt;(&quot;key_double&quot;));&#10;&#09;cf_trace_report(&quot;                key_char = %c               &quot;, MsgQMap_trans.get_map_data&lt;char&gt;(&quot;key_char&quot;));&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;*****map received by using conv_map_to_string*****&quot;);&#10;&#09;cf_trace_report(&quot;                   map:%s                         &quot;, MsgQMap_trans.conv_map_to_string().c_str());&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;*****size of the map received*****&quot;);&#09;&#10;&#09;cf_trace_report(&quot;           map size = %d          &quot;, MsgQMap_trans.get_map_size());&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;*****delete element related to the key_char*****&quot;);&#10;&#09;MsgQMap_trans.delete_map_data(&quot;key_char&quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;*****verify if the element related to the key_char is in the map*****&quot;);&#10;&#09;if(MsgQMap_trans.has_map_data(&quot;key_char&quot;))&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;                    key_char = %c                               &quot;, MsgQMap_trans.get_map_data&lt;char&gt;(&quot;key_char&quot;));&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;        no element related to key_char in the map       &quot;);&#10;&#09;}&#09;&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;*****content of the map after the element related to the key_char has been deleted*****&quot;);&#10;&#09;cf_trace_report(&quot;                                   map: %s                                          &quot;, MsgQMap_trans.conv_map_to_string().c_str());&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#09;&#10;&#09;&#10;&#09;cf_trace_report(&quot;************size of the map after the element related to the key_char has been deleted*************&quot;);&#09;&#10;&#09;cf_trace_report(&quot;                                   map size = %d                                                &quot;, MsgQMap_trans.get_map_size());&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#09;&#10;&#09;&#09;&#10;&#09;cf_trace_report(&quot;************erase all the content of the map**************&quot;);&#10;&#09;MsgQMap_trans.erase_map_data();&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#10;&#09;cf_trace_report(&quot;*****map is empty?*****&quot;);&#10;&#09;if(MsgQMap_trans.is_map_empty())&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;     map is empty  &quot;);&#10;&#09;&#09;cf_trace_report(&quot;     map size = %d &quot;, MsgQMap_trans.get_map_size());&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;     map is not empty&quot;);&#10;&#09;&#09;cf_trace_report(&quot;     map size = %d &quot;, MsgQMap_trans.get_map_size());&#10;&#09;}\" executionTime=\"5 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQMap\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" predefinedType=\"MAP\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"ApplicationVectorDataType\" version=\"6.1.0_alpha1_20151007-1142\" declarations=\"\" initializations=\"\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"ApplicationVectorDataTypeSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" declarations=\"int value;\" initializations=\"value = 0;\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"user_data_in\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"&#09;for(int i=0; i&lt;8;i++)&#10;&#09;{&#10;&#09;&#09;user_data_in_trans.set_vector_data&lt;int&gt;(i, value%2);&#10;&#09;&#09;value++;&#10;&#09;}&#10;&#09;user_data_in_trans.set_user_data_length( cf_dt::cf_data_size(20,CF_BYTE) );&#09;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Processing\" declarations=\"int block_index;\" initializations=\"block_index = 0;\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"user_data_in\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"user_data_out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProcessingBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;user_data_out_trans = user_data_in_trans;&#10;&#09;&#09;&#10;&#09;int parity_bit = 0;&#10;&#09;int total_zero_number = 0;&#10;&#09;int vector_size = user_data_in_trans.get_vector_size();&#10;&#09;&#10;&#09;for(int i=0; i&lt;vector_size ;i++)&#10;&#09;{&#10;&#09;&#09;if(user_data_in_trans.get_vector_data&lt;int&gt;(i) == 0) total_zero_number++;&#10;&#09;}&#10;&#09;&#10;&#09;if(total_zero_number % 2 == 0) parity_bit = 0; &#10;&#09;else parity_bit = 1; &#10;&#10;&#09;user_data_out_trans.set_vector_data&lt;int&gt;(user_data_in_trans.get_vector_size(), parity_bit);&#10;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" declarations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"user_data_out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"&#09;cf_trace_report(&quot;************Vector received by using conv_vector_to_string**************&quot;);&#10;&#09;cf_trace_report(&quot;                     user_data_out : %s                         &quot;, user_data_out_trans.conv_vector_to_string().c_str() );&#10;&#09;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"user_data_in\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" predefinedType=\"VECTOR\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"user_data_out\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" predefinedType=\"VECTOR\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"VectorDataTypeAPIApp\" version=\"6.1.0_alpha1_20151007-1142\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"VectorDataTypeAPIAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"ProducerVector\" declarations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQVector\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerVectorBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"&#09;for(int i=0; i&lt;10;i++)&#10;&#09;{&#10;&#09;&#09;MsgQVector_trans.set_vector_data&lt;int&gt;(i, i + 10);&#10;&#09;}\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"ConsumerVector\" includes=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQVector\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerVectorBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"1\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"&#09;cf_trace_report(&quot;************Vector received by using get_vector_data**************&quot;);&#10;&#09;for(int i=0; i&lt;10;i++)&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;                    MsgQVector[%d] = %d                       &quot;,i, MsgQVector_trans.get_vector_data&lt;int&gt;(i));&#10;&#09;}&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#10;&#09;cf_trace_report(&quot;************Vector received by using conv_vector_to_string**************&quot;);&#10;&#09;cf_trace_report(&quot;                     MsgQVector : %s                         &quot;, MsgQVector_trans.conv_vector_to_string().c_str());&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;************Size of the vector received**************&quot;);&#09;&#10;&#09;cf_trace_report(&quot;                  Vector size = %d                    &quot;, MsgQVector_trans.get_vector_size());&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#09;&#10;&#09;&#10;&#09;cf_trace_report(&quot;***************Init value stored at index 5 ***************&quot;);&#10;&#09;MsgQVector_trans.init_vector_data&lt;int&gt;(5);&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;****Check if the value stored at index 5 is equal to 0****&quot;);&#10;&#09;cf_trace_report(&quot;    MsgQVector[%d] = %d                       &quot;,5, MsgQVector_trans.get_vector_data&lt;int&gt;(5));&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;***************Remove element stored at index 7 ***************&quot;);&#10;&#09;MsgQVector_trans.remove_vector_data(7);&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;****Check if the element stored at index 7 was removed (element shifted)****&quot;);&#10;&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#10;&#10;&#09;cf_trace_report(&quot;************Size of the vector**************&quot;);&#09;&#10;&#09;cf_trace_report(&quot;             Vector size = %d                    &quot;, MsgQVector_trans.get_vector_size());&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#09;&#10;&#09;&#10;&#09;&#09;&#09;&#10;&#09;cf_trace_report(&quot;************All values of the vector after remove**************&quot;);&#10;&#09;cf_trace_report(&quot;                     Vector : %s                         &quot;, MsgQVector_trans.conv_vector_to_string().c_str());&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#09;&#10;&#09;&#10;&#09;&#10;&#09;cf_trace_report(&quot;****Check if the element stored at index 15 exists ****&quot;);&#10;&#09;if(MsgQVector_trans.has_vector_data(15))&#10;&#09;{&#10;   &#09;&#09;cf_trace_report(&quot; MsgQVector[%d] = %d &quot;,15, MsgQVector_trans.get_vector_data&lt;int&gt;(15));&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;   &#09;&#09;cf_trace_report(&quot; No value in MsgQVector[15] &quot;);&#10;&#09;}&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#09;&#10;&#09;&#10;&#09;cf_trace_report(&quot;*********Check if the vector is empty************&quot;);&#10;&#09;if(MsgQVector_trans.is_vector_empty())&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;                   Vector is empty                 &quot;);&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;                   Vector is not empty            &quot;);&#10;&#09;}&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#09;&#10;&#09;&#09;&#10;&#09;cf_trace_report(&quot;************Erase all the elements in the vector**************&quot;);&#10;&#09;MsgQVector_trans.erase_vector_data();&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#10;&#09;cf_trace_report(&quot;*************Check if the vector is empty****************&quot;);&#10;&#09;if(MsgQVector_trans.is_vector_empty())&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;                   Vector is empty                       &quot;);&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;cf_trace_report(&quot;                   Vector is not empty                    &quot;);&#10;&#09;}&#10;&#09;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#10;&#09;cf_trace_report(&quot;************Vector content by using conv_vector_to_string after erase**************&quot;);&#10;&#09;cf_trace_report(&quot;                     MsgQVector : %s                         &quot;, MsgQVector_trans.conv_vector_to_string().c_str());&#09;&#10;&#10;&#09;cf_trace_report(&quot; &quot;);&#10;&#09;&#09;&#10;&#09;cf_trace_report(&quot;************Size of the vector**************&quot;);&#09;&#10;&#09;cf_trace_report(&quot;             Vector size = %d                    &quot;, MsgQVector_trans.get_vector_size());\" executionTime=\"5 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQVector\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" predefinedType=\"VECTOR\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"CoSimVerilatorChiselApp\" version=\"x.y.z_Dev_dev\" target=\"\" includeInheritedHeader=\"\" inheritanceClass=\"\" callToInheritedConstructors=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n  <dataTypes name=\"Defsum\" definition=\"typedef struct{&#13;&#10;unsigned char s;&#13;&#10;unsigned char count;&#13;&#10;}Defsum;\" copyPayload=\"cf_payload::cb_copy_payload(_address, _value, _atom_count);\" allocatePayload=\"r = cf_payload::cb_alloc_payload(_atom_count);\" deallocatePayload=\"cf_payload::cb_delete_payload(_address);\" />\n  <dataTypes name=\"Defdata1\" definition=\"typedef unsigned char Defdata1;\" copyPayload=\"cf_payload::cb_copy_payload(_address, _value, _atom_count);\" allocatePayload=\"r = cf_payload::cb_alloc_payload(_atom_count);\" deallocatePayload=\"cf_payload::cb_delete_payload(_address);\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"CoSimVerilatorChiselAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Producer1\" declarations=\"int i =1;\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"data1\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"Producer1Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"cf\" algorithm=\"data1=cf_util_rand_uint(0,255);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"i&lt;=10\" type=\"CONDITIONAL\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"data1=cf_util_rand_int(0,255);&#13;&#10;cf_trace_report(&quot;data1[%d]:%u&quot;,i,data1);&#13;&#10;i++;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Producer2\" declarations=\"int i =1;\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"data2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"Producer2Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"data2=cf_util_rand_int(0,255);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"i&lt;=10\" type=\"CONDITIONAL\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"data2=cf_util_rand_uint(0,200);&#13;&#10;cf_trace_report(&quot;data2[%d]:%u&quot;,i,data2);&#13;&#10;i++;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"adder\" includes=\"#include &lt;cmath&gt;\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"CHISEL_COSIM_INTERFACE\">\n      <ports name=\"data1\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <ports name=\"sum\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <ports name=\"data2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"adderBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"sum.s=(data1+data2)&amp;0xff;&#13;&#10;sum.count=((data1+data2)&amp;0x100)&gt;&gt;8;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" declarations=\"int i=1;\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"sum\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"20\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"cf_trace_report(&quot;sum_total[%d]:s:%u,count:%u&quot;,i,sum.s,sum.count);&#13;&#10;//cf_trace_report(&quot;sum[%d]:%d&quot;,i,sum &amp; 0xff);&#13;&#10;//cf_trace_report(&quot;cout[%d]:%d&quot;,i,(sum &amp; 0x100)&gt;&gt;8);&#13;&#10;i++;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"sum\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"ONE_SIDE\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\" cosimChiselDataPortBits=\"9\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"data1\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"data2\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"TLM2LT\" includes=\"\" version=\"Dev\" cyclePeriod=\"10 ns\" globalTypeDeclarations=\"#ifndef __COMMON_HEADER2_H__&#13;&#10;#define __COMMON_HEADER2_H__&#13;&#10;&#13;&#10;&#09;struct my_ext : public tlm::tlm_extension&lt;int&gt;&#13;&#10;    {&#13;&#10;      tlm::tlm_extension_base* clone() const { return 0; }&#13;&#10;      void free() {}&#13;&#10;      void copy_from(tlm::tlm_extension_base const &amp;) {}&#13;&#10;      int i;&#13;&#10;    };&#13;&#10;&#13;&#10;#endif\" globalDeclarations=\"#define MEMORY_ADDRESS (1U&lt;&lt;28)+0x200&#13;&#10;#define TARGET_ADDRESS 2U&lt;&lt;28&#13;&#10;#define TARGET_2_ADDRESS 3U&lt;&lt;28\" globalDefinitions=\"\">\n  <dataTypes name=\"DefData\" definition=\"typedef int DefData;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"Initiator\" definition=\"typedef int Initiator;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"Target\" definition=\"typedef int Target;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"DefMsgQ\" definition=\"typedef int DefMsgQ;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"TLM2LTStructSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Writer\" declarations=\"int data;\" cyclePeriod=\" ns\">\n      <ports name=\"InitiatorWriter\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReferenceQueue\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReferenceQueue2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReferenceQueue3\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync2\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync3\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"WriterBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction3\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"WriteToMemory\" algorithm=\"&#09;data++;&#10;&#09;ReferenceQueue = data;&#10;&#09;ReferenceQueue2 = data;&#10;&#09;ReferenceQueue3 = data;&#10;&#09;// prepare TLM2 transaction&#10;&#09;InitiatorWriter_trans.set_tlm2_delay(cf_dt::cf_time(1, CF_US));&#10;&#09;tlm::tlm_generic_payload*   tlm2_gp_req =&#10;        InitiatorWriter_trans.allocate_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_req )&#10;&#09;tlm2_gp_req-&gt;set_address( MEMORY_ADDRESS );&#10;&#09;tlm2_gp_req-&gt;set_write();&#10;&#09;tlm2_gp_req-&gt;set_data_ptr(&#10;        reinterpret_cast&lt; unsigned char* &gt;( &amp;data )&#10;        );&#10;&#09;tlm2_gp_req-&gt;set_data_length( sizeof( int ) );&#10;&#09;tlm2_gp_req-&gt;set_streaming_width(1);\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"WriteToTarget_2\" algorithm=\"&#09;// prepare TLM2 transaction&#10;&#09;InitiatorWriter_trans.set_tlm2_delay(cf_dt::cf_time(2, CF_US));&#10;&#09;tlm::tlm_generic_payload*   tlm2_gp_req =&#10;        InitiatorWriter_trans.allocate_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_req )&#10;&#09;tlm2_gp_req-&gt;set_address( TARGET_2_ADDRESS );&#10;&#09;tlm2_gp_req-&gt;set_write();&#10;&#09;tlm2_gp_req-&gt;set_data_ptr(&#10;        reinterpret_cast&lt; unsigned char* &gt;( &amp;data )&#10;        );&#10;&#09;tlm2_gp_req-&gt;set_data_length( sizeof( int ) );&#10;&#09;tlm2_gp_req-&gt;set_streaming_width(1);\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"Initialization\" algorithm=\"&#09;data = 0;\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction5\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"WriteToTarget\" algorithm=\"&#09;// prepare TLM2 transaction&#10;&#09;InitiatorWriter_trans.set_tlm2_delay(cf_dt::cf_time(1, CF_US));&#10;&#09;tlm::tlm_generic_payload*   tlm2_gp_req =&#10;        InitiatorWriter_trans.allocate_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_req )&#10;&#09;tlm2_gp_req-&gt;set_address( TARGET_ADDRESS );&#10;&#09;tlm2_gp_req-&gt;set_write();&#10;&#09;tlm2_gp_req-&gt;set_data_ptr(&#10;        reinterpret_cast&lt; unsigned char* &gt;( &amp;data )&#10;        );&#10;&#09;tlm2_gp_req-&gt;set_data_length( sizeof( int ) );&#10;&#09;tlm2_gp_req-&gt;set_streaming_width(1);\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction4\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction3\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction6\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Target\" declarations=\"\" cyclePeriod=\" ns\">\n      <ports name=\"ReferenceQueue2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"TargetWrapper\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync2\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"TargetBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"Compare\" algorithm=\"&#09;tlm::tlm_generic_payload*   tlm2_gp_resp =&#10;        TargetWrapper_trans.get_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_resp )&#10;    int     rcv_data = *reinterpret_cast&lt; int* &gt;(&#10;                tlm2_gp_resp-&gt;get_data_ptr()&#10;                );&#10;&#09;cf_trace_report(&quot;Reference data: 0x%x, received data: 0x%x&quot;,&#10;&#09;&#09;&#09;ReferenceQueue2, rcv_data&#10;            );&#10;    TargetWrapper_trans.release_tlm2_gp();\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Reader\" declarations=\"int data;\" cyclePeriod=\" ns\">\n      <ports name=\"ReferenceQueue3\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"InitiatorReader\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReaderResponse\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ReaderBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"ReadMemory\" algorithm=\"&#09;// prepare TLM2 transaction&#10;&#09;InitiatorReader_trans.set_tlm2_delay(cf_dt::cf_time(3, CF_US));&#10;&#09;tlm::tlm_generic_payload*   tlm2_gp_req =&#10;        InitiatorReader_trans.allocate_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_req )&#10;&#09;tlm2_gp_req-&gt;set_address( MEMORY_ADDRESS );&#10;&#09;tlm2_gp_req-&gt;set_read();&#10;&#09;tlm2_gp_req-&gt;set_data_ptr(&#10;        reinterpret_cast&lt; unsigned char* &gt;( &amp;data )&#10;        );&#10;&#09;tlm2_gp_req-&gt;set_data_length( sizeof( int ) );&#10;&#09;tlm2_gp_req-&gt;set_streaming_width(1);\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"Compare\" algorithm=\"&#09;tlm::tlm_generic_payload*   tlm2_gp_resp =&#10;        ReaderResponse_trans.get_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_resp )&#10;    int     rcv_data = *reinterpret_cast&lt; int* &gt;(&#10;                tlm2_gp_resp-&gt;get_data_ptr()&#10;                );&#10;&#09;cf_trace_report(&quot;Reference data: 0x%x, received data: 0x%x&quot;,&#10;&#09;&#09;&#09;ReferenceQueue3, rcv_data&#10;            );&#10;    ReaderResponse_trans.release_tlm2_gp();\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:SystemCIP\" name=\"TLM2Platfom\" className=\"lt_top\" generateInclude=\"true\">\n      <ports name=\"m_bus.target_socket[2]\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"m_bus.initiator_socket[2]\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"m_bus.target_socket[3]\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"m_bus.initiator_socket[3]\" documentation=\"\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Target_2\" declarations=\"\" cyclePeriod=\" ns\">\n      <ports name=\"TargetRequest\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"TargetResponse\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReferenceQueue\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync3\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"TargetBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"Compare\" algorithm=\"    TargetResponse_trans = TargetRequest_trans;&#10;    TargetResponse_trans.set_tlm2_delay(cf_dt::cf_time(4, CF_US));&#10;    &#10;&#09;tlm::tlm_generic_payload*   tlm2_gp_resp =&#10;        TargetRequest_trans.get_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_resp )&#10;    int     rcv_data = *reinterpret_cast&lt; int* &gt;(&#10;                tlm2_gp_resp-&gt;get_data_ptr()&#10;                );&#10;&#09;cf_trace_report(&quot;Reference data: 0x%x, received data: 0x%x&quot;,&#10;&#09;&#09;&#09;ReferenceQueue, rcv_data&#10;            );    \" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReferenceQueue\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReferenceQueue2\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"InitiatorWriter\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_LT\" address=\"0x000001\" mask=\"0x0000FF\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"TargetWrapper\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_LT\" address=\"0x000001\" mask=\"0x0000FF\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"InitiatorReader\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_LT\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:Event\" name=\"Sync\" setTime=\"1 ns\" getTime=\"1 ns\" />\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReaderResponse\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_LT\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"TargetRequest\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_LT\" address=\"0x000001\" mask=\"0x0000FF\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"TargetResponse\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_LT\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReferenceQueue3\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:Event\" name=\"Sync2\" setTime=\"1 ns\" getTime=\"1 ns\" />\n    <relations xsi:type=\"cofluent:Event\" name=\"Sync3\" setTime=\"1 ns\" getTime=\"1 ns\" />\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"AutomatedPayloadTrackers\" postSimulation=\"\" version=\"Ibiza_dev3_20150212-1038\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" postElaboration=\"\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"AutomatedPayloadTrackersSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"C2\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"M2_2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"C2Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"cf_trace_report(&quot;[C2] payload %d received&quot;, M2_2);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"F2\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"M1_2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"M1_3\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"F2Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"M1_3 = M1_2;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"F12\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"M1_1\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"M2_1\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"M1_2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"M2_2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"F12Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"compute\" algorithm=\"M1_2 = M1_1 + M2_1;&#10;M2_2 = M1_1 - M2_1;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"P1\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"M1_1\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"P1Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"M1_1 = 100;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"10\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"M1_1++;&#10;cf_trace_report(&quot;[P1] payload %d sent&quot;,M1_1);\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"P2\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"M2_1\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"P2Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"M2_1 = 0;\" executionTime=\"5 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"10\" type=\"MULTIPLICATION\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"M2_1++;&#10;cf_trace_report(&quot;[P2] payload %d sent&quot;,M2_1);\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"C1\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"M1_3\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"C1Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"cf_trace_report(&quot;[C1] payload %d received&quot;, M1_3);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"M1_1\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"M1_3\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"M2_1\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"M2_2\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"M1_2\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"10 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"DDRMemory\" constructor=\"\" includes=\"\" postSimulation=\"AverageReadLatency = TotalReadLatency / NbTotalReadRequests;&#13;AverageWriteLatency = TotalWriteLatency / NbTotalWriteRequests;&#13;AverageWriteBandwidth = TotalWriteData * 1000 / TotalWriteLatency;&#13;AverageReadBandwidth = TotalReadData * 1000 / TotalReadLatency;&#13;AverageCombinedBandwidth = (TotalWriteData + TotalReadData) * 1000/ (TotalReadLatency + TotalWriteLatency);&#13;cf_trace_gui_f_t(&quot;AverageReadLatency&quot;, AverageReadLatency);&#13;cf_trace_report(&quot;AverageReadLatency = %f ns, %f Cycles&quot;, AverageReadLatency,(AverageReadLatency /(CyclePeriod)));&#13;cf_trace_gui_f_t(&quot;AverageWriteLatency&quot;, AverageWriteLatency, &quot;ns&quot;);&#13;cf_trace_report(&quot;AverageWriteLatency = %f ns, %f Cycles&quot;,&#13;AverageWriteLatency, (AverageWriteLatency / (CyclePeriod)));&#13;cf_trace_gui_f_t(&quot;AverageReadBandwidth&quot;, AverageReadBandwidth, &quot;Mb/s&quot;);&#13;cf_trace_gui_f_t(&quot;AverageWriteBandwidth&quot;,AverageWriteBandwidth, &quot;Mb/s&quot;);&#13;cf_trace_gui_f_t(&quot;AverageCombinedBandwidth&quot;, AverageCombinedBandwidth, &quot;Mb/s&quot;);&#13;cf_trace_report(&quot;AverageReadBandwidth = %f Mb/s&quot;, AverageReadBandwidth);&#13;cf_trace_report(&quot;AverageWriteBandwidth = %f Mb/s&quot;, AverageWriteBandwidth);&#13;cf_trace_report(&quot;AverageCombinedBandwidth = %f Mb/s&quot;, AverageCombinedBandwidth);\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"CyclePeriod ns\" preSimulation=\"\" postElaboration=\"\" globalTypeDeclarations=\"const long MEMORYSIZE = 1048575;&#13;&#13;typedef enum {&#13;&#09;WRITEREQ, READREQ&#13;} DefMemCmd;&#13;typedef enum {&#13;&#09;ACTIVESTBY,&#13;&#09;PRECHARGESTBY,&#13;&#09;ACTIVEPWDN,&#13;&#09;PRECHARGEPWDN,&#13;&#09;ACTIVATING,&#13;&#09;READING,&#13;&#09;WRITING,&#13;&#09;PRECHARGING&#13;} DefMemoryMode;&#13;typedef enum {&#13;&#09;ACTIVATE, READ, WRITE, PRECHARGE&#13;} DefDDRCmd;&#13;typedef int DefDataSize;&#13;&#13;typedef struct {&#13;&#09;DefDataSize dataSize;&#13;&#09;float startTime;&#13;&#09;int ID;&#13;&#09;long address;&#13;&#09;int burstLength;&#13;&#09;int size;&#13;} DefAXIADDRchn;&#13;&#13;typedef struct {&#13;&#09;DefDataSize dataSize;&#13;&#09;float startTime;&#13;&#09;int ID;&#13;&#09;int dataValue;&#13;&#09;int burstLength;&#13;} DefAXIDATAchn;&#13;&#13;typedef struct {&#13;&#09;DefDataSize dataSize;&#13;&#09;float startTime;&#13;&#09;int ID;&#13;&#09;int dataValue;&#13;&#09;long address;&#13;&#09;int burstLength;&#13;&#09;int size;&#13;} DefMemoryWriteRequest;&#13;&#13;typedef DefAXIADDRchn DefMemoryReadRequest;&#13;&#13;typedef struct {&#13;&#09;DefDataSize dataSize;&#13;&#09;float startTime;&#13;&#09;int ID;&#13;&#09;int dataValue;&#13;&#09;int burstLength;&#13;} DefMemoryReadData;&#13;&#13;typedef struct {&#13;&#09;DefDataSize dataSize;&#13;&#09;float startTime;&#13;&#09;DefMemCmd memCmd;&#13;&#09;int ID;&#13;&#09;int memID;&#13;&#09;long address;&#13;&#09;int dataValue;&#13;&#09;int size;&#13;&#09;int burstLength;&#13;} DefMemoryRequest;&#13;&#13;struct DefListRequests{&#13;&#09;DefMemoryRequest memoryRequest;&#13;&#09;struct DefListRequests * nextRequestPtr;&#13;&#09;struct DefListRequests * prevRequestPtr;&#13;} ;&#13;&#13;typedef struct {&#13;&#09;DefDDRCmd Cmd;&#13;&#09;int BankAccessed;&#13;&#09;int RowAccessed;&#13;&#09;int ColumnAccessed;&#13;&#09;int memID;&#13;} DefDDRAction;\" globalDeclarations=\"extern int cumulativeBytes;&#13;extern float cumulativeLatency;&#13;extern int transferNumber;&#13;&#13;extern int NbWriteRequests;&#13;extern int NbReadRequests;&#13;extern int NbTotalWriteRequests;&#13;extern int NbTotalReadRequests;&#13;extern float TotalWriteLatency;&#13;extern float TotalReadLatency;&#13;extern float AverageReadLatency;&#13;extern float AverageWriteLatency;&#13;extern float ReadBandwidth;&#13;extern float WriteBandwidth;&#13;extern float CombinedBandwidth;&#13;extern float AverageReadBandwidth;&#13;extern float AverageCombinedBandwidth;&#13;extern float AverageWriteBandwidth;&#13;extern float TotalReadData;&#13;extern float TotalWriteData;&#13;extern float TotalCombinedData;&#13;extern int MemoryConsumption;&#13;extern int DQPutTime;&#13;extern int srand_seed;&#13;extern DefListRequests FirstEmptyRequest;&#13;extern int Tabtest[2][94];&#13;extern int TabSelectCmd[2][94];&#13;extern long TabAdressRead[2][51];&#13;extern long TabAdressWrite[2][44];\" globalDefinitions=\"int cumulativeBytes = 0;&#13;float cumulativeLatency = 0;&#13;int transferNumber = 0;&#13;&#13;int NbWriteRequests = 0;&#13;int NbReadRequests = 0;&#13;int NbTotalWriteRequests = 0;&#13;int NbTotalReadRequests = 0;&#13;float TotalWriteLatency = 0;&#13;float TotalReadLatency = 0;&#13;float AverageReadLatency = 0;&#13;float AverageWriteLatency = 0;&#13;float ReadBandwidth = 0;&#13;float WriteBandwidth = 0;&#13;float CombinedBandwidth = 0;&#13;float AverageReadBandwidth = 0;&#13;float AverageCombinedBandwidth = 0;&#13;float AverageWriteBandwidth = 0;&#13;float TotalReadData = 0;&#13;float TotalWriteData = 0;&#13;float TotalCombinedData = 0;&#13;int MemoryConsumption = 4;&#13;int DQPutTime = 0;&#13;int srand_seed = 1;&#13;DefListRequests FirstEmptyRequest;&#13;int Tabtest[2][94]={{5,1,4,4,8,4,1,7,7,3,3,0,0,6,6,2,2,9,5,2,8,2,8,5,8,4,1,4,1,7,1,7,4,7,3,0,3,0,6,3,3,6,2,6,2,9,2,9,5,2,8,5,1,8,4,1,7,4,0,4,0,7,0,7,3,0,6,3,9,6,9,6,2,9,5,5,1,1,8,8,4,4,0,7,3,7,7,3,0,6,3,6,2,6},{1,8,8,1,1,7,4,0,4,0,7,0,6,3,6,3,9,3,9,6,9,5,2,9,5,5,1,1,8,8,4,4,0,0,7,7,3,0,6,9,9,9,5,5,2,8,5,1,8,4,1,8,4,1,7,7,3,3,0,6,3,9,6,2,2,9,5,2,8,2,8,5,8,4,1,4,1,7,1,7,4,0,0,3,0,6,3,9,9,9}};&#13;int TabSelectCmd[2][94]={{66 ,45 ,83 ,10 ,41 ,28 ,96 ,75 ,92 ,79 ,96 ,75 ,92 ,71 ,88 ,75 ,92 ,71 ,50 ,37 ,16 ,54 ,33 ,20 ,50 ,37 ,16 ,54 ,33 ,12 ,50 ,29 ,16 ,46 ,33 ,12 ,50 ,29 ,98 ,85 ,12 ,42 ,29 ,60 ,46 ,25 ,64 ,42 ,21 ,98 ,77 ,56 ,43 ,21 ,90 ,77 ,56 ,43 ,21 ,60 ,39 ,17 ,56 ,35 ,21 ,90 ,69 ,56 ,35 ,14 ,52 ,31 ,18 ,86 ,65 ,82 ,69 ,86 ,65 ,82 ,61 ,78 ,65 ,44 ,23 ,61 ,79 ,65 ,44 ,23 ,10 ,40 ,27 ,57},{27, 96, 23, 62, 79, 58, 45, 24, 62, 41, 20, 58, 37, 24, 54, 41, 20, 58, 37, 16, 54, 33, 20, 89, 75, 93, 71, 89, 67, 85, 71, 89, 67, 85, 64, 81, 68, 46, 25, 64, 81, 98, 77, 94, 81, 60, 38, 25, 94, 73, 60, 39, 25, 94, 73, 90, 77, 94, 73, 52, 39, 17, 86, 73, 90, 69, 48, 35, 14, 52, 31, 10, 48, 27, 14, 44, 31, 10, 48, 27, 96, 83, 10, 48, 27, 96, 83, 61, 79, 96}};&#13;long TabAdressRead[2][51]={{869114 ,392171 ,9952 ,676372 ,771095 ,578353 ,196165 ,290888 ,957309 ,764567 ,382347 ,666548 ,284360 ,91618 ,186341 ,758039 ,852762 ,470542 ,660020 ,277832 ,372555 ,944220 ,1038975 ,179813 ,846233 ,464014 ,81826 ,748214 ,1032415 ,268008 ,457485 ,552208 ,741686 ,836409 ,359498 ,454221 ,72002 ,261479 ,356202 ,545680 ,447693 ,349674 ,1016094 ,823353 ,441133 ,535888 ,725334 ,1009566 ,55681 ,245159 ,911547},{202694 ,486894 ,104707 ,294152 ,388907 ,960573 ,6688 ,673108 ,862554 ,480366 ,98147 ,160 ,950749 ,568561 ,375819 ,1042239 ,88354 ,754775 ,562033 ,656756 ,366027 ,650227 ,839705 ,934428 ,75298 ,170021 ,1025887 ,643699 ,738422 ,927900 ,163492 ,829881 ,65474 ,731894 ,539152 ,633875 ,156932 ,251687 ,918076 ,58945 ,153668 ,820089 ,343146 ,437869 ,627347}};&#13;long TabAdressWrite[2][44]={{774358, 581617, 865817, 483630, 3424, 669843, 477102, 571824, 761302, 379083, 473838, 1045502, 947484, 565296, 183077, 85090, 369290, 1035678, 176549, 842968, 937691, 78562, 173285, 362762, 646963, 548944, 166756, 450957, 640402, 735157, 258215, 352938, 542416, 637138, 254951, 62209, 728629, 630610, 248423, 914811, 150404, 816824, 434604},{297416 ,963836 ,199429 ,101411 ,767830 ,385611 ,575089 ,192901 ,287624 ,859289 ,954044 ,94882 ,189637 ,856025 ,663283 ,281096 ,849497 ,467277 ,751478 ,274568 ,940955 ,558768 ,653491 ,271272 ,460749 ,555472 ,744950 ,1029150 ,264743 ,931163 ,833144 ,1022622 ,68738 ,924635 ,1019358 ,160228 ,826616 ,921339 ,444429 ,346410 ,1012829 ,532623 ,722069 ,339882}};\">\n  <dataTypes name=\"DefRDATAchn\" definition=\"typedef DefAXIDATAchn DefRDATAchn;\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,dataValue:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataValue;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;\" />\n  <dataTypes name=\"DefARADDRchn\" definition=\"typedef DefAXIADDRchn DefARADDRchn;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;\" />\n  <dataTypes name=\"DefBRESPchn\" definition=\"typedef DefAXIADDRchn DefBRESPchn;\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;\" />\n  <dataTypes name=\"DefWDATAchn\" definition=\"typedef DefAXIDATAchn DefWDATAchn;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,dataValue:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataValue;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;\" />\n  <dataTypes name=\"DefAWADDRchn\" definition=\"typedef DefAXIADDRchn DefAWADDRchn;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;\" readTime=\"\" writeTime=\"\" />\n  <dataTypes name=\"DefDDRCommand\" definition=\"typedef DefDDRAction DefDDRCommand;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; &quot;Cmd:&quot;;&#10;&#09;trace &lt;&lt; get_data().Cmd;&#10;&#09;trace &lt;&lt; &quot;,BankAccessed:&quot;;&#10;&#09;trace &lt;&lt; get_data().BankAccessed;&#10;&#09;trace &lt;&lt; &quot;,RowAccessed:&quot;;&#10;&#09;trace &lt;&lt; get_data().RowAccessed;&#10;&#09;trace &lt;&lt; &quot;,ColumnAccessed:&quot;;&#10;&#09;trace &lt;&lt; get_data().ColumnAccessed;&#10;&#09;trace &lt;&lt; &quot;,memID:&quot;;&#10;&#09;trace &lt;&lt; get_data().memID;\" readTime=\"\" writeTime=\"\" />\n  <dataTypes name=\"DefDQs\" definition=\"typedef int DefDQs;\" tracePayload=\"&#09;trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"DefDataRead\" definition=\"typedef DefMemoryWriteRequest DefDataRead;\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,dataValue:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataValue;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;\" />\n  <dataTypes name=\"DefWriteAck\" definition=\"typedef DefAXIADDRchn DefWriteAck;\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;&#09;\" allocatePayload=\"\" />\n  <dataTypes name=\"DefMemReadRequest\" definition=\"typedef DefMemoryReadRequest DefMemReadRequest;\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;\" />\n  <dataTypes name=\"DefMemWriteRequest\" definition=\"typedef DefMemoryWriteRequest DefMemWriteRequest;\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().startTime;&#10;&#09;trace &lt;&lt; &quot;,ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().ID;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().burstLength;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;\" />\n  <dataTypes name=\"DefListRequestsPtr\" definition=\"typedef DefListRequests *DefListRequestsPtr;\" copyPayload=\"\" tracePayload=\"trace &lt;&lt; get_data()-&gt;memoryRequest.size;&#10;\" readTime=\"\" writeTime=\"\" allocatePayload=\"\" deallocatePayload=\"\" />\n  <dataTypes name=\"DefRequestInformation\" definition=\"typedef struct {&#09;&#13;&#10;&#09;DefMemoryRequest MemRequest;&#13;&#10;&#09;int NbMemTransactions;&#13;&#10;} DefRequestInformation;\" tracePayload=\"&#09;trace &lt;&lt; &quot;MemRequest.dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.dataSize;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.startTime:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.startTime;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.memCmd:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.memCmd;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.ID:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.ID;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.memID:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.memID;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.address:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.address;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.dataValue:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.dataValue;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.size:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.size;&#10;&#09;trace &lt;&lt; &quot;,MemRequest.burstLength:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemRequest.burstLength;&#10;&#09;trace &lt;&lt; &quot;,NbMemTransactions:&quot;;&#10;&#09;trace &lt;&lt; get_data().NbMemTransactions;&#09;\" />\n  <dataTypes name=\"DefRequests2Memory\" definition=\"typedef struct {&#09;&#09;&#13;&#10;&#09;DefDataSize dataSize;&#13;&#10;&#09;DefMemCmd memCmd;&#13;&#10;&#09;long address;&#13;&#10;&#09;int dataValue;&#13;&#10;&#09;int size;&#13;&#10;&#09;int memID;&#13;&#10;} DefRequests2Memory;\" tracePayload=\"&#09;trace &lt;&lt; &quot;dataSize:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataSize;&#10;&#09;trace &lt;&lt; &quot;,memCmd:&quot;;&#10;&#09;trace &lt;&lt; get_data().memCmd;&#10;&#09;trace &lt;&lt; &quot;,address:&quot;;&#10;&#09;trace &lt;&lt; get_data().address;&#10;&#09;trace &lt;&lt; &quot;,dataValue:&quot;;&#10;&#09;trace &lt;&lt; get_data().dataValue;&#10;&#09;trace &lt;&lt; &quot;,size:&quot;;&#10;&#09;trace &lt;&lt; get_data().size;&#10;&#09;trace &lt;&lt; &quot;,memID:&quot;;&#10;&#09;trace &lt;&lt; get_data().memID;\" />\n  <dataTypes name=\"DefMemoryStatus\" definition=\"typedef struct {&#09;&#13;&#10;&#09;DefMemoryMode MemoryState;&#13;&#10;&#09;int ActiveRow[4];&#13;&#10;} DefMemoryStatus;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; &quot;MemoryState:&quot;;&#10;&#09;trace &lt;&lt; get_data().MemoryState;&#10;&#09;trace &lt;&lt; &quot;,ActiveRow[0]:&quot;;&#10;&#09;trace &lt;&lt; get_data().ActiveRow[0];&#10;&#09;trace &lt;&lt; &quot;,ActiveRow[1]:&quot;;&#10;&#09;trace &lt;&lt; get_data().ActiveRow[1];&#10;&#09;trace &lt;&lt; &quot;,ActiveRow[2]:&quot;;&#10;&#09;trace &lt;&lt; get_data().ActiveRow[2];&#10;&#09;trace &lt;&lt; &quot;,ActiveRow[3]:&quot;;&#10;&#09;trace &lt;&lt; get_data().ActiveRow[3];\" readTime=\"\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"DDRMemoryStrucSt\" documentation=\"\">\n    <models xsi:type=\"cofluent:Function\" name=\"ClientSide\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n      <ports name=\"RDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"ARADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"BRESPchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"WDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"AWADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"ClientSideStrucSt\" documentation=\"\">\n        <models xsi:type=\"cofluent:Function\" name=\"Device\" documentation=\"\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"RDATAin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"BRESPin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"ARADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"WDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"AWADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"DeviceStrucSt\">\n            <models xsi:type=\"cofluent:Function\" name=\"Sender\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"DefMemCmd Cmd;&#13;int dataValue;&#13;int myIndex;&#13;long SendInitDuration;&#13;int burstLength;&#13;int size;&#13;float startTime;&#13;long address;&#13;int test;&#13;int SelectCmdDuration;&#13;&#13;int cptTabTest;&#13;int cptTabSelectCmd;&#13;int cptTabAdressRead;&#13;int cptTabAdressWrite;\" definitions=\"\" initializations=\"cptTabTest=0;&#13;&#10;cptTabSelectCmd=0;&#13;&#10;cptTabAdressRead=0;&#13;&#10;cptTabAdressWrite=0;\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n              <ports name=\"ARADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"WDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"AWADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"SenderBehaviorBh\">\n                <statements xsi:type=\"cofluent:Operation\" name=\"SenderInit\" algorithm=\"&#09;myIndex = cf_get_innermost_mi_container()-&gt;get_cp_index();//cf_get_current_function_index();&#13;&#09;switch (Scenario) {&#13;&#09;case WRITEFIRST:&#13;&#09;&#09;SendInitDuration = 1;&#13;&#09;&#09;break;&#13;&#09;case READFIRST:&#13;&#09;&#09;SendInitDuration = 800;&#13;&#09;&#09;break;&#13;&#09;case BOTH:&#13;&#09;&#09;SendInitDuration = 1;&#13;&#09;&#09;break;&#13;&#09;default:&#13;&#09;&#09;break;&#13;&#09;}&#13;&#09;if (myIndex &gt; C_Nbr)&#13;&#09;&#09;SendInitDuration = 1000000;&#10;&#09;&#09;&#09;\" executionTime=\"SendInitDuration Cycle\" type=\"PASSIVE\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop0\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"SelectCmd\" algorithm=\"&#09;&#10;&#10;&#09;if (MODE == DEMO) {&#10;&#09;&#09;test=Tabtest[myIndex][cptTabTest];&#10;&#09;&#09;//cf_trace_report(&quot;1: %d &quot;,Tabtest[0][0]);&#10;&#09;&#09;//cf_trace_report(&quot;test: %d &quot;,test);&#10;&#09;&#09;//cf_trace_report(&quot; %d &quot;,Tabtest[0][0]);&#10;&#09;&#09;//cf_trace_report(&quot; %d &quot;,Tabtest[0][1]);&#10;&#09;&#09;//cf_trace_report(&quot; %d &quot;,Tabtest[0][2]);&#10;&#09;&#09;//cf_trace_report(&quot; %d &quot;,Tabtest[1][0]);&#10;&#09;&#09;//cf_trace_report(&quot; %d &quot;,Tabtest[1][1]);&#10;&#09;&#09;//cf_trace_report(&quot; %d &quot;,Tabtest[1][2]);&#10;&#09;&#09;//cf_trace_report(&quot;%d &quot;,cptTabTest);&#09;&#10;&#09;&#09;cptTabTest++;&#10;&#09;&#09;&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;dataValue = 0;&#10;&#09;&#09;srand( srand_seed);&#10;&#09;&#09;srand_seed++;&#10;&#09;&#09;test = rand() % 10;&#10;&#09;&#09;/*if(myIndex==0){&#10;&#09;&#09;cf_trace_report(&quot;%d &quot;, test);}*/&#10;&#09;&#09;/*cptTabTest++;*/&#10;&#09;&#09;/*cf_trace_report(&quot;%d &quot;, cptTabTest);}*/&#10;&#09;}&#10;&#09;&#13;&#09;if (test &lt; 5) {&#13;&#09;&#09;Cmd = READREQ;&#10;&#09;&#09;/*cf_trace_report(&quot;Cmd = READREQ&quot;);*/&#13;&#09;} else {&#13;&#09;&#09;Cmd = WRITEREQ;&#10;&#09;&#09;/*cf_trace_report(&quot;Cmd = WRITEREQ&quot;);*/&#13;&#09;}&#10;&#09;&#10;&#10;&#09;if (MODE == DEMO) {&#10;&#09;&#09;SelectCmdDuration=TabSelectCmd[myIndex][cptTabSelectCmd];&#10;&#09;&#09;cptTabSelectCmd++;&#10;&#09;&#09;//cf_trace_report(&quot;%d: %d &quot;, myIndex, SelectCmdDuration);/*}*/&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;SelectCmdDuration = rand() % 90 + 10;&#10;&#09;}\" executionTime=\"SelectCmdDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"PrepareReadCmd\" documentation=\"\" algorithm=\"&#09;/* Datasize is only 1 because it takes one cycle to send it*/&#13;&#09;ARADDRchn.dataSize = 1;&#13;&#09;ARADDRchn.startTime = (float) ( cf_time_stamp().to_scalar(CF_NS) + 10 * MasterDelay );&#13;&#09;ARADDRchn.ID = myIndex;&#10;&#09;//cf_trace_report(&quot;Before cf_util_rand_uint 1, M_Nbr=%d, MEMORYSIZE=%d&quot;,M_Nbr.get_value(),MEMORYSIZE);&#10;&#09;/*ARADDRchn.address = MEMORYSIZE * cf_util_rand_uint(0, M_Nbr.get_value() -1 ) + cf_util_rand_uint(0,MEMORYSIZE); replace by following code in v5.0.0 because cf_util_rand_uint(0, 0) does't work (MIN must be &lt; to MAX)*/ &#10;&#09;if (M_Nbr.get_value()==1)&#10;&#09;{&#13;&#09;&#09;if (MODE == DEMO) {&#10;&#09;&#09;&#09;ARADDRchn.address=TabAdressRead[myIndex][cptTabAdressRead];&#10;&#09;&#09;&#09;cptTabAdressRead++;&#10;&#09;&#09;}&#10;&#09;&#09;else&#10;&#09;&#09;&#09;ARADDRchn.address = cf_util_rand_uint(0,MEMORYSIZE);&#10;&#09;}&#10;&#09;else&#10;&#09;{&#10;&#09;&#09;if (MODE == DEMO) {&#10;&#09;&#09;&#09;ARADDRchn.address=TabAdressRead[myIndex][cptTabAdressRead];&#10;&#09;&#09;&#09;cptTabAdressRead++;&#10;&#09;&#09;}&#10;&#09;&#09;else&#10;&#09;&#09;ARADDRchn.address = MEMORYSIZE * cf_util_rand_uint(0, M_Nbr.get_value() -1 ) + cf_util_rand_uint(0,MEMORYSIZE);&#10;&#10;&#09;}&#10;&#09;/*ARADDRchn.address = MEMORYSIZE * cf_util_rand_uint(M_Nbr - 1, 0) + cf_util_rand_uint(MEMORYSIZE, 0);*/&#10;&#09;/*cf_trace_report(&quot;%d&quot;,ARADDRchn.address);*/&#13;&#09;if (BurstLengthMode == FIX) {&#13;&#09;&#09;burstLength = BurstLength;&#13;&#09;} else {&#10;&#09;&#09;//cf_trace_report(&quot;Before cf_util_rand_uint 2&quot;);&#13;&#09;&#09;/*burstLength = cf_util_rand_uint(1, BurstLength);*/&#10;&#09;&#09;burstLength = cf_util_rand_uint(BurstLength, 1);&#10;&#09;&#09;/*cf_trace_report(&quot;burstLength=%d&quot;,burstLength);*/&#13;&#09;}&#13;&#09;ARADDRchn.burstLength = burstLength;&#13;&#09;size = AXIDataTransferSize;&#13;&#09;ARADDRchn.size = size;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&quot;Sending Read Address, Master %i, burstlength %i, address %i, size %i&quot;,&#09;myIndex, burstLength, ARADDRchn.address, size);&#13;&#09;}\" executionTime=\"MasterDelay Cycle\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action16\" duration=\" fs\" condition=\"\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action17\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"PrepareWriteCmd\" algorithm=\"&#09;startTime = (float) cf_time_stamp().to_scalar(CF_NS);&#13;&#09;AWADDRchn.startTime = startTime + 10 * MasterDelay;&#13;&#09;AWADDRchn.dataSize = 1;&#13;&#09;/* Up to now, 1 ID per master*/&#13;&#09;AWADDRchn.ID = myIndex;&#13;&#10;&#09;if (MODE == DEMO) {&#10;&#09;&#09;&#09;address =TabAdressWrite[myIndex][cptTabAdressWrite];&#10;&#09;&#09;&#09;cptTabAdressWrite++;&#10;&#09;&#09;}&#10;&#09;else&#10;&#09;&#09;address = cf_util_rand_uint(0, (M_Nbr * MEMORYSIZE) - 1);&#10;&#09;&#13;&#09;AWADDRchn.address = address;&#10;&#09;cf_trace_report(&quot;%d&quot;,AWADDRchn.address);&#13;&#09;if (BurstLengthMode == FIX) {&#13;&#09;&#09;burstLength = BurstLength;&#13;&#09;} else {&#13;&#09;&#09;burstLength = cf_util_rand_uint(1, BurstLength);&#13;&#09;}&#13;&#13;&#09;AWADDRchn.burstLength = burstLength;&#13;&#09;size = AXIDataTransferSize;&#13;&#09;AWADDRchn.size = size;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&quot;Sending Write Address, Master %i, burstlength %i, address %d, size %i&quot;,&#13;&#09;&#09;&#09;&#09;myIndex, burstLength, address, size);&#13;&#09;}\" executionTime=\"MasterDelay Cycle\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action18\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:AlternativeStatement\" documentation=\"\">\n                  <conditionalBranches condition=\"Cmd==READREQ\" />\n                  <conditionalBranches condition=\"\" />\n                </statements>\n                <statements xsi:type=\"cofluent:Operation\" name=\"PrepareDataTransfer\" algorithm=\"&#09;WDATAchn.dataValue = dataValue;&#13;&#09;WDATAchn.startTime = startTime;&#13;&#09;WDATAchn.ID = myIndex;&#13;&#09;dataValue++;\" executionTime=\"4 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"ReceiverRData\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"int burstLength;&#13;&#09;int myIndex;&#13;&#09;long ReceiveInitDuration;&#13;&#09;float startTime;&#13;&#09;float ReadLatency;&#13;&#09;int NbDataTransfer;&#13;&#09;int RemainingDataTransfer;\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n              <ports name=\"RDATAin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"ReceiverRDataBehaviorBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector2\" instanceNumber=\"SELF\">\n                  <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" />\n                </selectors>\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                  <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:Operation\" name=\"ReceiverRDataInit\" algorithm=\"&#09;myIndex = cf_get_innermost_mi_container()-&gt;get_cp_index();&#13;&#09;ReceiveInitDuration = 1;&#13;&#09;if (myIndex &gt; C_Nbr) {&#13;&#09;&#09;ReceiveInitDuration = 1000000;&#13;&#09;&#09;cf_trace_report(&quot;instance %i of rddata disabled&quot;, myIndex);&#13;&#09;}\" executionTime=\"ReceiveInitDuration Cycle\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop2\" condition=\"\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop3\" condition=\"NbDataTransfer\" type=\"MULTIPLICATION\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond1\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"RxNextDataTransfer\" algorithm=\"&#09;startTime = RDATAin.startTime;&#13;&#09;ReadLatency = ( float ) ( cf_time_stamp().to_scalar(CF_NS) - startTime );&#13;&#09;ReadBandwidth = (burstLength * AXIDataTransferSize) * 1000 / ReadLatency;&#13;&#09;RemainingDataTransfer--;&#13;&#09;if (RemainingDataTransfer == 0) {&#13;&#09;&#09;cf_trace_gui_f_t(&quot;ReadLatency&quot;, ReadLatency, &quot;ns&quot;);&#13;&#09;&#09;cf_trace_gui_f_t(&quot;ReadBandwidth&quot;, ReadBandwidth, &quot;Mb/s&quot;);&#13;&#09;&#09;cf_trace_gui_f_t(&quot;CombinedBandwith&quot;, ReadBandwidth, &quot;Mb/s&quot;);&#13;&#09;&#09;TotalReadData = TotalReadData + burstLength * AXIDataTransferSize;&#13;&#09;&#09;TotalReadLatency = TotalReadLatency + ReadLatency;&#13;&#09;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&quot;ReadLatency = %f ns, starttime %f currenttime %f NbDataTransfer %i ID %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;ReadLatency, startTime, cf_time_stamp().to_scalar(CF_NS),&#13;&#09;&#09;&#09;&#09;&#09;NbDataTransfer, cf_get_innermost_mi_container()-&gt;get_cp_index());/*cf_get_current_function_index());*/&#13;&#09;&#09;}&#13;&#09;}&#13;\" executionTime=\"1 Cycle\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"RxFirstDataTransfer\" algorithm=\"&#09;/* burstLength = RequestsStatus[RDATAin.ID];*/&#13;&#09;burstLength = RDATAin.burstLength;&#13;&#09;NbDataTransfer = burstLength - 1;&#13;&#09;RemainingDataTransfer = NbDataTransfer;&#13;&#09;startTime = RDATAin.startTime;&#13;&#09;ReadLatency = (float) ( cf_time_stamp().to_scalar(CF_NS) - startTime );&#13;&#09;ReadBandwidth = (burstLength * AXIDataTransferSize) * 1000 / ReadLatency;&#13;&#09;if (NbDataTransfer == 0) {&#13;&#09;&#09;cf_trace_gui_f_t(&quot;ReadLatency&quot;, ReadLatency, &quot;ns&quot;);&#13;&#09;&#09;cf_trace_gui_f_t(&quot;ReadBandwidth&quot;, ReadBandwidth, &quot;Mb/s&quot;);&#13;&#09;&#09;cf_trace_gui_f_t(&quot;CombinedBandwidth&quot;, ReadBandwidth, &quot;Mb/s&quot;);&#13;&#09;&#09;TotalReadData = TotalReadData + burstLength * AXIDataTransferSize;&#13;&#09;&#09;TotalReadLatency = TotalReadLatency + ReadLatency;&#13;&#09;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&quot;ReadLatency = %f ns, starttime %f currenttime %f NbDataTransfer %i ID %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;ReadLatency, startTime, cf_time_stamp().to_scalar(CF_NS),&#13;&#09;&#09;&#09;&#09;&#09;NbDataTransfer, cf_get_current_function_index());&#13;&#09;&#09;}&#13;&#09;}&#13;&#09;NbTotalReadRequests++;\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond27\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"ReceiveWACK\" documentation=\"\" constructor=\"\" includes=\"\" declarations=\"int myIndex;&#13;&#10;long ReceiveWACKInitDuration;&#13;&#10;float WriteLatency;&#13;&#10;float startTime;&#13;&#10;int burstLength;\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\">\n              <ports name=\"BRESPin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"ReceiveWACKBehaviorBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" documentation=\"\" instanceNumber=\"SELF\">\n                  <inputs priority=\"\" timeout=\" ms\" duration=\" ns\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop26\" condition=\"\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond28\" documentation=\"\" timeout=\" ms\" priority=\"\" duration=\" fs\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"RcvWACKInit\" documentation=\"\" algorithm=\"\" executionTime=\"10 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"RcvWACKProcess\" algorithm=\"&#09;startTime = BRESPin.startTime;&#13;&#09;burstLength = BRESPin.burstLength;&#13;&#09;WriteLatency = ( float ) (  cf_time_stamp().to_scalar(CF_NS) - startTime );&#13;&#09;cf_trace_gui_f_t(&quot;WriteLatency&quot;, WriteLatency, &quot;ns&quot;);&#13;&#09;NbTotalWriteRequests++;&#13;&#09;TotalWriteLatency = TotalWriteLatency + WriteLatency;&#13;&#09;WriteBandwidth = (burstLength * AXIDataTransferSize) * 1000 / WriteLatency;&#13;&#09;cf_trace_gui_f_t(&quot;WriteBandwidth&quot;, WriteBandwidth, &quot;Mb/s&quot;);&#13;&#09;cf_trace_gui_f_t(&quot;CombinedBandwidth&quot;, WriteBandwidth, &quot;Mb/s&quot;);&#13;&#09;TotalWriteData = TotalWriteData + burstLength * AXIDataTransferSize;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&quot;WriteLatency = %f us, starttime %f currenttime %f ID %i&quot;,WriteLatency, startTime, cf_time_stamp().to_scalar(CF_NS),cf_get_current_function_index());&#13;&#09;}\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n              </refinement>\n            </models>\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:RoutingFunction\" name=\"WRDmux\" constructor=\"\" destination=\" &#09; int sourceID;&#10; &#09; sourceID = ((cft_defbrespchn*)_trans)-&gt;get_data().ID;&#10; &#09; std::stringstream ss;&#10; &#09; ss &lt;&lt; &quot;BRESPin[&quot; &lt;&lt; sourceID &lt;&lt; &quot;]&quot;;&#10; &#09; return ss.str();&#10; &#09; return &quot;&quot;;\" concurrency=\"1\" routingTime=\"1 Cycle\">\n          <ports name=\"BRESPchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"BRESPin\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n        </models>\n        <models xsi:type=\"cofluent:RoutingFunction\" name=\"RDDmux\" documentation=\"\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" destination=\"&#09;int sourceID;&#13;&#09;sourceID = ((cft_defrdatachn*)_trans)-&gt;get_data().ID;&#13;&#13;&#09;std::stringstream ss;&#13;&#09;ss &lt;&lt; &quot;RDATAin[&quot; &lt;&lt; sourceID &lt;&lt; &quot;]&quot;;&#13;&#09;return ss.str();\" concurrency=\"1\" routingTime=\"1 Cycle\">\n          <ports name=\"RDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"RDATAin\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n        </models>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"BRESPin\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"RDATAin\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Target\" documentation=\"\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n      <ports name=\"RDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"ARADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"BRESPchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"WDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"AWADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"TargetStrucSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"MemoryController\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"DQs\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"RDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"ARADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"BRESPchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"WDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"AWADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"DDRCommand\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"MemoryControllerStrucSt\">\n            <models xsi:type=\"cofluent:RoutingFunction\" name=\"WAddrDmux\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"int Port_ID;\" definitions=\"\" preElaboration=\"\" initializations=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" destination=\"&#09;int sourceID;&#13;&#09;sourceID = ((cft_defawaddrchn*)_trans)-&gt;get_data().ID;&#13;&#09;&#13;&#09;std::stringstream ss;&#13;&#09;ss &lt;&lt; &quot;AWADDRin[&quot;&lt;&lt; sourceID &lt;&lt; &quot;]&quot;;&#09;cout &lt;&lt; ss.str();&#13;&#09;return ss.str();&#13;\" concurrency=\"1\" routingTime=\"0 Cycle\">\n              <ports name=\"AWADDRin\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"AWADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n            </models>\n            <models xsi:type=\"cofluent:RoutingFunction\" name=\"WdataDmux\" declarations=\"int Port_ID;\" definitions=\"\" destination=\"&#09;int sourceID;&#10;&#09;sourceID = ((cft_defwdatachn*)_trans)-&gt;get_data().ID;&#10;&#09;std::stringstream ss;&#10;&#09;ss &lt;&lt; &quot;WDATAin[&quot; &lt;&lt; sourceID &lt;&lt; &quot;]&quot;;&#10;&#09;return ss.str();\" concurrency=\"1\" routingTime=\"0 Cycle\">\n              <ports name=\"WDATAin\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"WDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n            </models>\n            <models xsi:type=\"cofluent:RoutingFunction\" name=\"RAddrDmux\" constructor=\"\" destructor=\"\" declarations=\"int Port_ID;\" definitions=\"\" initializations=\"\" destination=\"&#09;int sourceID;&#10;&#09;sourceID = ((cft_defaraddrchn*)_trans)-&gt;get_data().ID;&#10;&#09;std::stringstream ss;&#10;&#09;ss &lt;&lt; &quot;ARADDRin[&quot; &lt;&lt; sourceID &lt;&lt; &quot;]&quot;;&#10;&#09;return ss.str();\" concurrency=\"1\" routingTime=\"0 Cycle\">\n              <ports name=\"ARADDRin\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"ARADDRchn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"FrontEnd\" declarations=\"\" preElaboration=\"\" cyclePeriod=\"10 ns\">\n              <ports name=\"DataRead\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"WriteAck\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"RDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"BRESPchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"MemReadRequest\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"MemWriteRequest\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"ARADDRin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"WDATAin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"AWADDRin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"FrontEndStrucSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"WriteDriver\" declarations=\"int burstLength;&#13;&#09;float startTime;&#13;&#09;int address;&#13;&#09;int ID;&#13;&#09;int size;&#13;&#09;long WriteInitDuration;&#13;&#09;int myIndex;&#13;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"MemWriteRequest\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"WDATAin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"AWADDRin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"WriteDriverBehaviorBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                      <inputs priority=\"\" timeout=\" ms\" duration=\" ns\" />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector2\" instanceNumber=\"SELF\">\n                      <inputs priority=\"\" timeout=\" ms\" duration=\" ns\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"WdInit\" algorithm=\"&#09;myIndex = cf_get_innermost_mi_container()-&gt;get_cp_index();&#13;&#09;WriteInitDuration = 1;&#13;&#09;if (myIndex &gt; P_Nbr)&#13;&#09;&#09;WriteInitDuration = 1000000;\" executionTime=\"WriteInitDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop4\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond2\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"WdAddr\" algorithm=\"&#09;burstLength = AWADDRin.burstLength;&#13;&#09;startTime = AWADDRin.startTime;&#13;&#09;address = AWADDRin.address;&#13;&#09;ID = AWADDRin.ID;&#13;&#09;size = AWADDRin.size;&#13;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&quot;WriteDriver ADDR: address = %i, ID = %i, Instance = %i&quot;,&#13;&#09;&#09;&#09;&#09;address, ID, myIndex);&#13;&#09;}\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop5\" condition=\"burstLength\" type=\"MULTIPLICATION\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond3\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"WdData\" algorithm=\"&#09;MemWriteRequest.startTime = startTime;&#13;&#09;MemWriteRequest.ID = ID;&#13;&#09;MemWriteRequest.address = address;&#13;&#09;MemWriteRequest.burstLength = burstLength;&#13;&#09;MemWriteRequest.size = size;&#13;&#09;MemWriteRequest.dataValue = WDATAin.dataValue;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&quot;WriteDriver DATA: address = %i, ID = %i&quot;, address, ID);&#13;&#09;}&#13;&#09;address++;\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action3\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"ReadDriver\" constructor=\"\" destructor=\"\" declarations=\"int burstLength;&#13;&#09;float startTime;&#13;&#09;int address;&#13;&#09;int ID;&#13;&#09;int size;&#13;&#09;bool First;&#13;&#09;long RdInitDuration;&#13;&#09;int myIndex;\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n                  <ports name=\"MemReadRequest\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"ARADDRin\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"ReadDriverBehaviorBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                      <inputs priority=\"\" timeout=\" ms\" duration=\" ns\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"RdInit\" algorithm=\"&#09;First = true;&#13;&#09;myIndex = cf_get_innermost_mi_container()-&gt;get_cp_index();&#13;&#09;RdInitDuration = 1;&#13;&#09;if (myIndex &gt; P_Nbr)&#13;&#09;&#09;RdInitDuration = 1000000;\" executionTime=\"RdInitDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop7\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond5\" timeout=\" ms\" priority=\"\" duration=\" fs\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"RdAddr\" algorithm=\"&#09;burstLength = ARADDRin.burstLength;&#13;&#09;startTime = ARADDRin.startTime;&#13;&#09;address = ARADDRin.address;&#13;&#09;ID = ARADDRin.ID;&#13;&#09;size = ARADDRin.size;&#13;&#09;First = true;\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action6\" duration=\" fs\" condition=\"\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop25\" condition=\"burstLength\" type=\"MULTIPLICATION\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"UpdAddress\" algorithm=\"&#09;MemReadRequest.startTime = startTime;&#13;&#09;MemReadRequest.burstLength = burstLength;&#13;&#09;MemReadRequest.ID = ID;&#13;&#09;MemReadRequest.address = address;&#13;&#09;MemReadRequest.size = size;&#10;&#13;&#09;if (First == true) {&#13;&#09;&#09;First = false;&#13;&#09;&#09;address = address + size / (EffectiveMemoryWidth);&#13;&#09;} else {&#13;&#09;&#09;address = address + size / (EffectiveMemoryWidth);&#13;&#09;}\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"SendWAckDriver\" declarations=\"long WACKInitDuration;&#13;&#10;int myIndex;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"WriteAck\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"BRESPchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"SendWAckBehaviorBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                      <inputs priority=\"\" timeout=\" ms\" duration=\" ns\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SendWAckInit\" algorithm=\"&#09;myIndex = cf_get_innermost_mi_container()-&gt;get_cp_index();&#13;&#09;WACKInitDuration = 1;&#13;&#09;if (myIndex &gt; P_Nbr)&#13;&#09;&#09;WACKInitDuration = 1000000;\" executionTime=\"WACKInitDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop10\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond8\" timeout=\" ms\" priority=\"\" duration=\" fs\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"PrepareWAck\" algorithm=\"&#09;BRESPchn = WriteAck;\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action10\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"ReadDataDriver\" declarations=\"float startTime;&#13;&#09;int ID;&#13;&#09;int burstLength;&#13;&#09;long ReadDataInitDuration;&#13;&#09;int myIndex;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"RDATAchn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"DataRead\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"ReadDataDriverBehaviorBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                      <inputs priority=\"\" timeout=\" ms\" duration=\" ns\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"ReadDataInit\" algorithm=\"&#09;myIndex = cf_get_innermost_mi_container()-&gt;get_cp_index();&#13;&#09;ReadDataInitDuration = 1;&#13;&#09;if (myIndex &gt; P_Nbr)&#13;&#09;&#09;ReadDataInitDuration = 1000000;\" executionTime=\"ReadDataInitDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop19\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond15\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop20\" condition=\"1\" type=\"MULTIPLICATION\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"PrepareDataTransfer\" algorithm=\"&#09;RDATAchn.dataSize = DataRead.dataSize;&#13;&#09;RDATAchn.startTime = DataRead.startTime;&#13;&#09;RDATAchn.ID = DataRead.ID;&#13;&#09;RDATAchn.burstLength = DataRead.burstLength;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&quot;ReadDataDriver fwed = burstlength %i ID %i&quot;,&#13;&#09;&#09;&#09;&#09;DataRead.burstLength, DataRead.ID);&#13;&#09;}\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action20\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"RcvReadData\" algorithm=\"\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                  </refinement>\n                </models>\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"BackEnd\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" cyclePeriod=\"10 ns\">\n              <ports name=\"DQs\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"DataRead\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"WriteAck\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"MemReadRequest\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"MemWriteRequest\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"DDRCommand\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"BackEndStrucSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"CollectRequests\" declarations=\"DefListRequestsPtr currentRequestPtr;&#13;&#10;DefListRequestsPtr prevRequestPtr;&#13;&#10;int memID;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"ListRequestsPtr\" type=\"SHARED_VARIABLE\" direction=\"IN_OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RequestCounter\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"MemReadRequest\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"MemWriteRequest\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"CollectRequestsBehaviorBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop21\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond16\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action21\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"CollectInit\" algorithm=\"&#09;ListRequestsPtr = &amp;FirstEmptyRequest;&#13;&#09;ListRequestsPtr-&gt;prevRequestPtr = NULL;&#13;&#09;ListRequestsPtr-&gt;nextRequestPtr = NULL;\" executionTime=\"10 ns\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:MultipleGuardedStatement\" name=\"MultipleWait\">\n                      <guardedBranches />\n                      <guardedBranches />\n                    </statements>\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond17\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"StoreReadRequest\" algorithm=\"&#10;if (ListRequestsPtr-&gt;nextRequestPtr == NULL) {&#13;&#09;&#09;currentRequestPtr = (DefListRequests*) malloc(sizeof(DefListRequests));&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memCmd = READREQ;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataSize = MemReadRequest.dataSize;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.startTime = MemReadRequest.startTime;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.ID = MemReadRequest.ID;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memID = MemReadRequest.address&#13;&#09;&#09;&#09;&#09;/ MEMORYSIZE + 1;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.address = (MemReadRequest.address)&#13;&#09;&#09;&#09;&#09;% MEMORYSIZE;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.size = MemReadRequest.size;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataValue = 0;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.burstLength =&#13;&#09;&#09;&#09;&#09;MemReadRequest.burstLength;&#13;&#09;&#09;currentRequestPtr-&gt;nextRequestPtr = NULL;&#13;&#09;&#09;currentRequestPtr-&gt;prevRequestPtr = ListRequestsPtr;&#13;&#09;&#09;memID = MemReadRequest.address / MEMORYSIZE + 1;&#13;&#09;&#09;ListRequestsPtr-&gt;nextRequestPtr = currentRequestPtr;&#13;&#09;} else {&#13;&#09;&#09;currentRequestPtr = ListRequestsPtr-&gt;nextRequestPtr;&#13;&#09;&#09;do {&#13;&#09;&#09;&#09;prevRequestPtr = currentRequestPtr;&#13;&#09;&#09;&#09;currentRequestPtr = currentRequestPtr-&gt;nextRequestPtr;&#13;&#09;&#09;} while (currentRequestPtr != NULL);&#13;&#09;&#09;currentRequestPtr = (DefListRequests*) malloc(sizeof(DefListRequests));&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataSize = MemReadRequest.dataSize;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.startTime = MemReadRequest.startTime;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memCmd = READREQ;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.ID = MemReadRequest.ID;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memID = MemReadRequest.address&#13;&#09;&#09;&#09;&#09;/ MEMORYSIZE + 1;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.address = (MemReadRequest.address)&#13;&#09;&#09;&#09;&#09;% MEMORYSIZE;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.size = MemReadRequest.size;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.burstLength =&#13;&#09;&#09;&#09;&#09;MemReadRequest.burstLength;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataValue = 0;&#13;&#09;&#09;currentRequestPtr-&gt;nextRequestPtr = NULL;&#13;&#09;&#09;currentRequestPtr-&gt;prevRequestPtr = prevRequestPtr;&#13;&#09;&#09;prevRequestPtr-&gt;nextRequestPtr = currentRequestPtr;&#13;&#09;&#09;memID = MemReadRequest.address / MEMORYSIZE + 1;&#13;&#09;}&#13;&#09;NbReadRequests = NbReadRequests + 1;&#13;&#09;cf_trace_gui_f_t(&quot;NbReadRequests&quot;, NbReadRequests, &quot;requests&quot;);&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&quot;Request stored read = address %i datavalue %i size %i burstlength %i ID %i address request %x previous %x starttime %i&quot;,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.address,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataValue,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.size,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.burstLength,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.ID, currentRequestPtr,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;prevRequestPtr, MemReadRequest.startTime);&#13;&#09;}\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"StoreWriteRequest\" algorithm=\"if (ListRequestsPtr-&gt;nextRequestPtr == NULL) {&#13;&#09;&#09;currentRequestPtr = (DefListRequests*) malloc(sizeof(DefListRequests));&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataSize = MemWriteRequest.dataSize;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.startTime = MemWriteRequest.startTime;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memCmd = WRITEREQ;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.ID = MemWriteRequest.ID;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memID = MemWriteRequest.address&#13;&#09;&#09;&#09;&#09;/ MEMORYSIZE + 1;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.address = (MemWriteRequest.address)&#13;&#09;&#09;&#09;&#09;% MEMORYSIZE;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.size = MemWriteRequest.size;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataValue = MemWriteRequest.dataValue;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.burstLength =&#13;&#09;&#09;&#09;&#09;MemWriteRequest.burstLength;&#13;&#09;&#09;currentRequestPtr-&gt;nextRequestPtr = NULL;&#13;&#09;&#09;currentRequestPtr-&gt;prevRequestPtr = ListRequestsPtr;&#13;&#09;&#09;ListRequestsPtr-&gt;nextRequestPtr = currentRequestPtr;&#13;&#09;} else {&#13;&#09;&#09;currentRequestPtr = ListRequestsPtr-&gt;nextRequestPtr;&#13;&#09;&#09;do {&#13;&#09;&#09;&#09;prevRequestPtr = currentRequestPtr;&#13;&#09;&#09;&#09;currentRequestPtr = currentRequestPtr-&gt;nextRequestPtr;&#13;&#09;&#09;} while (currentRequestPtr != NULL);&#13;&#09;&#09;currentRequestPtr = (DefListRequests*) malloc(sizeof(DefListRequests));&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataSize = MemWriteRequest.dataSize;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.startTime = MemWriteRequest.startTime;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memCmd = WRITEREQ;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.ID = MemWriteRequest.ID;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.memID = MemWriteRequest.address&#13;&#09;&#09;&#09;&#09;/ MEMORYSIZE + 1;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.address = (MemWriteRequest.address)&#13;&#09;&#09;&#09;&#09;% MEMORYSIZE;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.size = MemWriteRequest.size;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataValue = MemWriteRequest.dataValue;&#13;&#09;&#09;currentRequestPtr-&gt;memoryRequest.burstLength =&#13;&#09;&#09;&#09;&#09;MemWriteRequest.burstLength;&#13;&#09;&#09;currentRequestPtr-&gt;nextRequestPtr = NULL;&#13;&#09;&#09;currentRequestPtr-&gt;prevRequestPtr = prevRequestPtr;&#13;&#09;&#09;prevRequestPtr-&gt;nextRequestPtr = currentRequestPtr;&#13;&#09;}&#13;&#09;NbWriteRequests = NbWriteRequests + 1;&#13;&#09;cf_trace_gui_f_t(&quot;NbWriteRequests&quot;, NbWriteRequests, &quot;requests&quot;);&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&quot;Request stored write = address %i datavalue %i size %i burstlength %i ID %i adresse requete %x previous %x&quot;,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.address,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.dataValue,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.size,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.burstLength,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;memoryRequest.ID, currentRequestPtr,&#13;&#09;&#09;&#09;&#09;currentRequestPtr-&gt;prevRequestPtr);&#13;&#09;}\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"ResponseForward\" destructor=\"\" declarations=\"bool IS_WRITE_ACK;&#13;&#10;bool IS_DATA_READ;&#13;&#10;int NbDataTransfer;&#13;&#10;// delay expected before data is available on dq signals&#13;&#10;int DqReadyDuration;&#13;&#10;bool NORMAL_ACK;&#13;&#10;bool SEND_NORMAL_ACK;&#13;&#10;long PrepareResponseDuration;&#13;&#10;int BankAccessed;&#13;&#10;int RowAccessed;&#13;&#10;int ColumnAccessed;&#13;&#10;int NbMemRcvTransactions;&#13;&#10;// Table used to count the number data transfers already processed within a burst for each master and each command Write/Read&#13;&#10;int RemainingData[10][2];&#13;&#10;int ID;&#13;&#10;int Length;&#13;&#10;int Command;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"DQs\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RequestInformation\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"DataRead\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"WriteAck\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"ResponseForwardBehaviorBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"OutSel5\" instanceNumber=\"SELF\">\n                      <output />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"OutSel6\" instanceNumber=\"SELF\">\n                      <output />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"ResponseFwInit\" algorithm=\"&#09;NbDataTransfer = 0;&#13;&#09;/* by default, put 3 cycles before data ready*/&#13;&#09;DqReadyDuration = 3;&#13;&#09;if (WriteAckStrategy == NORMAL) {&#13;&#09;&#09;NORMAL_ACK = true;&#13;&#09;} else {&#13;&#09;&#09;NORMAL_ACK = false;&#13;&#09;}&#13;&#09;memset(*RemainingData, 0, sizeof(RemainingData));\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop23\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond18\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"PrepareResponse\" algorithm=\"&#09;ID = RequestInformation.MemRequest.ID;&#13;&#09;Length = RequestInformation.MemRequest.burstLength;&#13;&#09;Command = RequestInformation.MemRequest.memCmd;&#13;&#13;&#09;if (RemainingData[ID][Command] == 0) {&#13;&#09;&#09;RemainingData[ID][Command] = Length;&#13;&#09;}&#13;&#09;NbDataTransfer = RemainingData[ID][Command];&#13;&#13;&#09;if (NbDataTransfer == 1) {&#13;&#09;&#09;if (Command == WRITEREQ) {&#13;&#09;&#09;&#09;IS_WRITE_ACK = true;&#13;&#09;&#09;&#09;IS_DATA_READ = false;&#13;&#09;&#09;&#09;WriteAck.startTime = RequestInformation.MemRequest.startTime;&#13;&#09;&#09;&#09;WriteAck.ID = ID;&#13;&#09;&#09;&#09;WriteAck.burstLength = Length;&#13;&#09;&#09;&#09;WriteAck.size = 1;&#13;&#09;&#09;&#09;WriteAck.address = RequestInformation.MemRequest.address;&#13;&#09;&#09;&#09;RemainingData[ID][Command]--;&#13;&#09;&#09;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Request Write fwed = address %i ID %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.address,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.ID);&#13;&#09;&#09;&#09;}&#13;&#09;&#09;} else {&#13;&#09;&#09;&#09;IS_WRITE_ACK = false;&#13;&#09;&#09;&#09;IS_DATA_READ = true;&#13;&#09;&#09;&#09;DataRead.startTime = RequestInformation.MemRequest.startTime;&#13;&#09;&#09;&#09;DataRead.ID = ID;&#13;&#09;&#09;&#09;DataRead.address = RequestInformation.MemRequest.address;&#13;&#09;&#09;&#09;DataRead.burstLength = Length;&#13;&#09;&#09;&#09;DataRead.size = RequestInformation.MemRequest.size;&#13;&#09;&#09;&#09;RemainingData[ID][Command]--;&#13;&#09;&#09;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&#09;&quot;Request Read fwed = address %i size %i burstlength %i ID %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.address,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.size,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.burstLength,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.ID);&#13;&#09;&#09;&#09;}&#13;&#09;&#09;}&#13;&#09;} else {&#13;&#09;&#09;if (Command == WRITEREQ) {&#13;&#09;&#09;&#09;IS_WRITE_ACK = false;&#13;&#09;&#09;&#09;IS_DATA_READ = false;&#13;&#09;&#09;&#09;RemainingData[ID][Command]--;&#13;&#09;&#09;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;&#09;&#09;cf_trace_report(&quot;Data Transfers Write Expected, Remaining %i &quot;,&#13;&#09;&#09;&#09;&#09;&#09;&#09;NbDataTransfer);&#13;&#09;&#09;&#09;}&#13;&#09;&#09;} else {&#13;&#09;&#09;&#09;IS_WRITE_ACK = false;&#13;&#09;&#09;&#09;IS_DATA_READ = true;&#13;&#09;&#09;&#09;DataRead.startTime = RequestInformation.MemRequest.startTime;&#13;&#09;&#09;&#09;DataRead.ID = ID;&#13;&#09;&#09;&#09;DataRead.address = RequestInformation.MemRequest.address;&#13;&#09;&#09;&#09;DataRead.burstLength = Length;&#13;&#09;&#09;&#09;DataRead.size = RequestInformation.MemRequest.size;&#13;&#09;&#09;&#09;RemainingData[ID][Command]--;&#13;&#09;&#09;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&#09;&quot;Request Read fwed = address %i size %i burstlength %i ID %i Remaining %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.address,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.size,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.burstLength,&#13;&#09;&#09;&#09;&#09;&#09;&#09;RequestInformation.MemRequest.ID, NbDataTransfer);&#13;&#09;&#09;&#09;}&#13;&#09;&#09;}&#13;&#09;}&#13;&#09;SEND_NORMAL_ACK = NORMAL_ACK &amp;&amp; IS_WRITE_ACK;&#13;&#13;&#09;NbMemRcvTransactions = RequestInformation.NbMemTransactions;&#13;&#09;PrepareResponseDuration = 1;\" executionTime=\"DqReadyDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action23\" duration=\" fs\" condition=\"SEND_NORMAL_ACK\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action24\" duration=\" fs\" condition=\"IS_DATA_READ\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop30\" condition=\"NbMemRcvTransactions\" type=\"MULTIPLICATION\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond34\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"Arbitration\" declarations=\"DefListRequestsPtr SelectedRequestPtr;&#13;&#10;DefListRequestsPtr CurrentRequestPtr;&#13;&#10;DefListRequestsPtr NextRequestPtr;&#13;&#10;int memID;&#13;&#10;int RemainingRequests;&#13;&#10;int BurstID;&#13;&#10;int RequestID;&#13;&#10;bool RequestIDerror;&#13;&#10;int NbRequestsCk;&#13;&#10;DefMemCmd CMDRef;&#13;&#10;DefMemCmd CMDCurrent;&#13;&#10;int NbMemoryTransactions;&#13;&#10;bool SendFastAck;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"WriteAck\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RequestInformation\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"ListRequestsPtr\" type=\"SHARED_VARIABLE\" direction=\"IN_OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"Requests2Memory\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RequestCounter\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"ArbitrationBehaviorBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"OutSel26\" instanceNumber=\"SELF\">\n                      <output name=\"OutputSelectorOutput\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"ArbitrerInit\" algorithm=\"&#09;RemainingRequests = 0;&#13;&#09;RequestID = 0;&#13;&#09;BurstID = 0;&#13;&#09;SendFastAck = false;&#13;&#09;RequestIDerror = false;\" executionTime=\"10 ns\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop24\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond19\" timeout=\" ms\" duration=\" ns\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"ReadRequestList\" algorithm=\"/* Up to now, just select the first pending request*/&#13;&#09;CurrentRequestPtr = ListRequestsPtr-&gt;nextRequestPtr;&#13;\" executionTime=\"1 Cycle\" systematicRead=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action25\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action26\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SelectRequest\" algorithm=\"&#09;if (ArbitrationScheme == FIRSTREQUEST) {&#13;&#09;&#09;SelectedRequestPtr = CurrentRequestPtr;&#13;&#09;} &#10;&#09;else if (ArbitrationScheme == FIRSTBURST) {&#13;&#09;&#09;if (RemainingRequests == 0) {&#13;&#09;&#09;&#09;SelectedRequestPtr = CurrentRequestPtr;&#13;&#09;&#09;&#09;RemainingRequests = SelectedRequestPtr-&gt;memoryRequest.burstLength;&#13;&#09;&#09;&#09;CMDRef = SelectedRequestPtr-&gt;memoryRequest.memCmd;&#13;&#09;&#09;&#09;BurstID = SelectedRequestPtr-&gt;memoryRequest.ID;&#13;&#09;&#09;&#09;RemainingRequests--;&#13;&#09;&#09;} &#10;&#09;&#09;else {&#13;&#09;&#09;&#09;SelectedRequestPtr = CurrentRequestPtr;&#13;&#09;&#09;&#09;RequestID = SelectedRequestPtr-&gt;memoryRequest.ID;&#13;&#09;&#09;&#09;CMDCurrent = SelectedRequestPtr-&gt;memoryRequest.memCmd;&#13;&#09;&#09;&#09;NbRequestsCk = 0;&#13;&#09;&#09;&#09;while (((RequestID != BurstID) || (CMDCurrent != CMDRef))&amp;&amp; (RequestIDerror == false)) {&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr = SelectedRequestPtr-&gt;nextRequestPtr;&#13;&#09;&#09;&#09;&#09;RequestID = SelectedRequestPtr-&gt;memoryRequest.ID;&#13;&#09;&#09;&#09;&#09;CMDCurrent = SelectedRequestPtr-&gt;memoryRequest.memCmd;&#13;&#09;&#09;&#09;&#09;NbRequestsCk++;&#13;&#09;&#09;&#09;&#09;/*If after 20 tries, no request ID match, there s a problem in the algorithm*/&#13;&#09;&#09;&#09;&#09;if (NbRequestsCk &gt; 20) {&#13;&#09;&#09;&#09;&#09;&#09;RequestIDerror = true;&#13;&#09;&#09;&#09;&#09;&#09;cf_trace_report(&quot;ERROR identifying pending requests&quot;);&#13;&#09;&#09;&#09;&#09;}&#13;&#09;&#09;&#09;}&#13;&#09;&#09;&#09;RemainingRequests--;&#13;&#09;&#09;}&#13;&#09;}&#13;&#13;&#09;NbMemoryTransactions = ((SelectedRequestPtr-&gt;memoryRequest.size - 1)/ (EffectiveMemoryWidth * BurstLengthMemory)) + 1;&#13;&#09;RequestInformation.MemRequest = SelectedRequestPtr-&gt;memoryRequest;&#13;&#09;RequestInformation.NbMemTransactions = NbMemoryTransactions;&#13;&#09;memID = SelectedRequestPtr-&gt;memoryRequest.memID;&#13;&#09;if (SelectedRequestPtr-&gt;memoryRequest.memCmd == WRITEREQ) {&#13;&#09;&#09;NbWriteRequests = NbWriteRequests - 1;&#13;&#09;&#09;cf_trace_gui_f_t(&quot;NbWriteRequests&quot;, NbWriteRequests, &quot;requests&quot;);&#13;&#09;} &#10;&#09;else {&#13;&#09;&#09;NbReadRequests = NbReadRequests - 1;&#13;&#09;&#09;cf_trace_gui_f_t(&quot;NbReadRequests&quot;, NbReadRequests, &quot;requests&quot;);&#13;&#09;}&#13;&#13;&#09;if ((WriteAckStrategy == FAST) &amp;&amp; (SelectedRequestPtr-&gt;memoryRequest.memCmd == WRITEREQ)) {&#13;&#09;&#09;SendFastAck = true;&#13;&#09;&#09;WriteAck.startTime = SelectedRequestPtr-&gt;memoryRequest.startTime;&#13;&#09;&#09;WriteAck.ID = SelectedRequestPtr-&gt;memoryRequest.ID;&#13;&#09;&#09;WriteAck.burstLength = SelectedRequestPtr-&gt;memoryRequest.burstLength;&#13;&#09;&#09;WriteAck.size = 1;&#13;&#09;&#09;WriteAck.address = SelectedRequestPtr-&gt;memoryRequest.address;&#13;&#09;} &#10;&#09;else {&#13;&#09;&#09;SendFastAck = false;&#13;&#09;}&#13;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&quot;Request Selected = address %i datavalue %i size %i burstlength %i ID %i&quot;,&#13;&#09;&#09;&#09;&#09;CurrentRequestPtr-&gt;memoryRequest.address,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.dataValue,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.size,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.burstLength,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.ID);&#13;&#09;}\" executionTime=\"ArbitrationDelay Cycle\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"UpdateRequestList\" algorithm=\"if (SelectedRequestPtr == ListRequestsPtr-&gt;nextRequestPtr) {&#10;&#09;NextRequestPtr = ListRequestsPtr-&gt;nextRequestPtr-&gt;nextRequestPtr;&#10;&#09;if (NextRequestPtr == NULL) {&#10;&#09;&#09;ListRequestsPtr-&gt;nextRequestPtr = NULL;&#10;&#09;} &#10;&#09;else {&#10;&#09;&#09;ListRequestsPtr-&gt;nextRequestPtr = NextRequestPtr;&#10;&#09;&#09;ListRequestsPtr-&gt;nextRequestPtr-&gt;prevRequestPtr = NULL;&#10;&#09;}&#10;&#09;free (SelectedRequestPtr);&#10;} &#10;else {&#10;&#09;SelectedRequestPtr-&gt;prevRequestPtr-&gt;nextRequestPtr = SelectedRequestPtr-&gt;nextRequestPtr;&#10;&#09;if (SelectedRequestPtr-&gt;nextRequestPtr) /*added in v4.1*/&#10;&#09;SelectedRequestPtr-&gt;nextRequestPtr-&gt;prevRequestPtr = SelectedRequestPtr-&gt;prevRequestPtr;&#10;&#09;free (SelectedRequestPtr);&#10;&#09;}\" executionTime=\"1 Cycle\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop29\" condition=\"NbMemoryTransactions\" type=\"MULTIPLICATION\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"PrepRequest\" algorithm=\"Requests2Memory.memCmd = SelectedRequestPtr-&gt;memoryRequest.memCmd;&#13;&#09;Requests2Memory.address = SelectedRequestPtr-&gt;memoryRequest.address;&#13;&#09;Requests2Memory.dataValue = SelectedRequestPtr-&gt;memoryRequest.dataValue;&#13;&#09;Requests2Memory.size = SelectedRequestPtr-&gt;memoryRequest.size;&#13;&#09;Requests2Memory.size = BurstLengthMemory * EffectiveMemoryWidth;&#13;&#09;Requests2Memory.memID = memID;&#13;&#13;&#09;if (MODE == VERBOSE) {&#13;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&quot;Request transaction = address %i datavalue %i size %i burstlength %i ID %i&quot;,&#13;&#09;&#09;&#09;&#09;CurrentRequestPtr-&gt;memoryRequest.address,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.dataValue,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.size,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.burstLength,&#13;&#09;&#09;&#09;&#09;SelectedRequestPtr-&gt;memoryRequest.ID);&#13;&#09;}\" executionTime=\"1 Cycle\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"Action52\" duration=\" fs\" condition=\"SendFastAck\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"DDRCommandGeneration\" declarations=\"int BankAccessed, RowAccessed, ColumnAccessed;&#13;&#09;bool NeedActive, NeedPrecharge;&#13;&#09;DefMemoryMode MemoryState;&#13;&#09;unsigned int memID;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"MemoryStatus\" type=\"SHARED_VARIABLE\" direction=\"IN_OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"Requests2Memory\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"DDRCommand\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"DDRCommandGenerationBehaviorBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"OutSel24\" instanceNumber=\"memID\">\n                      <output name=\"OutputSelectorOutput\" />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector37\" instanceNumber=\"SELF\">\n                      <output />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector38\" instanceNumber=\"SELF\">\n                      <output name=\"OutputSelectorOutput\" />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                      <inputs priority=\"\" timeout=\" ns\" duration=\" ns\" />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n                      <output />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"CommandGenInit\" algorithm=\"\" executionTime=\"10 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop33\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"Cond38\" timeout=\" ms\" priority=\"\" duration=\" fs\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"NeedPrechargeOrNot\" algorithm=\"&#13;&#09;if ((RowAccessed == MemoryStatus.ActiveRow[BankAccessed])&#13;&#09;&#09;&#09;&amp;&amp; (AutoPreChargeEnabled == OFF)) {&#13;&#09;&#09;NeedActive = false;&#13;&#09;} else {&#13;&#09;&#09;NeedActive = true;&#13;&#09;&#09;if (AutoPreChargeEnabled == OFF) {&#13;&#09;&#09;&#09;NeedPrecharge = true;&#13;&#09;&#09;&#09;DDRCommand.Cmd = PRECHARGE;&#13;&#09;&#09;&#09;DDRCommand.BankAccessed = BankAccessed;&#13;&#09;&#09;&#09;DDRCommand.memID = memID;&#13;&#09;&#09;&#09;DDRCommand.RowAccessed = RowAccessed;&#13;&#09;&#09;&#09;DDRCommand.ColumnAccessed = ColumnAccessed;&#13;&#09;&#09;&#09;if (MEMORYVERBOSE == ON) {&#13;&#09;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&#09;&quot;Memory Command Generation PRECHARGE Module %i, Bank %i, Row %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;&#09;memID, BankAccessed, RowAccessed);&#13;&#09;&#09;&#09;}&#13;&#09;&#09;} else {&#13;&#09;&#09;&#09;NeedPrecharge = false;&#13;&#09;&#09;}&#13;&#09;}&#13;&#09;MemoryStatus.ActiveRow[BankAccessed] = RowAccessed;&#13;\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"NeedActivateOrNot\" algorithm=\"if (NeedActive == true) {&#13;&#09;&#09;DDRCommand.Cmd = ACTIVATE;&#13;&#09;&#09;DDRCommand.RowAccessed = RowAccessed;&#13;&#09;&#09;DDRCommand.ColumnAccessed = ColumnAccessed;&#13;&#09;&#09;DDRCommand.BankAccessed = BankAccessed;&#13;&#09;&#09;DDRCommand.memID = memID;&#13;&#09;&#09;if (MEMORYVERBOSE == ON) {&#13;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&quot;Memory Command Generation ACTIVATE Module %i, Bank %i, Row %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;memID, BankAccessed, RowAccessed);&#13;&#09;&#09;}&#13;&#09;}&#13;\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"PrepareCommand\" algorithm=\"if (Requests2Memory.memCmd == READREQ) {&#13;&#09;&#09;DDRCommand.Cmd = READ;&#13;&#09;&#09;DDRCommand.memID = memID;&#13;&#09;&#09;DDRCommand.RowAccessed = RowAccessed;&#13;&#09;&#09;DDRCommand.ColumnAccessed = ColumnAccessed;&#13;&#09;&#09;DDRCommand.BankAccessed = BankAccessed;&#13;&#09;&#09;if (MEMORYVERBOSE == ON) {&#13;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&quot;Memory Command Generation READ Module %i, Bank %i, Row %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;memID, BankAccessed, RowAccessed);&#13;&#09;&#09;}&#13;&#09;} else {&#13;&#09;&#09;DDRCommand.Cmd = WRITE;&#13;&#09;&#09;DDRCommand.memID = memID;&#13;&#09;&#09;DDRCommand.RowAccessed = RowAccessed;&#13;&#09;&#09;DDRCommand.ColumnAccessed = ColumnAccessed;&#13;&#09;&#09;DDRCommand.BankAccessed = BankAccessed;&#13;&#09;&#09;if (MEMORYVERBOSE == ON) {&#13;&#09;&#09;&#09;cf_trace_report(&#13;&#09;&#09;&#09;&#09;&#09;&quot;Memory Command Generation WRITE Module %i, Bank %i, Row %i&quot;,&#13;&#09;&#09;&#09;&#09;&#09;memID, BankAccessed, RowAccessed);&#13;&#09;&#09;}&#13;&#09;}\" executionTime=\"1 Cycle\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"AfterNeedPrecharge\" duration=\" fs\" condition=\"NeedPrecharge\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"AfterNeedActivate\" duration=\" fs\" condition=\"NeedActive\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"AfterPrepareCommand\" duration=\" ns\" priority=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SelectStatus\" algorithm=\"NeedActive = false;&#10;NeedPrecharge = false;&#10;memID = Requests2Memory.memID;&#10;BankAccessed = (Requests2Memory.address / (MEMORYSIZE / NbBanksperMemory))&#09;&#09;&#09;+ 1;&#10;/* Let's consider row address are the 8 LSB and column access 8 MSB*/&#10;ColumnAccessed = ((Requests2Memory.address - BankAccessed) &lt;&lt; 8) &gt;&gt; 8;&#10;RowAccessed = (Requests2Memory.address - BankAccessed) &gt;&gt; 8;&#10;/* Var_MemoryStatus.SetRelationIndex(memID);*/&#10;/* Var_MemoryStatus.Read(&amp;MemoryStatus);*/\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                  </refinement>\n                </models>\n                <relations xsi:type=\"cofluent:Event\" name=\"RequestCounter\" policy=\"COUNTER\" setTime=\"0 Cycle\" getTime=\"0 Cycle\" />\n                <relations xsi:type=\"cofluent:SharedVariable\" name=\"ListRequestsPtr\" concurrency=\"1\" counter=\"\" writeTime=\"0 Cycle\" readTime=\"0 Cycle\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"RequestInformation\" policy=\"INFINITE\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"Requests2Memory\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:SharedVariable\" name=\"MemoryStatus\" concurrency=\"1\" counter=\"\" writeTime=\"0 Cycle\" readTime=\"0 Cycle\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n              </refinement>\n            </models>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"AWADDRin\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"WDATAin\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"ARADDRin\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MemWriteRequest\" policy=\"INFINITE\" capacity=\"MemWriteReqFifoSize\" concurrency=\"1\" sendTime=\"0 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"WriteAck\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MemReadRequest\" policy=\"INFINITE\" capacity=\"MemReadReqFifoSize\" concurrency=\"1\" sendTime=\"0 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"DataRead\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Memory\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" cyclePeriod=\"10 ns\">\n          <ports name=\"DQs\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"DDRCommand\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"MemoryStructComplexSt\">\n            <models xsi:type=\"cofluent:Function\" name=\"MemoryCommandExecution\" constructor=\"\" declarations=\"int ExecuteCommandDuration;&#13;&#10;bool SendDQ;&#13;&#10;int AutoPrechargedDuration;&#13;&#10;int memID;&#13;&#10;int InitBankDuration;&#13;&#10;int PowerConsumption;&#13;&#10;double StaticPowerConsumption;&#13;&#10;// 4 because of a maximum of 4 banks per memory&#13;&#10;int StartBank[4];&#13;&#10;int Instance;\" definitions=\"\" initializations=\"StartBank[0] = 0;&#13;StartBank[1] = 0;&#13;StartBank[2] = 0;&#13;StartBank[3] = 0;&#13;memID = 0;\" cyclePeriod=\"10 ns\">\n              <ports name=\"DQs\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"DDRAction\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"MemoryCommandExecutionBehaviorBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"OutSel16\" instanceNumber=\"memID\">\n                  <output />\n                </selectors>\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                  <inputs priority=\"\" timeout=\" ms\" duration=\" ns\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop32\" condition=\"\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Cond36\" timeout=\" ms\" priority=\"\" duration=\" fs\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action40\" duration=\" fs\" condition=\"SendDQ\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"CommandExecInit\" algorithm=\"&#09;InitBankDuration = 1;&#10;&#09;ExecuteCommandDuration =1;\" executionTime=\"ExecuteCommandDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"ExecuteCommand\" algorithm=\"&#09;if (DDRAction.Cmd == READ) {&#10;&#09;&#09;SendDQ = true;&#10;&#09;&#09;DQPutTime = BurstLengthMemory;&#10;&#09;&#09;ExecuteCommandDuration = CASLatency;&#10;&#09;}&#10;&#09;else if (DDRAction.Cmd == WRITE) {&#10;&#09;&#09;SendDQ = true;&#09;DQPutTime = BurstLengthMemory;&#10;&#09;&#09;ExecuteCommandDuration = CASLatency;&#10;&#09;} &#10;&#09;else if (DDRAction.Cmd == ACTIVATE) {&#10;&#09;&#09;SendDQ = false;&#10;&#09;&#09;ExecuteCommandDuration = RCDLatency;&#10;&#09;}&#10;&#09;else if (DDRAction.Cmd == PRECHARGE) {&#10;&#09;&#09;SendDQ = false;&#10;&#09;&#09;ExecuteCommandDuration = RPLatency;&#10;&#09;}\" executionTime=\"ExecuteCommandDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"AutoPrecharged\" algorithm=\"&#09;if (AutoPreChargeEnabled == ON) {&#10;&#09;&#09;AutoPrechargedDuration = 1;&#10;&#09;}&#10;&#09;else &#10;&#09;{&#09;&#10;&#09;&#09;AutoPrechargedDuration = 0;&#10;&#09;}\" executionTime=\"AutoPrechargedDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"PrechargeStandby\" algorithm=\"\" executionTime=\"0 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"BankDmuxer\" constructor=\"\" destructor=\"\" declarations=\"bool RcvRequest;&#13;int Bank;&#13;float LastActivate, CurrentActivate;&#13;int LastBank;&#13;int Send2BankDuration;&#13;int DDRActionSend;\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\">\n              <ports name=\"DDRAction\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"DDRCommand\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"BankDmuxerBehaviorBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"OutSel25\" instanceNumber=\"Bank\">\n                  <output />\n                </selectors>\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector2\" instanceNumber=\"SELF\">\n                  <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" />\n                </selectors>\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                  <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:Operation\" name=\"BankDmuxInit\" algorithm=\"\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"Standby\" timeout=\" us\" priority=\"\" duration=\" fs\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"Action47\" duration=\"DDRActionSend* 10 ns\" condition=\"\" priority=\"1\" vectorSize=\"\" blocking=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"Send2Bank\" algorithm=\"&#09;DDRAction = DDRCommand;&#10;&#09;Bank = DDRCommand.BankAccessed;&#10;&#09;Send2BankDuration = 1;DDRActionSend = 1;&#10;&#09;if (DDRCommand.Cmd == ACTIVATE){&#09;&#10;&#09;&#09;if (RcvRequest == true) {&#10;&#09;&#09;&#09;/*CurrentActivate = CurrentUserTime(cycle);*/&#10;&#09;&#09;&#09;LastBank = Bank;&#09;&#10;&#09;&#09;}&#10;&#09;}&#10;&#09;else if (DDRCommand.Cmd == WRITE){&#10;&#09;&#09;DDRActionSend = BurstLengthMemory;&#10;&#09;}\" executionTime=\"Send2BankDuration Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop34\" condition=\"\" />\n                <statements xsi:type=\"cofluent:AlternativeStatement\">\n                  <conditionalBranches condition=\"RcvRequest==false\" />\n                  <conditionalBranches condition=\"\" />\n                </statements>\n                <statements xsi:type=\"cofluent:Operation\" name=\"PowerDownTimeoutOrNot\" algorithm=\"&#09;RcvRequest = true;\" executionTime=\"0 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"GoToPowerDown\" algorithm=\"&#09;/* if (AutoPreChargeEnabled == ON) {&#10;&#09;&#09;SetStaticPowerConsumption(PrechargePowerDownPowerConsumption,mW);&#10;&#09;&#09;SetDynamicPowerConsumption(0,mW);&#10;&#09;&#09;}&#10;&#09;&#09;else {&#10;&#09;&#09;SetStaticPowerConsumption(ActivePowerDownModePowerConsumption,mW);&#10;&#09;&#09;SetDynamicPowerConsumption(0,mW);} &#10;&#09;*/\" executionTime=\"1 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"ExitPowerDown\" algorithm=\"&#09;/* if (AutoPreChargeEnabled == ON) {&#10; &#09;&#09;SetStaticPowerConsumption(0, mW);&#10; &#09;&#09;SetDynamicPowerConsumption(PrechargeStandbyModePowerConsumption, mW);&#10; &#09;&#09;}&#10; &#09;&#09;else {&#10; &#09;&#09;SetStaticPowerConsumption(0, mW);&#10; &#09;&#09;SetDynamicPowerConsumption(ActiveStandbyModePowerConsumption, mW);&#10; &#09;&#09;}&#10;&#09;*/\" executionTime=\"6 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"NoPowerDown\" algorithm=\"\" executionTime=\"0 Cycle\" systematicRead=\"true\" systematicWrite=\"true\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"PowerDown\" timeout=\"PowerDownTimeout ms\" priority=\"\" duration=\" fs\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n              </refinement>\n            </models>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"DDRAction\" capacity=\"1\" concurrency=\"1\" sendTime=\"10 ns\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"DQs\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 Cycle\" receiveTime=\"DQPutTime Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"DDRCommand\" policy=\"INFINITE\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"AWADDRchn\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"WDATAchn\" capacity=\"1\" concurrency=\"1\" sendTime=\"BurstLength Cycle\" receiveTime=\"1 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"BRESPchn\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ARADDRchn\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"RDATAchn\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 Cycle\" receiveTime=\"0 Cycle\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"Inheritance_example3App\" version=\"8.1.0_r1_434\" target=\"\" includeInheritedHeader=\"\" inheritanceClass=\"\" callToInheritedConstructors=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"Inheritance_example3AppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n          <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n        </selectors>\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"300 Cycle\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"3\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" executionTime=\"200 Cycle\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"OS\" includes=\"#include &quot;user_processor_base_class.h&quot;\" destructor=\"delete sel_processor;\" declarations=\"cf_core::cf_cp_selection&lt; cf_core::cf_processor &gt;*  sel_processor;\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"OSBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"std::string path = &quot;/Inheritance_example3Plf&quot;;&#13;&#10;sel_processor = new cf_cp_selection&lt;cf_processor&gt;(path);&#13;&#10;&#13;&#10;for (auto i = sel_processor-&gt;begin();&#13;&#10;&#09;&#09;i != sel_processor-&gt;end(); i++) {&#13;&#10;&#09;user_processor_base_class* p = dynamic_cast&lt;user_processor_base_class*&gt;(*i);&#13;&#10;&#09;// update processor reference to enable computation&#13;&#10;&#09;p-&gt;update_processor_ref(p-&gt;get_hcp_name());&#13;&#10;&#09;// start new active ratio period measurement&#13;&#10;&#09;p-&gt;start_temp_active_ratio();&#13;&#10;}&#13;&#10;\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"get_active_ratio\" algorithm=\"for (auto i = sel_processor-&gt;begin();&#13;&#10;&#09;&#09;&#09;i != sel_processor-&gt;end(); i++) {&#13;&#10;&#09;&#09;// cast processor object to user_processor_base_class&#09;&#13;&#10;&#09;&#09;user_processor_base_class* p = dynamic_cast&lt;user_processor_base_class*&gt;(*i);&#13;&#10;&#09;&#09;//&#13;&#10;&#09;&#09;double period = p-&gt;get_temp_period().to_scalar(CF_NS);&#13;&#10;&#09;&#09;// start new active ratio period measurement&#13;&#10;&#09;&#09;double active_ratio = p-&gt;start_temp_active_ratio();&#13;&#10;&#09;&#09;// print active ratio data&#13;&#10;&#09;&#09;cf_trace_report(&quot;%s has an active ratio of %.2lf over a period of %.2lf ns&quot;,&#13;&#10;&#09;&#09;p-&gt;get_cp_name(), active_ratio, period);&#13;&#10;&#09;&#09;// update processor custom state&#13;&#10;&#09;&#09;p-&gt;update_user_state(active_ratio);&#13;&#10;&#09;}\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"wait\" executionTime=\"500 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n          <output name=\"OutputSelectorOutput\" />\n        </selectors>\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 Cycle\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"3\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" executionTime=\"200 Cycle\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQ\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"datacenter\" constructor=\"\" includes=\"#include &lt;chrono&gt;&#13;&#10;\" postSimulation=\"// End chrono except for controller (controller already measures execution time)&#13;&#10;#ifndef COF_LSS_CONTROLLER&#13;&#10;std::chrono::high_resolution_clock::time_point t_end = std::chrono::high_resolution_clock::now();&#13;&#10;std::chrono::duration&lt;double&gt; time_span = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt; &gt;(t_end - t_start);&#13;&#10;cf_mon_ostream  &lt;&lt; &quot;Wall-clock simulation time: &quot;&lt;&lt; time_span.count() &lt;&lt; &quot; sec&quot; &lt;&lt; cf_mon_endl;&#13;&#10;#endif&#13;&#10;&#13;&#10;// Create map for chart&#13;&#10;std::map&lt;int,int&gt; graph;&#13;&#10;// Need dp for it&#13;&#10;for (auto it : producer_exec_time){&#13;&#10;&#09;//cf_trace_report(&quot;time %s&quot;, it.to_c_str());&#13;&#10;&#09;int t = (int)it.to_scalar(CF_NS) / 100;&#13;&#10;&#09;auto s = graph.find(t);&#13;&#10;&#09;if (s != graph.end())&#13;&#10;&#09;&#09;s-&gt;second = s-&gt;second + 1 ;&#13;&#10;&#09;else&#13;&#10;&#09;&#09;graph.insert(std::pair&lt;int,int&gt;(t,1));&#13;&#10;}&#13;&#10;&#13;&#10;for(auto it : graph)&#13;&#10;{&#13;&#10;&#09;//cf_trace_report(&quot;key %d value %d&quot;, it.first, it.second);&#13;&#10;&#09;// create graph point&#13;&#10;&#09;cf_trace_gui_f_x(&quot;latency&quot;,&quot;nb_func&quot;,it.first,it.second);&#13;&#10;}&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;// Display simulation result&#13;&#10;// Transaction counts&#13;&#10;cf_trace_report(&quot;Total number of transaction sent is %d&quot;,total_requests_sent);&#13;&#10;cf_trace_report(&quot;Transaction number routed by ToR switches : %d&quot;,nb_trans_routed_by_ToR_Switch);&#13;&#10;cf_trace_report(&quot;Transaction number routed by AGG switches : %d&quot;,nb_trans_routed_by_AGG_Switch);&#13;&#10;cf_trace_report(&quot;Transaction number routed by Data Center switch : %d&quot;,nb_trans_routed_by_Data_Center_Switch);&#13;&#10;cf_trace_report(&quot;Total number of transaction received is %d&quot;,total_requests_received);&#13;&#10;&#13;&#10;// controller and sequential simulation &#13;&#10;#if defined(COF_LSS_CONTROLLER) || !defined(COF_LSS)&#13;&#10;&#13;&#10;cf_trace_report(&quot;Assert number of requests sent and received are the same.&quot;);&#13;&#10;cf_assert( (total_requests_sent ==  total_requests_received),&#13;&#10;&#09;&#09;&#09;&quot;Post-Simulation&quot;, CF_ERROR_USER_ASSERT,&#13;&#10;&#09;&#09;&#09;&quot;The number of transactions received (%d) is not the same as the number of transactions sent (%d). \\nIncrease simulation time to get full simulation results.&quot;,&#09;&#09;&#09;&#09; &#13;&#10;&#09;&#09;&#09;total_requests_received, total_requests_sent&#13;&#10;&#09;&#09;&#09;);&#13;&#10;&#13;&#10;// Transaction rate&#13;&#10;cf_trace_report(&quot;Rate of outside server room transaction is %.2f &quot;, ((float)nb_trans_routed_by_Data_Center_Switch/total_requests_received)*100 );&#13;&#10;cf_trace_report(&quot;Rate of outside rack transaction is %.2f &quot;, ((float)(nb_trans_routed_by_AGG_Switch-(nb_trans_routed_by_Data_Center_Switch))/total_requests_received)*100 );&#13;&#10;// Display simulation_duration&#13;&#10;cf_trace_report(&quot;simulation_duration %s&quot;,simulation_duration.to_string() );&#13;&#10;// Display switches load &#13;&#10;data_center_switch_load = (data_center_switch_running_time.to_scalar(CF_MS) *100) / simulation_duration.to_scalar(CF_MS);&#13;&#10;cf_trace_report(&quot;Data center switch load = %.2f%%&quot;, data_center_switch_load);&#13;&#10;agg_switch_load = ( (agg_switch_running_time.to_scalar(CF_MS) *100) / simulation_duration.to_scalar(CF_MS)) / (dpServerRoomNb + 1);&#13;&#10;cf_trace_report(&quot;Agg switch average load = %.2f%%&quot;, agg_switch_load);&#13;&#10;tor_switch_load = ((tor_switch_running_time.to_scalar(CF_MS) *100) / simulation_duration.to_scalar(CF_MS)) / ((dpServerRoomNb + 1)*(dpRackNb + 1));&#13;&#10;cf_trace_report(&quot;ToR switch average load = %.2f%%&quot;, tor_switch_load);&#13;&#10;&#13;&#10;// Latencies&#13;&#10;// Update average latency&#09;&#09;&#13;&#10;average_latency = total_latency / ((double) total_requests_received);&#13;&#10;cf_trace_report(&quot;Average latency = %.0f ns&quot;, average_latency.to_scalar(CF_NS));&#13;&#10;intra_rack_average_latency = intra_rack_total_latency / ((double) intra_rack_total_requests_received);&#13;&#10;cf_trace_report(&quot;Intra rack requests average latency = %.0f ns&quot;, intra_rack_average_latency.to_scalar(CF_NS));&#13;&#10;intra_server_room_average_latency = intra_server_room_total_latency / ((double) intra_server_room_total_requests_received);&#13;&#10;cf_trace_report(&quot;Intra server room requests average latency = %.0f ns&quot;, intra_server_room_average_latency.to_scalar(CF_NS));&#13;&#10;outside_server_room_average_latency = outside_server_room_total_latency / ((double) outside_server_room_total_requests_received);&#13;&#10;cf_trace_report(&quot;Outside server room requests average latency = %.0f ns&quot;, outside_server_room_average_latency.to_scalar(CF_NS));&#13;&#10;&#13;&#10;#endif&#13;&#10;\" version=\"6.2.0_r1_20160630-2100\" destructor=\"\" declarations=\"std::chrono::high_resolution_clock::time_point t_start;\" definitions=\"void merge_and_sort_vector(std::vector&lt;cf_dt::cf_time&gt;&amp; vect1,&#13;&#10;&#09;&#09;std::vector&lt;cf_dt::cf_time&gt;&amp; vect2) {&#13;&#10;&#09;vect1.insert(vect1.begin(), vect2.begin(), vect2.end());&#13;&#10;}\" preElaboration=\"\" initializations=\"&#09;// Init variables used to generate transaction rate&#13;&#10;&#09;min_waiting_time = 1000000000 / ( dpTransactionRate + dpTransactionRateInterval ) ;&#13;&#10;&#09;max_waiting_time = 1000000000 / ( dpTransactionRate - dpTransactionRateInterval ) ;&#13;&#10;&#09;&#13;&#10;&#09;// Init variables used to count transaction&#13;&#10;&#09;nb_trans_routed_by_ToR_Switch = 0;&#13;&#10;&#09;nb_trans_routed_by_AGG_Switch = 0;&#13;&#10;&#09;nb_trans_routed_by_Data_Center_Switch = 0;&#13;&#10;&#09;&#13;&#10;&#09;// Init variables used to compute latency&#13;&#10;&#09;total_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;average_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;intra_rack_total_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;intra_rack_average_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;intra_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;intra_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;outside_server_room_total_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;outside_server_room_average_latency = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#13;&#10;&#09;// Init variables used to compute requests number&#13;&#10;&#09;/*total_requests_sent = (dpServerRoomNb + 1) * (dpRackNb + 1)&#13;&#10;&#09;&#09;&#09;* (dpServerPerRackNb + 1) * dpNbTransPerServer;*/&#13;&#10;&#09;total_requests_received = 0;&#13;&#10;&#09;intra_rack_total_requests_received = 0;&#13;&#10;&#09;intra_server_room_total_requests_received = 0;&#13;&#10;&#13;&#10;&#09;// Variables used to compute switches loads&#13;&#10;&#09;simulation_duration = cf_dt::cf_time(0,CF_SEC);&#13;&#10;&#09;data_center_switch_running_time = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;data_center_switch_load = 0;&#13;&#10;&#09;agg_switch_running_time = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;agg_switch_load = 0;&#13;&#10;&#09;tor_switch_running_time = cf_dt::cf_time(0, CF_SEC);&#13;&#10;&#09;tor_switch_load = 0;&#13;&#10;&#09;\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" postElaboration=\"// Start chrono&#13;&#10;t_start = std::chrono::high_resolution_clock::now();\" globalTypeDeclarations=\"// Transaction structure used in producer&#13;&#10;struct transaction_struct{&#13;&#10;&#09;&#09;float&#09;IntraServerRoomDraw;&#13;&#10;&#09;&#09;float&#09;IntraRackDraw;&#13;&#10;&#09;&#09;int&#09;&#09;RackNumber;&#13;&#10;&#09;&#09;int&#09;&#09;ServerNumber;&#13;&#10;&#09;&#09;int &#09;ServerRoomNumber;&#13;&#10;&#09;&#09;int &#09;WaitingTime;&#13;&#10;&#09;};\" globalDeclarations=\"// Store end of execution time for each producer&#13;&#10;extern std::vector&lt;cf_dt::cf_time&gt; producer_exec_time;&#13;&#10;&#13;&#10;// Variables used to count transaction&#13;&#10;extern unsigned int nb_trans_routed_by_ToR_Switch;&#13;&#10;extern unsigned int nb_trans_routed_by_AGG_Switch;&#13;&#10;extern unsigned int nb_trans_routed_by_Data_Center_Switch;&#13;&#10;&#13;&#10;// Variables used to generate transaction rate&#13;&#10;extern unsigned int min_waiting_time;&#13;&#10;extern unsigned int max_waiting_time;&#13;&#10;&#13;&#10;// Variables used to compute latency&#13;&#10;extern cf_dt::cf_time total_latency;&#13;&#10;extern cf_dt::cf_time average_latency;&#13;&#10;extern cf_dt::cf_time intra_rack_total_latency;&#13;&#10;extern cf_dt::cf_time intra_rack_average_latency;&#13;&#10;extern cf_dt::cf_time intra_server_room_total_latency;&#13;&#10;extern cf_dt::cf_time intra_server_room_average_latency;&#13;&#10;extern cf_dt::cf_time outside_server_room_total_latency;&#13;&#10;extern cf_dt::cf_time outside_server_room_average_latency;&#13;&#10;&#13;&#10;// Variables used to compute requests number&#13;&#10;extern int total_requests_sent;&#13;&#10;extern int total_requests_received;&#13;&#10;extern int intra_rack_total_requests_received;&#13;&#10;extern int intra_server_room_total_requests_received;&#13;&#10;extern int outside_server_room_total_requests_received;&#13;&#10;&#13;&#10;// Variables used to compute switches loads&#13;&#10;extern cf_dt::cf_time simulation_duration;&#13;&#10;extern cf_dt::cf_time data_center_switch_running_time;&#13;&#10;extern double data_center_switch_load;&#13;&#10;extern cf_dt::cf_time agg_switch_running_time;&#13;&#10;extern double agg_switch_load;&#13;&#10;extern cf_dt::cf_time tor_switch_running_time;&#13;&#10;extern double tor_switch_load;&#13;&#10;&#13;&#10;// functions&#13;&#10;extern void merge_vector(std::vector&lt;cf_dt::cf_time&gt;&amp; vect1,&#13;&#10; &#09;&#09;std::vector&lt;cf_dt::cf_time&gt;&amp; vect2);\" globalDefinitions=\"// Variables used to count transaction&#13;&#10;unsigned int nb_trans_routed_by_ToR_Switch;&#13;&#10;unsigned int nb_trans_routed_by_AGG_Switch;&#13;&#10;unsigned int nb_trans_routed_by_Data_Center_Switch;&#13;&#10;&#13;&#10;// Variables used to generate transaction rate&#13;&#10;unsigned int min_waiting_time;&#13;&#10;unsigned int max_waiting_time;&#13;&#10;&#13;&#10;// Variables used to compute latency&#13;&#10;cf_dt::cf_time total_latency;&#13;&#10;cf_dt::cf_time average_latency;&#13;&#10;cf_dt::cf_time intra_rack_total_latency;&#13;&#10;cf_dt::cf_time intra_rack_average_latency;&#13;&#10;cf_dt::cf_time intra_server_room_total_latency;&#13;&#10;cf_dt::cf_time intra_server_room_average_latency;&#13;&#10;cf_dt::cf_time outside_server_room_total_latency;&#13;&#10;cf_dt::cf_time outside_server_room_average_latency;&#13;&#10;&#13;&#10;// Variables used to compute requests number&#13;&#10;int total_requests_sent;&#13;&#10;int total_requests_received;&#13;&#10;int intra_rack_total_requests_received;&#13;&#10;int intra_server_room_total_requests_received;&#13;&#10;int outside_server_room_total_requests_received;&#13;&#10;&#13;&#10;// Variables used to compute switches loads&#13;&#10;cf_dt::cf_time simulation_duration; // LSS_FUNCTION_MERGE std::max&#13;&#10;cf_dt::cf_time data_center_switch_running_time;&#13;&#10;double data_center_switch_load;&#13;&#10;cf_dt::cf_time agg_switch_running_time;&#13;&#10;double agg_switch_load;&#13;&#10;cf_dt::cf_time tor_switch_running_time;&#13;&#10;double tor_switch_load;&#13;&#10;std::vector&lt;cf_dt::cf_time&gt; producer_exec_time; // LSS_VECTOR_MERGE merge_and_sort_vector &lt;cf_dt::cf_time&gt;&#13;&#10;&#13;&#10;// functions&#13;&#10;void merge_and_sort_vector(std::vector&lt;cf_dt::cf_time&gt;&amp; vect1, std::vector&lt;cf_dt::cf_time&gt;&amp; vect2);\">\n  <dataTypes name=\"DefPacket\" definition=\"typedef struct{&#10;&#09;int dstServerRoom;&#10;&#09;int dstRack;&#10;&#09;int dstServer;&#10;&#09;int srcServerRoom;&#10;&#09;int srcRack;&#10;&#09;int srcServer;&#10;&#09;cf_dt::cf_time time_stamp;&#10;}DefPacket;\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"datacenterSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"ServerRoom\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQToDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n      <ports name=\"MsgQToServerRoom\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"ServerRoomSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"AGGSwitch\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"MsgQToAggSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <ports name=\"MsgQToRack\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <ports name=\"MsgQToServerRoom\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <ports name=\"MsgQToDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"AGGSwitchSt\">\n            <models xsi:type=\"cofluent:RoutingFunction\" name=\"RoutingFunction\" constructor=\"\" destructor=\"\" declarations=\"int server_room_id;\" definitions=\"\" preElaboration=\"\" initializations=\"server_room_id = get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;//cf_trace_report(&quot;AGG switch router : server room %d&quot;,server_room_id);\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" destination=\"    // Update agg switch running time&#10;   &#09;agg_switch_running_time += cf_time(dpAGGSwitchRoutingTime,CF_NS) + cf_time(2,CF_NS);&#10;    &#10;    // Increment nb of trans &#10;    nb_trans_routed_by_AGG_Switch++;&#10;    &#10;    // Get rack destination&#10;    int dest_server_room = (((cft_defpacket*) _trans)-&gt;get_data_ptr())-&gt;dstServerRoom;&#10;    if( dest_server_room == server_room_id ) // inside server room&#10;    {&#10;    &#09;// Get server destination&#10;    &#09;int dest_rack = (((cft_defpacket*) _trans)-&gt;get_data_ptr())-&gt;dstRack;&#10;&#09;&#09;string dest_string = &quot;MsgQOutboundRack[&quot; + std::to_string(dest_rack) + &quot;]&quot;;&#10;&#09;&#09;return dest_string;&#10;    }&#10;    else // outside server ro&#10;    {&#10;    &#09;string dest_string = &quot;MsgQOutboundDataCenterSwitch&quot;;&#10;    &#09;return dest_string;&#10;    }    \" concurrency=\"dpAGGSwitchRoutingConcurrency\" routingTime=\"dpAGGSwitchRoutingTime ns\">\n              <ports name=\"MsgQInboundRack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQOutboundRack\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQInboundDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQOutboundDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"OutboundDataCenterSwitch\" declarations=\"int server_room_id;\" preElaboration=\"\" initializations=\"server_room_id = get_container()-&gt;get_container()-&gt;get_cp_index();\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n              <ports name=\"MsgQOutboundDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQToDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"OutboundDataCenterSwitchBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n                  <output name=\"OutputSelectorOutput\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"&#09;//cf_trace_report(&quot;AGG switch outbound : server room %d&quot;,server_room_id);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQToDataCenterSwitch = MsgQOutboundDataCenterSwitch; \" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"InboundDataCenterSwitch\" constructor=\"\" destructor=\"\" declarations=\"int server_room_id;\" preElaboration=\"\" initializations=\"server_room_id = get_container()-&gt;get_container()-&gt;get_cp_index();\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n              <ports name=\"MsgQToServerRoom\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQInboundDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"InboundDataCenterSwitchBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                  <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"&#09;//cf_trace_report(&quot;AGG switch inbound : server room %d&quot;,server_room_id);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;assert( server_room_id == MsgQToServerRoom.dstServerRoom);&#13;&#10;&#09;MsgQInboundDataCenterSwitch = MsgQToServerRoom; \" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"InboundRack\" includes=\"\" declarations=\"int server_room_id;&#13;&#10;int rack_id;\" preElaboration=\"\" initializations=\"server_room_id = get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;rack_id = get_cp_index();\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n              <ports name=\"MsgQInboundRack\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQToAggSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"InboundRackBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                  <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                </selectors>\n                <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n                  <output name=\"OutputSelectorOutput\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"&#09;//cf_trace_report(&quot;AGG switch inbound : server room %d rack %d&quot;,server_room_id,rack_id);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQInboundRack_trans = MsgQToAggSwitch_trans;\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"OutboundRack\" constructor=\"\" declarations=\"int server_room_id;&#13;&#10;int rack_id;\" definitions=\"\" preElaboration=\"\" initializations=\"server_room_id = get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;rack_id = get_cp_index();\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n              <ports name=\"MsgQToRack\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQOutboundRack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <refinement xsi:type=\"cofluent:Behavior\" name=\"OutboundRackBh\">\n                <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n                  <output name=\"OutputSelectorOutput\" />\n                </selectors>\n                <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                  <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                </selectors>\n                <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"&#09;//cf_trace_report(&quot;AGG switch outbound : server room %d rack %d&quot;,server_room_id,rack_id);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQToRack_trans = MsgQOutboundRack_trans;\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n              </refinement>\n            </models>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQOutboundDataCenterSwitch\" capacity=\"dpAggSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQOutboundRack\" capacity=\"dpAggSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQInboundDataCenterSwitch\" capacity=\"dpAggSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQInboundRack\" capacity=\"dpAggSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Rack\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"MsgQToRack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <ports name=\"MsgQToAggSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"RackSt\">\n            <models xsi:type=\"cofluent:Function\" name=\"Server\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n              <ports name=\"MsgQServerToToRSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQToServer\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"ServerSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"Producer\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"// components ID&#13;&#10;int server_room_id; &#13;&#10;int rack_id;&#13;&#10;int server_id;&#13;&#10;// Server transaction count&#13;&#10;int local_transaction_count;&#13;&#10;int local_transaction_outside_rack_count;&#13;&#10;int local_transaction_outside_server_room_count;&#13;&#10;// Store waiting time for produce operation&#13;&#10;int waiting_time;\" definitions=\"\" preElaboration=\"\" initializations=\"// Initialize components ID&#13;&#10;server_room_id = get_container()-&gt;get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;rack_id = get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;server_id = get_container()-&gt;get_cp_index();&#13;&#10;&#13;&#10;// Get transaction data&#13;&#10;local_transaction_count = 0;&#13;&#10;local_transaction_outside_rack_count=0;&#13;&#10;local_transaction_outside_server_room_count=0;&#13;&#10;\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n                  <ports name=\"MsgQServerToToRSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"server_id\">\n                      <output name=\"OutputSelectorOutput\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"local_transaction_count &lt; dpNbTransPerServer\" type=\"CONDITIONAL\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"produce\" algorithm=\"&#09;/*&#10;&#09; * Produce transaction according to :&#10;&#09; * -&gt; dpIntraRackFactor&#10;&#09; * -&gt; dpIntraServerRoomFactor&#10;&#09; * -&gt; dpTransactionRate and dpTransactionRateInterval&#10;&#09; * */&#10;&#09; &#09;&#10;&#09;transaction_struct trans ;&#10;&#09;// Fill transaction with random data&#10;&#09;trans.IntraRackDraw = cf_util_rand_float(0,1);&#10;&#09;trans.IntraServerRoomDraw = cf_util_rand_float(0,1);&#10;&#09;trans.ServerNumber = cf_util_rand_int(0,dpServerPerRackNb.get_value());&#10;&#09;do{ // get a server number which is not server_id&#10;&#09;&#09;trans.ServerNumber = cf_util_rand_int(0,dpServerPerRackNb.get_value());&#10;&#09;}while(trans.ServerNumber == server_id);&#10;&#09;do{ // get a rack number which is not rack_id&#10;&#09;&#09;trans.RackNumber = cf_util_rand_int(0,dpRackNb.get_value());&#10;&#09;}while(trans.RackNumber == rack_id);&#10;&#09;do{ // get a server room number which is not server_room_id&#10;&#09;&#09;trans.ServerRoomNumber = cf_util_rand_int(0,dpServerRoomNb.get_value());&#10;&#09;}while( trans.ServerRoomNumber == server_room_id);&#10;&#09;trans.WaitingTime = cf_util_rand_int(min_waiting_time,max_waiting_time);&#10;&#09;&#10;&#09;// Update waiting time of this operation&#10;&#09;waiting_time = trans.WaitingTime;&#10;&#09;&#10;&#09;local_transaction_count++;&#10;&#09;total_requests_sent++;&#10;&#09;// Check if transaction is inside rack&#10;&#09;if ( trans.IntraRackDraw &lt;= dpIntraRackFactor.get_value() )  // inside rack&#10;&#09;{&#10;&#09;&#09;MsgQServerToToRSwitch.dstServerRoom = server_room_id;&#10;&#09;&#09;MsgQServerToToRSwitch.dstRack = rack_id;&#10;&#09;&#09;MsgQServerToToRSwitch.dstServer = trans.ServerNumber;&#10;&#09;} &#10;&#09;else // outside rack&#10;&#09;{&#10;&#09;&#09;local_transaction_outside_rack_count++;&#10;&#09;&#09;MsgQServerToToRSwitch.dstRack = trans.RackNumber;&#10;&#09;&#09;cf_assert(trans.RackNumber != rack_id,&quot;Producer&quot;,CF_ERROR_USER_ASSERT,&quot;Error in parameter generation for destination rack&quot;);&#10;&#09;&#09;MsgQServerToToRSwitch.dstServer = trans.ServerNumber;&#10;&#09;&#09;// Check if transaction is intra server room&#10;&#09;&#09;if ( trans.IntraServerRoomDraw &lt;= dpIntraServerRoomFactor.get_value() ) // inside server room &#10;&#09;&#09;{&#10;&#09;&#09;&#09;MsgQServerToToRSwitch.dstServerRoom = server_room_id;&#10;&#09;&#09;}&#10;&#09;&#09;else // outside server room&#10;&#09;&#09;{&#10;&#09;   &#09;&#09;local_transaction_outside_server_room_count++;&#10;&#09;   &#09;&#09;MsgQServerToToRSwitch.dstServerRoom = trans.ServerRoomNumber;&#10;&#09;   &#09;&#09;cf_assert(trans.ServerRoomNumber != server_room_id,&quot;Producer&quot;,CF_ERROR_USER_ASSERT,&quot;Error in parameter generation for destination server room&quot;);&#10;&#09;&#09;}&#10;&#09;}&#10;&#09;//Set the source info in the packet&#10;&#09;MsgQServerToToRSwitch.srcServerRoom = server_room_id;&#10;&#09;MsgQServerToToRSwitch.srcRack = rack_id;&#10;&#09;MsgQServerToToRSwitch.srcServer = server_id;&#10;&#09;//Set request time stamp&#10;&#09;MsgQServerToToRSwitch.time_stamp = cf_time_stamp() + cf_dt::cf_time(waiting_time, CF_NS);&#10;&#09;&#09;&#09;\" executionTime=\"waiting_time ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"display_result\" algorithm=\"cf_trace_report(&quot;End of %d transactions on server room %d rack %d server %d at %s. Average transaction rate is %f trans per sec&quot;,&#10;&#09;&#09;&#09;&#09;local_transaction_count, server_room_id ,rack_id, server_id,&#10;&#09;&#09;&#09;&#09;cf_time_stamp().to_c_str(),&#10;&#09;&#09;&#09;&#09;local_transaction_count / cf_time_stamp().to_scalar(CF_SEC)  &#10;&#09;&#09;&#09;);&#10;&#09;&#09;&#09;&#10;// Add time to the vector&#10;producer_exec_time.push_back(cf_time_stamp());\" executionTime=\"0 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"Consumer\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"// components ID&#13;&#10;int server_room_id; &#13;&#10;int rack_id;&#13;&#10;int server_id;&#13;&#10;&#13;&#10;cf_dt::cf_time latency; &#13;&#10;&#13;&#10;\" preElaboration=\"\" initializations=\"// Initialize components ID&#13;&#10;server_room_id = get_container()-&gt;get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;rack_id = get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;server_id = get_container()-&gt;get_cp_index();&#13;&#10;// Init latency&#13;&#10;latency = cf_dt::cf_time(0, CF_SEC);\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n                  <ports name=\"MsgQToServer\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"server_id\">\n                      <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"consume\" algorithm=\"&#09;// Increment number of requests received&#10;&#09;total_requests_received++;&#10;&#09;&#10;&#09;// Assert that the request is received in the correct server &#10;&#09;cf_assert( ((MsgQToServer.dstServerRoom == server_room_id) &amp;&amp; (MsgQToServer.dstRack == rack_id) &amp;&amp;  (MsgQToServer.dstServer == server_id)) ,&#10;&#09;&#09;&#09;&#09;&quot;Consumer&quot;, CF_ERROR_USER_ASSERT,&#10;&#09;&#09;&#09;&#09;&quot; !!!! Server room %d Rack %d Server %d received wrong message with dest info server room %d rack %d server %d !!!!&quot;,&#10;&#09;&#09;&#09;&#09;server_room_id,rack_id, server_id, MsgQToServer.dstServerRoom, MsgQToServer.dstRack, MsgQToServer.dstServer&#10;&#09;&#09;&#09;);&#10;&#09;&#10;&#09;// Update latencies&#10;&#09;latency =  cf_time_stamp() - MsgQToServer.time_stamp;&#10;&#09;total_latency += latency;&#10;&#09;&#10;&#09;// Update inside rack latency&#10;&#09;if(MsgQToServer.srcRack == rack_id &amp;&amp; MsgQToServer.srcServerRoom == server_room_id )&#10;&#09;{&#10;&#09;&#09;intra_rack_total_requests_received++;&#10;&#09;&#09;intra_rack_total_latency += latency;&#10;&#09;}&#10;&#09;else if(MsgQToServer.srcServerRoom == server_room_id ) // Update inside server room latency&#10;&#09;{&#10;&#09;&#09;intra_server_room_total_requests_received++;&#10;&#09;&#09;intra_server_room_total_latency += latency;&#10;&#09;}&#10;&#09;else // Update outside server room latency&#10;&#09;{&#10;&#09;&#09;outside_server_room_total_requests_received++;&#10;&#09;&#09;outside_server_room_total_latency += latency;&#10;&#09;}&#10;&#09;&#10;&#09;// Update the simulation duration. &#10;&#09;simulation_duration = cf_time_stamp();&#10;&#09;\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                  </refinement>\n                </models>\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"ToRSwitch\" includes=\"\" declarations=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n              <ports name=\"MsgQToRack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQServerToToRSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQToServer\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <ports name=\"MsgQToAggSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"ToRSwitchSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"InboundServer\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"int rack_id;\" preElaboration=\"\" initializations=\"rack_id = get_container()-&gt;get_container()-&gt;get_cp_index();\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n                  <ports name=\"MsgQInboundServer\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <ports name=\"MsgQServerToToRSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"InboundServerBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                      <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n                      <output name=\"OutputSelectorOutput\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQInboundServer = MsgQServerToToRSwitch;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:RoutingFunction\" name=\"RoutingFunction\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"int server_room_id;&#13;&#10;int rack_id;\" definitions=\"\" preElaboration=\"\" initializations=\"server_room_id = get_container()-&gt;get_container()-&gt;get_container()-&gt;get_cp_index();&#13;&#10;rack_id = get_container()-&gt;get_container()-&gt;get_cp_index();\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" destination=\"    // Update ToR switch running time&#10;  &#09;tor_switch_running_time += cf_time(dpToRSwitchRoutingTime,CF_NS) + cf_time(2,CF_NS);&#10;&#10;    // Increment transaction number &#10;    nb_trans_routed_by_ToR_Switch++;&#10;    &#10;    // Get server room destination&#10;    int dest_server_room = (((cft_defpacket*) _trans)-&gt;get_data_ptr())-&gt;dstServerRoom;&#10;    if(server_room_id == dest_server_room )// inside server room&#10;    {&#10;    &#09;int dest_rack = (((cft_defpacket*) _trans)-&gt;get_data_ptr())-&gt;dstRack;&#10;    &#09;if( dest_rack == rack_id ) // inside rack&#10;    &#09;{&#10;    &#09;&#09;// Get server destination&#10;    &#09;&#09;int dest = (((cft_defpacket*) _trans)-&gt;get_data_ptr())-&gt;dstServer;&#10;&#09;&#09;&#09;string dest_string = &quot;MsgQOutboundServer[&quot; + std::to_string(dest) + &quot;]&quot;;&#10;&#09;&#09;&#09;return dest_string;&#10;    &#09;}&#10;    &#09;else // outside rack&#10;    &#09;{&#10;    &#09;&#09;string dest_string = &quot;MsgQOutboundAGGSwitch&quot;;&#10;    &#09;&#09;return dest_string;&#10;    &#09;}   &#10;    }&#10;    else // outside server room&#10;    {&#10;    &#09;string dest_string = &quot;MsgQOutboundAGGSwitch&quot;;&#10;    &#09;return dest_string;&#09;&#10;    } \" concurrency=\"dpToRSwitchRoutingConcurrency\" routingTime=\"dpToRSwitchRoutingTime ns\">\n                  <ports name=\"MsgQInboundServer\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <ports name=\"MsgQOutboundServer\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <ports name=\"MsgQInboundAGGSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <ports name=\"MsgQOutboundAGGSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"OutboundServer\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"int rack_id;\" definitions=\"\" preElaboration=\"\" initializations=\"rack_id = get_container()-&gt;get_container()-&gt;get_cp_index();\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n                  <ports name=\"MsgQToServer\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <ports name=\"MsgQOutboundServer\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"OutboundServerBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n                      <output name=\"OutputSelectorOutput\" />\n                    </selectors>\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n                      <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQToServer = MsgQOutboundServer;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"InboundAGGSwitch\" declarations=\"int rack_id;\" preElaboration=\"\" initializations=\"rack_id = get_container()-&gt;get_container()-&gt;get_cp_index();\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n                  <ports name=\"MsgQToRack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <ports name=\"MsgQInboundAGGSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"InboundAGGSwitchBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"rack_id\">\n                      <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;assert(rack_id == MsgQToRack.dstRack);&#13;&#10;&#09;MsgQInboundAGGSwitch = MsgQToRack; \" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"OutboundAGGSwitch\" declarations=\"int rack_id;\" preElaboration=\"\" initializations=\"rack_id = get_container()-&gt;get_container()-&gt;get_cp_index();\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n                  <ports name=\"MsgQOutboundAGGSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <ports name=\"MsgQToAggSwitch\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"OutboundAGGSwitchBh\">\n                    <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"rack_id\">\n                      <output name=\"OutputSelectorOutput\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQToAggSwitch = MsgQOutboundAGGSwitch; \" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n                  </refinement>\n                </models>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQInboundAGGSwitch\" capacity=\"dpToRSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQInboundServer\" capacity=\"dpToRSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQOutboundServer\" capacity=\"dpToRSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQOutboundAGGSwitch\" capacity=\"dpToRSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n              </refinement>\n            </models>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQServerToToRSwitch\" capacity=\"dpServerToToRSwitchBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"dpServerToToRSwitchTime ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQToServer\" capacity=\"dpToRSwitchToServerBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"dpToRSwitchToServerTime/2 ns\" receiveTime=\"dpToRSwitchToServerTime/2 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQToAggSwitch\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"dpRackToSwitchTime/2 ns\" receiveTime=\"dpRackToSwitchTime/2 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQToRack\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"dpSwitchToRackTime/2 ns\" receiveTime=\"dpSwitchToRackTime/2 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"DataCenterSwitch\" includes=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQToDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n      <ports name=\"MsgQToServerRoom\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"DataCenterSwitchSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"Inbound\" preElaboration=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"MsgQRouting_in\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <ports name=\"MsgQToDataCenterSwitch\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"InboundBh\">\n            <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n              <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n            </selectors>\n            <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n              <output name=\"OutputSelectorOutput\" />\n            </selectors>\n            <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQRouting_in = MsgQToDataCenterSwitch;\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Outbound\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"/*int outIndex;*/\" definitions=\"\" preElaboration=\"\" initializations=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"MsgQToServerRoom\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <ports name=\"MsgQRouting_out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"OutboundBh\">\n            <selectors xsi:type=\"cofluent:MultiInstancesOutputSelector\" name=\"InstanceOutSelector\" instanceNumber=\"SELF\">\n              <output name=\"OutputSelectorOutput\" />\n            </selectors>\n            <selectors xsi:type=\"cofluent:MultiInstancesInputSelector\" name=\"InstanceInSelector\" instanceNumber=\"SELF\">\n              <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" condition=\"\" vectorSize=\"\" />\n            </selectors>\n            <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;MsgQToServerRoom = MsgQRouting_out;\" executionTime=\"1 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:RoutingFunction\" name=\"RoutingFunction\" constructor=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" affinity=\"0\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" destination=\"    &#10;    // Update data center switch running time &#10;   &#09;data_center_switch_running_time += cf_time(dpDataCenterSwitchRoutingTime,CF_NS) + cf_time(2,CF_NS);&#10;   &#09;&#10;   &#09;// Update trans routed number&#09;&#10;    nb_trans_routed_by_Data_Center_Switch++;&#10;    &#10;    // Update destination&#10;    int dest = (((cft_defpacket*) _trans)-&gt;get_data_ptr())-&gt;dstServerRoom;&#10;&#09;string dest_string = &quot;MsgQRouting_out[&quot; + std::to_string(dest) + &quot;]&quot;;&#10;&#09;return dest_string;&#10;&#09;\" concurrency=\"dpDataCenterSwitchRoutingConcurrency\" routingTime=\"dpDataCenterSwitchRoutingTime ns\">\n          <ports name=\"MsgQRouting_in\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n          <ports name=\"MsgQRouting_out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n        </models>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQRouting_out\" capacity=\"dpDataCenterSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQRouting_in\" capacity=\"dpDataCenterSwitchPortBufferSize\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQToDataCenterSwitch\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"dpServerRoomToDataCenterTime / 2 ns\" receiveTime=\"dpServerRoomToDataCenterTime / 2 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQToServerRoom\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"dpDataCenterToServerRoomTime / 2 ns\" receiveTime=\"dpDataCenterToServerRoomTime / 2 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n  <parameterFolders name=\"Instance_number\">\n    </parameterFolders>\n  <parameterFolders name=\"Factor\">\n    </parameterFolders>\n  <parameterFolders name=\"Buffer_size\">\n    </parameterFolders>\n  <parameterFolders name=\"Routing\">\n    <subFolders name=\"Time\">\n      </subFolders>\n    <subFolders name=\"Concurrency\">\n      </subFolders>\n  </parameterFolders>\n  <parameterFolders name=\"Transaction\">\n    </parameterFolders>\n  <parameterFolders name=\"Communication_time\">\n    </parameterFolders>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"ApplicationModel\" version=\"6.2.0_dev4_20160511-2100\" preElaboration=\"\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" globalTypeDeclarations=\"typedef cf_dt::cf_time DefStartTime;&#13;&#10;typedef cf_dt::cf_data_size DefDataSize;&#13;&#10;typedef float DefValue; &#13;&#10; &#13;&#10;typedef struct{&#13;&#10;&#09;DefStartTime StartTime;&#13;&#10;&#09;DefDataSize DataSize;&#13;&#10;&#09;DefValue Value;&#13;&#10;} DefData;\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"ApplicationModelSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" constructor=\"\" includes=\"\" declarations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"Msg\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Ack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"ProducerSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"Generator\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"Req\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"DataVar\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"TestProd\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"GeneratorBh\">\n            <statements xsi:type=\"cofluent:Operation\" name=\"OpInit\" algorithm=\"&#09;DataVar = 0.0;&#10;&#09;TestProd = DataVar;\" executionTime=\"10 ns\" systematicWrite=\"true\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"OpGen\" algorithm=\"&#09;// Produces a discrete sinusoidal signal&#10;&#09;double f = Frequency.get_value().to_scalar(CF_HZ);&#10;&#09;double t = cf_time_stamp().to_scalar();&#10;&#09;DataVar = (DefValue)(1000.0 * sin( (2 * 3.14 * f * t)/1000.0 ) );&#10;&#09;TestProd = DataVar;\" executionTime=\"100 ns\" systematicWrite=\"true\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Sender\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"1\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"Req\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"Msg\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"Ack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"DataVar\" type=\"SHARED_VARIABLE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"SenderBh\">\n            <statements xsi:type=\"cofluent:Operation\" name=\"OpEncode\" algorithm=\"&#09;Msg.Value = DataVar;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction3\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:Event\" name=\"Req\" setTime=\"1 ns\" getTime=\"1 ns\" />\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"DataVar\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n          <relationType xsi:type=\"cofluent:RelationDataType\">\n            <dataType href=\"reuse://_mGIWUiGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFqcQiGuEeaaOsqBPt_qWw\" />\n          </relationType>\n        </relations>\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"TestProd\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n          <relationType xsi:type=\"cofluent:RelationDataType\">\n            <dataType href=\"reuse://_mGIWUiGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFrDUCGuEeaaOsqBPt_qWw\" />\n          </relationType>\n        </relations>\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Receiver\" includes=\"\" destructor=\"\" declarations=\"DefValue noise;&#13;&#10;DefValue TestCons;\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"Ack\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Msg\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ReceiverBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpInit\" algorithm=\"&#09;noise = 0.0;&#10;&#09;TestCons = 0.0;&#10;&#09;cf_trace_gui_f_t(&quot;TestCons&quot;, TestCons);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpDecode\" algorithm=\"&#09;// Adds noise to signal&#10;&#09;double t = cf_time_stamp().to_scalar();&#10;&#09;noise = (DefValue)(NoiseLevel * sin(0.25 * 3.14 * NoiseLevel*t));&#10;&#10;&#09;TestCons = Msg.Value + noise;&#10;&#09;// TestCons value is round down using floor C++ API&#10;&#09;cf_trace_gui_f_t(&quot;TestCons&quot;, floor(TestCons));\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"Msg\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationDataType\">\n        <dataType href=\"reuse://_mGIWUiGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFqcRSGuEeaaOsqBPt_qWw\" />\n      </relationType>\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"Ack\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationDataType\">\n        <dataType href=\"reuse://_mGIWUiGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFqcQCGuEeaaOsqBPt_qWw\" />\n      </relationType>\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"ApplicationModelRefinement\" postSimulation=\"if(TotalNbMsg!=0)&#13;&#10;{&#13;&#10;&#09;cf_trace_report(&quot;Total number of messages : %i&quot;, TotalNbMsg);&#13;&#10;&#09;cf_trace_report(&quot;Average data size : %f bytes&quot;, (float)TotalDataSize.to_scalar(CF_BYTE)/(float)TotalNbMsg);&#13;&#10;&#09;cf_trace_report(&quot;AverageLatency = %f ns&quot;, (float)AverageLatency.to_scalar(CF_NS)/(float)TotalNbMsg );&#13;&#10;&#09;AverageThroughput= cf_dt::cf_throughput(TotalDataSize, AverageLatency);&#13;&#10;&#09;cf_trace_report(&quot;AverageThroughput = %f MBps&quot;, (float)AverageThroughput.to_scalar(CF_MBYPS)/(float)TotalNbMsg);&#13;&#10;}&#13;&#10;&#13;&#10;cf_trace_gui_f_param(&quot;AverageLatency&quot;, (float)AverageLatency.to_scalar(CF_NS)/(float)TotalNbMsg );&#13;&#10;cf_trace_gui_f_param(&quot;AverageThroughput&quot;, (float)AverageThroughput.to_scalar(CF_MBYPS)/(float)TotalNbMsg);\" version=\"6.2.0_dev4_20160518-1508\" declarations=\"\" preElaboration=\"\" cyclePeriod=\"10 ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" preSimulation=\"\" postElaboration=\"\" globalTypeDeclarations=\"#include &quot;ExternalFile.h&quot;&#13;&#10;&#13;&#10;typedef cf_dt::cf_time DefStartTime;&#13;&#10;typedef cf_dt::cf_data_size DefDataSize;&#13;&#10;typedef float DefValue; &#13;&#10;&#13;&#10;// Using a common type for all data exchanges &#13;&#10;typedef struct{&#13;&#10;&#09;DefStartTime StartTime;&#13;&#10;&#09;DefDataSize DataSize;&#13;&#10;&#09;DefValue Value;&#13;&#10;} DefData;\" globalDeclarations=\"extern int TotalNbMsg;&#13;&#10;extern cf_dt::cf_data_size TotalDataSize;&#13;&#10;extern cf_dt::cf_time AverageLatency;&#13;&#10;extern cf_dt::cf_throughput AverageThroughput;\" globalDefinitions=\"int TotalNbMsg=0;&#13;&#10;cf_dt::cf_data_size TotalDataSize(0, CF_BYTE );&#13;&#10;cf_dt::cf_time AverageLatency(0.0, CF_NS);&#13;&#10;cf_dt::cf_throughput AverageThroughput(0.0, CF_MBYPS);\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"ApplicationModelRefinementSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" includes=\"\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"Msg\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n      <ports name=\"Ack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"ProducerSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"Sender\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"int r;&#13;&#10;// Loop condition declaration&#13;&#10;bool Resend;\" definitions=\"\" preElaboration=\"\" initializations=\"r = 0;\" cyclePeriod=\" ns\" affinity=\"1\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"Req\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"Msg\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"Ack\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"DataVar\" type=\"SHARED_VARIABLE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"SenderBh\">\n            <statements xsi:type=\"cofluent:Operation\" name=\"OpEncode\" algorithm=\"&#09;r = ( r * 11 + 37)%DataSize;&#10;&#09;cf_data_size ds((cf_dt::cf_data_size_st)r, CF_BYTE);&#10;&#09;Msg_trans.set_user_data_length( ds);&#10;&#09;Msg_trans.set_time_stamp(cf_time_stamp());&#10;&#09;Msg.DataSize = Msg_trans.get_user_data_length();&#10;&#09;Msg.StartTime = Msg_trans.get_time_stamp();&#10;&#09;Msg.Value = DataVar;&#10;&#09;Resend = true; // To enter the loop\" executionTime=\"10 ns\" dynamicDataSize=\"2 kB\" dynamicPowerConsumption=\"1 uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction3\" timeout=\"40 ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop2\" condition=\"Resend\" type=\"CONDITIONAL\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"OpTestResend\" algorithm=\"&#09;if (InAction3_has_timed_out)&#10;  &#09;&#09;cf_trace_report(&quot;Timeout!&quot;);&#10;&#10;&#09;Resend = InAction3_has_timed_out || Ack;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Generator\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"Req\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\">\n            <reuse href=\"reuse://_xhZAECGrEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModel.cf_app#_baqE6BkYEealL-5xWZDvNw\" />\n          </ports>\n          <ports name=\"DataVar\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\">\n            <reuse href=\"reuse://_xhZAECGrEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModel.cf_app#_baqr8BkYEealL-5xWZDvNw\" />\n          </ports>\n          <ports name=\"TestProd\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\">\n            <reuse href=\"reuse://_xhZAECGrEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModel.cf_app#_baqr8RkYEealL-5xWZDvNw\" />\n          </ports>\n          <reuse xsi:type=\"cofluent:Function\" href=\"reuse://_xhZAECGrEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModel.cf_app#_baqE5hkYEealL-5xWZDvNw\" />\n        </models>\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"TestProd\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n          <relationType xsi:type=\"cofluent:RelationDataType\">\n            <dataType href=\"reuse://_mFwi6CGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFrDUCGuEeaaOsqBPt_qWw\" />\n          </relationType>\n        </relations>\n        <relations xsi:type=\"cofluent:Event\" name=\"Req\" setTime=\"1 ns\" getTime=\"1 ns\" />\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"DataVar\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n          <relationType xsi:type=\"cofluent:RelationDataType\">\n            <dataType href=\"reuse://_mFwi6CGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFqcQiGuEeaaOsqBPt_qWw\" />\n          </relationType>\n        </relations>\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Receiver\" includes=\"\" destructor=\"\" declarations=\"DefValue noise;&#13;&#10;DefValue TestCons; &#13;&#10;int DecodeTime; &#13;&#10;int errorGen;&#13;&#10;bool Error; // OR branch condition&#13;&#10;cf_dt::cf_time Latency;&#13;&#10;cf_dt::cf_throughput Throughput;\" definitions=\"\" preElaboration=\"\" initializations=\"DecodeTime = 0;\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"1\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"Ack\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Msg\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ReceiverBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpInit\" algorithm=\"&#09;noise = 0.0;&#10;&#09;Error = false;&#10;&#09;errorGen = 1;&#10;&#09;TestCons = 0.0;&#10;&#09;// TestCons value is round down using floor C++ API&#10;&#09;cf_trace_gui_f_t(&quot;TestCons&quot;, floor(TestCons));\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"OpDecode\" algorithm=\"&#09;// Adds noise to signal&#10;&#09;double t = cf_time_stamp().to_scalar();&#10;&#09;noise = (DefValue)(NoiseLevel * sin(0.25 * 3.14 * NoiseLevel * t)) ;&#10;&#10;&#09;// TestCons = Msg.Value + noise;&#10;&#09;TestCons = Add(Msg.Value, noise);&#10;&#09;// TestCons value is round down using floor C++ API&#10;&#09;cf_trace_gui_f_t(&quot;TestCons&quot;, floor(TestCons));&#10;&#10;&#09;Latency = cf_time_stamp() - Msg.StartTime;&#10;&#09;AverageLatency+=Latency;&#10;  &#09;&#10;&#09;// Error generation&#10;&#09;errorGen = (errorGen * 37 + 11)%101;&#10;&#09;if (errorGen &lt; ErrorRate)&#10;&#09;{&#10;&#09;&#09;Error = true;&#10;  &#09;&#09;cf_trace_report(&quot;Error!&quot;);&#10;&#09;} &#10;&#09;else &#10;&#09;{&#10;  &#09;&#09;Error = false;&#10;  &#09;&#09;TotalNbMsg++;&#10;  &#09;&#09;TotalDataSize+=Msg.DataSize;&#10;  &#09;&#09;cf_trace_gui_f_t(&quot;Latency&quot;,(int)(Latency.to_scalar(CF_NS)),&quot;ns&quot;);&#10;  &#09;&#09;cf_trace_gui_f_t(&quot;Throughput&quot;,(int)(Throughput.to_scalar(CF_MBYPS)),&quot;MBps&quot;);&#10;  &#09;&#09;cf_trace_gui_f_x(&quot;Msg&quot;,&quot;Latency&quot;, TotalNbMsg, (int)(Latency.to_scalar(CF_NS)),&quot;&quot;, &quot;ns&quot;);&#10;&#09;}&#10;&#10;&#09;Ack = Error;&#10;&#09;Throughput = cf_throughput(Msg.DataSize, Latency);&#10;&#09;DecodeTime = (DecodeTime * 11 + 37 )%101;\" executionTime=\"DecodeTime ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:AlternativeStatement\" name=\"Alternative\">\n          <conditionalBranches name=\"Branch\" condition=\"\" />\n          <conditionalBranches name=\"Branch2\" condition=\"Error\" />\n        </statements>\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"Ack\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationDataType\">\n        <dataType href=\"reuse://_mFwi6CGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFqcQCGuEeaaOsqBPt_qWw\" />\n      </relationType>\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"Msg\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationDataType\">\n        <dataType href=\"reuse://_mFwi6CGuEeaaOsqBPt_qWw/Tutorial/Tutorial/models/ApplicationModelDataTypes.cf_dt#_mFqcRSGuEeaaOsqBPt_qWw\" />\n      </relationType>\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"HybridSchedulingApp\" version=\"8.0.2_r1_287\" target=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"HybridSchedulingAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Controller\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ControllerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"500 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"schedule\" algorithm=\"/*&#13;&#10; * Since both Producer and Consumer are mapped to the same processor, Processor1 is idle.&#13;&#10; * To get a better resource utilization, this controller function will migrate one task &#13;&#10; * (Consumer) to the other processor.&#13;&#10; */&#13;&#10; &#13;&#10;// get the reference of Consumer and the two processors/schedulers&#13;&#10;auto c = cf_get_component(&quot;/HybridSchedulingApp/Consumer&quot;);&#13;&#10;auto consumer = dynamic_cast&lt;cf_function*&gt;(c);&#13;&#10;assert(consumer);&#13;&#10;&#13;&#10;auto p = cf_get_component(&quot;/HybridSchedulingPlf/Processor/Scheduler&quot;);&#13;&#10;auto processor = dynamic_cast&lt;cf_scheduler*&gt;(p);&#13;&#10;assert(processor);&#13;&#10;&#13;&#10;auto p2 = cf_get_component(&quot;/HybridSchedulingPlf/Processor2/Scheduler&quot;);&#13;&#10;auto processor2 = dynamic_cast&lt;cf_scheduler*&gt;(p2);&#13;&#10;assert(processor2);&#13;&#10;&#13;&#10;cf_log(CF_LOG_LEVEL_INFO, &quot;before migration:\\n%s%s&quot;, &#13;&#10;&#09;   cf_dump_task_status(processor).c_str(),&#13;&#10;&#09;   cf_dump_task_status(processor2).c_str());&#13;&#10;&#09;   &#13;&#10;cf_migrate_task(consumer, processor2, 0);&#13;&#10;&#13;&#10;cf_log(CF_LOG_LEVEL_INFO, &quot;after migration:\\n%s%s&quot;, &#13;&#10;&#09;   cf_dump_task_status(processor).c_str(),&#13;&#10;&#09;   cf_dump_task_status(processor2).c_str());\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQ\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"Inheritance_example2App\" version=\"8.1.0_charles_1\" target=\"\" includeInheritedHeader=\"\" inheritanceClass=\"\" callToInheritedConstructors=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"Inheritance_example2AppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"F1\" includeInheritedHeader=\"camera_class.h\" inheritanceClass=\"camera_class,cf_core::cf_function\" callToInheritedConstructors=\" camera_class(640,480),cf_function(name)\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"F1Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"film();\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"F2\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"F2Bh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"display();\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n      </refinement>\n    </models>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"CustomizedDispatcherApp\" version=\"8.0.2_r1_287\" target=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"CustomizedDispatcherAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"ROUND_ROBIN\" timeSlicePeriod=\"20 ns\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" cyclePeriod=\" ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"ROUND_ROBIN\" timeSlicePeriod=\"20 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQ\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"CustomizedSchedulerApp\" version=\"8.0.2_r1_287\" target=\"\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"CustomizedSchedulerAppSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Producer\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ProducerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"produce\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Consumer\" cyclePeriod=\" ns\" affinity=\"0\" priority=\"0\" schedulingPolicy=\"FIFO\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"MsgQ\" type=\"MESSAGE_QUEUE\" direction=\"IN\" size=\"\" synchronizeName=\"true\" vector=\"false\" requestPipelineDepth=\"1\">\n        <constructorArguments />\n        </ports>\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ConsumerBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"consume\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"MsgQ\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n      <relationType xsi:type=\"cofluent:RelationPredefinedType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"MyModel\" constructor=\"\" includes=\"\" postSimulation=\"\" version=\"4.0.0\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\" preSimulation=\"\" postElaboration=\"// initialize socket server&#13;&#10;cf_csl::cf_csl_init_socket_server( &quot;1250&quot; );\" globalTypeDeclarations=\"#include &quot;csl/csl_api.h&quot;\" globalDeclarations=\"\" globalDefinitions=\"\">\n  <dataTypes name=\"DefPacket\" definition=\"typedef int DefPacket;\" tracePayload=\"&#09;trace &lt;&lt; get_data();\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"MyModelSt\" documentation=\"\">\n    <models xsi:type=\"cofluent:Function\" name=\"packet_in\" documentation=\"\" constructor=\"// set synchronization callback&#13;&#10;CF_CSL_SET_SYNC_CB( cfm_packet_in::my_callback )\" declarations=\"// synchronization event callback&#13;&#10;void my_callback();&#13;&#10;// synchronization event declaration&#13;&#10;CSL_SYNC_EV_DECL\" definitions=\"// synchronization event callback definition&#13;&#10;void cfm_packet_in::my_callback()&#13;&#10;{&#13;&#10;   // notify internal synchronization event&#13;&#10;   CF_CSL_NOTIFY_SYNC_EV&#13;&#10;}\" cyclePeriod=\" ns\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n      <ports name=\"p_in\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"packet_inBh\">\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"10\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"send\" documentation=\"\" algorithm=\"&#09;&#09;// wait for syncrhonization event&#10;        CF_CSL_WAIT_SYNC_EV&#10;        // get first input packet&#10;&#09;&#09;packet* input_packet = cf_csl_get_first_input_packet();&#10;&#09;&#09;cf_trace_report(&quot;packet received at %f ns:&quot;,cf_time_stamp().to_scalar(CF_NS));&#10;&#09;&#09;cf_trace_report(&quot;...source: %d&quot;, input_packet-&gt;source);&#10;&#09;&#09;cf_trace_report(&quot;...destination: %d&quot;, input_packet-&gt;destination);&#10;&#09;&#09;cf_trace_report(&quot;...packet_id: %d&quot;, input_packet-&gt;packet_id);&#10;&#09;&#09;cf_trace_report(&quot;...packet_size: %d&quot;, input_packet-&gt;packet_size);&#10;&#09;&#09;cf_trace_report(&quot;...data: %d&quot;, (int)*(input_packet-&gt;data));&#10;&#09;&#09;cf_trace_report(&quot;...endianess: %d&quot;, input_packet-&gt;endianess);&#10;&#09;&#09;// send packet data to message queue&#10;&#09;&#09;p_in = (int)*(input_packet-&gt;data);&#10;&#09;&#09;// delete packet in the buffer&#10;&#09;&#09;cf_csl_delete_first_input_packet();    \" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"packet_out\" documentation=\"\" cyclePeriod=\" ns\">\n      <ports name=\"p_out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"packet_outBh\">\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"10\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"receive\" algorithm=\"    cf_csl::packet* current_packet;&#10;&#10;    // generate a packet to send to third-party simulator&#10;    current_packet = cf_csl::cf_csl_new_output_packet( 1 );&#10;    current_packet-&gt;source = 1;&#10;    current_packet-&gt;destination = 2;&#10;    current_packet-&gt;packet_id = 100+p_out;&#10;    current_packet-&gt;packet_size = 1;&#10;    *(current_packet-&gt;data) = p_out;&#10;    current_packet-&gt;endianess = true;&#10;    cf_csl_output_packet_ready( current_packet );&#10;&#10;    cf_trace_report(&quot;packet ready to be sent at %f ns:&quot;,cf_time_stamp().to_scalar(CF_NS));&#10;&#09;cf_trace_report( &quot;...source: %d&quot;, current_packet-&gt;source );&#10;&#09;cf_trace_report( &quot;...destination: %d&quot;, current_packet-&gt;destination );&#10;&#09;cf_trace_report( &quot;...packet_id: %d&quot;, current_packet-&gt;packet_id );&#10;&#09;cf_trace_report( &quot;...packet_size: %d&quot;, current_packet-&gt;packet_size );&#10;&#09;cf_trace_report( &quot;...data: %d&quot;, *(current_packet-&gt;data) );&#10;&#09;cf_trace_report( &quot;...endianess: %d&quot;, current_packet-&gt;endianess );&#10;\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"packet_process\" constructor=\"\" cyclePeriod=\" ns\">\n      <ports name=\"p_in\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"p_out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"packet_processBh\">\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"process\" algorithm=\"&#09;p_out = p_in + 100;\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"p_in\" documentation=\"\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"p_out\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"TLM2AT\" constructor=\"\" postSimulation=\"\" version=\"Dev\" cyclePeriod=\"10 ns\" globalTypeDeclarations=\"#include &quot;my_ext.h&quot;\" globalDeclarations=\"//#define TARGET_ADDRESS 16824&#13;&#10;#define TARGET_ADDRESS 3U&lt;&lt;28&#13;&#10;#define TARGET_2_ADDRESS 1536&#13;&#10;//#define MEMORY_ADDRESS (1U&lt;&lt;28)+0x200&#13;\">\n  <dataTypes name=\"Target\" definition=\"typedef int Target;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"Initiator\" definition=\"typedef int Initiator;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"DefData\" definition=\"typedef int DefData;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <dataTypes name=\"DefMsgQ\" definition=\"typedef int DefMsgQ;\" tracePayload=\"trace &lt;&lt; get_data();\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"TLM2ATStructSt\">\n    <models xsi:type=\"cofluent:SystemCIP\" name=\"TLM2Platfom\" constructor=\"\" className=\"at_top\" generateInclude=\"true\">\n      <ports name=\"interconnect-&gt;targ_socket\" documentation=\"\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"interconnect-&gt;init_socket\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"interconnect-&gt;targ_socket\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"interconnect-&gt;init_socket\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"interconnect-&gt;init_socket\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Writer\" declarations=\"int data;&#13;&#10;my_ext ext;\" definitions=\"\" cyclePeriod=\" ns\">\n      <ports name=\"ReferenceQueue\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"InitiatorWriter\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReferenceQueue2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReferenceQueue3\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync2\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync3\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"WriterBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"WriteToTarget\" algorithm=\"&#09;// increment&#10;&#09;data++;&#10;&#09;// initialize reference buffers&#10;&#09;ReferenceQueue = data;&#10;&#09;ReferenceQueue2 = data;&#10;&#09;ReferenceQueue3 = data;&#09;&#10;    // prepare TLM2 transaction&#10;    InitiatorWriter_trans.set_tlm2_delay(cf_dt::cf_time(1, CF_US));&#10;    tlm::tlm_generic_payload*   tlm2_gp_req =&#10;        InitiatorWriter_trans.allocate_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_req )&#10;&#09;tlm2_gp_req-&gt;set_address( TARGET_ADDRESS );&#10;&#09;tlm2_gp_req-&gt;set_write();&#10;&#09;tlm2_gp_req-&gt;set_data_ptr(&#10;        reinterpret_cast&lt; unsigned char* &gt;( &amp;data )&#10;        );&#10;&#09;tlm2_gp_req-&gt;set_data_length(&#10;        sizeof( int )&#10;        );&#10;&#09;// set command extension&#10;&#09;ext.i = data;&#10;&#09;tlm2_gp_req-&gt;set_extension &lt; my_ext &gt; (&amp;ext);&#10;&#09;tlm2_gp_req-&gt;set_streaming_width(1);\" executionTime=\"100 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"Initialization\" algorithm=\"&#09;data = 0;\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction5\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction3\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction3\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Target\" declarations=\"\" cyclePeriod=\" ns\">\n      <ports name=\"ReferenceQueue2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"TargetWrapper\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync2\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"TargetBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" documentation=\"\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"Compare\" algorithm=\"&#09;tlm::tlm_generic_payload*   tlm2_gp_resp =&#10;        TargetWrapper_trans.get_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_resp )&#10;    int     rcv_data = *reinterpret_cast&lt; int* &gt;(&#10;                tlm2_gp_resp-&gt;get_data_ptr()&#10;                );&#10;&#09;cf_trace_report(&quot;Reference data: 0x%x, received data: 0x%x&quot;,&#10;&#09;&#09;&#09;ReferenceQueue2, rcv_data&#10;            );&#10;&#09;//my_ext* ext = tlm2_gp_resp-&gt;get_extension&lt;my_ext&gt; ();&#10;    TargetWrapper_trans.release_tlm2_gp();\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Reader\" declarations=\"int data;\" cyclePeriod=\" ns\">\n      <ports name=\"ReferenceQueue3\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"InitiatorReader\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReaderResponse\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"ReaderBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"ReadTarget_2\" algorithm=\"&#09;InitiatorReader_trans.set_tlm2_delay(cf_dt::cf_time(3, CF_US));&#10;&#09;tlm::tlm_generic_payload*   tlm2_gp_req =&#10;        InitiatorReader_trans.allocate_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_req )&#10;&#09;tlm2_gp_req-&gt;set_address( TARGET_2_ADDRESS );&#10;&#09;tlm2_gp_req-&gt;set_read();&#10;&#09;tlm2_gp_req-&gt;set_data_ptr(&#10;        reinterpret_cast&lt; unsigned char* &gt;( &amp;data )&#10;        );&#10;&#09;tlm2_gp_req-&gt;set_data_length(&#10;        sizeof( int )&#10;        );&#10;    tlm2_gp_req-&gt;set_streaming_width(1);\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"Compare\" documentation=\"\" algorithm=\"&#09;tlm::tlm_generic_payload*   tlm2_gp_resp =&#10;        ReaderResponse_trans.get_tlm2_gp();&#10;    COFS_SCL_ASSERT( tlm2_gp_resp )&#10;    int     rcv_data = *reinterpret_cast&lt; int* &gt;(&#10;                tlm2_gp_resp-&gt;get_data_ptr()&#10;                );&#10;&#09;cf_trace_report(&quot;Reference data: 0x%x, received data: 0x%x&quot;,&#10;&#09;&#09;&#09;ReferenceQueue3, rcv_data&#10;            );&#10;    ReaderResponse_trans.release_tlm2_gp();\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Target_2\" declarations=\"\" cyclePeriod=\" ns\">\n      <ports name=\"TargetRequest\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"TargetResponse\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"ReferenceQueue\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"Sync3\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"TargetBehvBh\">\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"SendResponse\" algorithm=\"&#09;TargetResponse_trans = TargetRequest_trans;&#10;&#09;tlm::tlm_generic_payload* tlm2_gp_resp = TargetResponse_trans.get_tlm2_gp();&#10;&#09;COFS_SCL_ASSERT(tlm2_gp_resp)&#10;    *reinterpret_cast&lt;int*&gt;(tlm2_gp_resp-&gt;get_data_ptr()) = ReferenceQueue;\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReferenceQueue\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"InitiatorWriter\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_AT\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"TargetWrapper\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_AT\" address=\"16824\" mask=\"15\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReaderResponse\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_AT\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"InitiatorReader\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_AT\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReferenceQueue2\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:Event\" name=\"Sync\" setTime=\"1 ns\" getTime=\"1 ns\" />\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"TargetRequest\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_AT\" address=\"16824\" mask=\"15\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"TargetResponse\" capacity=\"1\" concurrency=\"1\" sendTime=\"0 ns\" receiveTime=\"1 ns\" sendThreshold=\"\" receiveThreshold=\"\" protocol=\"TLM2_AT\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReferenceQueue3\" capacity=\"1\" concurrency=\"1\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:Event\" name=\"Sync2\" setTime=\"1 ns\" getTime=\"1 ns\" />\n    <relations xsi:type=\"cofluent:Event\" name=\"Sync3\" setTime=\"1 ns\" getTime=\"1 ns\" />\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"HwDeviceModel\" constructor=\"\" includes=\"\" postSimulation=\"\" version=\"Tahiti_s9_20131209-0438\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\" priority=\"1\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" postElaboration=\"\" coSimulationType=\"NONE_COSIM\" preSimulation=\"\" globalTypeDeclarations=\"typedef unsigned char byte;&#13;&#10;&#13;&#10;#define NbLinesMax 144&#13;&#10;#define NbPixelsPerLineMax 176&#13;&#10;\" globalDeclarations=\"#define COPY_MODE 0&#13;&#10;#define REVERT_MODE 1&#13;&#10;\" globalDefinitions=\"\">\n  <dataTypes name=\"DefFrame\" definition=\"typedef unsigned char DefVideo422[NbPixelsPerLineMax * NbLinesMax * 2];&#10;&#10;typedef struct DefFrame_s { &#13;&#10;&#09;&#09;DefVideo422 payload;&#13;&#10;} DefFrame;&#10;\" copyPayload=\"&#09;&#09;memcpy(_address, _value, sizeof(DefFrame));\" tracePayload=\"    cf_color_rgb_t* rgbImage = new cf_color_rgb_t[60000];&#10;&#10;&#09;DefVideo422* tmp = &amp;(get_data_ptr()-&gt;payload);&#10;&#10;&#09;unsigned char* Frame = (unsigned char*)&amp;(tmp[0]);&#10;&#09;cf_color_rgb_t *OutputFrame = rgbImage;&#10;&#09;int sizeX = NbPixelsPerLineMax;&#10;&#09;int sizeY = NbLinesMax;&#10;&#09;&#10;&#09;const int YUV_CORRECTION_FACTOR_Y = 16;&#10;&#09;const int YUV_CORRECTION_FACTOR_UV = 128;&#10;&#10;&#09;const double YUV_COEF_V_EQUA_R = 1.140;&#10;&#09;const double YUV_COEF_U_EQUA_G = -0.395;&#10;&#09;const double YUV_COEF_V_EQUA_G = -0.581;&#10;&#09;const double YUV_COEF_U_EQUA_B = 2.032;&#10;&#10;&#09;// YUV blocks&#10;&#09;int y1c, y1n;&#10;&#09;int y2c, y2n;&#10;&#10;&#09;// RGB blocks&#10;&#09;int u1, u2, v1, v2;&#10;&#09;int r1, g1, b1;&#10;&#09;int r2, g2, b2;&#10;&#10;&#10;&#09;// 4-Pixel block index&#10;&#09;int current_block_idx = 0;&#10;&#10;&#10;&#09;int pixelX, pixelY;&#10;&#10;&#09;// 'U' table Offset&#10;&#09;int offsetU = (int) (sizeX * sizeY);&#10;&#09;// 'V' table offset&#10;&#09;int offsetV = (int) (sizeX * sizeY * 1.5);&#10;&#10;    int pixel_block_idx, line_idx;&#10;&#10;    // For each frame line&#10;&#09;for (line_idx = 0; line_idx &lt; sizeY; line_idx++) {&#10;&#10;&#09;&#09;// For each pixel block&#10;&#09;&#09;for (pixel_block_idx = 0; pixel_block_idx &lt; sizeX / 4; pixel_block_idx++) {&#10;&#09;&#09;&#09;y1c = (int) Frame[current_block_idx + 0];&#10;&#09;&#09;&#09;y2c = (int) Frame[current_block_idx + 1];&#10;&#09;&#09;&#09;y1n = (int) Frame[current_block_idx + 2];&#10;&#09;&#09;&#09;y2n = (int) Frame[current_block_idx + 3];&#10;&#10;&#09;&#09;&#09;y1c = y1c - YUV_CORRECTION_FACTOR_Y;&#10;&#09;&#09;&#09;y2c = y2c - YUV_CORRECTION_FACTOR_Y;&#10;&#09;&#09;&#09;y1n = y1n - YUV_CORRECTION_FACTOR_Y;&#10;&#09;&#09;&#09;y2n = y2n - YUV_CORRECTION_FACTOR_Y;&#10;&#10;&#09;&#09;&#09;u1 = (int) Frame[(current_block_idx / 2) + offsetU];&#10;&#09;&#09;&#09;u2 = (int) Frame[(current_block_idx / 2) + offsetU + 1];&#10;&#09;&#09;&#09;v1 = (int) Frame[(current_block_idx / 2) + offsetV];&#10;&#09;&#09;&#09;v2 = (int) Frame[(current_block_idx / 2) + offsetV + 1];&#10;&#10;&#09;&#09;&#09;u1 = u1 - YUV_CORRECTION_FACTOR_UV;&#10;&#09;&#09;&#09;u2 = u2 - YUV_CORRECTION_FACTOR_UV;&#10;&#09;&#09;&#09;v1 = v1 - YUV_CORRECTION_FACTOR_UV;&#10;&#09;&#09;&#09;v2 = v2 - YUV_CORRECTION_FACTOR_UV;&#10;&#10;&#09;&#09;&#09;r1 = (int) (y1c + YUV_COEF_V_EQUA_R * v1);&#10;&#09;&#09;&#09;g1 = (int) (y1c + YUV_COEF_U_EQUA_G * u1 + YUV_COEF_V_EQUA_G * v1);&#10;&#09;&#09;&#09;b1 = (int) (y1c + YUV_COEF_U_EQUA_B * u1);&#10;&#10;&#09;&#09;&#09;r2 = (int) (y2c + YUV_COEF_V_EQUA_R * v2);&#10;&#09;&#09;&#09;g2 = (int) (y2c + YUV_COEF_U_EQUA_G * u2 + YUV_COEF_V_EQUA_G * v2);&#10;&#09;&#09;&#09;b2 = (int) (y2c + YUV_COEF_U_EQUA_B * u2);&#10;&#10;&#09;&#09;&#09;// range clipping ensures that all computed values stay inside 0..255&#10;&#09;&#09;&#09;if (r1 &lt; 0)&#10;&#09;&#09;&#09;&#09;r1 = 0;&#10;&#09;&#09;&#09;else if (r1 &gt; 255)&#10;&#09;&#09;&#09;&#09;r1 = 255;&#10;&#10;&#09;&#09;&#09;if (g1 &lt; 0)&#10;&#09;&#09;&#09;&#09;g1 = 0;&#10;&#09;&#09;&#09;else if (g1 &gt; 255)&#10;&#09;&#09;&#09;&#09;g1 = 255;&#10;&#10;&#09;&#09;&#09;if (b1 &lt; 0)&#10;&#09;&#09;&#09;&#09;b1 = 0;&#10;&#09;&#09;&#09;else if (b1 &gt; 255)&#10;&#09;&#09;&#09;&#09;b1 = 255;&#10;&#10;&#09;&#09;&#09;if (r2 &lt; 0)&#10;&#09;&#09;&#09;&#09;r2 = 0;&#10;&#09;&#09;&#09;else if (r2 &gt; 255)&#10;&#09;&#09;&#09;&#09;r2 = 255;&#10;&#10;&#09;&#09;&#09;if (g2 &lt; 0)&#10;&#09;&#09;&#09;&#09;g2 = 0;&#10;&#09;&#09;&#09;else if (g2 &gt; 255)&#10;&#09;&#09;&#09;&#09;g2 = 255;&#10;&#10;&#09;&#09;&#09;if (b2 &lt; 0)&#10;&#09;&#09;&#09;&#09;b2 = 0;&#10;&#09;&#09;&#09;else if (b2 &gt; 255)&#10;&#09;&#09;&#09;&#09;b2 = 255;&#10;&#10;&#09;&#09;&#09;pixelX = (pixel_block_idx * 4);&#10;&#09;&#09;&#09;pixelY = (line_idx);&#10;&#10;&#09;&#09;&#09;// Compute new pixel index for RGB format&#10;&#09;&#09;&#09;int noPixel = (int) (pixelX + pixelY * sizeX);&#10;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb = { (unsigned char)r1, (unsigned char)g1, (unsigned char)b1 };&#10;&#09;&#09;&#09;OutputFrame[noPixel] = rgb;&#10;&#10;&#09;&#09;&#09;pixelX++;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb2 = { (unsigned char)r2, (unsigned char)g2, (unsigned char)b2 };&#10;&#09;&#09;&#09;OutputFrame[noPixel + 1] = rgb2;&#10;&#10;&#09;&#09;&#09;r1 = (int) (y1n + YUV_COEF_V_EQUA_R * v1);&#10;&#09;&#09;&#09;g1 = (int) (y1n + YUV_COEF_U_EQUA_G * u1 + YUV_COEF_V_EQUA_G * v1);&#10;&#09;&#09;&#09;b1 = (int) (y1n + YUV_COEF_U_EQUA_B * u1);&#10;&#10;&#09;&#09;&#09;r2 = (int) (y2n + YUV_COEF_V_EQUA_R * v2);&#10;&#09;&#09;&#09;g2 = (int) (y2n + YUV_COEF_U_EQUA_G * u2 + YUV_COEF_V_EQUA_G * v2);&#10;&#09;&#09;&#09;b2 = (int) (y2n + YUV_COEF_U_EQUA_B * u2);&#10;&#10;&#09;&#09;&#09;if (r1 &lt; 0)&#10;&#09;&#09;&#09;&#09;r1 = 0;&#10;&#09;&#09;&#09;else if (r1 &gt; 255)&#10;&#09;&#09;&#09;&#09;r1 = 255;&#10;&#10;&#09;&#09;&#09;if (g1 &lt; 0)&#10;&#09;&#09;&#09;&#09;g1 = 0;&#10;&#09;&#09;&#09;else if (g1 &gt; 255)&#10;&#09;&#09;&#09;&#09;g1 = 255;&#10;&#10;&#09;&#09;&#09;if (b1 &lt; 0)&#10;&#09;&#09;&#09;&#09;b1 = 0;&#10;&#09;&#09;&#09;else if (b1 &gt; 255)&#10;&#09;&#09;&#09;&#09;b1 = 255;&#10;&#10;&#09;&#09;&#09;if (r2 &lt; 0)&#10;&#09;&#09;&#09;&#09;r2 = 0;&#10;&#09;&#09;&#09;else if (r2 &gt; 255)&#10;&#09;&#09;&#09;&#09;r2 = 255;&#10;&#10;&#09;&#09;&#09;if (g2 &lt; 0)&#10;&#09;&#09;&#09;&#09;g2 = 0;&#10;&#09;&#09;&#09;else if (g2 &gt; 255)&#10;&#09;&#09;&#09;&#09;g2 = 255;&#10;&#10;&#09;&#09;&#09;if (b2 &lt; 0)&#10;&#09;&#09;&#09;&#09;b2 = 0;&#10;&#09;&#09;&#09;else if (b2 &gt; 255)&#10;&#09;&#09;&#09;&#09;b2 = 255;&#10;&#10;&#09;&#09;&#09;pixelX++;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb3 = { (unsigned char)r1, (unsigned char)g1, (unsigned char)b1 };&#10;&#09;&#09;&#09;OutputFrame[noPixel + 2] = rgb3;&#10;&#10;&#09;&#09;&#09;pixelX++;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb4 = { (unsigned char)r2, (unsigned char)g2, (unsigned char)b2 };&#10;&#09;&#09;&#09;OutputFrame[noPixel + 3] = rgb4;&#10;&#10;&#09;&#09;&#09;current_block_idx += 4;&#10;&#09;&#09;}&#10;&#09;}&#10;&#10;&#10;&#09;cf_trace_payload_chart_image(0, 0, NbPixelsPerLineMax, NbLinesMax,&#10;&#09;&#09;&#09;(const cf_dt::cf_color_rgb_t*) rgbImage);\" readTime=\"\" writeTime=\"\" allocatePayload=\"r = cf_payload::cb_alloc_payload(_atom_count);\" deallocatePayload=\"cf_payload::cb_delete_payload(_address);\" />\n  <dataTypes name=\"DefProcessingMode\" definition=\"typedef cf_dt::cf_dpv_data_t DefProcessingMode;\" copyPayload=\"cf_payload::cb_copy_payload(_address, _value, _atom_count);\" tracePayload=\"&#09;trace = &quot;&quot;;\" writeTime=\"\" allocatePayload=\"r = cf_payload::cb_alloc_payload(_atom_count);\" deallocatePayload=\"cf_payload::cb_delete_payload(_address);\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"HwDeviceModelSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"hwDeviceTest\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\" ns\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" resetPolarity=\"LOW\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"inputStream\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"outputStream\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"hwDeviceTestSt\" documentation=\"\">\n        <models xsi:type=\"cofluent:Function\" name=\"hwModel\" constructor=\"\" includes=\"\" destructor=\"\" declarations=\"void revert_frame();\" definitions=\"void cfm_hwmodel::revert_frame() {&#13;&#10;&#13;&#10;&#09;/* Reverting the image means that Pixel 0 becomes Pixel N-1, where N is the frame size (in Pixels)&#13;&#10;&#09; * In YUV 422 format, it implies to:&#13;&#10;&#09; *   - Revert the Y table, located at offset 0&#13;&#10;&#09; *   - Revert the U table, located at offset N&#13;&#10;&#09; *   - Revert the V table, located at offset N*1.5&#13;&#10;&#09; */&#13;&#10;&#09;unsigned char* outpayload = outputFrame.payload;&#13;&#10;&#09;unsigned char* inpayload = inputFrame.payload;&#13;&#10;&#13;&#10;&#09;// 'U' table Offset&#13;&#10;&#09;int offsetU = (int) (NbPixelsPerLineMax * NbLinesMax);&#13;&#10;&#09;// 'V' table offset&#13;&#10;&#09;int offsetV = (int) (NbPixelsPerLineMax * NbLinesMax * 1.5);&#13;&#10;&#13;&#10;&#09;// 4-Pixel block index in a line&#13;&#10;&#09;int pixel_block_idx = 0;&#13;&#10;&#13;&#10;&#09;// Line index&#13;&#10;&#09;int line_idx;&#13;&#10;&#13;&#10;&#09;// 4-Pixel block offset, from the beginning of the frame&#13;&#10;&#09;int current_block_ofs = 0;&#13;&#10;&#13;&#10;&#09;// For each frame line&#13;&#10;&#09;for (line_idx = 0; line_idx &lt; NbLinesMax; line_idx++) {&#13;&#10;&#09;&#09;// For each pixel block&#13;&#10;&#09;&#09;for (pixel_block_idx = 0; pixel_block_idx &lt; NbPixelsPerLineMax / 4;&#13;&#10;&#09;&#09;&#09;&#09;pixel_block_idx++) {&#13;&#10;&#13;&#10;&#09;&#09;&#09;// Revert the Y table&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 0];&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs - 1] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 1];&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs - 2] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 2];&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs - 3] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 3];&#13;&#10;&#13;&#10;&#09;&#09;&#09;// Revert the U table&#13;&#10;&#09;&#09;&#09;outpayload[offsetV - 1 - current_block_ofs / 2 - 0] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[offsetU + current_block_ofs / 2 + 0];&#13;&#10;&#09;&#09;&#09;outpayload[offsetV - 1 - current_block_ofs / 2 - 1] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[offsetU + current_block_ofs / 2 + 1];&#13;&#10;&#13;&#10;&#09;&#09;&#09;// Revert the V table&#13;&#10;&#09;&#09;&#09;outpayload[NbPixelsPerLineMax*NbLinesMax*2-1&#13;&#10;&#09;&#09;&#09;&#09;&#09;- current_block_ofs / 2 - 0] = inpayload[offsetV + current_block_ofs / 2 + 0];&#13;&#10;&#09;&#09;&#09;outpayload[NbPixelsPerLineMax*NbLinesMax*2-1&#13;&#10;&#09;&#09;&#09;&#09;&#09;- current_block_ofs / 2 - 1] = inpayload[offsetV + current_block_ofs / 2 + 1];&#13;&#10;&#13;&#10;&#09;&#09;&#09;current_block_ofs += 4;&#13;&#10;&#13;&#10;&#09;&#09;}&#13;&#10;&#09;}&#13;&#10;}\" preElaboration=\"\" initializations=\"\" cyclePeriod=\" ns\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" resetPolarity=\"LOW\" coSimulationType=\"NONE_COSIM\">\n          <ports name=\"startProcess\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"inputFrame\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"outputFrame\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"processingMode\" type=\"SHARED_VARIABLE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"hwModelBh\">\n            <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"processLoop\" algorithm=\"&#10;    if(processingMode == COPY_MODE)&#10;      outputFrame = inputFrame;&#10;    else&#13;&#10;      revert_frame();&#10;   &#13;\" executionTime=\"10 ns\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" documentation=\"\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"hwTestBench\" constructor=\"\" destructor=\"\" declarations=\"std::string movieInputFile;&#13;&#10;int ProducerNbPicture;&#13;&#10;int ConsumerNbPicture;&#13;&#10;FILE* movieInputFile_f;&#13;&#10;int VideoFrameNumber;&#13;&#10;int numread;\" definitions=\"\" preElaboration=\"\" initializations=\"movieInputFile = &quot;../../../video_file/susie422.40.qcif&quot;;&#13;&#10;cf_trace_report(&quot;TEST file name = %s&quot;, movieInputFile.c_str());&#13;&#10;ProducerNbPicture = 0;&#13;&#10;ConsumerNbPicture = 0;&#13;&#10;numread = 0;\" priority=\"1\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\" coSimulationType=\"NONE_COSIM\">\n          <ports name=\"startProcess\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"inputFrame\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"processingMode\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"outputFrame\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"inputStream\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"outputStream\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"hwTestBenchBh\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"&#09;ProducerNbPicture = 0;&#10;&#09;// Open movie file&#10;&#09;movieInputFile_f = fopen(movieInputFile.c_str(), &quot;r&quot;);&#10;&#09;COFS_SCL_API_VERIFY(movieInputFile_f,&#10;&#09;&#09;&#09;&quot;[TB] Unable to read the source image file ... exiting\\n&quot;)&#10;&#09;// Compute available frame number&#10;&#09;fseek(movieInputFile_f, 0L, SEEK_END);&#10;&#09;int sz = ftell(movieInputFile_f);&#10;&#09;fseek(movieInputFile_f, 0L, SEEK_SET);&#10;&#09;VideoFrameNumber = sz / sizeof(DefFrame);&#10;&#09;cf_trace_report(&quot;[TB] Available frame number = %d&quot;, VideoFrameNumber);&#10;&#09;processingMode = REVERT_MODE;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"prepareFrame\" algorithm=\"&#09;&#10;&#09;int imax = NbPixelsPerLineMax*NbLinesMax*2;&#10;  &#09;int PositionInFile;&#10;  &#09;int j;&#10;&#10;  &#09;// Init frame buffer&#10;  &#09;for ( j=0; j&lt;imax; j++ )  (inputFrame.payload)[j]=0;&#10;&#10; &#09;PositionInFile = imax*ProducerNbPicture;&#10;  &#09;fseek(movieInputFile_f,PositionInFile, SEEK_SET);&#10;  &#09;numread = fread( inputFrame.payload, 1, imax, movieInputFile_f );&#10;&#10;&#09;cf_trace_report(&quot;[TB] -- sending input frame  #%d...&quot;,ProducerNbPicture);&#10;&#09;&#10;&#09;inputStream = inputFrame;&#10;&#09;&#10;&#09;if(ProducerNbPicture%15 == 0) {&#10;       cf_trace_report(&quot;[TB] -- switching processing mode...&quot;);&#10;       processingMode = (processingMode == 0) ? 1 : 0;&#10;&#09;}&#10;&#09;&#10;&#09;ProducerNbPicture = (ProducerNbPicture &gt;= VideoFrameNumber -1) ? 0 : (ProducerNbPicture+1);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"displayFrame\" algorithm=\"&#09;cf_trace_report(&quot;[TB] -- getting output frame #%d&quot;, ConsumerNbPicture);&#10;&#09;outputStream = outputFrame;&#10;&#09;ConsumerNbPicture++;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction3\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction4\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction5\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction6\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:Event\" name=\"startProcess\" setTime=\"1 ns\" getTime=\"1 ns\" />\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"inputFrame\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"outputFrame\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"processingMode\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:SharedVariable\" name=\"inputStream\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:SharedVariable\" name=\"outputStream\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"CompleteDevice\" constructor=\"\" includes=\"\" version=\"BoraBora\" destructor=\"\" declarations=\"\" definitions=\"\" initializations=\"\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" resetPolarity=\"LOW\" coSimulationType=\"NONE_COSIM\" globalTypeDeclarations=\"typedef unsigned char byte;&#13;&#10;&#13;&#10;#define NbLinesMax 144&#13;&#10;#define NbPixelsPerLineMax 176&#13;&#10;\" globalDeclarations=\"#define COPY_MODE 0&#13;&#10;#define REVERT_MODE 1\" globalDefinitions=\"\">\n  <dataTypes name=\"DefFrame\" definition=\"typedef unsigned char DefVideo422[NbPixelsPerLineMax * NbLinesMax * 2];&#10;&#10;typedef struct DefFrame_s { &#10;&#09;&#09;DefVideo422 payload;&#10;} DefFrame;&#10;\" copyPayload=\"&#09;memcpy(_address, _value, sizeof(DefFrame));\" tracePayload=\"&#09;cf_color_rgb_t* rgbImage = new cf_color_rgb_t[60000];&#10;&#10;&#09;DefVideo422* tmp = &amp;(get_data_ptr()-&gt;payload);&#10;&#10;&#09;unsigned char* Frame = (unsigned char*)&amp;(tmp[0]);&#10;&#09;cf_color_rgb_t *OutputFrame = rgbImage;&#10;&#09;int sizeX = NbPixelsPerLineMax;&#10;&#09;int sizeY = NbLinesMax;&#10;&#09;&#10;&#09;const int YUV_CORRECTION_FACTOR_Y = 16;&#10;&#09;const int YUV_CORRECTION_FACTOR_UV = 128;&#10;&#10;&#09;const double YUV_COEF_V_EQUA_R = 1.140;&#10;&#09;const double YUV_COEF_U_EQUA_G = -0.395;&#10;&#09;const double YUV_COEF_V_EQUA_G = -0.581;&#10;&#09;const double YUV_COEF_U_EQUA_B = 2.032;&#10;&#10;&#09;// YUV blocks&#10;&#09;int y1c, y1n;&#10;&#09;int y2c, y2n;&#10;&#10;&#09;// RGB blocks&#10;&#09;int u1, u2, v1, v2;&#10;&#09;int r1, g1, b1;&#10;&#09;int r2, g2, b2;&#10;&#10;&#10;&#09;// 4-Pixel block index&#10;&#09;int current_block_idx = 0;&#10;&#10;&#10;&#09;int pixelX, pixelY;&#10;&#10;&#09;// 'U' table Offset&#10;&#09;int offsetU = (int) (sizeX * sizeY);&#10;&#09;// 'V' table offset&#10;&#09;int offsetV = (int) (sizeX * sizeY * 1.5);&#10;&#10;    int pixel_block_idx, line_idx;&#10;&#10;    // For each frame line&#10;&#09;for (line_idx = 0; line_idx &lt; sizeY; line_idx++) {&#10;&#10;&#09;&#09;// For each pixel block&#10;&#09;&#09;for (pixel_block_idx = 0; pixel_block_idx &lt; sizeX / 4; pixel_block_idx++) {&#10;&#09;&#09;&#09;y1c = (int) Frame[current_block_idx + 0];&#10;&#09;&#09;&#09;y2c = (int) Frame[current_block_idx + 1];&#10;&#09;&#09;&#09;y1n = (int) Frame[current_block_idx + 2];&#10;&#09;&#09;&#09;y2n = (int) Frame[current_block_idx + 3];&#10;&#10;&#09;&#09;&#09;y1c = y1c - YUV_CORRECTION_FACTOR_Y;&#10;&#09;&#09;&#09;y2c = y2c - YUV_CORRECTION_FACTOR_Y;&#10;&#09;&#09;&#09;y1n = y1n - YUV_CORRECTION_FACTOR_Y;&#10;&#09;&#09;&#09;y2n = y2n - YUV_CORRECTION_FACTOR_Y;&#10;&#10;&#09;&#09;&#09;u1 = (int) Frame[(current_block_idx / 2) + offsetU];&#10;&#09;&#09;&#09;u2 = (int) Frame[(current_block_idx / 2) + offsetU + 1];&#10;&#09;&#09;&#09;v1 = (int) Frame[(current_block_idx / 2) + offsetV];&#10;&#09;&#09;&#09;v2 = (int) Frame[(current_block_idx / 2) + offsetV + 1];&#10;&#10;&#09;&#09;&#09;u1 = u1 - YUV_CORRECTION_FACTOR_UV;&#10;&#09;&#09;&#09;u2 = u2 - YUV_CORRECTION_FACTOR_UV;&#10;&#09;&#09;&#09;v1 = v1 - YUV_CORRECTION_FACTOR_UV;&#10;&#09;&#09;&#09;v2 = v2 - YUV_CORRECTION_FACTOR_UV;&#10;&#10;&#09;&#09;&#09;r1 = (int) (y1c + YUV_COEF_V_EQUA_R * v1);&#10;&#09;&#09;&#09;g1 = (int) (y1c + YUV_COEF_U_EQUA_G * u1 + YUV_COEF_V_EQUA_G * v1);&#10;&#09;&#09;&#09;b1 = (int) (y1c + YUV_COEF_U_EQUA_B * u1);&#10;&#10;&#09;&#09;&#09;r2 = (int) (y2c + YUV_COEF_V_EQUA_R * v2);&#10;&#09;&#09;&#09;g2 = (int) (y2c + YUV_COEF_U_EQUA_G * u2 + YUV_COEF_V_EQUA_G * v2);&#10;&#09;&#09;&#09;b2 = (int) (y2c + YUV_COEF_U_EQUA_B * u2);&#10;&#10;&#09;&#09;&#09;// range clipping ensures that all computed values stay inside 0..255&#10;&#09;&#09;&#09;if (r1 &lt; 0)&#10;&#09;&#09;&#09;&#09;r1 = 0;&#10;&#09;&#09;&#09;else if (r1 &gt; 255)&#10;&#09;&#09;&#09;&#09;r1 = 255;&#10;&#10;&#09;&#09;&#09;if (g1 &lt; 0)&#10;&#09;&#09;&#09;&#09;g1 = 0;&#10;&#09;&#09;&#09;else if (g1 &gt; 255)&#10;&#09;&#09;&#09;&#09;g1 = 255;&#10;&#10;&#09;&#09;&#09;if (b1 &lt; 0)&#10;&#09;&#09;&#09;&#09;b1 = 0;&#10;&#09;&#09;&#09;else if (b1 &gt; 255)&#10;&#09;&#09;&#09;&#09;b1 = 255;&#10;&#10;&#09;&#09;&#09;if (r2 &lt; 0)&#10;&#09;&#09;&#09;&#09;r2 = 0;&#10;&#09;&#09;&#09;else if (r2 &gt; 255)&#10;&#09;&#09;&#09;&#09;r2 = 255;&#10;&#10;&#09;&#09;&#09;if (g2 &lt; 0)&#10;&#09;&#09;&#09;&#09;g2 = 0;&#10;&#09;&#09;&#09;else if (g2 &gt; 255)&#10;&#09;&#09;&#09;&#09;g2 = 255;&#10;&#10;&#09;&#09;&#09;if (b2 &lt; 0)&#10;&#09;&#09;&#09;&#09;b2 = 0;&#10;&#09;&#09;&#09;else if (b2 &gt; 255)&#10;&#09;&#09;&#09;&#09;b2 = 255;&#10;&#10;&#09;&#09;&#09;pixelX = (pixel_block_idx * 4);&#10;&#09;&#09;&#09;pixelY = (line_idx);&#10;&#10;&#09;&#09;&#09;// Compute new pixel index for RGB format&#10;&#09;&#09;&#09;int noPixel = (int) (pixelX + pixelY * sizeX);&#10;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb = { (unsigned char)r1, (unsigned char)g1, (unsigned char)b1 };&#10;&#09;&#09;&#09;OutputFrame[noPixel] = rgb;&#10;&#10;&#09;&#09;&#09;pixelX++;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb2 = { (unsigned char)r2, (unsigned char)g2, (unsigned char)b2 };&#10;&#09;&#09;&#09;OutputFrame[noPixel + 1] = rgb2;&#10;&#10;&#09;&#09;&#09;r1 = (int) (y1n + YUV_COEF_V_EQUA_R * v1);&#10;&#09;&#09;&#09;g1 = (int) (y1n + YUV_COEF_U_EQUA_G * u1 + YUV_COEF_V_EQUA_G * v1);&#10;&#09;&#09;&#09;b1 = (int) (y1n + YUV_COEF_U_EQUA_B * u1);&#10;&#10;&#09;&#09;&#09;r2 = (int) (y2n + YUV_COEF_V_EQUA_R * v2);&#10;&#09;&#09;&#09;g2 = (int) (y2n + YUV_COEF_U_EQUA_G * u2 + YUV_COEF_V_EQUA_G * v2);&#10;&#09;&#09;&#09;b2 = (int) (y2n + YUV_COEF_U_EQUA_B * u2);&#10;&#10;&#09;&#09;&#09;if (r1 &lt; 0)&#10;&#09;&#09;&#09;&#09;r1 = 0;&#10;&#09;&#09;&#09;else if (r1 &gt; 255)&#10;&#09;&#09;&#09;&#09;r1 = 255;&#10;&#10;&#09;&#09;&#09;if (g1 &lt; 0)&#10;&#09;&#09;&#09;&#09;g1 = 0;&#10;&#09;&#09;&#09;else if (g1 &gt; 255)&#10;&#09;&#09;&#09;&#09;g1 = 255;&#10;&#10;&#09;&#09;&#09;if (b1 &lt; 0)&#10;&#09;&#09;&#09;&#09;b1 = 0;&#10;&#09;&#09;&#09;else if (b1 &gt; 255)&#10;&#09;&#09;&#09;&#09;b1 = 255;&#10;&#10;&#09;&#09;&#09;if (r2 &lt; 0)&#10;&#09;&#09;&#09;&#09;r2 = 0;&#10;&#09;&#09;&#09;else if (r2 &gt; 255)&#10;&#09;&#09;&#09;&#09;r2 = 255;&#10;&#10;&#09;&#09;&#09;if (g2 &lt; 0)&#10;&#09;&#09;&#09;&#09;g2 = 0;&#10;&#09;&#09;&#09;else if (g2 &gt; 255)&#10;&#09;&#09;&#09;&#09;g2 = 255;&#10;&#10;&#09;&#09;&#09;if (b2 &lt; 0)&#10;&#09;&#09;&#09;&#09;b2 = 0;&#10;&#09;&#09;&#09;else if (b2 &gt; 255)&#10;&#09;&#09;&#09;&#09;b2 = 255;&#10;&#10;&#09;&#09;&#09;pixelX++;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb3 = { (unsigned char)r1, (unsigned char)g1, (unsigned char)b1 };&#10;&#09;&#09;&#09;OutputFrame[noPixel + 2] = rgb3;&#10;&#10;&#09;&#09;&#09;pixelX++;&#10;&#09;&#09;&#09;cf_color_rgb_t rgb4 = { (unsigned char)r2, (unsigned char)g2,(unsigned char) b2 };&#10;&#09;&#09;&#09;OutputFrame[noPixel + 3] = rgb4;&#10;&#10;&#09;&#09;&#09;current_block_idx += 4;&#10;&#09;&#09;}&#10;&#09;}&#10;&#10;&#10;&#09;cf_trace_payload_chart_image(0, 0, NbPixelsPerLineMax, NbLinesMax,&#10;&#09;&#09;&#09;(const cf_dt::cf_color_rgb_t*) rgbImage);\" readTime=\"\" writeTime=\"\" allocatePayload=\"r = cf_payload::cb_alloc_payload(_atom_count);\" deallocatePayload=\"cf_payload::cb_delete_payload(_address);\" />\n  <dataTypes name=\"DefProcessingMode\" definition=\"typedef cf_dt::cf_dpv_data_t DefProcessingMode;\" copyPayload=\"cf_payload::cb_copy_payload(_address, _value, _atom_count);\" tracePayload=\"&#09;trace = &quot;&quot;;\" readTime=\"\" writeTime=\"\" allocatePayload=\"r = cf_payload::cb_alloc_payload(_atom_count);\" deallocatePayload=\"cf_payload::cb_delete_payload(_address);\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"CompleteDeviceSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"device\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\" ns\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" resetPolarity=\"LOW\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"dpv\" type=\"METHOD_CALL_INTERFACE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"newFrame\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"deviceSt\" documentation=\"\">\n        <models xsi:type=\"cofluent:Function\" name=\"hwModel\" constructor=\"\" declarations=\"void revert_frame();\" definitions=\"void cfm_hwmodel::revert_frame() {&#13;&#10;&#13;&#10;&#09;/* Reverting the image means that Pixel 0 becomes Pixel N-1, where N is the frame size (in Pixels)&#13;&#10;&#09; * In YUV 422 format, it implies to:&#13;&#10;&#09; *   - Revert the Y table, located at offset 0&#13;&#10;&#09; *   - Revert the U table, located at offset N&#13;&#10;&#09; *   - Revert the V table, located at offset N*1.5&#13;&#10;&#09; */&#13;&#10;&#09;unsigned char* outpayload = outputFrame.payload;&#13;&#10;&#09;unsigned char* inpayload = inputFrame.payload;&#13;&#10;&#13;&#10;&#09;// 'U' table Offset&#13;&#10;&#09;int offsetU = (int) (NbPixelsPerLineMax * NbLinesMax);&#13;&#10;&#09;// 'V' table offset&#13;&#10;&#09;int offsetV = (int) (NbPixelsPerLineMax * NbLinesMax * 1.5);&#13;&#10;&#13;&#10;&#09;// 4-Pixel block index in a line&#13;&#10;&#09;int pixel_block_idx = 0;&#13;&#10;&#13;&#10;&#09;// Line index&#13;&#10;&#09;int line_idx;&#13;&#10;&#13;&#10;&#09;// 4-Pixel block offset, from the beginning of the frame&#13;&#10;&#09;int current_block_ofs = 0;&#13;&#10;&#13;&#10;&#09;// For each frame line&#13;&#10;&#09;for (line_idx = 0; line_idx &lt; NbLinesMax; line_idx++) {&#13;&#10;&#09;&#09;// For each pixel block&#13;&#10;&#09;&#09;for (pixel_block_idx = 0; pixel_block_idx &lt; NbPixelsPerLineMax / 4;&#13;&#10;&#09;&#09;&#09;&#09;pixel_block_idx++) {&#13;&#10;&#13;&#10;&#09;&#09;&#09;// Revert the Y table&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 0];&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs - 1] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 1];&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs - 2] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 2];&#13;&#10;&#09;&#09;&#09;outpayload[offsetU - 1 - current_block_ofs - 3] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[current_block_ofs + 3];&#13;&#10;&#13;&#10;&#09;&#09;&#09;// Revert the U table&#13;&#10;&#09;&#09;&#09;outpayload[offsetV - 1 - current_block_ofs / 2 - 0] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[offsetU + current_block_ofs / 2 + 0];&#13;&#10;&#09;&#09;&#09;outpayload[offsetV - 1 - current_block_ofs / 2 - 1] =&#13;&#10;&#09;&#09;&#09;&#09;&#09;inpayload[offsetU + current_block_ofs / 2 + 1];&#13;&#10;&#13;&#10;&#09;&#09;&#09;// Revert the V table&#13;&#10;&#09;&#09;&#09;outpayload[NbPixelsPerLineMax*NbLinesMax*2-1&#13;&#10;&#09;&#09;&#09;&#09;&#09;- current_block_ofs / 2 - 0] = inpayload[offsetV + current_block_ofs / 2 + 0];&#13;&#10;&#09;&#09;&#09;outpayload[NbPixelsPerLineMax*NbLinesMax*2-1&#13;&#10;&#09;&#09;&#09;&#09;&#09;- current_block_ofs / 2 - 1] = inpayload[offsetV + current_block_ofs / 2 + 1];&#13;&#10;&#13;&#10;&#09;&#09;&#09;current_block_ofs += 4;&#13;&#10;&#13;&#10;&#09;&#09;}&#13;&#10;&#09;}&#13;&#10;}\" initializations=\"\" cyclePeriod=\" ns\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" resetPolarity=\"LOW\" coSimulationType=\"NONE_COSIM\">\n          <ports name=\"startProcess\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"inputFrame\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"outputFrame\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"processingMode\" type=\"SHARED_VARIABLE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"hwModelBh\">\n            <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"\" executionTime=\"10 ns\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"processLoop\" algorithm=\"    if ( processingMode == COPY_MODE )&#10;      outputFrame = inputFrame;&#10;    else&#13;&#10;      revert_frame();&#13;\" executionTime=\"10 ns\" systematicRead=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" documentation=\"\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" condition=\"\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:DeviceProgrammersView\" name=\"swInterface\" documentation=\"\" constructor=\"\" includes=\"#include &lt;list&gt;\" destructor=\"\" declarations=\"std::list&lt;DefFrame&gt; frame_memory;&#13;&#10;void storeOutputFrame(DefFrame* frame);\" definitions=\"void cfm_swinterface::storeOutputFrame(DefFrame* frame) {&#13;&#10;    frame_memory.push_back(*frame);&#13;&#10;&#09;processedFrameCount.write(processedFrameCount.read() + 1);&#13;&#10;&#09;raise_interrupt_int( &quot;newFrameInt&quot; );&#13;&#10;}\" preElaboration=\"\" initializations=\"\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" address=\"\">\n          <ports name=\"startProcess\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"dpv\" type=\"METHOD_CALL_INTERFACE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"inputFrame\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"newFrame\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"processingMode\" documentation=\"\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"storeFrame\" type=\"METHOD_CALL_INTERFACE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"swInterfaceSt\" />\n          </models>\n        <models xsi:type=\"cofluent:Function\" name=\"mqToCommand\" includes=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\" ns\" priority=\"1\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" coSimulationType=\"NONE_COSIM\">\n          <ports name=\"outputFrame\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n          <ports name=\"storeFrame\" type=\"METHOD_CALL_INTERFACE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"mqToCommandBh\">\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" documentation=\"\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"storeFrame-&gt;storeOutputFrame( &amp;outputFrame );\" />\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:Event\" name=\"startProcess\" setTime=\"1 ns\" getTime=\"1 ns\" />\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"inputFrame\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"outputFrame\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"1 ns\" receiveTime=\"1 ns\" sendThreshold=\"1\" receiveThreshold=\"1\" address=\"\" mask=\"\" messageQueueType=\"STANDARD\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"processingMode\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MethodCallInterface\" name=\"storeFrame\" declarations=\"virtual void storeOutputFrame(DefFrame* frame) = 0;\" includes=\"\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"testBench\" documentation=\"\" constructor=\"\" includes=\"\" declarations=\"/* Register address definition */&#13;&#10;#define PROCESSED_FRAME_COUNT_REGISTER_ADDR 0x200&#13;&#10;#define PROCESSING_MODE_REGISTER_ADDR 0x100&#13;&#10;&#13;&#10;DefFrame inputFrame, outputFrame;&#13;&#10;std::string movieInputFile;&#13;&#10;int ProducerNbPicture;&#13;&#10;int ConsumerNbPicture;&#13;&#10;FILE* movieInputFile_f;&#13;&#10;int VideoFrameNumber;&#13;&#10;int new_mode;&#13;&#10;int numread;\" definitions=\"\" preElaboration=\"\" initializations=\"movieInputFile = &quot;../../../video_file/susie422.40.qcif&quot;;&#13;&#10;cf_trace_report(&quot;TEST file name = %s&quot;, movieInputFile.c_str());&#13;&#10;ProducerNbPicture = 0;&#13;&#10;ConsumerNbPicture = 0;&#13;&#10;new_mode = REVERT_MODE;\" cyclePeriod=\" ns\" affinity=\"\" priority=\"\" schedulingPolicy=\"FIFO\" InterfaceBlockingBehavior=\"RELEASE_CORE\" timeSlicePeriod=\"10 ms\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\" resetPolarity=\"LOW\" coSimulationType=\"NONE_COSIM\">\n      <ports name=\"dpv\" type=\"METHOD_CALL_INTERFACE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"newFrame\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"inputStream\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <ports name=\"outputStream\" type=\"SHARED_VARIABLE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"false\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"testBenchBh\" documentation=\"\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"init\" algorithm=\"&#09;ProducerNbPicture = 0;&#13;&#10;&#09;// Open movie file&#13;&#10;&#09;movieInputFile_f = fopen(movieInputFile.c_str(), &quot;r&quot;);&#13;&#10;&#09;COFS_SCL_API_VERIFY(movieInputFile_f,&#13;&#10;&#09;&#09;&#09;&quot;[TB] Unable to read the source image file ... exiting\\n&quot;)&#13;&#10;&#09;// Compute available frame number&#13;&#10;&#09;fseek(movieInputFile_f, 0L, SEEK_END);&#13;&#10;&#09;int sz = ftell(movieInputFile_f);&#13;&#10;&#09;fseek(movieInputFile_f, 0L, SEEK_SET);&#13;&#10;&#09;VideoFrameNumber = sz / sizeof(DefFrame);&#13;&#10;&#09;cf_trace_report(&quot;[TB] Available frame number = %d&quot;, VideoFrameNumber);&#13;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\"0 uW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" documentation=\"\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"dpv-&gt;write_register( 0x100 , REVERT_MODE );\" />\n        <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"prepareFrame\" algorithm=\"&#09;int imax = NbPixelsPerLineMax*NbLinesMax*2;&#10;  &#09;int PositionInFile;&#10;  &#09;int j;&#10;&#10;  &#09;// Init frame buffer&#10;  &#09;for ( j=0; j&lt;imax; j++ )  (inputFrame.payload)[j]=0;&#10;&#10; &#09;PositionInFile = imax*ProducerNbPicture;&#10;  &#09;fseek(movieInputFile_f,PositionInFile, SEEK_SET);&#10;  &#09;numread = fread( inputFrame.payload, 1, imax, movieInputFile_f );&#10;&#10;&#09;cf_trace_report(&quot;[TB] -- sending input frame  #%d...&quot;,ProducerNbPicture);&#10;&#09;&#10;&#09;inputStream = inputFrame;&#10;&#09;&#10;&#09;if(ProducerNbPicture%15 == 0) {&#10;       cf_trace_report(&quot;[TB] -- switching processing mode...&quot;);&#10;       int current_mode = (int)(dpv-&gt;read_register(PROCESSING_MODE_REGISTER_ADDR));&#10;       new_mode = (current_mode == 0) ? 1 : 0;&#10;       &#10;&#09;}&#10;&#09;&#10;&#09;ProducerNbPicture = (ProducerNbPicture &gt;= VideoFrameNumber -1) ? 0 : (ProducerNbPicture+1);\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\"0 uW\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"dpv-&gt;send_command(&quot;pushFrame&quot;, sizeof(DefFrame), (unsigned char*) &amp;inputFrame);\" />\n        <statements xsi:type=\"cofluent:Operation\" name=\"displayFrame\" documentation=\"\" algorithm=\"&#09;cf_trace_report(&quot;[TB] -- getting output frame #%d&quot;, ConsumerNbPicture);&#13;&#10;&#09;outputStream = outputFrame;\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\"0 uW\" />\n        <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction3\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"dpv-&gt;send_command(&quot;getFrame&quot;, sizeof(DefFrame), (unsigned char*) &amp;outputFrame);&#13;&#10;ConsumerNbPicture = (int)(dpv-&gt;read_register(PROCESSED_FRAME_COUNT_REGISTER_ADDR));\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction4\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction5\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction6\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"dpv-&gt;send_command(&quot;startCmd&quot;, 0, NULL);\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction7\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"dpv-&gt;write_register( (int) PROCESSING_MODE_REGISTER_ADDR, new_mode);\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MethodCallInterface\" name=\"dpv\" documentation=\"\" declarations=\"\" dpvInterface=\"EXTERNAL\" includes=\"\" />\n    <relations xsi:type=\"cofluent:Event\" name=\"newFrame\" setTime=\"0 ns\" getTime=\"0 ns\" />\n    <relations xsi:type=\"cofluent:SharedVariable\" name=\"inputStream\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:SharedVariable\" name=\"outputStream\" concurrency=\"1\" counter=\"1\" writeTime=\"1 ns\" readTime=\"1 ns\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"Bluetooth_IPs\" constructor=\"\" includes=\"\" postSimulation=\"\" version=\"4.0.0\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\" postElaboration=\"nb_file_parts = 0;&#13;&#10;nb_OBEX_df = 0;&#13;&#10;nb_RFCOMM_df = 0;&#13;&#10;total_delay_FILE = 0;&#13;&#10;total_delay_OBEX = 0;&#13;&#10;total_delay_RFCOMM = 0;&#13;&#10;nb_cdts_req = 0;&#13;&#10;total_L2CAP_data = 0;\" globalTypeDeclarations=\"//Packet level&#13;&#10;#define FILE_PART 0x00&#13;&#10;#define OBEX 0x01&#13;&#10;#define RFCOMM 0x02&#13;&#10;#define L2CAP 0x03&#13;&#10;#define BASEBAND 0x04&#13;&#10;//Header sizes&#13;&#10;#define OBEX_HDR_S 3&#13;&#10;#define RFCOMM_HDR_S 5&#13;&#10;#define L2CAP_HDR_S 4&#13;&#10;//OBEX packet type&#13;&#10;#define PUT 0x01&#13;&#10;#define FINAL 0x02&#13;&#10;//RFCOMM packet type&#13;&#10;#define DATA 0x01&#13;&#10;#define DATA_END 0x02&#13;&#10;#define CREDITS 0x03&#13;&#10;&#13;&#10;/*** TYPE DEFINITIONS ***/&#13;&#10;//DefOrder&#13;&#10;enum DefOrderType{read_order,write_order};&#13;&#10;struct DefOrder{&#13;&#10;&#09;DefOrderType order_type;&#13;&#10;&#09;int size;&#13;&#10;};&#13;&#10;&#13;&#10;//DefFile&#13;&#10;struct DefFile{&#13;&#10;&#09;int file_size;&#13;&#10;};&#13;&#10;&#13;&#10;//DefFrame is an abstract structure to describe Bluetooth frame&#13;&#10;//at any protocol layer&#13;&#10;struct DefFrame{&#13;&#10;&#09;int total_frame_size; //USERDATASIZE&#13;&#10;&#09;int header_size;&#13;&#10;&#09;int payload_size;&#13;&#10;&#09;int FILE_timestamp; //in us&#13;&#10;&#09;int OBEX_timestamp; //in us&#13;&#10;&#09;int RFCOMM_timestamp; //in us&#13;&#10;&#09;unsigned char packet_type;&#13;&#10;&#09;unsigned char OBEX_type; //put or final/continue packet&#13;&#10;&#09;unsigned char RFCOMM_type; //data, data final, or credits&#13;&#10;};&#13;&#10;\" globalDeclarations=\"/*** Variables for perf monitoring ***/&#13;&#10;extern int first_read_time; //in us&#13;&#10;extern int last_write_time; //in us&#13;&#10;extern int nb_file_parts;&#13;&#10;extern int nb_OBEX_df;&#13;&#10;extern int nb_RFCOMM_df;&#13;&#10;extern int total_delay_FILE;//in us&#13;&#10;extern int total_delay_OBEX;//in us&#13;&#10;extern int total_delay_RFCOMM;//in us&#13;&#10;extern int nb_cdts_req;&#13;&#10;extern int total_L2CAP_data;&#13;&#10;&#13;&#10;/*** Variables for perf results ***/&#13;&#10;extern int total_time; //in us&#13;&#10;extern double average_throughput; //in kpbs&#13;&#10;\" globalDefinitions=\"/*** Variables for perf monitoring ***/&#13;&#10;int first_read_time; //in us&#13;&#10;int last_write_time; //in us&#13;&#10;int nb_file_parts;&#13;&#10;int nb_OBEX_df;&#13;&#10;int nb_RFCOMM_df;&#13;&#10;int total_delay_FILE;//in us&#13;&#10;int total_delay_OBEX;//in us&#13;&#10;int total_delay_RFCOMM;//in us&#13;&#10;int nb_cdts_req;&#13;&#10;int total_L2CAP_data;&#13;&#10;&#13;&#10;/*** Variables for perf results ***/&#13;&#10;int total_time; //in us&#13;&#10;double average_throughput; //in kpbs&#13;&#10;\">\n  <dataTypes name=\"DefBaseBand\" definition=\"typedef DefFrame DefBaseBand;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <dataTypes name=\"DefRFCOMM_In\" definition=\"typedef DefFrame DefRFCOMM_In;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <dataTypes name=\"DefReadWrite\" definition=\"typedef DefOrder DefReadWrite;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; get_data().size;\" />\n  <dataTypes name=\"DefL2CAP_Out\" definition=\"typedef DefFrame DefL2CAP_Out;\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <dataTypes name=\"DefData\" definition=\"typedef DefFile DefData;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; get_data().file_size;\" />\n  <dataTypes name=\"DefOBEX_In\" definition=\"typedef DefFrame DefOBEX_In;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <dataTypes name=\"DefDataOut\" definition=\"typedef DefFrame DefDataOut;\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" readTime=\"\" />\n  <dataTypes name=\"DefOBEX_Out\" definition=\"typedef DefFrame DefOBEX_Out;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <dataTypes name=\"DefL2CAP_In\" definition=\"typedef DefFrame DefL2CAP_In;\" copyPayload=\"\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <dataTypes name=\"DefDataIn\" definition=\"typedef DefFrame DefDataIn;\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <dataTypes name=\"DefRFCOMM_Out\" definition=\"typedef DefFrame DefRFCOMM_Out;\" tracePayload=\"&#09;trace &lt;&lt; get_data().total_frame_size;\" />\n  <refinement xsi:type=\"cofluent:Structure\" name=\"Bluetooth_IPsStructSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"Slave_Stub\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\" ns\">\n      <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"Slave_StubSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"In_Stub\" cyclePeriod=\" ns\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"In_StubBh\">\n            <statements xsi:type=\"cofluent:Operation\" name=\"stub_send\" executionTime=\"10 ns\" dynamicDataSize=\"0 kB\" dynamicPowerConsumption=\" uW\" dynamicResourceLoad=\"0\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"false\" priority=\"\" vectorSize=\"\" blocking=\"true\" call=\"\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"Out_Stub\" cyclePeriod=\" ns\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n          <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"Out_StubBh\">\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ns\" priority=\"\" duration=\" ns\" vectorSize=\"\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop\" condition=\"\" />\n          </refinement>\n        </models>\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"BT_System\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n      <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <ports name=\"startEv\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Structure\" name=\"MasterStructSt\">\n        <models xsi:type=\"cofluent:Function\" name=\"FileSystem\" constructor=\"\" includes=\"\" declarations=\"//stop flag is activated when file has been read entirely&#10;bool stop;&#10;//read/write flag&#10;int wr;&#10;//file size&#10;int f_size;&#10;//size of a part&#10;int p_size;&#10;//read operation duration in ms&#10;double op_read_duration;&#10;//write operation duration in ms&#10;double op_write_duration;&#10;//first read flag&#10;bool first_read;\" definitions=\"\" initializations=\"//stop flag is activated when file has been read entirely&#13;&#10;stop = false;&#13;&#10;//read/write flag&#13;&#10;wr = 0;&#13;&#10;//file size&#13;&#10;f_size = File_Size*1000;&#13;&#10;//first read flag&#13;&#10;first_read = true;\" cyclePeriod=\"10 ns\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\">\n          <ports name=\"Data\" type=\"SHARED_VARIABLE\" direction=\"IN_OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"WrOK\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"DataOut\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"DataIn\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"ReadWrite\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Behavior\" name=\"FileSystemBehvBh\">\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction20\" timeout=\" ms\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"DecodeOrder\" documentation=\"\" algorithm=\"switch (ReadWrite.order_type) {&#13;&#10;&#09;case read_order:&#13;&#10;&#09;&#09;wr = 0;&#13;&#10;&#09;&#09;break;&#13;&#10;&#09;case write_order:&#13;&#10;&#09;&#09;wr = 1;&#13;&#10;&#09;&#09;break;&#13;&#10;&#09;}&#13;&#10;&#09;p_size = ReadWrite.size;\" executionTime=\"0 ns\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n            <statements xsi:type=\"cofluent:AlternativeStatement\">\n              <conditionalBranches condition=\"wr==1\" />\n              <conditionalBranches condition=\"\" />\n            </statements>\n            <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop15\" condition=\"stop==false\" type=\"CONDITIONAL\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Write\" algorithm=\"op_write_duration = (double) (DataIn.payload_size) * 8.0&#13;&#10;&#09;&#09;&#09;/ (double) FS_write_throughput;&#13;&#10;&#09;//file system verbose&#13;&#10;&#09;if (Verbose_Level != LEVEL_SILENT &amp;&amp; Verbose_Level != LEVEL_RESULTS) {&#13;&#10;&#09;&#09;cf_trace_report(&quot;FS: Write:%d bytes&quot;, DataIn.payload_size);&#13;&#10;&#09;}&#13;&#10;&#09;last_write_time = (int) cf_time_stamp().to_scalar(CF_US);\" executionTime=\"op_write_duration ms\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"Read\" documentation=\"\" algorithm=\"&#09;if (first_read) {&#13;&#10;&#09;&#09;first_read_time = (int) cf_time_stamp().to_scalar(CF_US);&#13;&#10;&#09;&#09;first_read = false;&#13;&#10;&#09;}&#13;&#10;&#09;if (f_size &gt;= p_size) {&#13;&#10;&#09;&#09;f_size -= p_size;&#13;&#10;&#09;&#09;op_read_duration = (double) p_size * 8.0 / (double) FS_read_throughput;&#13;&#10;&#09;&#09;DataOut.payload_size = p_size;&#13;&#10;&#09;&#09;if (f_size == 0)&#13;&#10;&#09;&#09;&#09;stop = true;&#13;&#10;&#09;} else {&#13;&#10;&#09;&#09;op_read_duration = (double) f_size * 8.0 / (double) FS_read_throughput;&#13;&#10;&#09;&#09;DataOut.payload_size = f_size;&#13;&#10;&#09;&#09;f_size = 0;&#13;&#10;&#09;&#09;stop = true;&#13;&#10;&#09;}&#13;&#10;&#09;//file system verbose&#13;&#10;&#09;if (Verbose_Level != LEVEL_SILENT &amp;&amp; Verbose_Level != LEVEL_RESULTS) {&#13;&#10;&#09;&#09;cf_trace_report(&quot;FS: Read:%d bytes&quot;, DataOut.payload_size);&#13;&#10;&#09;&#09;if (stop)&#13;&#10;&#09;&#09;&#09;cf_trace_report(&quot;FS: File reading finished&quot;);&#13;&#10;&#09;}&#13;&#10;&#09;//monitoring&#13;&#10;&#09;nb_file_parts++;&#13;&#10;&#09;DataOut.total_frame_size = DataOut.payload_size;&#10;&#09;DataOut.FILE_timestamp = (int) cf_time_stamp().to_scalar(CF_US);&#10;&#09;DataOut_trans.set_user_data_length( cf_dt::cf_data_size( DataOut.total_frame_size, CF_BYTE ) );\" executionTime=\"op_read_duration ms\" systematicRead=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction19\" timeout=\" ms\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction24\" duration=\"1 ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction23\" duration=\"1 ns\" condition=\"\" blocking=\"true\" />\n            <statements xsi:type=\"cofluent:InputAction\" name=\"InAction43\" timeout=\" ms\" priority=\"\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n            <statements xsi:type=\"cofluent:Operation\" name=\"EndSim\" documentation=\"\" algorithm=\"&#09;cf_stop();\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n          </refinement>\n        </models>\n        <models xsi:type=\"cofluent:Function\" name=\"BT_Stack\" cyclePeriod=\"10 ns\">\n          <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"ReadWrite\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"DataIn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"WrOK\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"DataOut\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <ports name=\"startEv\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n          <refinement xsi:type=\"cofluent:Structure\" name=\"BT_StackStructSt\">\n            <models xsi:type=\"cofluent:Function\" name=\"OBEX_Layer\" includes=\"\" cyclePeriod=\"10 ns\">\n              <ports name=\"ReadWrite\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"DataIn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"WrOK\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"DataOut\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"OBEX_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"startEv\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"OBEX_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"OBEX_LayerStructSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"OBEX_Send\" constructor=\"\" includes=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\">\n                  <ports name=\"continueEv\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"OB_Out2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"ReadWrite\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"DataOut\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"startEv\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"OBEX_SendBehvBh\">\n                    <selectors xsi:type=\"cofluent:OrInputSelector\" name=\"InSelector\">\n                      <inputs name=\"InputSelectorInput\" priority=\"\" timeout=\" ns\" duration=\" ns\" />\n                      <inputs name=\"InputSelectorInput2\" priority=\"\" timeout=\" ns\" duration=\" ns\" />\n                    </selectors>\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction28\" duration=\"1 ns\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"AskForFragment\" algorithm=\"//ask to read file system&#10;ReadWrite.order_type = read_order;&#10;//specify the size to read (in bytes)&#10;ReadWrite.size = OBEX_pl_size;&#10;\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SendFrame\" algorithm=\"OB_Out2.header_size = OBEX_HDR_S;&#10;OB_Out2.payload_size = DataOut.payload_size;&#10;OB_Out2.total_frame_size = OB_Out2.header_size + OB_Out2.payload_size;&#10;OB_Out2.packet_type = OBEX;&#10;OB_Out2.OBEX_type = PUT;&#10;OB_Out2.FILE_timestamp = DataOut.FILE_timestamp;&#10;OB_Out2.OBEX_timestamp = (int) cf_time_stamp().to_scalar(CF_US);&#10;//OBEX verbose&#10;if(Verbose_Level != LEVEL_SILENT &amp;&amp; Verbose_Level != LEVEL_RESULTS &amp;&amp; Verbose_Level != LEVEL_FS){&#10;&#09;cf_trace_report(&quot;OBEX: Send frame:%d bytes&quot;,OB_Out2.total_frame_size);&#10;}&#10;//monitoring&#10;nb_OBEX_df++;&#10;OB_Out2_trans.set_user_data_length( cf_dt::cf_data_size( OB_Out2.total_frame_size, CF_BYTE ) );\" executionTime=\"OBEX_SendFrameTime us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop17\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\"1 ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"OBEX_Receive\" constructor=\"\" includes=\"\" declarations=\"int ack;\" initializations=\"ack = 0;\" cyclePeriod=\"10 ns\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\">\n                  <ports name=\"continueEv\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"OB_Out1\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"ReadWrite\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"DataIn\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"WrOK\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"OBEX_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"OBEXReceiveBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop16\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Decode\" algorithm=\"switch(OBEX_In.OBEX_type){&#10;&#09;case PUT: {&#10;&#09;&#09;ack = 0;&#10;&#09;&#09;total_delay_OBEX += (int) cf_time_stamp().to_scalar(CF_US) - OBEX_In.OBEX_timestamp;&#10;&#09;}&#10;&#09;&#09;break;&#10;&#09;case FINAL: {&#09;&#09;&#09;&#10;&#09;&#09;&#09;ack = 1;&#10;&#09;&#09;&#09;//monitoring&#10;&#09;&#09;&#09;total_delay_FILE += (int) cf_time_stamp().to_scalar(CF_US) - OBEX_In.FILE_timestamp;&#10;&#09;&#09;}&#10;&#09;&#09;break;&#10;}\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:AlternativeStatement\">\n                      <conditionalBranches condition=\"\" />\n                      <conditionalBranches condition=\"ack==1\" />\n                    </statements>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Ack\" algorithm=\"\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"DataRcv\" algorithm=\"//ask to write in file system&#10;ReadWrite.order_type = write_order;&#10;//specify the size to write (in bytes)&#10;ReadWrite.size = OBEX_In.payload_size;&#10;//Send payload to write&#10;DataIn.payload_size = OBEX_In.payload_size;&#10;DataIn.packet_type = FILE_PART;&#10;//OBEX verbose&#10;if(Verbose_Level != LEVEL_SILENT &amp;&amp; Verbose_Level != LEVEL_RESULTS &amp;&amp; Verbose_Level != LEVEL_FS){&#10;&#09;cf_trace_report(&quot;OBEX: Received frame:%d bytes&quot;,OBEX_In.total_frame_size);&#10;&#09;cf_trace_report(&quot;OBEX: Send data to FS:%d bytes&quot;,DataIn.payload_size);&#10;}&#10;DataIn_trans.set_user_data_length( cf_dt::cf_data_size( DataIn.payload_size, CF_BYTE ) );\" executionTime=\"OBEX_ReceiveFrameTime us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SendAck\" algorithm=\"//send a final packet&#10;OB_Out1.total_frame_size = 3;&#10;OB_Out1.header_size = OBEX_HDR_S;&#10;OB_Out1.payload_size = 0;&#10;OB_Out1.packet_type = OBEX;&#10;OB_Out1.OBEX_type = FINAL;&#10;OB_Out1.FILE_timestamp = OBEX_In.FILE_timestamp;//transmit file timestamp with the acknowledge&#10;//OBEX verbose&#10;if(Verbose_Level != LEVEL_SILENT &amp;&amp; Verbose_Level != LEVEL_RESULTS &amp;&amp; Verbose_Level != LEVEL_FS){&#10;&#09;cf_trace_report(&quot;OBEX: Send a final/continue packet&quot;);&#10;}&#10;OB_Out1_trans.set_user_data_length( cf_dt::cf_data_size( OB_Out1.total_frame_size, CF_BYTE ) );\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction3\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction2\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction4\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"OB_Out\" constructor=\"\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n                  <ports name=\"OB_Out2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"OB_Out1\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"OBEX_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"OB_OutBehvBh\">\n                    <statements xsi:type=\"cofluent:MultipleGuardedStatement\" name=\"MultipleWait\">\n                      <guardedBranches />\n                      <guardedBranches />\n                    </statements>\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction39\" timeout=\" ms\" priority=\"\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction40\" timeout=\" ms\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Out1\" algorithm=\"OBEX_Out=OB_Out1;&#10;OBEX_Out_trans.set_user_data_length( OB_Out1_trans.get_user_data_length() );&#10;&#10;OB_Out1_trans.unset_user_data_length();\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Out2\" algorithm=\"OBEX_Out=OB_Out2;&#10;OBEX_Out_trans.set_user_data_length( OB_Out2_trans.get_user_data_length() );&#10;&#10;OB_Out2_trans.unset_user_data_length();\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop31\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <relations xsi:type=\"cofluent:Event\" name=\"continueEv\" setTime=\"0 ns\" getTime=\"0 ns\" />\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"OB_Out1\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"OB_Out2\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"RFCOMM_Layer\" cyclePeriod=\"10 ns\">\n              <ports name=\"OBEX_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"OBEX_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"RFCOMM_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"RFCOMM_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"RFCOMM_LayerStructSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"RFCOMM_Receive\" constructor=\"\" includes=\"\" declarations=\"//number of credits available for the peer device&#10;int peer_credits;&#10;//flag indicating if peer need credits&#10;bool peer_need_credits;&#10;//flag indicating if OBEX frame reconstruction is finished&#10;bool receive_complete;&#10;//size of the already received RFCOMM payloads&#10;int received_payload_size;&#10;//type of the OBEX packet under reconstruction&#10;unsigned char OBEX_packet_type;&#10;//receive operation time in us&#10;double receive_op_time;\" definitions=\"\" initializations=\"//number of credits available for the peer device&#13;&#10;peer_credits = RFCOMM_credits;&#13;&#10;//flag indicating if peer need credits&#13;&#10;peer_need_credits = false;&#13;&#10;//flag indicating if OBEX frame reconstruction is finished&#13;&#10;receive_complete = false;&#13;&#10;//size of the already received RFCOMM payloads&#13;&#10;received_payload_size = 0;&#13;&#10;//receive operation time in us&#13;&#10;receive_op_time = 0.0;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"RFC_Data\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RFC_Out1\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"OBEX_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"RFCOMM_ReceiveBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop20\" condition=\"receive_complete==false\" type=\"CONDITIONAL\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction26\" timeout=\" ms\" priority=\"\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Receive\" algorithm=\"receive_op_time = RFCOMM_ReceiveFrameTime.get_value().to_scalar( CF_US );&#10;peer_need_credits = false;&#10;//receive incoming RFCOMM frame&#10;if(received_payload_size == 0) OBEX_packet_type = RFC_Data.OBEX_type;&#10;received_payload_size += RFC_Data.payload_size;&#10;if(OBEX_packet_type == PUT) peer_credits--;&#10;if(RFC_Data.RFCOMM_type == DATA_END) receive_complete = true;&#10;//RFCOMM verbose&#10;if(Verbose_Level == LEVEL_RFCOMM){&#10;&#09;cf_trace_report(&quot;RFCOMM: received frame, payload:%d bytes&quot;,RFC_Data.payload_size);&#10;}&#10;//send credits if needed&#10;if(peer_credits == 0){&#10;&#09;peer_need_credits = true;&#10;&#09;RFC_Out1.total_frame_size = RFCOMM_HDR_S;&#10;&#09;RFC_Out1.header_size = RFCOMM_HDR_S;&#10;&#09;RFC_Out1.payload_size = 0;&#10;&#09;RFC_Out1.packet_type = RFCOMM;&#10;&#09;RFC_Out1.RFCOMM_type = CREDITS;&#10;&#09;peer_credits = RFCOMM_credits;&#10;&#09;receive_op_time = RFCOMM_recredits_delay;&#10;&#09;//RFCOMM verbose&#10;&#09;if(Verbose_Level == LEVEL_RFCOMM){&#10;&#09;&#09;cf_trace_report(&quot;RFCOMM: send credits&quot;);&#10;&#09;}&#10;&#09;RFC_Out1_trans.set_user_data_length( cf_dt::cf_data_size( RFC_Out1.total_frame_size, CF_BYTE ) );&#10;}&#10;//monitoring&#10;total_delay_RFCOMM += (int) cf_time_stamp().to_scalar(CF_US) - RFC_Data.RFCOMM_timestamp;&#10;&#10;//cf_trace_report(&quot;receive_op_time = %f&quot;, receive_op_time);\" executionTime=\"receive_op_time us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction31\" duration=\"1 ns\" condition=\"peer_need_credits\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SendOBEX\" algorithm=\"//send OBEX frame&#10;OBEX_In.total_frame_size = received_payload_size;&#10;OBEX_In.header_size = OBEX_HDR_S;&#10;OBEX_In.payload_size = received_payload_size - OBEX_HDR_S;&#10;OBEX_In.packet_type = OBEX;&#10;OBEX_In.OBEX_type = OBEX_packet_type;&#10;OBEX_In.FILE_timestamp = RFC_Data.FILE_timestamp;&#10;OBEX_In.OBEX_timestamp = RFC_Data.OBEX_timestamp;&#10;//reset receive complete flag&#10;receive_complete = false;&#10;//reset receive payload size&#10;received_payload_size = 0;&#10;//RFCOMM verbose&#10;if(Verbose_Level == LEVEL_RFCOMM){&#10;&#09;cf_trace_report(&quot;RFCOMM: send data to OBEX:%d bytes&quot;,OBEX_In.total_frame_size);&#10;}&#10;OBEX_In_trans.set_user_data_length( cf_dt::cf_data_size( OBEX_In.total_frame_size, CF_BYTE ) );\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop18\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"RFCOMM_Send\" declarations=\"//number of RFCOMM data packets to send&#10;int nb_packets_to_send;&#10;//size of the last RFCOMM packet payload&#10;int last_payload_size;&#10;//credits&#10;int credits;&#10;bool needCredits;&#10;//type of the OBEX packet under fragmentation&#10;unsigned char OBEX_packet_type;\" initializations=\"//credits&#13;&#10;credits = RFCOMM_credits;&#13;&#10;needCredits = false;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"RFC_Cdts\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RFC_Out2\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"OBEX_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"RFCOMM_SendBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop19\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Fragment\" algorithm=\"nb_packets_to_send = OBEX_Out.total_frame_size/RFCOMM_pl_size;&#10;last_payload_size = OBEX_Out.total_frame_size%RFCOMM_pl_size;&#10;OBEX_packet_type = OBEX_Out.OBEX_type;&#10;if(last_payload_size != 0) nb_packets_to_send++;&#10;else last_payload_size = RFCOMM_pl_size;\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop22\" condition=\"nb_packets_to_send&gt;0\" type=\"CONDITIONAL\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SendPacket\" algorithm=\"RFC_Out2.header_size = RFCOMM_HDR_S;&#10;RFC_Out2.OBEX_type = OBEX_packet_type;&#10;RFC_Out2.FILE_timestamp = OBEX_Out.FILE_timestamp;&#10;RFC_Out2.OBEX_timestamp = OBEX_Out.OBEX_timestamp;&#10;RFC_Out2.RFCOMM_timestamp = (int)cf_time_stamp().to_scalar(CF_US);&#10;&#10;RFC_Out2.packet_type = RFCOMM;&#10;if(nb_packets_to_send &gt; 1){&#10;&#09;RFC_Out2.RFCOMM_type = DATA;&#10;&#09;RFC_Out2.payload_size = RFCOMM_pl_size;&#10;}&#10;else{&#10;&#09;RFC_Out2.RFCOMM_type = DATA_END;&#10;&#09;RFC_Out2.payload_size = last_payload_size;&#10;}&#10;&#10;RFC_Out2.total_frame_size = RFC_Out2.header_size + RFC_Out2.payload_size;&#10;RFC_Out2_trans.set_user_data_length( cf_dt::cf_data_size( RFC_Out2.total_frame_size, CF_BYTE ) );&#10;nb_packets_to_send--;&#10;if(OBEX_packet_type == PUT)credits--;&#10;//RFCOMM verbose&#10;if(Verbose_Level == LEVEL_RFCOMM){&#10;&#09;cf_trace_report(&quot;RFCOMM: send frame, payload:%d bytes&quot;,RFC_Out2.payload_size);&#10;}&#10;//monitoring&#10;nb_RFCOMM_df++;\" executionTime=\"RFCOMM_SendFrameTime us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction32\" duration=\"1 ns\" condition=\"\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction27\" timeout=\" ms\" priority=\"\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"UpdateCredits\" algorithm=\"credits = RFCOMM_credits;&#10;needCredits = false;\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:AlternativeStatement\">\n                      <conditionalBranches condition=\"\" />\n                      <conditionalBranches condition=\"needCredits==true\" />\n                    </statements>\n                    <statements xsi:type=\"cofluent:Operation\" name=\"CheckCredits\" algorithm=\"if(credits == 0){&#10;&#09;needCredits = true;&#10;&#09;nb_cdts_req++;&#10;}\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"CreditsOrData\" declarations=\"//data flag&#10;bool data_flag;&#10;//credit flag&#10;bool cdt_flag;\" initializations=\"//data flag&#13;&#10;data_flag = false;&#13;&#10;//credit flag&#13;&#10;cdt_flag = false;\" cyclePeriod=\"10 ns\">\n                  <ports name=\"RFC_Data\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RFC_Cdts\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RFCOMM_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"CreditsOrDataBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop21\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Decode\" algorithm=\"//reset flags&#10;data_flag = false;&#10;cdt_flag = false;&#10;//set flags&#10;if(RFCOMM_In.RFCOMM_type == CREDITS){&#10;&#09;cdt_flag = true;&#10;&#09;RFC_Cdts = RFCOMM_In;&#10;&#09;RFC_Cdts_trans.set_user_data_length( RFCOMM_In_trans.get_user_data_length() );&#10;&#09;RFCOMM_In_trans.unset_user_data_length();&#10;}&#10;else{&#10;&#09;data_flag = true;&#10;&#09;RFC_Data = RFCOMM_In;&#10;&#09;RFC_Data_trans.set_user_data_length( RFCOMM_In_trans.get_user_data_length() );&#10;&#09;RFCOMM_In_trans.unset_user_data_length();&#10;}\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction34\" duration=\"1 ns\" condition=\"data_flag\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction35\" duration=\"1 ns\" condition=\"cdt_flag\" priority=\"1\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"RFC_Out\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n                  <ports name=\"RFC_Out1\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RFC_Out2\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"RFCOMM_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"RFC_OutBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop32\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:MultipleGuardedStatement\" name=\"MultipleWait\">\n                      <guardedBranches />\n                      <guardedBranches />\n                    </statements>\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction41\" timeout=\" ms\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction42\" timeout=\" ms\" duration=\"1 ns\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Out1\" algorithm=\"RFCOMM_Out=RFC_Out1;&#10;RFCOMM_Out_trans.set_user_data_length( RFC_Out1_trans.get_user_data_length() );&#10;&#10;RFC_Out1_trans.unset_user_data_length();\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"Out2\" algorithm=\"RFCOMM_Out=RFC_Out2;&#10;RFCOMM_Out_trans.set_user_data_length( RFC_Out2_trans.get_user_data_length() );&#10;&#10;RFC_Out2_trans.unset_user_data_length();\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction2\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"RFC_Data\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" address=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"RFC_Cdts\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" address=\"\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"RFC_Out1\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n                <relations xsi:type=\"cofluent:MessageQueue\" name=\"RFC_Out2\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\">\n                  <relationType xsi:type=\"cofluent:RelationDataType\" />\n                </relations>\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"BaseBand_Layer\" cyclePeriod=\"10 ns\">\n              <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"L2CAP_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"L2CAP_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"BaseBand_LayerStructSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"BB_Receive\" declarations=\"//receive operation duration in ms&#10;double op_rcv_duration;\" initializations=\"//receive operation duration in ms&#13;&#10;op_rcv_duration = 0;\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\"40 mW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"L2CAP_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"BB_ReceiveBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop29\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"PacketReceive\" algorithm=\"//receive operation duration computing&#10;op_rcv_duration =&#10;&#09;8000.0*(double)(BaseBand_In.total_frame_size)/(double)Throughput_BaseBand;&#10;//receive&#10;L2CAP_In = BaseBand_In;&#10;L2CAP_In_trans.set_user_data_length( BaseBand_In_trans.get_user_data_length() );&#10;//cf_trace_report(&quot;BB_receive = %s&quot;, BaseBand_In_trans.get_user_data_length().to_c_str());&#10;&#10;BaseBand_In_trans.unset_user_data_length();\" executionTime=\"op_rcv_duration us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"BB_Send\" declarations=\"//send operation duration in ms&#10;double op_send_duration;\" initializations=\"//send operation duration in ms&#13;&#10;op_send_duration = 0;\" cyclePeriod=\"10 ns\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\"70 mW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n                  <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"L2CAP_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"BB_SendBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop28\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"PacketSend\" algorithm=\"//send operation duration computing&#10;op_send_duration =&#10;&#09;8000.0*(double)(L2CAP_Out.total_frame_size)/(double)Throughput_BaseBand;&#10;\" executionTime=\"op_send_duration us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"ForwardData\" algorithm=\"//send&#10;BaseBand_Out = L2CAP_Out;&#10;BaseBand_Out_trans.set_user_data_length( L2CAP_Out_trans.get_user_data_length() );&#10;&#10;//cf_trace_report(&quot;BB_send = %s&quot;, BaseBand_Out_trans.get_user_data_length().to_c_str());&#10;&#10;L2CAP_Out_trans.unset_user_data_length();\" executionTime=\"0 ns\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                  </refinement>\n                </models>\n              </refinement>\n            </models>\n            <models xsi:type=\"cofluent:Function\" name=\"L2CAP_Layer\" cyclePeriod=\"10 ns\">\n              <ports name=\"RFCOMM_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"RFCOMM_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"L2CAP_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n              <ports name=\"L2CAP_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n              <refinement xsi:type=\"cofluent:Structure\" name=\"L2CAP_LayerStructSt\">\n                <models xsi:type=\"cofluent:Function\" name=\"L2CAP_Receive\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n                  <ports name=\"RFCOMM_In\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"L2CAP_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"L2CAP_ReceiveBehvBh\">\n                    <statements xsi:type=\"cofluent:Operation\" name=\"ReceiveFrame\" algorithm=\"RFCOMM_In.total_frame_size = L2CAP_In.payload_size;&#10;RFCOMM_In.header_size = RFCOMM_HDR_S;&#10;RFCOMM_In.payload_size = RFCOMM_In.total_frame_size - RFCOMM_In.header_size;&#10;RFCOMM_In.packet_type = RFCOMM;&#10;RFCOMM_In.OBEX_type = L2CAP_In.OBEX_type;&#10;RFCOMM_In.RFCOMM_type = L2CAP_In.RFCOMM_type;&#10;RFCOMM_In.FILE_timestamp = L2CAP_In.FILE_timestamp;&#10;RFCOMM_In.OBEX_timestamp = L2CAP_In.OBEX_timestamp;&#10;RFCOMM_In.RFCOMM_timestamp = L2CAP_In.RFCOMM_timestamp;&#10;RFCOMM_In_trans.set_user_data_length( cf_dt::cf_data_size( RFCOMM_In.total_frame_size, CF_BYTE ) );\" executionTime=\"L2CAP_ReceiveFrameTime us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop27\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n                <models xsi:type=\"cofluent:Function\" name=\"L2CAP_Send\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n                  <ports name=\"RFCOMM_Out\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\" />\n                  <ports name=\"L2CAP_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n                  <refinement xsi:type=\"cofluent:Behavior\" name=\"L2CAP_SendBehvBh\">\n                    <statements xsi:type=\"cofluent:LoopStatement\" name=\"Loop30\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:Operation\" name=\"SendFrame\" algorithm=\"L2CAP_Out.header_size = L2CAP_HDR_S;&#13;&#10;&#09;L2CAP_Out.payload_size = RFCOMM_Out.total_frame_size;&#13;&#10;&#09;L2CAP_Out.total_frame_size = L2CAP_Out.header_size + L2CAP_Out.payload_size;&#13;&#10;&#09;L2CAP_Out.packet_type = L2CAP;&#13;&#10;&#09;L2CAP_Out.OBEX_type = RFCOMM_Out.OBEX_type;&#13;&#10;&#09;L2CAP_Out.RFCOMM_type = RFCOMM_Out.RFCOMM_type;&#13;&#10;&#09;total_L2CAP_data += L2CAP_Out.total_frame_size;&#13;&#10;&#09;L2CAP_Out.FILE_timestamp = RFCOMM_Out.FILE_timestamp;&#13;&#10;&#09;L2CAP_Out.OBEX_timestamp = RFCOMM_Out.OBEX_timestamp;&#13;&#10;&#09;L2CAP_Out.RFCOMM_timestamp = RFCOMM_Out.RFCOMM_timestamp;&#10;&#09;L2CAP_Out_trans.set_user_data_length( cf_dt::cf_data_size( L2CAP_Out.total_frame_size, CF_BYTE ) );\" executionTime=\"L2CAP_SendFrameTime us\" systematicRead=\"true\" systematicWrite=\"true\" />\n                    <statements xsi:type=\"cofluent:InputAction\" name=\"InAction\" timeout=\" ms\" priority=\"\" duration=\" ns\" vectorSize=\"1\" blocking=\"true\" condition=\"\" />\n                    <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n                  </refinement>\n                </models>\n              </refinement>\n            </models>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"OBEX_Out\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"OBEX_In\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"RFCOMM_Out\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"RFCOMM_In\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"L2CAP_In\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" address=\"\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n            <relations xsi:type=\"cofluent:MessageQueue\" name=\"L2CAP_Out\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\">\n              <relationType xsi:type=\"cofluent:RelationDataType\" />\n            </relations>\n          </refinement>\n        </models>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"DataOut\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:Event\" name=\"WrOK\" setTime=\"0 ns\" getTime=\"0 ns\" />\n        <relations xsi:type=\"cofluent:SharedVariable\" name=\"Data\" concurrency=\"1\" writeTime=\"0 ns\" readTime=\"0 ns\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"DataIn\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n        <relations xsi:type=\"cofluent:MessageQueue\" name=\"ReadWrite\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n          <relationType xsi:type=\"cofluent:RelationDataType\" />\n        </relations>\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Start\" declarations=\"\" definitions=\"\" initializations=\"\" cyclePeriod=\"10 ns\">\n      <ports name=\"startEv\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"StartBehvBh\">\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"BaseBand_Out\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" address=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n    <relations xsi:type=\"cofluent:Event\" name=\"startEv\" setTime=\"1 ns\" getTime=\"1 ns\" />\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"BaseBand_In\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\" />\n    </relations>\n  </refinement>\n</ns0:Application>",
    "Please act as a CoFLuent Code tree structure extractor. Please extract the tree structure of the following CoFluent model and the result is in json format: \n<ns0:Application xmlns:ns0=\"http://cofluent.intel.com/cofluent/1.0.0\" xmlns:ns1=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ns1:version=\"2.0\" name=\"OPP_UseCase\" constructor=\"\" includes=\"\" postSimulation=\"//perf result computation&#13;&#10;total_time = last_write_time - first_read_time; //in us&#13;&#10;average_throughput = 1000000.0 * (double) File_Size * 8.0 / (double) total_time;&#13;&#10;cf_trace_gui_f_param(&quot;average_throughput&quot;,average_throughput, &quot;kbits/s&quot;);&#13;&#10;&#13;&#10;//print out results&#13;&#10;if (Verbose_Level != LEVEL_SILENT) {&#13;&#10;&#09;//file level perfs&#13;&#10;&#09;cf_trace_report(&quot;FILE LEVEL:&quot;);&#13;&#10;&#09;cf_trace_report(&quot;&#09;File size: %d kBytes&quot;, (int)File_Size);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Max file part size: %d Bytes&quot;, (int)OBEX_pl_size);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Number of file parts: %d&quot;, nb_file_parts);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Total time between first read and last write:%d us&quot;,total_time);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Average throughput:%f kbits/s&quot;,&#09;average_throughput);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Average delay between read and OBEX final packet (acknowledge) reception:%f us&quot;,(double) total_delay_FILE / (double) nb_file_parts);&#13;&#10;&#09;cf_trace_report(&quot;OBEX LEVEL:&quot;);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Maximum frame size:%d Bytes&quot;,(int)OBEX_pl_size + OBEX_HDR_S);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Number of data frames: %d&quot;, nb_OBEX_df);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Average delay between data frame send and receive:%f us&quot;,(double) total_delay_OBEX / (double) nb_OBEX_df);&#13;&#10;&#09;cf_trace_report(&quot;RFCOMM LEVEL:&quot;);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Maximum frame size:%d Bytes&quot;,(int)RFCOMM_pl_size + RFCOMM_HDR_S);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Number of data frames:%d&quot;, nb_RFCOMM_df);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Average delay between data frame send and receive:%f us&quot;,(double) total_delay_RFCOMM / (double) nb_RFCOMM_df);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Number of credits:%d&quot;, (int)RFCOMM_credits);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Number of credit requests:%d&quot;, nb_cdts_req);&#13;&#10;&#09;cf_trace_report(&quot;L2CAP LEVEL:&quot;);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Maximum frame size:%d Bytes&quot;,(int)RFCOMM_pl_size + RFCOMM_HDR_S + L2CAP_HDR_S);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Number of data frames:%d&quot;, nb_RFCOMM_df);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Total amount of data exchanged:%d Bytes&quot;,total_L2CAP_data);&#13;&#10;&#09;cf_trace_report(&quot;&#09;--&gt; Average load:%f kbits/s&quot;,8000.0 * (float) total_L2CAP_data / (float) total_time);&#13;&#10;&#09;cf_trace_report(&quot;BASEBAND LEVEL:&quot;);&#13;&#10;&#09;cf_trace_report(&quot;&#09;Average throughput:%d kbits/s&quot;, (int) Throughput_BaseBand);&#13;&#10;}\" version=\"4.0.0\" declarations=\"\" definitions=\"\" preElaboration=\"\" initializations=\"\" cyclePeriod=\"10 ns\" postElaboration=\"nb_file_parts = 0;&#13;&#10;nb_OBEX_df = 0;&#13;&#10;nb_RFCOMM_df = 0;&#13;&#10;total_delay_FILE = 0;&#13;&#10;total_delay_OBEX = 0;&#13;&#10;total_delay_RFCOMM = 0;&#13;&#10;nb_cdts_req = 0;&#13;&#10;total_L2CAP_data = 0;\" globalTypeDeclarations=\"//Packet level&#13;&#10;#define FILE_PART 0x00&#13;&#10;#define OBEX 0x01&#13;&#10;#define RFCOMM 0x02&#13;&#10;#define L2CAP 0x03&#13;&#10;#define BASEBAND 0x04&#13;&#10;//Header sizes&#13;&#10;#define OBEX_HDR_S 3&#13;&#10;#define RFCOMM_HDR_S 5&#13;&#10;#define L2CAP_HDR_S 4&#13;&#10;//OBEX packet type&#13;&#10;#define PUT 0x01&#13;&#10;#define FINAL 0x02&#13;&#10;//RFCOMM packet type&#13;&#10;#define DATA 0x01&#13;&#10;#define DATA_END 0x02&#13;&#10;#define CREDITS 0x03&#13;&#10;&#13;&#10;/*** TYPE DEFINITIONS ***/&#13;&#10;//DefOrder&#13;&#10;enum DefOrderType{read_order,write_order};&#13;&#10;struct DefOrder{&#13;&#10;&#09;DefOrderType order_type;&#13;&#10;&#09;int size;&#13;&#10;};&#13;&#10;&#13;&#10;//DefFile&#13;&#10;struct DefFile{&#13;&#10;&#09;int file_size;&#13;&#10;};&#13;&#10;&#13;&#10;//DefFrame is an abstract structure to describe Bluetooth frame&#13;&#10;//at any protocol layer&#13;&#10;struct DefFrame{&#13;&#10;&#09;int total_frame_size; //USERDATASIZE&#13;&#10;&#09;int header_size;&#13;&#10;&#09;int payload_size;&#13;&#10;&#09;int FILE_timestamp; //in us&#13;&#10;&#09;int OBEX_timestamp; //in us&#13;&#10;&#09;int RFCOMM_timestamp; //in us&#13;&#10;&#09;unsigned char packet_type;&#13;&#10;&#09;unsigned char OBEX_type; //put or final/continue packet&#13;&#10;&#09;unsigned char RFCOMM_type; //data, data final, or credits&#13;&#10;};&#13;&#10;\" globalDeclarations=\"/*** Variables for perf monitoring ***/&#13;&#10;extern int first_read_time; //in us&#13;&#10;extern int last_write_time; //in us&#13;&#10;extern int nb_file_parts;&#13;&#10;extern int nb_OBEX_df;&#13;&#10;extern int nb_RFCOMM_df;&#13;&#10;extern int total_delay_FILE;//in us&#13;&#10;extern int total_delay_OBEX;//in us&#13;&#10;extern int total_delay_RFCOMM;//in us&#13;&#10;extern int nb_cdts_req;&#13;&#10;extern int total_L2CAP_data;&#13;&#10;&#13;&#10;/*** Variables for perf results ***/&#13;&#10;extern int total_time; //in us&#13;&#10;extern double average_throughput; //in kpbs\" globalDefinitions=\"/*** Variables for perf monitoring ***/&#13;&#10;int first_read_time; //in us&#13;&#10;int last_write_time; //in us&#13;&#10;int nb_file_parts;&#13;&#10;int nb_OBEX_df;&#13;&#10;int nb_RFCOMM_df;&#13;&#10;int total_delay_FILE;//in us&#13;&#10;int total_delay_OBEX;//in us&#13;&#10;int total_delay_RFCOMM;//in us&#13;&#10;int nb_cdts_req;&#13;&#10;int total_L2CAP_data;&#13;&#10;&#13;&#10;/*** Variables for perf results ***/&#13;&#10;int total_time; //in us&#13;&#10;double average_throughput; //in kpbs\">\n  <refinement xsi:type=\"cofluent:Structure\" name=\"OPP_UseCaseStructSt\">\n    <models xsi:type=\"cofluent:Function\" name=\"StartFunc\" declarations=\"\" cyclePeriod=\" ns\" affinity=\"\" priority=\"\" staticCodeSize=\" b\" staticDataSize=\" b\" staticPowerConsumption=\" nW\" dynamicPowerConsumption=\" nW\" cost=\" EUR\" dynamicResourceLoad=\"\">\n      <ports name=\"StartEv\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"StartFuncBehvBh\">\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"1\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"UnusedFunc\" declarations=\"\" cyclePeriod=\" ns\">\n      <ports name=\"UnusedEv\" type=\"EVENT\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\" />\n      <refinement xsi:type=\"cofluent:Behavior\" name=\"UnusedFuncBehvBh\">\n        <statements xsi:type=\"cofluent:Operation\" name=\"Wait\" executionTime=\"10 d\" systematicRead=\"true\" systematicWrite=\"true\" dynamicDataSize=\" b\" dynamicPowerConsumption=\" nW\" dynamicResourceLoad=\"\" />\n        <statements xsi:type=\"cofluent:OutputAction\" name=\"OutAction\" duration=\" ns\" condition=\"\" priority=\"\" vectorSize=\"\" blocking=\"true\" />\n      </refinement>\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Master\" cyclePeriod=\" ns\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\">\n        <reuse href=\"reuse://_DPup0Kn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_LUusQKx1EeCTXoYQNfqU0w\" />\n      </ports>\n      <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\">\n        <reuse href=\"reuse://_DPup0Kn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_W9L9IKx1EeCTXoYQNfqU0w\" />\n      </ports>\n      <ports name=\"startEv\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\">\n        <reuse href=\"reuse://_DPup0Kn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_Nyc80Kx-EeCTXoYQNfqU0w\" />\n      </ports>\n      <reuse xsi:type=\"cofluent:Function\" href=\"reuse://_DPup0Kn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_F6FrA6x1EeCTXoYQNfqU0w\" />\n    </models>\n    <models xsi:type=\"cofluent:Function\" name=\"Slave\" cyclePeriod=\" ns\" priority=\"1\" staticCodeSize=\"0 kB\" staticDataSize=\"0 kB\" staticPowerConsumption=\"0 uW\" dynamicPowerConsumption=\"0 uW\" cost=\"0 USD\" dynamicResourceLoad=\"100\">\n      <ports name=\"BaseBand_Out\" type=\"MESSAGE_QUEUE\" direction=\"OUT\" synchronizeName=\"true\" vector=\"true\">\n        <reuse href=\"reuse://_GAfhQKn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_LUusQKx1EeCTXoYQNfqU0w\" />\n      </ports>\n      <ports name=\"BaseBand_In\" type=\"MESSAGE_QUEUE\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\">\n        <reuse href=\"reuse://_GAfhQKn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_W9L9IKx1EeCTXoYQNfqU0w\" />\n      </ports>\n      <ports name=\"startEv\" type=\"EVENT\" direction=\"IN\" synchronizeName=\"true\" vector=\"true\">\n        <reuse href=\"reuse://_GAfhQKn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_Nyc80Kx-EeCTXoYQNfqU0w\" />\n      </ports>\n      <reuse xsi:type=\"cofluent:Function\" href=\"reuse://_GAfhQKn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_F6FrA6x1EeCTXoYQNfqU0w\" />\n    </models>\n    <relations xsi:type=\"cofluent:Event\" name=\"StartEv\" setTime=\"1 ns\" getTime=\"0 ns\" />\n    <relations xsi:type=\"cofluent:Event\" name=\"UnusedEv\" setTime=\"1 ns\" getTime=\"1 ns\" />\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"M2S\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\" mask=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\">\n        <dataType href=\"reuse://_DPup0Kn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_F6iU36x1EeCTXoYQNfqU0w\" />\n      </relationType>\n    </relations>\n    <relations xsi:type=\"cofluent:MessageQueue\" name=\"S2M\" capacity=\"1\" concurrency=\"1\" concurrencyManagement=\"FULL\" sendTime=\"0 ns\" receiveTime=\"0 ns\" sendThreshold=\"\" receiveThreshold=\"\" address=\"\">\n      <relationType xsi:type=\"cofluent:RelationDataType\">\n        <dataType href=\"reuse://_DPup0Kn4EeO7XIyg--LdSg/BluetoothOpp/BluetoothStack/BluetoothStack.cf_app#_F6iU36x1EeCTXoYQNfqU0w\" />\n      </relationType>\n    </relations>\n  </refinement>\n</ns0:Application>"
]